(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~calendar"],{

/***/ "./node_modules/fullcalendar/dist/fullcalendar.js":
/*!********************************************************!*\
  !*** ./node_modules/fullcalendar/dist/fullcalendar.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * FullCalendar v3.10.2
 * Docs & License: https://fullcalendar.io/
 * (c) 2019 Adam Shaw
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"), __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"));
	else {}
})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 256);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_0__;

/***/ }),
/* 1 */,
/* 2 */
/***/ (function(module, exports) {

/*
derived from:
https://github.com/Microsoft/tslib/blob/v1.6.0/tslib.js

only include the helpers we need, to keep down filesize
*/
var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b)
        if (b.hasOwnProperty(p))
            d[p] = b[p]; };
exports.__extends = function (d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};


/***/ }),
/* 3 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(0);
var $ = __webpack_require__(3);
/* FullCalendar-specific DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/
// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
function compensateScroll(rowEls, scrollbarWidths) {
    if (scrollbarWidths.left) {
        rowEls.css({
            'border-left-width': 1,
            'margin-left': scrollbarWidths.left - 1
        });
    }
    if (scrollbarWidths.right) {
        rowEls.css({
            'border-right-width': 1,
            'margin-right': scrollbarWidths.right - 1
        });
    }
}
exports.compensateScroll = compensateScroll;
// Undoes compensateScroll and restores all borders/margins
function uncompensateScroll(rowEls) {
    rowEls.css({
        'margin-left': '',
        'margin-right': '',
        'border-left-width': '',
        'border-right-width': ''
    });
}
exports.uncompensateScroll = uncompensateScroll;
// Make the mouse cursor express that an event is not allowed in the current area
function disableCursor() {
    $('body').addClass('fc-not-allowed');
}
exports.disableCursor = disableCursor;
// Returns the mouse cursor to its original look
function enableCursor() {
    $('body').removeClass('fc-not-allowed');
}
exports.enableCursor = enableCursor;
// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and
// reduces the available height.
function distributeHeight(els, availableHeight, shouldRedistribute) {
    // *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
    // and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.
    var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
    var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
    var flexEls = []; // elements that are allowed to expand. array of DOM nodes
    var flexOffsets = []; // amount of vertical space it takes up
    var flexHeights = []; // actual css height
    var usedHeight = 0;
    undistributeHeight(els); // give all elements their natural height
    // find elements that are below the recommended height (expandable).
    // important to query for heights in a single first pass (to avoid reflow oscillation).
    els.each(function (i, el) {
        var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
        var naturalOffset = $(el).outerHeight(true);
        if (naturalOffset < minOffset) {
            flexEls.push(el);
            flexOffsets.push(naturalOffset);
            flexHeights.push($(el).height());
        }
        else {
            // this element stretches past recommended height (non-expandable). mark the space as occupied.
            usedHeight += naturalOffset;
        }
    });
    // readjust the recommended height to only consider the height available to non-maxed-out rows.
    if (shouldRedistribute) {
        availableHeight -= usedHeight;
        minOffset1 = Math.floor(availableHeight / flexEls.length);
        minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
    }
    // assign heights to all expandable elements
    $(flexEls).each(function (i, el) {
        var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
        var naturalOffset = flexOffsets[i];
        var naturalHeight = flexHeights[i];
        var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding
        if (naturalOffset < minOffset) { // we check this again because redistribution might have changed things
            $(el).height(newHeight);
        }
    });
}
exports.distributeHeight = distributeHeight;
// Undoes distrubuteHeight, restoring all els to their natural height
function undistributeHeight(els) {
    els.height('');
}
exports.undistributeHeight = undistributeHeight;
// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
function matchCellWidths(els) {
    var maxInnerWidth = 0;
    els.find('> *').each(function (i, innerEl) {
        var innerWidth = $(innerEl).outerWidth();
        if (innerWidth > maxInnerWidth) {
            maxInnerWidth = innerWidth;
        }
    });
    maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance
    els.width(maxInnerWidth);
    return maxInnerWidth;
}
exports.matchCellWidths = matchCellWidths;
// Given one element that resides inside another,
// Subtracts the height of the inner element from the outer element.
function subtractInnerElHeight(outerEl, innerEl) {
    var both = outerEl.add(innerEl);
    var diff;
    // effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
    both.css({
        position: 'relative',
        left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
    });
    diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions
    both.css({ position: '', left: '' }); // undo hack
    return diff;
}
exports.subtractInnerElHeight = subtractInnerElHeight;
/* Element Geom Utilities
----------------------------------------------------------------------------------------------------------------------*/
// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51
function getScrollParent(el) {
    var position = el.css('position');
    var scrollParent = el.parents().filter(function () {
        var parent = $(this);
        return (/(auto|scroll)/).test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x'));
    }).eq(0);
    return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
}
exports.getScrollParent = getScrollParent;
// Queries the outer bounding area of a jQuery element.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getOuterRect(el, origin) {
    var offset = el.offset();
    var left = offset.left - (origin ? origin.left : 0);
    var top = offset.top - (origin ? origin.top : 0);
    return {
        left: left,
        right: left + el.outerWidth(),
        top: top,
        bottom: top + el.outerHeight()
    };
}
exports.getOuterRect = getOuterRect;
// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
// WARNING: given element can't have borders
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getClientRect(el, origin) {
    var offset = el.offset();
    var scrollbarWidths = getScrollbarWidths(el);
    var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);
    var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);
    return {
        left: left,
        right: left + el[0].clientWidth,
        top: top,
        bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars
    };
}
exports.getClientRect = getClientRect;
// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getContentRect(el, origin) {
    var offset = el.offset(); // just outside of border, margin not included
    var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -
        (origin ? origin.left : 0);
    var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -
        (origin ? origin.top : 0);
    return {
        left: left,
        right: left + el.width(),
        top: top,
        bottom: top + el.height()
    };
}
exports.getContentRect = getContentRect;
// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.
// WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getScrollbarWidths(el) {
    var leftRightWidth = el[0].offsetWidth - el[0].clientWidth;
    var bottomWidth = el[0].offsetHeight - el[0].clientHeight;
    var widths;
    leftRightWidth = sanitizeScrollbarWidth(leftRightWidth);
    bottomWidth = sanitizeScrollbarWidth(bottomWidth);
    widths = { left: 0, right: 0, top: 0, bottom: bottomWidth };
    if (getIsLeftRtlScrollbars() && el.css('direction') === 'rtl') { // is the scrollbar on the left side?
        widths.left = leftRightWidth;
    }
    else {
        widths.right = leftRightWidth;
    }
    return widths;
}
exports.getScrollbarWidths = getScrollbarWidths;
// The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to
// retina displays, rounding, and IE11. Massage them into a usable value.
function sanitizeScrollbarWidth(width) {
    width = Math.max(0, width); // no negatives
    width = Math.round(width);
    return width;
}
// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side
var _isLeftRtlScrollbars = null;
function getIsLeftRtlScrollbars() {
    if (_isLeftRtlScrollbars === null) {
        _isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
    }
    return _isLeftRtlScrollbars;
}
function computeIsLeftRtlScrollbars() {
    var el = $('<div><div></div></div>')
        .css({
        position: 'absolute',
        top: -1000,
        left: 0,
        border: 0,
        padding: 0,
        overflow: 'scroll',
        direction: 'rtl'
    })
        .appendTo('body');
    var innerEl = el.children();
    var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?
    el.remove();
    return res;
}
// Retrieves a jQuery element's computed CSS value as a floating-point number.
// If the queried value is non-numeric (ex: IE can return "medium" for border width), will just return zero.
function getCssFloat(el, prop) {
    return parseFloat(el.css(prop)) || 0;
}
/* Mouse / Touch Utilities
----------------------------------------------------------------------------------------------------------------------*/
// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
function isPrimaryMouseButton(ev) {
    return ev.which === 1 && !ev.ctrlKey;
}
exports.isPrimaryMouseButton = isPrimaryMouseButton;
function getEvX(ev) {
    var touches = ev.originalEvent.touches;
    // on mobile FF, pageX for touch events is present, but incorrect,
    // so, look at touch coordinates first.
    if (touches && touches.length) {
        return touches[0].pageX;
    }
    return ev.pageX;
}
exports.getEvX = getEvX;
function getEvY(ev) {
    var touches = ev.originalEvent.touches;
    // on mobile FF, pageX for touch events is present, but incorrect,
    // so, look at touch coordinates first.
    if (touches && touches.length) {
        return touches[0].pageY;
    }
    return ev.pageY;
}
exports.getEvY = getEvY;
function getEvIsTouch(ev) {
    return /^touch/.test(ev.type);
}
exports.getEvIsTouch = getEvIsTouch;
function preventSelection(el) {
    el.addClass('fc-unselectable')
        .on('selectstart', preventDefault);
}
exports.preventSelection = preventSelection;
function allowSelection(el) {
    el.removeClass('fc-unselectable')
        .off('selectstart', preventDefault);
}
exports.allowSelection = allowSelection;
// Stops a mouse/touch event from doing it's native browser action
function preventDefault(ev) {
    ev.preventDefault();
}
exports.preventDefault = preventDefault;
/* General Geometry Utils
----------------------------------------------------------------------------------------------------------------------*/
// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
function intersectRects(rect1, rect2) {
    var res = {
        left: Math.max(rect1.left, rect2.left),
        right: Math.min(rect1.right, rect2.right),
        top: Math.max(rect1.top, rect2.top),
        bottom: Math.min(rect1.bottom, rect2.bottom)
    };
    if (res.left < res.right && res.top < res.bottom) {
        return res;
    }
    return false;
}
exports.intersectRects = intersectRects;
// Returns a new point that will have been moved to reside within the given rectangle
function constrainPoint(point, rect) {
    return {
        left: Math.min(Math.max(point.left, rect.left), rect.right),
        top: Math.min(Math.max(point.top, rect.top), rect.bottom)
    };
}
exports.constrainPoint = constrainPoint;
// Returns a point that is the center of the given rectangle
function getRectCenter(rect) {
    return {
        left: (rect.left + rect.right) / 2,
        top: (rect.top + rect.bottom) / 2
    };
}
exports.getRectCenter = getRectCenter;
// Subtracts point2's coordinates from point1's coordinates, returning a delta
function diffPoints(point1, point2) {
    return {
        left: point1.left - point2.left,
        top: point1.top - point2.top
    };
}
exports.diffPoints = diffPoints;
/* Object Ordering by Field
----------------------------------------------------------------------------------------------------------------------*/
function parseFieldSpecs(input) {
    var specs = [];
    var tokens = [];
    var i;
    var token;
    if (typeof input === 'string') {
        tokens = input.split(/\s*,\s*/);
    }
    else if (typeof input === 'function') {
        tokens = [input];
    }
    else if ($.isArray(input)) {
        tokens = input;
    }
    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        if (typeof token === 'string') {
            specs.push(token.charAt(0) === '-' ?
                { field: token.substring(1), order: -1 } :
                { field: token, order: 1 });
        }
        else if (typeof token === 'function') {
            specs.push({ func: token });
        }
    }
    return specs;
}
exports.parseFieldSpecs = parseFieldSpecs;
function compareByFieldSpecs(obj1, obj2, fieldSpecs, obj1fallback, obj2fallback) {
    var i;
    var cmp;
    for (i = 0; i < fieldSpecs.length; i++) {
        cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i], obj1fallback, obj2fallback);
        if (cmp) {
            return cmp;
        }
    }
    return 0;
}
exports.compareByFieldSpecs = compareByFieldSpecs;
function compareByFieldSpec(obj1, obj2, fieldSpec, obj1fallback, obj2fallback) {
    if (fieldSpec.func) {
        return fieldSpec.func(obj1, obj2);
    }
    var val1 = obj1[fieldSpec.field];
    var val2 = obj2[fieldSpec.field];
    if (val1 == null && obj1fallback) {
        val1 = obj1fallback[fieldSpec.field];
    }
    if (val2 == null && obj2fallback) {
        val2 = obj2fallback[fieldSpec.field];
    }
    return flexibleCompare(val1, val2) * (fieldSpec.order || 1);
}
exports.compareByFieldSpec = compareByFieldSpec;
function flexibleCompare(a, b) {
    if (!a && !b) {
        return 0;
    }
    if (b == null) {
        return -1;
    }
    if (a == null) {
        return 1;
    }
    if ($.type(a) === 'string' || $.type(b) === 'string') {
        return String(a).localeCompare(String(b));
    }
    return a - b;
}
exports.flexibleCompare = flexibleCompare;
/* Date Utilities
----------------------------------------------------------------------------------------------------------------------*/
exports.dayIDs = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
exports.unitsDesc = ['year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond']; // descending
// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
function diffDayTime(a, b) {
    return moment.duration({
        days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),
        ms: a.time() - b.time() // time-of-day from day start. disregards timezone
    });
}
exports.diffDayTime = diffDayTime;
// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.
function diffDay(a, b) {
    return moment.duration({
        days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')
    });
}
exports.diffDay = diffDay;
// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.
function diffByUnit(a, b, unit) {
    return moment.duration(Math.round(a.diff(b, unit, true)), // returnFloat=true
    unit);
}
exports.diffByUnit = diffByUnit;
// Computes the unit name of the largest whole-unit period of time.
// For example, 48 hours will be "days" whereas 49 hours will be "hours".
// Accepts start/end, a range object, or an original duration object.
function computeGreatestUnit(start, end) {
    var i;
    var unit;
    var val;
    for (i = 0; i < exports.unitsDesc.length; i++) {
        unit = exports.unitsDesc[i];
        val = computeRangeAs(unit, start, end);
        if (val >= 1 && isInt(val)) {
            break;
        }
    }
    return unit; // will be "milliseconds" if nothing else matches
}
exports.computeGreatestUnit = computeGreatestUnit;
// like computeGreatestUnit, but has special abilities to interpret the source input for clues
function computeDurationGreatestUnit(duration, durationInput) {
    var unit = computeGreatestUnit(duration);
    // prevent days:7 from being interpreted as a week
    if (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {
        unit = 'day';
    }
    return unit;
}
exports.computeDurationGreatestUnit = computeDurationGreatestUnit;
// Computes the number of units (like "hours") in the given range.
// Range can be a {start,end} object, separate start/end args, or a Duration.
// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling
// of month-diffing logic (which tends to vary from version to version).
function computeRangeAs(unit, start, end) {
    if (end != null) { // given start, end
        return end.diff(start, unit, true);
    }
    else if (moment.isDuration(start)) { // given duration
        return start.as(unit);
    }
    else { // given { start, end } range object
        return start.end.diff(start.start, unit, true);
    }
}
// Intelligently divides a range (specified by a start/end params) by a duration
function divideRangeByDuration(start, end, dur) {
    var months;
    if (durationHasTime(dur)) {
        return (end - start) / dur;
    }
    months = dur.asMonths();
    if (Math.abs(months) >= 1 && isInt(months)) {
        return end.diff(start, 'months', true) / months;
    }
    return end.diff(start, 'days', true) / dur.asDays();
}
exports.divideRangeByDuration = divideRangeByDuration;
// Intelligently divides one duration by another
function divideDurationByDuration(dur1, dur2) {
    var months1;
    var months2;
    if (durationHasTime(dur1) || durationHasTime(dur2)) {
        return dur1 / dur2;
    }
    months1 = dur1.asMonths();
    months2 = dur2.asMonths();
    if (Math.abs(months1) >= 1 && isInt(months1) &&
        Math.abs(months2) >= 1 && isInt(months2)) {
        return months1 / months2;
    }
    return dur1.asDays() / dur2.asDays();
}
exports.divideDurationByDuration = divideDurationByDuration;
// Intelligently multiplies a duration by a number
function multiplyDuration(dur, n) {
    var months;
    if (durationHasTime(dur)) {
        return moment.duration(dur * n);
    }
    months = dur.asMonths();
    if (Math.abs(months) >= 1 && isInt(months)) {
        return moment.duration({ months: months * n });
    }
    return moment.duration({ days: dur.asDays() * n });
}
exports.multiplyDuration = multiplyDuration;
// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)
function durationHasTime(dur) {
    return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
}
exports.durationHasTime = durationHasTime;
function isNativeDate(input) {
    return Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
}
exports.isNativeDate = isNativeDate;
// Returns a boolean about whether the given input is a time string, like "06:40:00" or "06:00"
function isTimeString(str) {
    return typeof str === 'string' &&
        /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
}
exports.isTimeString = isTimeString;
/* Logging and Debug
----------------------------------------------------------------------------------------------------------------------*/
function log() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var console = window.console;
    if (console && console.log) {
        return console.log.apply(console, args);
    }
}
exports.log = log;
function warn() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var console = window.console;
    if (console && console.warn) {
        return console.warn.apply(console, args);
    }
    else {
        return log.apply(null, args);
    }
}
exports.warn = warn;
/* General Utilities
----------------------------------------------------------------------------------------------------------------------*/
var hasOwnPropMethod = {}.hasOwnProperty;
// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
function mergeProps(propObjs, complexProps) {
    var dest = {};
    var i;
    var name;
    var complexObjs;
    var j;
    var val;
    var props;
    if (complexProps) {
        for (i = 0; i < complexProps.length; i++) {
            name = complexProps[i];
            complexObjs = [];
            // collect the trailing object values, stopping when a non-object is discovered
            for (j = propObjs.length - 1; j >= 0; j--) {
                val = propObjs[j][name];
                if (typeof val === 'object') {
                    complexObjs.unshift(val);
                }
                else if (val !== undefined) {
                    dest[name] = val; // if there were no objects, this value will be used
                    break;
                }
            }
            // if the trailing values were objects, use the merged value
            if (complexObjs.length) {
                dest[name] = mergeProps(complexObjs);
            }
        }
    }
    // copy values into the destination, going from last to first
    for (i = propObjs.length - 1; i >= 0; i--) {
        props = propObjs[i];
        for (name in props) {
            if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign
                dest[name] = props[name];
            }
        }
    }
    return dest;
}
exports.mergeProps = mergeProps;
function copyOwnProps(src, dest) {
    for (var name_1 in src) {
        if (hasOwnProp(src, name_1)) {
            dest[name_1] = src[name_1];
        }
    }
}
exports.copyOwnProps = copyOwnProps;
function hasOwnProp(obj, name) {
    return hasOwnPropMethod.call(obj, name);
}
exports.hasOwnProp = hasOwnProp;
function applyAll(functions, thisObj, args) {
    if ($.isFunction(functions)) {
        functions = [functions];
    }
    if (functions) {
        var i = void 0;
        var ret = void 0;
        for (i = 0; i < functions.length; i++) {
            ret = functions[i].apply(thisObj, args) || ret;
        }
        return ret;
    }
}
exports.applyAll = applyAll;
function removeMatching(array, testFunc) {
    var removeCnt = 0;
    var i = 0;
    while (i < array.length) {
        if (testFunc(array[i])) { // truthy value means *remove*
            array.splice(i, 1);
            removeCnt++;
        }
        else {
            i++;
        }
    }
    return removeCnt;
}
exports.removeMatching = removeMatching;
function removeExact(array, exactVal) {
    var removeCnt = 0;
    var i = 0;
    while (i < array.length) {
        if (array[i] === exactVal) {
            array.splice(i, 1);
            removeCnt++;
        }
        else {
            i++;
        }
    }
    return removeCnt;
}
exports.removeExact = removeExact;
function isArraysEqual(a0, a1) {
    var len = a0.length;
    var i;
    if (len == null || len !== a1.length) { // not array? or not same length?
        return false;
    }
    for (i = 0; i < len; i++) {
        if (a0[i] !== a1[i]) {
            return false;
        }
    }
    return true;
}
exports.isArraysEqual = isArraysEqual;
function firstDefined() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    for (var i = 0; i < args.length; i++) {
        if (args[i] !== undefined) {
            return args[i];
        }
    }
}
exports.firstDefined = firstDefined;
function htmlEscape(s) {
    return (s + '').replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/'/g, '&#039;')
        .replace(/"/g, '&quot;')
        .replace(/\n/g, '<br>');
}
exports.htmlEscape = htmlEscape;
function stripHtmlEntities(text) {
    return text.replace(/&.*?;/g, '');
}
exports.stripHtmlEntities = stripHtmlEntities;
// Given a hash of CSS properties, returns a string of CSS.
// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
function cssToStr(cssProps) {
    var statements = [];
    $.each(cssProps, function (name, val) {
        if (val != null) {
            statements.push(name + ':' + val);
        }
    });
    return statements.join(';');
}
exports.cssToStr = cssToStr;
// Given an object hash of HTML attribute names to values,
// generates a string that can be injected between < > in HTML
function attrsToStr(attrs) {
    var parts = [];
    $.each(attrs, function (name, val) {
        if (val != null) {
            parts.push(name + '="' + htmlEscape(val) + '"');
        }
    });
    return parts.join(' ');
}
exports.attrsToStr = attrsToStr;
function capitaliseFirstLetter(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
}
exports.capitaliseFirstLetter = capitaliseFirstLetter;
function compareNumbers(a, b) {
    return a - b;
}
exports.compareNumbers = compareNumbers;
function isInt(n) {
    return n % 1 === 0;
}
exports.isInt = isInt;
// Returns a method bound to the given object context.
// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with
// different contexts as identical when binding/unbinding events.
function proxy(obj, methodName) {
    var method = obj[methodName];
    return function () {
        return method.apply(obj, arguments);
    };
}
exports.proxy = proxy;
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
function debounce(func, wait, immediate) {
    if (immediate === void 0) { immediate = false; }
    var timeout;
    var args;
    var context;
    var timestamp;
    var result;
    var later = function () {
        var last = +new Date() - timestamp;
        if (last < wait) {
            timeout = setTimeout(later, wait - last);
        }
        else {
            timeout = null;
            if (!immediate) {
                result = func.apply(context, args);
                context = args = null;
            }
        }
    };
    return function () {
        context = this;
        args = arguments;
        timestamp = +new Date();
        var callNow = immediate && !timeout;
        if (!timeout) {
            timeout = setTimeout(later, wait);
        }
        if (callNow) {
            result = func.apply(context, args);
            context = args = null;
        }
        return result;
    };
}
exports.debounce = debounce;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(0);
var moment_ext_1 = __webpack_require__(11);
var UnzonedRange = /** @class */ (function () {
    function UnzonedRange(startInput, endInput) {
        // TODO: move these into footprint.
        // Especially, doesn't make sense for null startMs/endMs.
        this.isStart = true;
        this.isEnd = true;
        if (moment.isMoment(startInput)) {
            startInput = startInput.clone().stripZone();
        }
        if (moment.isMoment(endInput)) {
            endInput = endInput.clone().stripZone();
        }
        if (startInput) {
            this.startMs = startInput.valueOf();
        }
        if (endInput) {
            this.endMs = endInput.valueOf();
        }
    }
    /*
    SIDEEFFECT: will mutate eventRanges.
    Will return a new array result.
    Only works for non-open-ended ranges.
    */
    UnzonedRange.invertRanges = function (ranges, constraintRange) {
        var invertedRanges = [];
        var startMs = constraintRange.startMs; // the end of the previous range. the start of the new range
        var i;
        var dateRange;
        // ranges need to be in order. required for our date-walking algorithm
        ranges.sort(compareUnzonedRanges);
        for (i = 0; i < ranges.length; i++) {
            dateRange = ranges[i];
            // add the span of time before the event (if there is any)
            if (dateRange.startMs > startMs) { // compare millisecond time (skip any ambig logic)
                invertedRanges.push(new UnzonedRange(startMs, dateRange.startMs));
            }
            if (dateRange.endMs > startMs) {
                startMs = dateRange.endMs;
            }
        }
        // add the span of time after the last event (if there is any)
        if (startMs < constraintRange.endMs) { // compare millisecond time (skip any ambig logic)
            invertedRanges.push(new UnzonedRange(startMs, constraintRange.endMs));
        }
        return invertedRanges;
    };
    UnzonedRange.prototype.intersect = function (otherRange) {
        var startMs = this.startMs;
        var endMs = this.endMs;
        var newRange = null;
        if (otherRange.startMs != null) {
            if (startMs == null) {
                startMs = otherRange.startMs;
            }
            else {
                startMs = Math.max(startMs, otherRange.startMs);
            }
        }
        if (otherRange.endMs != null) {
            if (endMs == null) {
                endMs = otherRange.endMs;
            }
            else {
                endMs = Math.min(endMs, otherRange.endMs);
            }
        }
        if (startMs == null || endMs == null || startMs < endMs) {
            newRange = new UnzonedRange(startMs, endMs);
            newRange.isStart = this.isStart && startMs === this.startMs;
            newRange.isEnd = this.isEnd && endMs === this.endMs;
        }
        return newRange;
    };
    UnzonedRange.prototype.intersectsWith = function (otherRange) {
        return (this.endMs == null || otherRange.startMs == null || this.endMs > otherRange.startMs) &&
            (this.startMs == null || otherRange.endMs == null || this.startMs < otherRange.endMs);
    };
    UnzonedRange.prototype.containsRange = function (innerRange) {
        return (this.startMs == null || (innerRange.startMs != null && innerRange.startMs >= this.startMs)) &&
            (this.endMs == null || (innerRange.endMs != null && innerRange.endMs <= this.endMs));
    };
    // `date` can be a moment, a Date, or a millisecond time.
    UnzonedRange.prototype.containsDate = function (date) {
        var ms = date.valueOf();
        return (this.startMs == null || ms >= this.startMs) &&
            (this.endMs == null || ms < this.endMs);
    };
    // If the given date is not within the given range, move it inside.
    // (If it's past the end, make it one millisecond before the end).
    // `date` can be a moment, a Date, or a millisecond time.
    // Returns a MS-time.
    UnzonedRange.prototype.constrainDate = function (date) {
        var ms = date.valueOf();
        if (this.startMs != null && ms < this.startMs) {
            ms = this.startMs;
        }
        if (this.endMs != null && ms >= this.endMs) {
            ms = this.endMs - 1;
        }
        return ms;
    };
    UnzonedRange.prototype.equals = function (otherRange) {
        return this.startMs === otherRange.startMs && this.endMs === otherRange.endMs;
    };
    UnzonedRange.prototype.clone = function () {
        var range = new UnzonedRange(this.startMs, this.endMs);
        range.isStart = this.isStart;
        range.isEnd = this.isEnd;
        return range;
    };
    // Returns an ambig-zoned moment from startMs.
    // BEWARE: returned moment is not localized.
    // Formatting and start-of-week will be default.
    UnzonedRange.prototype.getStart = function () {
        if (this.startMs != null) {
            return moment_ext_1.default.utc(this.startMs).stripZone();
        }
        return null;
    };
    // Returns an ambig-zoned moment from startMs.
    // BEWARE: returned moment is not localized.
    // Formatting and start-of-week will be default.
    UnzonedRange.prototype.getEnd = function () {
        if (this.endMs != null) {
            return moment_ext_1.default.utc(this.endMs).stripZone();
        }
        return null;
    };
    UnzonedRange.prototype.as = function (unit) {
        return moment.utc(this.endMs).diff(moment.utc(this.startMs), unit, true);
    };
    return UnzonedRange;
}());
exports.default = UnzonedRange;
/*
Only works for non-open-ended ranges.
*/
function compareUnzonedRanges(range1, range2) {
    return range1.startMs - range2.startMs; // earlier ranges go first
}


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var ParsableModelMixin_1 = __webpack_require__(52);
var Class_1 = __webpack_require__(35);
var EventDefParser_1 = __webpack_require__(36);
var EventSource = /** @class */ (function (_super) {
    tslib_1.__extends(EventSource, _super);
    // can we do away with calendar? at least for the abstract?
    // useful for buildEventDef
    function EventSource(calendar) {
        var _this = _super.call(this) || this;
        _this.calendar = calendar;
        _this.className = [];
        _this.uid = String(EventSource.uuid++);
        return _this;
    }
    /*
    rawInput can be any data type!
    */
    EventSource.parse = function (rawInput, calendar) {
        var source = new this(calendar);
        if (typeof rawInput === 'object') {
            if (source.applyProps(rawInput)) {
                return source;
            }
        }
        return false;
    };
    EventSource.normalizeId = function (id) {
        if (id) {
            return String(id);
        }
        return null;
    };
    EventSource.prototype.fetch = function (start, end, timezone) {
        // subclasses must implement. must return a promise.
    };
    EventSource.prototype.removeEventDefsById = function (eventDefId) {
        // optional for subclasses to implement
    };
    EventSource.prototype.removeAllEventDefs = function () {
        // optional for subclasses to implement
    };
    /*
    For compairing/matching
    */
    EventSource.prototype.getPrimitive = function (otherSource) {
        // subclasses must implement
    };
    EventSource.prototype.parseEventDefs = function (rawEventDefs) {
        var i;
        var eventDef;
        var eventDefs = [];
        for (i = 0; i < rawEventDefs.length; i++) {
            eventDef = this.parseEventDef(rawEventDefs[i]);
            if (eventDef) {
                eventDefs.push(eventDef);
            }
        }
        return eventDefs;
    };
    EventSource.prototype.parseEventDef = function (rawInput) {
        var calendarTransform = this.calendar.opt('eventDataTransform');
        var sourceTransform = this.eventDataTransform;
        if (calendarTransform) {
            rawInput = calendarTransform(rawInput, this.calendar);
        }
        if (sourceTransform) {
            rawInput = sourceTransform(rawInput, this.calendar);
        }
        return EventDefParser_1.default.parse(rawInput, this);
    };
    EventSource.prototype.applyManualStandardProps = function (rawProps) {
        if (rawProps.id != null) {
            this.id = EventSource.normalizeId(rawProps.id);
        }
        // TODO: converge with EventDef
        if ($.isArray(rawProps.className)) {
            this.className = rawProps.className;
        }
        else if (typeof rawProps.className === 'string') {
            this.className = rawProps.className.split(/\s+/);
        }
        return true;
    };
    EventSource.uuid = 0;
    EventSource.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;
    EventSource.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;
    return EventSource;
}(Class_1.default));
exports.default = EventSource;
ParsableModelMixin_1.default.mixInto(EventSource);
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
EventSource.defineStandardProps({
    // manually process...
    id: false,
    className: false,
    // automatically transfer...
    color: true,
    backgroundColor: true,
    borderColor: true,
    textColor: true,
    editable: true,
    startEditable: true,
    durationEditable: true,
    rendering: true,
    overlap: true,
    constraint: true,
    allDayDefault: true,
    eventDataTransform: true
});


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

/*
Utility methods for easily listening to events on another object,
and more importantly, easily unlistening from them.

USAGE:
  import { default as ListenerMixin, ListenerInterface } from './ListenerMixin'
in class:
  listenTo: ListenerInterface['listenTo']
  stopListeningTo: ListenerInterface['stopListeningTo']
after class:
  ListenerMixin.mixInto(TheClass)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var Mixin_1 = __webpack_require__(15);
var guid = 0;
var ListenerMixin = /** @class */ (function (_super) {
    tslib_1.__extends(ListenerMixin, _super);
    function ListenerMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
    Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.
    The `callback` will be called with the `this` context of the object that .listenTo is being called on.
    Can be called:
      .listenTo(other, eventName, callback)
    OR
      .listenTo(other, {
        eventName1: callback1,
        eventName2: callback2
      })
    */
    ListenerMixin.prototype.listenTo = function (other, arg, callback) {
        if (typeof arg === 'object') { // given dictionary of callbacks
            for (var eventName in arg) {
                if (arg.hasOwnProperty(eventName)) {
                    this.listenTo(other, eventName, arg[eventName]);
                }
            }
        }
        else if (typeof arg === 'string') {
            other.on(arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object
            $.proxy(callback, this) // always use `this` context
            // the usually-undesired jQuery guid behavior doesn't matter,
            // because we always unbind via namespace
            );
        }
    };
    /*
    Causes the current object to stop listening to events on the `other` object.
    `eventName` is optional. If omitted, will stop listening to ALL events on `other`.
    */
    ListenerMixin.prototype.stopListeningTo = function (other, eventName) {
        other.off((eventName || '') + '.' + this.getListenerNamespace());
    };
    /*
    Returns a string, unique to this object, to be used for event namespacing
    */
    ListenerMixin.prototype.getListenerNamespace = function () {
        if (this.listenerId == null) {
            this.listenerId = guid++;
        }
        return '_listener' + this.listenerId;
    };
    return ListenerMixin;
}(Mixin_1.default));
exports.default = ListenerMixin;


/***/ }),
/* 8 */,
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var EventDef_1 = __webpack_require__(37);
var EventInstance_1 = __webpack_require__(53);
var EventDateProfile_1 = __webpack_require__(16);
var SingleEventDef = /** @class */ (function (_super) {
    tslib_1.__extends(SingleEventDef, _super);
    function SingleEventDef() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
    Will receive start/end params, but will be ignored.
    */
    SingleEventDef.prototype.buildInstances = function () {
        return [this.buildInstance()];
    };
    SingleEventDef.prototype.buildInstance = function () {
        return new EventInstance_1.default(this, // definition
        this.dateProfile);
    };
    SingleEventDef.prototype.isAllDay = function () {
        return this.dateProfile.isAllDay();
    };
    SingleEventDef.prototype.clone = function () {
        var def = _super.prototype.clone.call(this);
        def.dateProfile = this.dateProfile;
        return def;
    };
    SingleEventDef.prototype.rezone = function () {
        var calendar = this.source.calendar;
        var dateProfile = this.dateProfile;
        this.dateProfile = new EventDateProfile_1.default(calendar.moment(dateProfile.start), dateProfile.end ? calendar.moment(dateProfile.end) : null, calendar);
    };
    /*
    NOTE: if super-method fails, should still attempt to apply
    */
    SingleEventDef.prototype.applyManualStandardProps = function (rawProps) {
        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
        var dateProfile = EventDateProfile_1.default.parse(rawProps, this.source); // returns null on failure
        if (dateProfile) {
            this.dateProfile = dateProfile;
            // make sure `date` shows up in the legacy event objects as-is
            if (rawProps.date != null) {
                this.miscProps.date = rawProps.date;
            }
            return superSuccess;
        }
        else {
            return false;
        }
    };
    return SingleEventDef;
}(EventDef_1.default));
exports.default = SingleEventDef;
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
SingleEventDef.defineStandardProps({
    start: false,
    date: false,
    end: false,
    allDay: false
});


/***/ }),
/* 10 */,
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(0);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
var ambigTimeOrZoneRegex = /^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
var newMomentProto = moment.fn; // where we will attach our new methods
exports.newMomentProto = newMomentProto;
var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods
exports.oldMomentProto = oldMomentProto;
// tell momentjs to transfer these properties upon clone
var momentProperties = moment.momentProperties;
momentProperties.push('_fullCalendar');
momentProperties.push('_ambigTime');
momentProperties.push('_ambigZone');
/*
Call this if you want Moment's original format method to be used
*/
function oldMomentFormat(mom, formatStr) {
    return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js
}
exports.oldMomentFormat = oldMomentFormat;
// Creating
// -------------------------------------------------------------------------------------------------
// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
var momentExt = function () {
    return makeMoment(arguments);
};
exports.default = momentExt;
// Sames as momentExt, but forces the resulting moment to be in the UTC timezone.
momentExt.utc = function () {
    var mom = makeMoment(arguments, true);
    // Force it into UTC because makeMoment doesn't guarantee it
    // (if given a pre-existing moment for example)
    if (mom.hasTime()) { // don't give ambiguously-timed moments a UTC zone
        mom.utc();
    }
    return mom;
};
// Same as momentExt, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
momentExt.parseZone = function () {
    return makeMoment(arguments, true, true);
};
// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
function makeMoment(args, parseAsUTC, parseZone) {
    if (parseAsUTC === void 0) { parseAsUTC = false; }
    if (parseZone === void 0) { parseZone = false; }
    var input = args[0];
    var isSingleString = args.length === 1 && typeof input === 'string';
    var isAmbigTime;
    var isAmbigZone;
    var ambigMatch;
    var mom;
    if (moment.isMoment(input) || util_1.isNativeDate(input) || input === undefined) {
        mom = moment.apply(null, args);
    }
    else { // "parsing" is required
        isAmbigTime = false;
        isAmbigZone = false;
        if (isSingleString) {
            if (ambigDateOfMonthRegex.test(input)) {
                // accept strings like '2014-05', but convert to the first of the month
                input += '-01';
                args = [input]; // for when we pass it on to moment's constructor
                isAmbigTime = true;
                isAmbigZone = true;
            }
            else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
                isAmbigTime = !ambigMatch[5]; // no time part?
                isAmbigZone = true;
            }
        }
        else if ($.isArray(input)) {
            // arrays have no timezone information, so assume ambiguous zone
            isAmbigZone = true;
        }
        // otherwise, probably a string with a format
        if (parseAsUTC || isAmbigTime) {
            mom = moment.utc.apply(moment, args);
        }
        else {
            mom = moment.apply(null, args);
        }
        if (isAmbigTime) {
            mom._ambigTime = true;
            mom._ambigZone = true; // ambiguous time always means ambiguous zone
        }
        else if (parseZone) { // let's record the inputted zone somehow
            if (isAmbigZone) {
                mom._ambigZone = true;
            }
            else if (isSingleString) {
                mom.utcOffset(input); // if not a valid zone, will assign UTC
            }
        }
    }
    mom._fullCalendar = true; // flag for extended functionality
    return mom;
}
// Week Number
// -------------------------------------------------------------------------------------------------
// Returns the week number, considering the locale's custom week number calcuation
// `weeks` is an alias for `week`
newMomentProto.week = newMomentProto.weeks = function (input) {
    var weekCalc = this._locale._fullCalendar_weekCalc;
    if (input == null && typeof weekCalc === 'function') { // custom function only works for getter
        return weekCalc(this);
    }
    else if (weekCalc === 'ISO') {
        return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter
    }
    return oldMomentProto.week.apply(this, arguments); // local getter/setter
};
// Time-of-day
// -------------------------------------------------------------------------------------------------
// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
newMomentProto.time = function (time) {
    // Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
    // `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
    if (!this._fullCalendar) {
        return oldMomentProto.time.apply(this, arguments);
    }
    if (time == null) { // getter
        return moment.duration({
            hours: this.hours(),
            minutes: this.minutes(),
            seconds: this.seconds(),
            milliseconds: this.milliseconds()
        });
    }
    else { // setter
        this._ambigTime = false; // mark that the moment now has a time
        if (!moment.isDuration(time) && !moment.isMoment(time)) {
            time = moment.duration(time);
        }
        // The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
        // Only for Duration times, not Moment times.
        var dayHours = 0;
        if (moment.isDuration(time)) {
            dayHours = Math.floor(time.asDays()) * 24;
        }
        // We need to set the individual fields.
        // Can't use startOf('day') then add duration. In case of DST at start of day.
        return this.hours(dayHours + time.hours())
            .minutes(time.minutes())
            .seconds(time.seconds())
            .milliseconds(time.milliseconds());
    }
};
// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
newMomentProto.stripTime = function () {
    if (!this._ambigTime) {
        this.utc(true); // keepLocalTime=true (for keeping *date* value)
        // set time to zero
        this.set({
            hours: 0,
            minutes: 0,
            seconds: 0,
            ms: 0
        });
        // Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
        // which clears all ambig flags.
        this._ambigTime = true;
        this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset
    }
    return this; // for chaining
};
// Returns if the moment has a non-ambiguous time (boolean)
newMomentProto.hasTime = function () {
    return !this._ambigTime;
};
// Timezone
// -------------------------------------------------------------------------------------------------
// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
newMomentProto.stripZone = function () {
    var wasAmbigTime;
    if (!this._ambigZone) {
        wasAmbigTime = this._ambigTime;
        this.utc(true); // keepLocalTime=true (for keeping date and time values)
        // the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
        this._ambigTime = wasAmbigTime || false;
        // Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
        // which clears the ambig flags.
        this._ambigZone = true;
    }
    return this; // for chaining
};
// Returns of the moment has a non-ambiguous timezone offset (boolean)
newMomentProto.hasZone = function () {
    return !this._ambigZone;
};
// implicitly marks a zone
newMomentProto.local = function (keepLocalTime) {
    // for when converting from ambiguously-zoned to local,
    // keep the time values when converting from UTC -> local
    oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);
    // ensure non-ambiguous
    // this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals
    this._ambigTime = false;
    this._ambigZone = false;
    return this; // for chaining
};
// implicitly marks a zone
newMomentProto.utc = function (keepLocalTime) {
    oldMomentProto.utc.call(this, keepLocalTime);
    // ensure non-ambiguous
    // this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals
    this._ambigTime = false;
    this._ambigZone = false;
    return this;
};
// implicitly marks a zone (will probably get called upon .utc() and .local())
newMomentProto.utcOffset = function (tzo) {
    if (tzo != null) { // setter
        // these assignments needs to happen before the original zone method is called.
        // I forget why, something to do with a browser crash.
        this._ambigTime = false;
        this._ambigZone = false;
    }
    return oldMomentProto.utcOffset.apply(this, arguments);
};


/***/ }),
/* 12 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
/*
Meant to be immutable
*/
var ComponentFootprint = /** @class */ (function () {
    function ComponentFootprint(unzonedRange, isAllDay) {
        this.isAllDay = false; // component can choose to ignore this
        this.unzonedRange = unzonedRange;
        this.isAllDay = isAllDay;
    }
    /*
    Only works for non-open-ended ranges.
    */
    ComponentFootprint.prototype.toLegacy = function (calendar) {
        return {
            start: calendar.msToMoment(this.unzonedRange.startMs, this.isAllDay),
            end: calendar.msToMoment(this.unzonedRange.endMs, this.isAllDay)
        };
    };
    return ComponentFootprint;
}());
exports.default = ComponentFootprint;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

/*
USAGE:
  import { default as EmitterMixin, EmitterInterface } from './EmitterMixin'
in class:
  on: EmitterInterface['on']
  one: EmitterInterface['one']
  off: EmitterInterface['off']
  trigger: EmitterInterface['trigger']
  triggerWith: EmitterInterface['triggerWith']
  hasHandlers: EmitterInterface['hasHandlers']
after class:
  EmitterMixin.mixInto(TheClass)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var Mixin_1 = __webpack_require__(15);
var EmitterMixin = /** @class */ (function (_super) {
    tslib_1.__extends(EmitterMixin, _super);
    function EmitterMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // jQuery-ification via $(this) allows a non-DOM object to have
    // the same event handling capabilities (including namespaces).
    EmitterMixin.prototype.on = function (types, handler) {
        $(this).on(types, this._prepareIntercept(handler));
        return this; // for chaining
    };
    EmitterMixin.prototype.one = function (types, handler) {
        $(this).one(types, this._prepareIntercept(handler));
        return this; // for chaining
    };
    EmitterMixin.prototype._prepareIntercept = function (handler) {
        // handlers are always called with an "event" object as their first param.
        // sneak the `this` context and arguments into the extra parameter object
        // and forward them on to the original handler.
        var intercept = function (ev, extra) {
            return handler.apply(extra.context || this, extra.args || []);
        };
        // mimick jQuery's internal "proxy" system (risky, I know)
        // causing all functions with the same .guid to appear to be the same.
        // https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448
        // this is needed for calling .off with the original non-intercept handler.
        if (!handler.guid) {
            handler.guid = $.guid++;
        }
        intercept.guid = handler.guid;
        return intercept;
    };
    EmitterMixin.prototype.off = function (types, handler) {
        $(this).off(types, handler);
        return this; // for chaining
    };
    EmitterMixin.prototype.trigger = function (types) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        // pass in "extra" info to the intercept
        $(this).triggerHandler(types, { args: args });
        return this; // for chaining
    };
    EmitterMixin.prototype.triggerWith = function (types, context, args) {
        // `triggerHandler` is less reliant on the DOM compared to `trigger`.
        // pass in "extra" info to the intercept.
        $(this).triggerHandler(types, { context: context, args: args });
        return this; // for chaining
    };
    EmitterMixin.prototype.hasHandlers = function (type) {
        var hash = $._data(this, 'events'); // http://blog.jquery.com/2012/08/09/jquery-1-8-released/
        return hash && hash[type] && hash[type].length > 0;
    };
    return EmitterMixin;
}(Mixin_1.default));
exports.default = EmitterMixin;


/***/ }),
/* 14 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var Interaction = /** @class */ (function () {
    function Interaction(component) {
        this.view = component._getView();
        this.component = component;
    }
    Interaction.prototype.opt = function (name) {
        return this.view.opt(name);
    };
    Interaction.prototype.end = function () {
        // subclasses can implement
    };
    return Interaction;
}());
exports.default = Interaction;


/***/ }),
/* 15 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var Mixin = /** @class */ (function () {
    function Mixin() {
    }
    Mixin.mixInto = function (destClass) {
        var _this = this;
        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
            if (!destClass.prototype[name]) { // if destination class doesn't already define it
                destClass.prototype[name] = _this.prototype[name];
            }
        });
    };
    /*
    will override existing methods
    TODO: remove! not used anymore
    */
    Mixin.mixOver = function (destClass) {
        var _this = this;
        Object.getOwnPropertyNames(this.prototype).forEach(function (name) {
            destClass.prototype[name] = _this.prototype[name];
        });
    };
    return Mixin;
}());
exports.default = Mixin;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var UnzonedRange_1 = __webpack_require__(5);
/*
Meant to be immutable
*/
var EventDateProfile = /** @class */ (function () {
    function EventDateProfile(start, end, calendar) {
        this.start = start;
        this.end = end || null;
        this.unzonedRange = this.buildUnzonedRange(calendar);
    }
    /*
    Needs an EventSource object
    */
    EventDateProfile.parse = function (rawProps, source) {
        var startInput = rawProps.start || rawProps.date;
        var endInput = rawProps.end;
        if (!startInput) {
            return false;
        }
        var calendar = source.calendar;
        var start = calendar.moment(startInput);
        var end = endInput ? calendar.moment(endInput) : null;
        var forcedAllDay = rawProps.allDay;
        var forceEventDuration = calendar.opt('forceEventDuration');
        if (!start.isValid()) {
            return false;
        }
        if (forcedAllDay == null) {
            forcedAllDay = source.allDayDefault;
            if (forcedAllDay == null) {
                forcedAllDay = calendar.opt('allDayDefault');
            }
        }
        if (forcedAllDay === true) {
            start.stripTime();
            if (end) {
                end.stripTime();
            }
        }
        else if (forcedAllDay === false) {
            if (!start.hasTime()) {
                start.time(0);
            }
            if (end && !end.hasTime()) {
                end.time(0);
            }
        }
        if (end && (!end.isValid() || !end.isAfter(start))) {
            end = null;
        }
        if (!end && forceEventDuration) {
            end = calendar.getDefaultEventEnd(!start.hasTime(), start);
        }
        return new EventDateProfile(start, end, calendar);
    };
    EventDateProfile.isStandardProp = function (propName) {
        return propName === 'start' || propName === 'date' || propName === 'end' || propName === 'allDay';
    };
    EventDateProfile.prototype.isAllDay = function () {
        return !(this.start.hasTime() || (this.end && this.end.hasTime()));
    };
    /*
    Needs a Calendar object
    */
    EventDateProfile.prototype.buildUnzonedRange = function (calendar) {
        var startMs = this.start.clone().stripZone().valueOf();
        var endMs = this.getEnd(calendar).stripZone().valueOf();
        return new UnzonedRange_1.default(startMs, endMs);
    };
    /*
    Needs a Calendar object
    */
    EventDateProfile.prototype.getEnd = function (calendar) {
        return this.end ?
            this.end.clone() :
            // derive the end from the start and allDay. compute allDay if necessary
            calendar.getDefaultEventEnd(this.isAllDay(), this.start);
    };
    return EventDateProfile;
}());
exports.default = EventDateProfile;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var DragListener_1 = __webpack_require__(59);
/* Tracks mouse movements over a component and raises events about which hit the mouse is over.
------------------------------------------------------------------------------------------------------------------------
options:
- subjectEl
- subjectCenter
*/
var HitDragListener = /** @class */ (function (_super) {
    tslib_1.__extends(HitDragListener, _super);
    function HitDragListener(component, options) {
        var _this = _super.call(this, options) || this;
        _this.component = component;
        return _this;
    }
    // Called when drag listening starts (but a real drag has not necessarily began).
    // ev might be undefined if dragging was started manually.
    HitDragListener.prototype.handleInteractionStart = function (ev) {
        var subjectEl = this.subjectEl;
        var subjectRect;
        var origPoint;
        var point;
        this.component.hitsNeeded();
        this.computeScrollBounds(); // for autoscroll
        if (ev) {
            origPoint = { left: util_1.getEvX(ev), top: util_1.getEvY(ev) };
            point = origPoint;
            // constrain the point to bounds of the element being dragged
            if (subjectEl) {
                subjectRect = util_1.getOuterRect(subjectEl); // used for centering as well
                point = util_1.constrainPoint(point, subjectRect);
            }
            this.origHit = this.queryHit(point.left, point.top);
            // treat the center of the subject as the collision point?
            if (subjectEl && this.options.subjectCenter) {
                // only consider the area the subject overlaps the hit. best for large subjects.
                // TODO: skip this if hit didn't supply left/right/top/bottom
                if (this.origHit) {
                    subjectRect = util_1.intersectRects(this.origHit, subjectRect) ||
                        subjectRect; // in case there is no intersection
                }
                point = util_1.getRectCenter(subjectRect);
            }
            this.coordAdjust = util_1.diffPoints(point, origPoint); // point - origPoint
        }
        else {
            this.origHit = null;
            this.coordAdjust = null;
        }
        // call the super-method. do it after origHit has been computed
        _super.prototype.handleInteractionStart.call(this, ev);
    };
    // Called when the actual drag has started
    HitDragListener.prototype.handleDragStart = function (ev) {
        var hit;
        _super.prototype.handleDragStart.call(this, ev);
        // might be different from this.origHit if the min-distance is large
        hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));
        // report the initial hit the mouse is over
        // especially important if no min-distance and drag starts immediately
        if (hit) {
            this.handleHitOver(hit);
        }
    };
    // Called when the drag moves
    HitDragListener.prototype.handleDrag = function (dx, dy, ev) {
        var hit;
        _super.prototype.handleDrag.call(this, dx, dy, ev);
        hit = this.queryHit(util_1.getEvX(ev), util_1.getEvY(ev));
        if (!isHitsEqual(hit, this.hit)) { // a different hit than before?
            if (this.hit) {
                this.handleHitOut();
            }
            if (hit) {
                this.handleHitOver(hit);
            }
        }
    };
    // Called when dragging has been stopped
    HitDragListener.prototype.handleDragEnd = function (ev) {
        this.handleHitDone();
        _super.prototype.handleDragEnd.call(this, ev);
    };
    // Called when a the mouse has just moved over a new hit
    HitDragListener.prototype.handleHitOver = function (hit) {
        var isOrig = isHitsEqual(hit, this.origHit);
        this.hit = hit;
        this.trigger('hitOver', this.hit, isOrig, this.origHit);
    };
    // Called when the mouse has just moved out of a hit
    HitDragListener.prototype.handleHitOut = function () {
        if (this.hit) {
            this.trigger('hitOut', this.hit);
            this.handleHitDone();
            this.hit = null;
        }
    };
    // Called after a hitOut. Also called before a dragStop
    HitDragListener.prototype.handleHitDone = function () {
        if (this.hit) {
            this.trigger('hitDone', this.hit);
        }
    };
    // Called when the interaction ends, whether there was a real drag or not
    HitDragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {
        _super.prototype.handleInteractionEnd.call(this, ev, isCancelled);
        this.origHit = null;
        this.hit = null;
        this.component.hitsNotNeeded();
    };
    // Called when scrolling has stopped, whether through auto scroll, or the user scrolling
    HitDragListener.prototype.handleScrollEnd = function () {
        _super.prototype.handleScrollEnd.call(this);
        // hits' absolute positions will be in new places after a user's scroll.
        // HACK for recomputing.
        if (this.isDragging) {
            this.component.releaseHits();
            this.component.prepareHits();
        }
    };
    // Gets the hit underneath the coordinates for the given mouse event
    HitDragListener.prototype.queryHit = function (left, top) {
        if (this.coordAdjust) {
            left += this.coordAdjust.left;
            top += this.coordAdjust.top;
        }
        return this.component.queryHit(left, top);
    };
    return HitDragListener;
}(DragListener_1.default));
exports.default = HitDragListener;
// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.
// Two null values will be considered equal, as two "out of the component" states are the same.
function isHitsEqual(hit0, hit1) {
    if (!hit0 && !hit1) {
        return true;
    }
    if (hit0 && hit1) {
        return hit0.component === hit1.component &&
            isHitPropsWithin(hit0, hit1) &&
            isHitPropsWithin(hit1, hit0); // ensures all props are identical
    }
    return false;
}
// Returns true if all of subHit's non-standard properties are within superHit
function isHitPropsWithin(subHit, superHit) {
    for (var propName in subHit) {
        if (!/^(component|left|right|top|bottom)$/.test(propName)) {
            if (subHit[propName] !== superHit[propName]) {
                return false;
            }
        }
    }
    return true;
}


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.version = '3.10.2';
// When introducing internal API incompatibilities (where fullcalendar plugins would break),
// the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)
// and the below integer should be incremented.
exports.internalApiVersion = 12;
var util_1 = __webpack_require__(4);
exports.applyAll = util_1.applyAll;
exports.debounce = util_1.debounce;
exports.isInt = util_1.isInt;
exports.htmlEscape = util_1.htmlEscape;
exports.cssToStr = util_1.cssToStr;
exports.proxy = util_1.proxy;
exports.capitaliseFirstLetter = util_1.capitaliseFirstLetter;
exports.getOuterRect = util_1.getOuterRect;
exports.getClientRect = util_1.getClientRect;
exports.getContentRect = util_1.getContentRect;
exports.getScrollbarWidths = util_1.getScrollbarWidths;
exports.preventDefault = util_1.preventDefault;
exports.parseFieldSpecs = util_1.parseFieldSpecs;
exports.compareByFieldSpecs = util_1.compareByFieldSpecs;
exports.compareByFieldSpec = util_1.compareByFieldSpec;
exports.flexibleCompare = util_1.flexibleCompare;
exports.computeGreatestUnit = util_1.computeGreatestUnit;
exports.divideRangeByDuration = util_1.divideRangeByDuration;
exports.divideDurationByDuration = util_1.divideDurationByDuration;
exports.multiplyDuration = util_1.multiplyDuration;
exports.durationHasTime = util_1.durationHasTime;
exports.log = util_1.log;
exports.warn = util_1.warn;
exports.removeExact = util_1.removeExact;
exports.intersectRects = util_1.intersectRects;
exports.allowSelection = util_1.allowSelection;
exports.attrsToStr = util_1.attrsToStr;
exports.compareNumbers = util_1.compareNumbers;
exports.compensateScroll = util_1.compensateScroll;
exports.computeDurationGreatestUnit = util_1.computeDurationGreatestUnit;
exports.constrainPoint = util_1.constrainPoint;
exports.copyOwnProps = util_1.copyOwnProps;
exports.diffByUnit = util_1.diffByUnit;
exports.diffDay = util_1.diffDay;
exports.diffDayTime = util_1.diffDayTime;
exports.diffPoints = util_1.diffPoints;
exports.disableCursor = util_1.disableCursor;
exports.distributeHeight = util_1.distributeHeight;
exports.enableCursor = util_1.enableCursor;
exports.firstDefined = util_1.firstDefined;
exports.getEvIsTouch = util_1.getEvIsTouch;
exports.getEvX = util_1.getEvX;
exports.getEvY = util_1.getEvY;
exports.getRectCenter = util_1.getRectCenter;
exports.getScrollParent = util_1.getScrollParent;
exports.hasOwnProp = util_1.hasOwnProp;
exports.isArraysEqual = util_1.isArraysEqual;
exports.isNativeDate = util_1.isNativeDate;
exports.isPrimaryMouseButton = util_1.isPrimaryMouseButton;
exports.isTimeString = util_1.isTimeString;
exports.matchCellWidths = util_1.matchCellWidths;
exports.mergeProps = util_1.mergeProps;
exports.preventSelection = util_1.preventSelection;
exports.removeMatching = util_1.removeMatching;
exports.stripHtmlEntities = util_1.stripHtmlEntities;
exports.subtractInnerElHeight = util_1.subtractInnerElHeight;
exports.uncompensateScroll = util_1.uncompensateScroll;
exports.undistributeHeight = util_1.undistributeHeight;
exports.dayIDs = util_1.dayIDs;
exports.unitsDesc = util_1.unitsDesc;
var date_formatting_1 = __webpack_require__(49);
exports.formatDate = date_formatting_1.formatDate;
exports.formatRange = date_formatting_1.formatRange;
exports.queryMostGranularFormatUnit = date_formatting_1.queryMostGranularFormatUnit;
var locale_1 = __webpack_require__(32);
exports.datepickerLocale = locale_1.datepickerLocale;
exports.locale = locale_1.locale;
exports.getMomentLocaleData = locale_1.getMomentLocaleData;
exports.populateInstanceComputableOptions = locale_1.populateInstanceComputableOptions;
var util_2 = __webpack_require__(19);
exports.eventDefsToEventInstances = util_2.eventDefsToEventInstances;
exports.eventFootprintToComponentFootprint = util_2.eventFootprintToComponentFootprint;
exports.eventInstanceToEventRange = util_2.eventInstanceToEventRange;
exports.eventInstanceToUnzonedRange = util_2.eventInstanceToUnzonedRange;
exports.eventRangeToEventFootprint = util_2.eventRangeToEventFootprint;
var moment_ext_1 = __webpack_require__(11);
exports.moment = moment_ext_1.default;
var EmitterMixin_1 = __webpack_require__(13);
exports.EmitterMixin = EmitterMixin_1.default;
var ListenerMixin_1 = __webpack_require__(7);
exports.ListenerMixin = ListenerMixin_1.default;
var Model_1 = __webpack_require__(51);
exports.Model = Model_1.default;
var Constraints_1 = __webpack_require__(217);
exports.Constraints = Constraints_1.default;
var DateProfileGenerator_1 = __webpack_require__(55);
exports.DateProfileGenerator = DateProfileGenerator_1.default;
var UnzonedRange_1 = __webpack_require__(5);
exports.UnzonedRange = UnzonedRange_1.default;
var ComponentFootprint_1 = __webpack_require__(12);
exports.ComponentFootprint = ComponentFootprint_1.default;
var BusinessHourGenerator_1 = __webpack_require__(218);
exports.BusinessHourGenerator = BusinessHourGenerator_1.default;
var EventPeriod_1 = __webpack_require__(219);
exports.EventPeriod = EventPeriod_1.default;
var EventManager_1 = __webpack_require__(220);
exports.EventManager = EventManager_1.default;
var EventDef_1 = __webpack_require__(37);
exports.EventDef = EventDef_1.default;
var EventDefMutation_1 = __webpack_require__(39);
exports.EventDefMutation = EventDefMutation_1.default;
var EventDefParser_1 = __webpack_require__(36);
exports.EventDefParser = EventDefParser_1.default;
var EventInstance_1 = __webpack_require__(53);
exports.EventInstance = EventInstance_1.default;
var EventRange_1 = __webpack_require__(50);
exports.EventRange = EventRange_1.default;
var RecurringEventDef_1 = __webpack_require__(54);
exports.RecurringEventDef = RecurringEventDef_1.default;
var SingleEventDef_1 = __webpack_require__(9);
exports.SingleEventDef = SingleEventDef_1.default;
var EventDefDateMutation_1 = __webpack_require__(40);
exports.EventDefDateMutation = EventDefDateMutation_1.default;
var EventDateProfile_1 = __webpack_require__(16);
exports.EventDateProfile = EventDateProfile_1.default;
var EventSourceParser_1 = __webpack_require__(38);
exports.EventSourceParser = EventSourceParser_1.default;
var EventSource_1 = __webpack_require__(6);
exports.EventSource = EventSource_1.default;
var ThemeRegistry_1 = __webpack_require__(57);
exports.defineThemeSystem = ThemeRegistry_1.defineThemeSystem;
exports.getThemeSystemClass = ThemeRegistry_1.getThemeSystemClass;
var EventInstanceGroup_1 = __webpack_require__(20);
exports.EventInstanceGroup = EventInstanceGroup_1.default;
var ArrayEventSource_1 = __webpack_require__(56);
exports.ArrayEventSource = ArrayEventSource_1.default;
var FuncEventSource_1 = __webpack_require__(223);
exports.FuncEventSource = FuncEventSource_1.default;
var JsonFeedEventSource_1 = __webpack_require__(224);
exports.JsonFeedEventSource = JsonFeedEventSource_1.default;
var EventFootprint_1 = __webpack_require__(34);
exports.EventFootprint = EventFootprint_1.default;
var Class_1 = __webpack_require__(35);
exports.Class = Class_1.default;
var Mixin_1 = __webpack_require__(15);
exports.Mixin = Mixin_1.default;
var CoordCache_1 = __webpack_require__(58);
exports.CoordCache = CoordCache_1.default;
var Iterator_1 = __webpack_require__(225);
exports.Iterator = Iterator_1.default;
var DragListener_1 = __webpack_require__(59);
exports.DragListener = DragListener_1.default;
var HitDragListener_1 = __webpack_require__(17);
exports.HitDragListener = HitDragListener_1.default;
var MouseFollower_1 = __webpack_require__(226);
exports.MouseFollower = MouseFollower_1.default;
var ParsableModelMixin_1 = __webpack_require__(52);
exports.ParsableModelMixin = ParsableModelMixin_1.default;
var Popover_1 = __webpack_require__(227);
exports.Popover = Popover_1.default;
var Promise_1 = __webpack_require__(21);
exports.Promise = Promise_1.default;
var TaskQueue_1 = __webpack_require__(228);
exports.TaskQueue = TaskQueue_1.default;
var RenderQueue_1 = __webpack_require__(229);
exports.RenderQueue = RenderQueue_1.default;
var Scroller_1 = __webpack_require__(41);
exports.Scroller = Scroller_1.default;
var Theme_1 = __webpack_require__(22);
exports.Theme = Theme_1.default;
var Component_1 = __webpack_require__(230);
exports.Component = Component_1.default;
var DateComponent_1 = __webpack_require__(231);
exports.DateComponent = DateComponent_1.default;
var InteractiveDateComponent_1 = __webpack_require__(42);
exports.InteractiveDateComponent = InteractiveDateComponent_1.default;
var Calendar_1 = __webpack_require__(232);
exports.Calendar = Calendar_1.default;
var View_1 = __webpack_require__(43);
exports.View = View_1.default;
var ViewRegistry_1 = __webpack_require__(24);
exports.defineView = ViewRegistry_1.defineView;
exports.getViewConfig = ViewRegistry_1.getViewConfig;
var DayTableMixin_1 = __webpack_require__(60);
exports.DayTableMixin = DayTableMixin_1.default;
var BusinessHourRenderer_1 = __webpack_require__(61);
exports.BusinessHourRenderer = BusinessHourRenderer_1.default;
var EventRenderer_1 = __webpack_require__(44);
exports.EventRenderer = EventRenderer_1.default;
var FillRenderer_1 = __webpack_require__(62);
exports.FillRenderer = FillRenderer_1.default;
var HelperRenderer_1 = __webpack_require__(63);
exports.HelperRenderer = HelperRenderer_1.default;
var ExternalDropping_1 = __webpack_require__(233);
exports.ExternalDropping = ExternalDropping_1.default;
var EventResizing_1 = __webpack_require__(234);
exports.EventResizing = EventResizing_1.default;
var EventPointing_1 = __webpack_require__(64);
exports.EventPointing = EventPointing_1.default;
var EventDragging_1 = __webpack_require__(235);
exports.EventDragging = EventDragging_1.default;
var DateSelecting_1 = __webpack_require__(236);
exports.DateSelecting = DateSelecting_1.default;
var DateClicking_1 = __webpack_require__(237);
exports.DateClicking = DateClicking_1.default;
var Interaction_1 = __webpack_require__(14);
exports.Interaction = Interaction_1.default;
var StandardInteractionsMixin_1 = __webpack_require__(65);
exports.StandardInteractionsMixin = StandardInteractionsMixin_1.default;
var AgendaView_1 = __webpack_require__(238);
exports.AgendaView = AgendaView_1.default;
var TimeGrid_1 = __webpack_require__(239);
exports.TimeGrid = TimeGrid_1.default;
var TimeGridEventRenderer_1 = __webpack_require__(240);
exports.TimeGridEventRenderer = TimeGridEventRenderer_1.default;
var TimeGridFillRenderer_1 = __webpack_require__(242);
exports.TimeGridFillRenderer = TimeGridFillRenderer_1.default;
var TimeGridHelperRenderer_1 = __webpack_require__(241);
exports.TimeGridHelperRenderer = TimeGridHelperRenderer_1.default;
var DayGrid_1 = __webpack_require__(66);
exports.DayGrid = DayGrid_1.default;
var DayGridEventRenderer_1 = __webpack_require__(243);
exports.DayGridEventRenderer = DayGridEventRenderer_1.default;
var DayGridFillRenderer_1 = __webpack_require__(245);
exports.DayGridFillRenderer = DayGridFillRenderer_1.default;
var DayGridHelperRenderer_1 = __webpack_require__(244);
exports.DayGridHelperRenderer = DayGridHelperRenderer_1.default;
var BasicView_1 = __webpack_require__(67);
exports.BasicView = BasicView_1.default;
var BasicViewDateProfileGenerator_1 = __webpack_require__(68);
exports.BasicViewDateProfileGenerator = BasicViewDateProfileGenerator_1.default;
var MonthView_1 = __webpack_require__(246);
exports.MonthView = MonthView_1.default;
var MonthViewDateProfileGenerator_1 = __webpack_require__(247);
exports.MonthViewDateProfileGenerator = MonthViewDateProfileGenerator_1.default;
var ListView_1 = __webpack_require__(248);
exports.ListView = ListView_1.default;
var ListEventPointing_1 = __webpack_require__(250);
exports.ListEventPointing = ListEventPointing_1.default;
var ListEventRenderer_1 = __webpack_require__(249);
exports.ListEventRenderer = ListEventRenderer_1.default;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventRange_1 = __webpack_require__(50);
var EventFootprint_1 = __webpack_require__(34);
var ComponentFootprint_1 = __webpack_require__(12);
function eventDefsToEventInstances(eventDefs, unzonedRange) {
    var eventInstances = [];
    var i;
    for (i = 0; i < eventDefs.length; i++) {
        eventInstances.push.apply(eventInstances, // append
        eventDefs[i].buildInstances(unzonedRange));
    }
    return eventInstances;
}
exports.eventDefsToEventInstances = eventDefsToEventInstances;
function eventInstanceToEventRange(eventInstance) {
    return new EventRange_1.default(eventInstance.dateProfile.unzonedRange, eventInstance.def, eventInstance);
}
exports.eventInstanceToEventRange = eventInstanceToEventRange;
function eventRangeToEventFootprint(eventRange) {
    return new EventFootprint_1.default(new ComponentFootprint_1.default(eventRange.unzonedRange, eventRange.eventDef.isAllDay()), eventRange.eventDef, eventRange.eventInstance // might not exist
    );
}
exports.eventRangeToEventFootprint = eventRangeToEventFootprint;
function eventInstanceToUnzonedRange(eventInstance) {
    return eventInstance.dateProfile.unzonedRange;
}
exports.eventInstanceToUnzonedRange = eventInstanceToUnzonedRange;
function eventFootprintToComponentFootprint(eventFootprint) {
    return eventFootprint.componentFootprint;
}
exports.eventFootprintToComponentFootprint = eventFootprintToComponentFootprint;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var UnzonedRange_1 = __webpack_require__(5);
var util_1 = __webpack_require__(19);
var EventRange_1 = __webpack_require__(50);
/*
It's expected that there will be at least one EventInstance,
OR that an explicitEventDef is assigned.
*/
var EventInstanceGroup = /** @class */ (function () {
    function EventInstanceGroup(eventInstances) {
        this.eventInstances = eventInstances || [];
    }
    EventInstanceGroup.prototype.getAllEventRanges = function (constraintRange) {
        if (constraintRange) {
            return this.sliceNormalRenderRanges(constraintRange);
        }
        else {
            return this.eventInstances.map(util_1.eventInstanceToEventRange);
        }
    };
    EventInstanceGroup.prototype.sliceRenderRanges = function (constraintRange) {
        if (this.isInverse()) {
            return this.sliceInverseRenderRanges(constraintRange);
        }
        else {
            return this.sliceNormalRenderRanges(constraintRange);
        }
    };
    EventInstanceGroup.prototype.sliceNormalRenderRanges = function (constraintRange) {
        var eventInstances = this.eventInstances;
        var i;
        var eventInstance;
        var slicedRange;
        var slicedEventRanges = [];
        for (i = 0; i < eventInstances.length; i++) {
            eventInstance = eventInstances[i];
            slicedRange = eventInstance.dateProfile.unzonedRange.intersect(constraintRange);
            if (slicedRange) {
                slicedEventRanges.push(new EventRange_1.default(slicedRange, eventInstance.def, eventInstance));
            }
        }
        return slicedEventRanges;
    };
    EventInstanceGroup.prototype.sliceInverseRenderRanges = function (constraintRange) {
        var unzonedRanges = this.eventInstances.map(util_1.eventInstanceToUnzonedRange);
        var ownerDef = this.getEventDef();
        unzonedRanges = UnzonedRange_1.default.invertRanges(unzonedRanges, constraintRange);
        return unzonedRanges.map(function (unzonedRange) {
            return new EventRange_1.default(unzonedRange, ownerDef); // don't give an EventInstance
        });
    };
    EventInstanceGroup.prototype.isInverse = function () {
        return this.getEventDef().hasInverseRendering();
    };
    EventInstanceGroup.prototype.getEventDef = function () {
        return this.explicitEventDef || this.eventInstances[0].def;
    };
    return EventInstanceGroup;
}());
exports.default = EventInstanceGroup;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var PromiseStub = {
    construct: function (executor) {
        var deferred = $.Deferred();
        var promise = deferred.promise();
        if (typeof executor === 'function') {
            executor(function (val) {
                deferred.resolve(val);
                attachImmediatelyResolvingThen(promise, val);
            }, function () {
                deferred.reject();
                attachImmediatelyRejectingThen(promise);
            });
        }
        return promise;
    },
    resolve: function (val) {
        var deferred = $.Deferred().resolve(val);
        var promise = deferred.promise();
        attachImmediatelyResolvingThen(promise, val);
        return promise;
    },
    reject: function () {
        var deferred = $.Deferred().reject();
        var promise = deferred.promise();
        attachImmediatelyRejectingThen(promise);
        return promise;
    }
};
exports.default = PromiseStub;
function attachImmediatelyResolvingThen(promise, val) {
    promise.then = function (onResolve) {
        if (typeof onResolve === 'function') {
            return PromiseStub.resolve(onResolve(val));
        }
        return promise;
    };
}
function attachImmediatelyRejectingThen(promise) {
    promise.then = function (onResolve, onReject) {
        if (typeof onReject === 'function') {
            onReject();
        }
        return promise;
    };
}


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var Theme = /** @class */ (function () {
    function Theme(optionsManager) {
        this.optionsManager = optionsManager;
        this.processIconOverride();
    }
    Theme.prototype.processIconOverride = function () {
        if (this.iconOverrideOption) {
            this.setIconOverride(this.optionsManager.get(this.iconOverrideOption));
        }
    };
    Theme.prototype.setIconOverride = function (iconOverrideHash) {
        var iconClassesCopy;
        var buttonName;
        if ($.isPlainObject(iconOverrideHash)) {
            iconClassesCopy = $.extend({}, this.iconClasses);
            for (buttonName in iconOverrideHash) {
                iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);
            }
            this.iconClasses = iconClassesCopy;
        }
        else if (iconOverrideHash === false) {
            this.iconClasses = {};
        }
    };
    Theme.prototype.applyIconOverridePrefix = function (className) {
        var prefix = this.iconOverridePrefix;
        if (prefix && className.indexOf(prefix) !== 0) { // if not already present
            className = prefix + className;
        }
        return className;
    };
    Theme.prototype.getClass = function (key) {
        return this.classes[key] || '';
    };
    Theme.prototype.getIconClass = function (buttonName) {
        var className = this.iconClasses[buttonName];
        if (className) {
            return this.baseIconClass + ' ' + className;
        }
        return '';
    };
    Theme.prototype.getCustomButtonIconClass = function (customButtonProps) {
        var className;
        if (this.iconOverrideCustomButtonOption) {
            className = customButtonProps[this.iconOverrideCustomButtonOption];
            if (className) {
                return this.baseIconClass + ' ' + this.applyIconOverridePrefix(className);
            }
        }
        return '';
    };
    return Theme;
}());
exports.default = Theme;
Theme.prototype.classes = {};
Theme.prototype.iconClasses = {};
Theme.prototype.baseIconClass = '';
Theme.prototype.iconOverridePrefix = '';


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var exportHooks = __webpack_require__(18);
var EmitterMixin_1 = __webpack_require__(13);
var ListenerMixin_1 = __webpack_require__(7);
exportHooks.touchMouseIgnoreWait = 500;
var globalEmitter = null;
var neededCount = 0;
/*
Listens to document and window-level user-interaction events, like touch events and mouse events,
and fires these events as-is to whoever is observing a GlobalEmitter.
Best when used as a singleton via GlobalEmitter.get()

Normalizes mouse/touch events. For examples:
- ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click
- compensates for various buggy scenarios where a touchend does not fire
*/
var GlobalEmitter = /** @class */ (function () {
    function GlobalEmitter() {
        this.isTouching = false;
        this.mouseIgnoreDepth = 0;
    }
    // gets the singleton
    GlobalEmitter.get = function () {
        if (!globalEmitter) {
            globalEmitter = new GlobalEmitter();
            globalEmitter.bind();
        }
        return globalEmitter;
    };
    // called when an object knows it will need a GlobalEmitter in the near future.
    GlobalEmitter.needed = function () {
        GlobalEmitter.get(); // ensures globalEmitter
        neededCount++;
    };
    // called when the object that originally called needed() doesn't need a GlobalEmitter anymore.
    GlobalEmitter.unneeded = function () {
        neededCount--;
        if (!neededCount) { // nobody else needs it
            globalEmitter.unbind();
            globalEmitter = null;
        }
    };
    GlobalEmitter.prototype.bind = function () {
        var _this = this;
        this.listenTo($(document), {
            touchstart: this.handleTouchStart,
            touchcancel: this.handleTouchCancel,
            touchend: this.handleTouchEnd,
            mousedown: this.handleMouseDown,
            mousemove: this.handleMouseMove,
            mouseup: this.handleMouseUp,
            click: this.handleClick,
            selectstart: this.handleSelectStart,
            contextmenu: this.handleContextMenu
        });
        // because we need to call preventDefault
        // because https://www.chromestatus.com/features/5093566007214080
        // TODO: investigate performance because this is a global handler
        window.addEventListener('touchmove', this.handleTouchMoveProxy = function (ev) {
            _this.handleTouchMove($.Event(ev));
        }, { passive: false } // allows preventDefault()
        );
        // attach a handler to get called when ANY scroll action happens on the page.
        // this was impossible to do with normal on/off because 'scroll' doesn't bubble.
        // http://stackoverflow.com/a/32954565/96342
        window.addEventListener('scroll', this.handleScrollProxy = function (ev) {
            _this.handleScroll($.Event(ev));
        }, true // useCapture
        );
    };
    GlobalEmitter.prototype.unbind = function () {
        this.stopListeningTo($(document));
        window.removeEventListener('touchmove', this.handleTouchMoveProxy, { passive: false } // use same options as addEventListener
        );
        window.removeEventListener('scroll', this.handleScrollProxy, true // useCapture
        );
    };
    // Touch Handlers
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.handleTouchStart = function (ev) {
        // if a previous touch interaction never ended with a touchend, then implicitly end it,
        // but since a new touch interaction is about to begin, don't start the mouse ignore period.
        this.stopTouch(ev, true); // skipMouseIgnore=true
        this.isTouching = true;
        this.trigger('touchstart', ev);
    };
    GlobalEmitter.prototype.handleTouchMove = function (ev) {
        if (this.isTouching) {
            this.trigger('touchmove', ev);
        }
    };
    GlobalEmitter.prototype.handleTouchCancel = function (ev) {
        if (this.isTouching) {
            this.trigger('touchcancel', ev);
            // Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.
            // If touchend fires later, it won't have any effect b/c isTouching will be false.
            this.stopTouch(ev);
        }
    };
    GlobalEmitter.prototype.handleTouchEnd = function (ev) {
        this.stopTouch(ev);
    };
    // Mouse Handlers
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.handleMouseDown = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('mousedown', ev);
        }
    };
    GlobalEmitter.prototype.handleMouseMove = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('mousemove', ev);
        }
    };
    GlobalEmitter.prototype.handleMouseUp = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('mouseup', ev);
        }
    };
    GlobalEmitter.prototype.handleClick = function (ev) {
        if (!this.shouldIgnoreMouse()) {
            this.trigger('click', ev);
        }
    };
    // Misc Handlers
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.handleSelectStart = function (ev) {
        this.trigger('selectstart', ev);
    };
    GlobalEmitter.prototype.handleContextMenu = function (ev) {
        this.trigger('contextmenu', ev);
    };
    GlobalEmitter.prototype.handleScroll = function (ev) {
        this.trigger('scroll', ev);
    };
    // Utils
    // -----------------------------------------------------------------------------------------------------------------
    GlobalEmitter.prototype.stopTouch = function (ev, skipMouseIgnore) {
        if (skipMouseIgnore === void 0) { skipMouseIgnore = false; }
        if (this.isTouching) {
            this.isTouching = false;
            this.trigger('touchend', ev);
            if (!skipMouseIgnore) {
                this.startTouchMouseIgnore();
            }
        }
    };
    GlobalEmitter.prototype.startTouchMouseIgnore = function () {
        var _this = this;
        var wait = exportHooks.touchMouseIgnoreWait;
        if (wait) {
            this.mouseIgnoreDepth++;
            setTimeout(function () {
                _this.mouseIgnoreDepth--;
            }, wait);
        }
    };
    GlobalEmitter.prototype.shouldIgnoreMouse = function () {
        return this.isTouching || Boolean(this.mouseIgnoreDepth);
    };
    return GlobalEmitter;
}());
exports.default = GlobalEmitter;
ListenerMixin_1.default.mixInto(GlobalEmitter);
EmitterMixin_1.default.mixInto(GlobalEmitter);


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var exportHooks = __webpack_require__(18);
exports.viewHash = {};
exportHooks.views = exports.viewHash;
function defineView(viewName, viewConfig) {
    exports.viewHash[viewName] = viewConfig;
}
exports.defineView = defineView;
function getViewConfig(viewName) {
    return exports.viewHash[viewName];
}
exports.getViewConfig = getViewConfig;


/***/ }),
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var exportHooks = __webpack_require__(18);
var options_1 = __webpack_require__(33);
var util_1 = __webpack_require__(4);
exports.localeOptionHash = {};
exportHooks.locales = exports.localeOptionHash;
// NOTE: can't guarantee any of these computations will run because not every locale has datepicker
// configs, so make sure there are English fallbacks for these in the defaults file.
var dpComputableOptions = {
    buttonText: function (dpOptions) {
        return {
            // the translations sometimes wrongly contain HTML entities
            prev: util_1.stripHtmlEntities(dpOptions.prevText),
            next: util_1.stripHtmlEntities(dpOptions.nextText),
            today: util_1.stripHtmlEntities(dpOptions.currentText)
        };
    },
    // Produces format strings like "MMMM YYYY" -> "September 2014"
    monthYearFormat: function (dpOptions) {
        return dpOptions.showMonthAfterYear ?
            'YYYY[' + dpOptions.yearSuffix + '] MMMM' :
            'MMMM YYYY[' + dpOptions.yearSuffix + ']';
    }
};
var momComputableOptions = {
    // Produces format strings like "ddd M/D" -> "Fri 9/15"
    dayOfMonthFormat: function (momOptions, fcOptions) {
        var format = momOptions.longDateFormat('l'); // for the format like "M/D/YYYY"
        // strip the year off the edge, as well as other misc non-whitespace chars
        format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, '');
        if (fcOptions.isRTL) {
            format += ' ddd'; // for RTL, add day-of-week to end
        }
        else {
            format = 'ddd ' + format; // for LTR, add day-of-week to beginning
        }
        return format;
    },
    // Produces format strings like "h:mma" -> "6:00pm"
    mediumTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
    },
    // Produces format strings like "h(:mm)a" -> "6pm" / "6:30pm"
    smallTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(':mm', '(:mm)')
            .replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
            .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
    },
    // Produces format strings like "h(:mm)t" -> "6p" / "6:30p"
    extraSmallTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(':mm', '(:mm)')
            .replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
            .replace(/\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
    },
    // Produces format strings like "ha" / "H" -> "6pm" / "18"
    hourFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(':mm', '')
            .replace(/(\Wmm)$/, '') // like above, but for foreign locales
            .replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
    },
    // Produces format strings like "h:mm" -> "6:30" (with no AM/PM)
    noMeridiemTimeFormat: function (momOptions) {
        return momOptions.longDateFormat('LT')
            .replace(/\s*a$/i, ''); // remove trailing AM/PM
    }
};
// options that should be computed off live calendar options (considers override options)
// TODO: best place for this? related to locale?
// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it
var instanceComputableOptions = {
    // Produces format strings for results like "Mo 16"
    smallDayDateFormat: function (options) {
        return options.isRTL ?
            'D dd' :
            'dd D';
    },
    // Produces format strings for results like "Wk 5"
    weekFormat: function (options) {
        return options.isRTL ?
            'w[ ' + options.weekNumberTitle + ']' :
            '[' + options.weekNumberTitle + ' ]w';
    },
    // Produces format strings for results like "Wk5"
    smallWeekFormat: function (options) {
        return options.isRTL ?
            'w[' + options.weekNumberTitle + ']' :
            '[' + options.weekNumberTitle + ']w';
    }
};
// TODO: make these computable properties in optionsManager
function populateInstanceComputableOptions(options) {
    $.each(instanceComputableOptions, function (name, func) {
        if (options[name] == null) {
            options[name] = func(options);
        }
    });
}
exports.populateInstanceComputableOptions = populateInstanceComputableOptions;
// Initialize jQuery UI datepicker translations while using some of the translations
// Will set this as the default locales for datepicker.
function datepickerLocale(localeCode, dpLocaleCode, dpOptions) {
    // get the FullCalendar internal option hash for this locale. create if necessary
    var fcOptions = exports.localeOptionHash[localeCode] || (exports.localeOptionHash[localeCode] = {});
    // transfer some simple options from datepicker to fc
    fcOptions.isRTL = dpOptions.isRTL;
    fcOptions.weekNumberTitle = dpOptions.weekHeader;
    // compute some more complex options from datepicker
    $.each(dpComputableOptions, function (name, func) {
        fcOptions[name] = func(dpOptions);
    });
    var jqDatePicker = $.datepicker;
    // is jQuery UI Datepicker is on the page?
    if (jqDatePicker) {
        // Register the locale data.
        // FullCalendar and MomentJS use locale codes like "pt-br" but Datepicker
        // does it like "pt-BR" or if it doesn't have the locale, maybe just "pt".
        // Make an alias so the locale can be referenced either way.
        jqDatePicker.regional[dpLocaleCode] =
            jqDatePicker.regional[localeCode] = // alias
                dpOptions;
        // Alias 'en' to the default locale data. Do this every time.
        jqDatePicker.regional.en = jqDatePicker.regional[''];
        // Set as Datepicker's global defaults.
        jqDatePicker.setDefaults(dpOptions);
    }
}
exports.datepickerLocale = datepickerLocale;
// Sets FullCalendar-specific translations. Will set the locales as the global default.
function locale(localeCode, newFcOptions) {
    var fcOptions;
    var momOptions;
    // get the FullCalendar internal option hash for this locale. create if necessary
    fcOptions = exports.localeOptionHash[localeCode] || (exports.localeOptionHash[localeCode] = {});
    // provided new options for this locales? merge them in
    if (newFcOptions) {
        fcOptions = exports.localeOptionHash[localeCode] = options_1.mergeOptions([fcOptions, newFcOptions]);
    }
    // compute locale options that weren't defined.
    // always do this. newFcOptions can be undefined when initializing from i18n file,
    // so no way to tell if this is an initialization or a default-setting.
    momOptions = getMomentLocaleData(localeCode); // will fall back to en
    $.each(momComputableOptions, function (name, func) {
        if (fcOptions[name] == null) {
            fcOptions[name] = (func)(momOptions, fcOptions);
        }
    });
    // set it as the default locale for FullCalendar
    options_1.globalDefaults.locale = localeCode;
}
exports.locale = locale;
// Returns moment's internal locale data. If doesn't exist, returns English.
function getMomentLocaleData(localeCode) {
    return moment.localeData(localeCode) || moment.localeData('en');
}
exports.getMomentLocaleData = getMomentLocaleData;
// Initialize English by forcing computation of moment-derived options.
// Also, sets it as the default.
locale('en', options_1.englishDefaults);


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(4);
exports.globalDefaults = {
    titleRangeSeparator: ' \u2013 ',
    monthYearFormat: 'MMMM YYYY',
    defaultTimedEventDuration: '02:00:00',
    defaultAllDayEventDuration: { days: 1 },
    forceEventDuration: false,
    nextDayThreshold: '09:00:00',
    // display
    columnHeader: true,
    defaultView: 'month',
    aspectRatio: 1.35,
    header: {
        left: 'title',
        center: '',
        right: 'today prev,next'
    },
    weekends: true,
    weekNumbers: false,
    weekNumberTitle: 'W',
    weekNumberCalculation: 'local',
    // editable: false,
    // nowIndicator: false,
    scrollTime: '06:00:00',
    minTime: '00:00:00',
    maxTime: '24:00:00',
    showNonCurrentDates: true,
    // event ajax
    lazyFetching: true,
    startParam: 'start',
    endParam: 'end',
    timezoneParam: 'timezone',
    timezone: false,
    // allDayDefault: undefined,
    // locale
    locale: null,
    isRTL: false,
    buttonText: {
        prev: 'prev',
        next: 'next',
        prevYear: 'prev year',
        nextYear: 'next year',
        year: 'year',
        today: 'today',
        month: 'month',
        week: 'week',
        day: 'day'
    },
    // buttonIcons: null,
    allDayText: 'all-day',
    // allows setting a min-height to the event segment to prevent short events overlapping each other
    agendaEventMinHeight: 0,
    // jquery-ui theming
    theme: false,
    // themeButtonIcons: null,
    // eventResizableFromStart: false,
    dragOpacity: .75,
    dragRevertDuration: 500,
    dragScroll: true,
    // selectable: false,
    unselectAuto: true,
    // selectMinDistance: 0,
    dropAccept: '*',
    eventOrder: 'title',
    // eventRenderWait: null,
    eventLimit: false,
    eventLimitText: 'more',
    eventLimitClick: 'popover',
    dayPopoverFormat: 'LL',
    handleWindowResize: true,
    windowResizeDelay: 100,
    longPressDelay: 1000
};
exports.englishDefaults = {
    dayPopoverFormat: 'dddd, MMMM D'
};
exports.rtlDefaults = {
    header: {
        left: 'next,prev today',
        center: '',
        right: 'title'
    },
    buttonIcons: {
        prev: 'right-single-arrow',
        next: 'left-single-arrow',
        prevYear: 'right-double-arrow',
        nextYear: 'left-double-arrow'
    },
    themeButtonIcons: {
        prev: 'circle-triangle-e',
        next: 'circle-triangle-w',
        nextYear: 'seek-prev',
        prevYear: 'seek-next'
    }
};
var complexOptions = [
    'header',
    'footer',
    'buttonText',
    'buttonIcons',
    'themeButtonIcons'
];
// Merges an array of option objects into a single object
function mergeOptions(optionObjs) {
    return util_1.mergeProps(optionObjs, complexOptions);
}
exports.mergeOptions = mergeOptions;


/***/ }),
/* 34 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventFootprint = /** @class */ (function () {
    function EventFootprint(componentFootprint, eventDef, eventInstance) {
        this.componentFootprint = componentFootprint;
        this.eventDef = eventDef;
        if (eventInstance) {
            this.eventInstance = eventInstance;
        }
    }
    EventFootprint.prototype.getEventLegacy = function () {
        return (this.eventInstance || this.eventDef).toLegacy();
    };
    return EventFootprint;
}());
exports.default = EventFootprint;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
// Class that all other classes will inherit from
var Class = /** @class */ (function () {
    function Class() {
    }
    // Called on a class to create a subclass.
    // LIMITATION: cannot provide a constructor!
    Class.extend = function (members) {
        var SubClass = /** @class */ (function (_super) {
            tslib_1.__extends(SubClass, _super);
            function SubClass() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return SubClass;
        }(this));
        util_1.copyOwnProps(members, SubClass.prototype);
        return SubClass;
    };
    // Adds new member variables/methods to the class's prototype.
    // Can be called with another class, or a plain object hash containing new members.
    Class.mixin = function (members) {
        util_1.copyOwnProps(members, this.prototype);
    };
    return Class;
}());
exports.default = Class;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var SingleEventDef_1 = __webpack_require__(9);
var RecurringEventDef_1 = __webpack_require__(54);
exports.default = {
    parse: function (eventInput, source) {
        if (util_1.isTimeString(eventInput.start) || moment.isDuration(eventInput.start) ||
            util_1.isTimeString(eventInput.end) || moment.isDuration(eventInput.end)) {
            return RecurringEventDef_1.default.parse(eventInput, source);
        }
        else {
            return SingleEventDef_1.default.parse(eventInput, source);
        }
    }
};


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var ParsableModelMixin_1 = __webpack_require__(52);
var EventDef = /** @class */ (function () {
    function EventDef(source) {
        this.source = source;
        this.className = [];
        this.miscProps = {};
    }
    EventDef.parse = function (rawInput, source) {
        var def = new this(source);
        if (def.applyProps(rawInput)) {
            return def;
        }
        return false;
    };
    EventDef.normalizeId = function (id) {
        return String(id);
    };
    EventDef.generateId = function () {
        return '_fc' + (EventDef.uuid++);
    };
    EventDef.prototype.clone = function () {
        var copy = new this.constructor(this.source);
        copy.id = this.id;
        copy.rawId = this.rawId;
        copy.uid = this.uid; // not really unique anymore :(
        EventDef.copyVerbatimStandardProps(this, copy);
        copy.className = this.className.slice(); // copy
        copy.miscProps = $.extend({}, this.miscProps);
        return copy;
    };
    EventDef.prototype.hasInverseRendering = function () {
        return this.getRendering() === 'inverse-background';
    };
    EventDef.prototype.hasBgRendering = function () {
        var rendering = this.getRendering();
        return rendering === 'inverse-background' || rendering === 'background';
    };
    EventDef.prototype.getRendering = function () {
        if (this.rendering != null) {
            return this.rendering;
        }
        return this.source.rendering;
    };
    EventDef.prototype.getConstraint = function () {
        if (this.constraint != null) {
            return this.constraint;
        }
        if (this.source.constraint != null) {
            return this.source.constraint;
        }
        return this.source.calendar.opt('eventConstraint'); // what about View option?
    };
    EventDef.prototype.getOverlap = function () {
        if (this.overlap != null) {
            return this.overlap;
        }
        if (this.source.overlap != null) {
            return this.source.overlap;
        }
        return this.source.calendar.opt('eventOverlap'); // what about View option?
    };
    EventDef.prototype.isStartExplicitlyEditable = function () {
        if (this.startEditable != null) {
            return this.startEditable;
        }
        return this.source.startEditable;
    };
    EventDef.prototype.isDurationExplicitlyEditable = function () {
        if (this.durationEditable != null) {
            return this.durationEditable;
        }
        return this.source.durationEditable;
    };
    EventDef.prototype.isExplicitlyEditable = function () {
        if (this.editable != null) {
            return this.editable;
        }
        return this.source.editable;
    };
    EventDef.prototype.toLegacy = function () {
        var obj = $.extend({}, this.miscProps);
        obj._id = this.uid;
        obj.source = this.source;
        obj.className = this.className.slice(); // copy
        obj.allDay = this.isAllDay();
        if (this.rawId != null) {
            obj.id = this.rawId;
        }
        EventDef.copyVerbatimStandardProps(this, obj);
        return obj;
    };
    EventDef.prototype.applyManualStandardProps = function (rawProps) {
        if (rawProps.id != null) {
            this.id = EventDef.normalizeId((this.rawId = rawProps.id));
        }
        else {
            this.id = EventDef.generateId();
        }
        if (rawProps._id != null) { // accept this prop, even tho somewhat internal
            this.uid = String(rawProps._id);
        }
        else {
            this.uid = EventDef.generateId();
        }
        // TODO: converge with EventSource
        if ($.isArray(rawProps.className)) {
            this.className = rawProps.className;
        }
        if (typeof rawProps.className === 'string') {
            this.className = rawProps.className.split(/\s+/);
        }
        return true;
    };
    EventDef.prototype.applyMiscProps = function (rawProps) {
        $.extend(this.miscProps, rawProps);
    };
    EventDef.uuid = 0;
    EventDef.defineStandardProps = ParsableModelMixin_1.default.defineStandardProps;
    EventDef.copyVerbatimStandardProps = ParsableModelMixin_1.default.copyVerbatimStandardProps;
    return EventDef;
}());
exports.default = EventDef;
ParsableModelMixin_1.default.mixInto(EventDef);
EventDef.defineStandardProps({
    // not automatically assigned (`false`)
    _id: false,
    id: false,
    className: false,
    source: false,
    // automatically assigned (`true`)
    title: true,
    url: true,
    rendering: true,
    constraint: true,
    overlap: true,
    editable: true,
    startEditable: true,
    durationEditable: true,
    color: true,
    backgroundColor: true,
    borderColor: true,
    textColor: true
});


/***/ }),
/* 38 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    sourceClasses: [],
    registerClass: function (EventSourceClass) {
        this.sourceClasses.unshift(EventSourceClass); // give highest priority
    },
    parse: function (rawInput, calendar) {
        var sourceClasses = this.sourceClasses;
        var i;
        var eventSource;
        for (i = 0; i < sourceClasses.length; i++) {
            eventSource = sourceClasses[i].parse(rawInput, calendar);
            if (eventSource) {
                return eventSource;
            }
        }
    }
};


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(4);
var EventDateProfile_1 = __webpack_require__(16);
var EventDef_1 = __webpack_require__(37);
var EventDefDateMutation_1 = __webpack_require__(40);
var SingleEventDef_1 = __webpack_require__(9);
var EventDefMutation = /** @class */ (function () {
    function EventDefMutation() {
    }
    EventDefMutation.createFromRawProps = function (eventInstance, rawProps, largeUnit) {
        var eventDef = eventInstance.def;
        var dateProps = {};
        var standardProps = {};
        var miscProps = {};
        var verbatimStandardProps = {};
        var eventDefId = null;
        var className = null;
        var propName;
        var dateProfile;
        var dateMutation;
        var defMutation;
        for (propName in rawProps) {
            if (EventDateProfile_1.default.isStandardProp(propName)) {
                dateProps[propName] = rawProps[propName];
            }
            else if (eventDef.isStandardProp(propName)) {
                standardProps[propName] = rawProps[propName];
            }
            else if (eventDef.miscProps[propName] !== rawProps[propName]) { // only if changed
                miscProps[propName] = rawProps[propName];
            }
        }
        dateProfile = EventDateProfile_1.default.parse(dateProps, eventDef.source);
        if (dateProfile) { // no failure?
            dateMutation = EventDefDateMutation_1.default.createFromDiff(eventInstance.dateProfile, dateProfile, largeUnit);
        }
        if (standardProps.id !== eventDef.id) {
            eventDefId = standardProps.id; // only apply if there's a change
        }
        if (!util_1.isArraysEqual(standardProps.className, eventDef.className)) {
            className = standardProps.className; // only apply if there's a change
        }
        EventDef_1.default.copyVerbatimStandardProps(standardProps, // src
        verbatimStandardProps // dest
        );
        defMutation = new EventDefMutation();
        defMutation.eventDefId = eventDefId;
        defMutation.className = className;
        defMutation.verbatimStandardProps = verbatimStandardProps;
        defMutation.miscProps = miscProps;
        if (dateMutation) {
            defMutation.dateMutation = dateMutation;
        }
        return defMutation;
    };
    /*
    eventDef assumed to be a SingleEventDef.
    returns an undo function.
    */
    EventDefMutation.prototype.mutateSingle = function (eventDef) {
        var origDateProfile;
        if (this.dateMutation) {
            origDateProfile = eventDef.dateProfile;
            eventDef.dateProfile = this.dateMutation.buildNewDateProfile(origDateProfile, eventDef.source.calendar);
        }
        // can't undo
        // TODO: more DRY with EventDef::applyManualStandardProps
        if (this.eventDefId != null) {
            eventDef.id = EventDef_1.default.normalizeId((eventDef.rawId = this.eventDefId));
        }
        // can't undo
        // TODO: more DRY with EventDef::applyManualStandardProps
        if (this.className) {
            eventDef.className = this.className;
        }
        // can't undo
        if (this.verbatimStandardProps) {
            SingleEventDef_1.default.copyVerbatimStandardProps(this.verbatimStandardProps, // src
            eventDef // dest
            );
        }
        // can't undo
        if (this.miscProps) {
            eventDef.applyMiscProps(this.miscProps);
        }
        if (origDateProfile) {
            return function () {
                eventDef.dateProfile = origDateProfile;
            };
        }
        else {
            return function () { };
        }
    };
    EventDefMutation.prototype.setDateMutation = function (dateMutation) {
        if (dateMutation && !dateMutation.isEmpty()) {
            this.dateMutation = dateMutation;
        }
        else {
            this.dateMutation = null;
        }
    };
    EventDefMutation.prototype.isEmpty = function () {
        return !this.dateMutation;
    };
    return EventDefMutation;
}());
exports.default = EventDefMutation;


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = __webpack_require__(4);
var EventDateProfile_1 = __webpack_require__(16);
var EventDefDateMutation = /** @class */ (function () {
    function EventDefDateMutation() {
        this.clearEnd = false;
        this.forceTimed = false;
        this.forceAllDay = false;
    }
    EventDefDateMutation.createFromDiff = function (dateProfile0, dateProfile1, largeUnit) {
        var clearEnd = dateProfile0.end && !dateProfile1.end;
        var forceTimed = dateProfile0.isAllDay() && !dateProfile1.isAllDay();
        var forceAllDay = !dateProfile0.isAllDay() && dateProfile1.isAllDay();
        var dateDelta;
        var endDiff;
        var endDelta;
        var mutation;
        // subtracts the dates in the appropriate way, returning a duration
        function subtractDates(date1, date0) {
            if (largeUnit) {
                return util_1.diffByUnit(date1, date0, largeUnit); // poorly named
            }
            else if (dateProfile1.isAllDay()) {
                return util_1.diffDay(date1, date0); // poorly named
            }
            else {
                return util_1.diffDayTime(date1, date0); // poorly named
            }
        }
        dateDelta = subtractDates(dateProfile1.start, dateProfile0.start);
        if (dateProfile1.end) {
            // use unzonedRanges because dateProfile0.end might be null
            endDiff = subtractDates(dateProfile1.unzonedRange.getEnd(), dateProfile0.unzonedRange.getEnd());
            endDelta = endDiff.subtract(dateDelta);
        }
        mutation = new EventDefDateMutation();
        mutation.clearEnd = clearEnd;
        mutation.forceTimed = forceTimed;
        mutation.forceAllDay = forceAllDay;
        mutation.setDateDelta(dateDelta);
        mutation.setEndDelta(endDelta);
        return mutation;
    };
    /*
    returns an undo function.
    */
    EventDefDateMutation.prototype.buildNewDateProfile = function (eventDateProfile, calendar) {
        var start = eventDateProfile.start.clone();
        var end = null;
        var shouldRezone = false;
        if (eventDateProfile.end && !this.clearEnd) {
            end = eventDateProfile.end.clone();
        }
        else if (this.endDelta && !end) {
            end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);
        }
        if (this.forceTimed) {
            shouldRezone = true;
            if (!start.hasTime()) {
                start.time(0);
            }
            if (end && !end.hasTime()) {
                end.time(0);
            }
        }
        else if (this.forceAllDay) {
            if (start.hasTime()) {
                start.stripTime();
            }
            if (end && end.hasTime()) {
                end.stripTime();
            }
        }
        if (this.dateDelta) {
            shouldRezone = true;
            start.add(this.dateDelta);
            if (end) {
                end.add(this.dateDelta);
            }
        }
        // do this before adding startDelta to start, so we can work off of start
        if (this.endDelta) {
            shouldRezone = true;
            end.add(this.endDelta);
        }
        if (this.startDelta) {
            shouldRezone = true;
            start.add(this.startDelta);
        }
        if (shouldRezone) {
            start = calendar.applyTimezone(start);
            if (end) {
                end = calendar.applyTimezone(end);
            }
        }
        // TODO: okay to access calendar option?
        if (!end && calendar.opt('forceEventDuration')) {
            end = calendar.getDefaultEventEnd(eventDateProfile.isAllDay(), start);
        }
        return new EventDateProfile_1.default(start, end, calendar);
    };
    EventDefDateMutation.prototype.setDateDelta = function (dateDelta) {
        if (dateDelta && dateDelta.valueOf()) {
            this.dateDelta = dateDelta;
        }
        else {
            this.dateDelta = null;
        }
    };
    EventDefDateMutation.prototype.setStartDelta = function (startDelta) {
        if (startDelta && startDelta.valueOf()) {
            this.startDelta = startDelta;
        }
        else {
            this.startDelta = null;
        }
    };
    EventDefDateMutation.prototype.setEndDelta = function (endDelta) {
        if (endDelta && endDelta.valueOf()) {
            this.endDelta = endDelta;
        }
        else {
            this.endDelta = null;
        }
    };
    EventDefDateMutation.prototype.isEmpty = function () {
        return !this.clearEnd && !this.forceTimed && !this.forceAllDay &&
            !this.dateDelta && !this.startDelta && !this.endDelta;
    };
    return EventDefDateMutation;
}());
exports.default = EventDefDateMutation;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var Class_1 = __webpack_require__(35);
/*
Embodies a div that has potential scrollbars
*/
var Scroller = /** @class */ (function (_super) {
    tslib_1.__extends(Scroller, _super);
    function Scroller(options) {
        var _this = _super.call(this) || this;
        options = options || {};
        _this.overflowX = options.overflowX || options.overflow || 'auto';
        _this.overflowY = options.overflowY || options.overflow || 'auto';
        return _this;
    }
    Scroller.prototype.render = function () {
        this.el = this.renderEl();
        this.applyOverflow();
    };
    Scroller.prototype.renderEl = function () {
        return (this.scrollEl = $('<div class="fc-scroller"></div>'));
    };
    // sets to natural height, unlocks overflow
    Scroller.prototype.clear = function () {
        this.setHeight('auto');
        this.applyOverflow();
    };
    Scroller.prototype.destroy = function () {
        this.el.remove();
    };
    // Overflow
    // -----------------------------------------------------------------------------------------------------------------
    Scroller.prototype.applyOverflow = function () {
        this.scrollEl.css({
            'overflow-x': this.overflowX,
            'overflow-y': this.overflowY
        });
    };
    // Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.
    // Useful for preserving scrollbar widths regardless of future resizes.
    // Can pass in scrollbarWidths for optimization.
    Scroller.prototype.lockOverflow = function (scrollbarWidths) {
        var overflowX = this.overflowX;
        var overflowY = this.overflowY;
        scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();
        if (overflowX === 'auto') {
            overflowX = (scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?
                // OR scrolling pane with massless scrollbars?
                this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth
            // subtract 1 because of IE off-by-one issue
            ) ? 'scroll' : 'hidden';
        }
        if (overflowY === 'auto') {
            overflowY = (scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?
                // OR scrolling pane with massless scrollbars?
                this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight
            // subtract 1 because of IE off-by-one issue
            ) ? 'scroll' : 'hidden';
        }
        this.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });
    };
    // Getters / Setters
    // -----------------------------------------------------------------------------------------------------------------
    Scroller.prototype.setHeight = function (height) {
        this.scrollEl.height(height);
    };
    Scroller.prototype.getScrollTop = function () {
        return this.scrollEl.scrollTop();
    };
    Scroller.prototype.setScrollTop = function (top) {
        this.scrollEl.scrollTop(top);
    };
    Scroller.prototype.getClientWidth = function () {
        return this.scrollEl[0].clientWidth;
    };
    Scroller.prototype.getClientHeight = function () {
        return this.scrollEl[0].clientHeight;
    };
    Scroller.prototype.getScrollbarWidths = function () {
        return util_1.getScrollbarWidths(this.scrollEl);
    };
    return Scroller;
}(Class_1.default));
exports.default = Scroller;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var DateComponent_1 = __webpack_require__(231);
var GlobalEmitter_1 = __webpack_require__(23);
var InteractiveDateComponent = /** @class */ (function (_super) {
    tslib_1.__extends(InteractiveDateComponent, _super);
    function InteractiveDateComponent(_view, _options) {
        var _this = _super.call(this, _view, _options) || this;
        // self-config, overridable by subclasses
        _this.segSelector = '.fc-event-container > *'; // what constitutes an event element?
        if (_this.dateSelectingClass) {
            _this.dateClicking = new _this.dateClickingClass(_this);
        }
        if (_this.dateSelectingClass) {
            _this.dateSelecting = new _this.dateSelectingClass(_this);
        }
        if (_this.eventPointingClass) {
            _this.eventPointing = new _this.eventPointingClass(_this);
        }
        if (_this.eventDraggingClass && _this.eventPointing) {
            _this.eventDragging = new _this.eventDraggingClass(_this, _this.eventPointing);
        }
        if (_this.eventResizingClass && _this.eventPointing) {
            _this.eventResizing = new _this.eventResizingClass(_this, _this.eventPointing);
        }
        if (_this.externalDroppingClass) {
            _this.externalDropping = new _this.externalDroppingClass(_this);
        }
        return _this;
    }
    // Sets the container element that the view should render inside of, does global DOM-related initializations,
    // and renders all the non-date-related content inside.
    InteractiveDateComponent.prototype.setElement = function (el) {
        _super.prototype.setElement.call(this, el);
        if (this.dateClicking) {
            this.dateClicking.bindToEl(el);
        }
        if (this.dateSelecting) {
            this.dateSelecting.bindToEl(el);
        }
        this.bindAllSegHandlersToEl(el);
    };
    InteractiveDateComponent.prototype.removeElement = function () {
        this.endInteractions();
        _super.prototype.removeElement.call(this);
    };
    InteractiveDateComponent.prototype.executeEventUnrender = function () {
        this.endInteractions();
        _super.prototype.executeEventUnrender.call(this);
    };
    InteractiveDateComponent.prototype.bindGlobalHandlers = function () {
        _super.prototype.bindGlobalHandlers.call(this);
        if (this.externalDropping) {
            this.externalDropping.bindToDocument();
        }
    };
    InteractiveDateComponent.prototype.unbindGlobalHandlers = function () {
        _super.prototype.unbindGlobalHandlers.call(this);
        if (this.externalDropping) {
            this.externalDropping.unbindFromDocument();
        }
    };
    InteractiveDateComponent.prototype.bindDateHandlerToEl = function (el, name, handler) {
        var _this = this;
        // attach a handler to the grid's root element.
        // jQuery will take care of unregistering them when removeElement gets called.
        this.el.on(name, function (ev) {
            if (!$(ev.target).is(_this.segSelector + ':not(.fc-helper),' + // directly on an event element
                _this.segSelector + ':not(.fc-helper) *,' + // within an event element
                '.fc-more,' + // a "more.." link
                'a[data-goto]' // a clickable nav link
            )) {
                return handler.call(_this, ev);
            }
        });
    };
    InteractiveDateComponent.prototype.bindAllSegHandlersToEl = function (el) {
        [
            this.eventPointing,
            this.eventDragging,
            this.eventResizing
        ].forEach(function (eventInteraction) {
            if (eventInteraction) {
                eventInteraction.bindToEl(el);
            }
        });
    };
    InteractiveDateComponent.prototype.bindSegHandlerToEl = function (el, name, handler) {
        var _this = this;
        el.on(name, this.segSelector, function (ev) {
            var segEl = $(ev.currentTarget);
            if (!segEl.is('.fc-helper')) {
                var seg = segEl.data('fc-seg'); // grab segment data. put there by View::renderEventsPayload
                if (seg && !_this.shouldIgnoreEventPointing()) {
                    return handler.call(_this, seg, ev); // context will be the Grid
                }
            }
        });
    };
    InteractiveDateComponent.prototype.shouldIgnoreMouse = function () {
        // HACK
        // This will still work even though bindDateHandlerToEl doesn't use GlobalEmitter.
        return GlobalEmitter_1.default.get().shouldIgnoreMouse();
    };
    InteractiveDateComponent.prototype.shouldIgnoreTouch = function () {
        var view = this._getView();
        // On iOS (and Android?) when a new selection is initiated overtop another selection,
        // the touchend never fires because the elements gets removed mid-touch-interaction (my theory).
        // HACK: simply don't allow this to happen.
        // ALSO: prevent selection when an *event* is already raised.
        return view.isSelected || view.selectedEvent;
    };
    InteractiveDateComponent.prototype.shouldIgnoreEventPointing = function () {
        // only call the handlers if there is not a drag/resize in progress
        return (this.eventDragging && this.eventDragging.isDragging) ||
            (this.eventResizing && this.eventResizing.isResizing);
    };
    InteractiveDateComponent.prototype.canStartSelection = function (seg, ev) {
        return util_1.getEvIsTouch(ev) &&
            !this.canStartResize(seg, ev) &&
            (this.isEventDefDraggable(seg.footprint.eventDef) ||
                this.isEventDefResizable(seg.footprint.eventDef));
    };
    InteractiveDateComponent.prototype.canStartDrag = function (seg, ev) {
        return !this.canStartResize(seg, ev) &&
            this.isEventDefDraggable(seg.footprint.eventDef);
    };
    InteractiveDateComponent.prototype.canStartResize = function (seg, ev) {
        var view = this._getView();
        var eventDef = seg.footprint.eventDef;
        return (!util_1.getEvIsTouch(ev) || view.isEventDefSelected(eventDef)) &&
            this.isEventDefResizable(eventDef) &&
            $(ev.target).is('.fc-resizer');
    };
    // Kills all in-progress dragging.
    // Useful for when public API methods that result in re-rendering are invoked during a drag.
    // Also useful for when touch devices misbehave and don't fire their touchend.
    InteractiveDateComponent.prototype.endInteractions = function () {
        [
            this.dateClicking,
            this.dateSelecting,
            this.eventPointing,
            this.eventDragging,
            this.eventResizing
        ].forEach(function (interaction) {
            if (interaction) {
                interaction.end();
            }
        });
    };
    // Event Drag-n-Drop
    // ---------------------------------------------------------------------------------------------------------------
    // Computes if the given event is allowed to be dragged by the user
    InteractiveDateComponent.prototype.isEventDefDraggable = function (eventDef) {
        return this.isEventDefStartEditable(eventDef);
    };
    InteractiveDateComponent.prototype.isEventDefStartEditable = function (eventDef) {
        var isEditable = eventDef.isStartExplicitlyEditable();
        if (isEditable == null) {
            isEditable = this.opt('eventStartEditable');
            if (isEditable == null) {
                isEditable = this.isEventDefGenerallyEditable(eventDef);
            }
        }
        return isEditable;
    };
    InteractiveDateComponent.prototype.isEventDefGenerallyEditable = function (eventDef) {
        var isEditable = eventDef.isExplicitlyEditable();
        if (isEditable == null) {
            isEditable = this.opt('editable');
        }
        return isEditable;
    };
    // Event Resizing
    // ---------------------------------------------------------------------------------------------------------------
    // Computes if the given event is allowed to be resized from its starting edge
    InteractiveDateComponent.prototype.isEventDefResizableFromStart = function (eventDef) {
        return this.opt('eventResizableFromStart') && this.isEventDefResizable(eventDef);
    };
    // Computes if the given event is allowed to be resized from its ending edge
    InteractiveDateComponent.prototype.isEventDefResizableFromEnd = function (eventDef) {
        return this.isEventDefResizable(eventDef);
    };
    // Computes if the given event is allowed to be resized by the user at all
    InteractiveDateComponent.prototype.isEventDefResizable = function (eventDef) {
        var isResizable = eventDef.isDurationExplicitlyEditable();
        if (isResizable == null) {
            isResizable = this.opt('eventDurationEditable');
            if (isResizable == null) {
                isResizable = this.isEventDefGenerallyEditable(eventDef);
            }
        }
        return isResizable;
    };
    // Event Mutation / Constraints
    // ---------------------------------------------------------------------------------------------------------------
    // Diffs the two dates, returning a duration, based on granularity of the grid
    // TODO: port isTimeScale into this system?
    InteractiveDateComponent.prototype.diffDates = function (a, b) {
        if (this.largeUnit) {
            return util_1.diffByUnit(a, b, this.largeUnit);
        }
        else {
            return util_1.diffDayTime(a, b);
        }
    };
    // is it allowed, in relation to the view's validRange?
    // NOTE: very similar to isExternalInstanceGroupAllowed
    InteractiveDateComponent.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {
        var view = this._getView();
        var dateProfile = this.dateProfile;
        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            // TODO: just use getAllEventRanges directly
            if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {
                return false;
            }
        }
        return view.calendar.constraints.isEventInstanceGroupAllowed(eventInstanceGroup);
    };
    // NOTE: very similar to isEventInstanceGroupAllowed
    // when it's a completely anonymous external drag, no event.
    InteractiveDateComponent.prototype.isExternalInstanceGroupAllowed = function (eventInstanceGroup) {
        var view = this._getView();
        var dateProfile = this.dateProfile;
        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            if (!dateProfile.validUnzonedRange.containsRange(eventFootprints[i].componentFootprint.unzonedRange)) {
                return false;
            }
        }
        for (i = 0; i < eventFootprints.length; i++) {
            // treat it as a selection
            // TODO: pass in eventInstanceGroup instead
            //  because we don't want calendar's constraint system to depend on a component's
            //  determination of footprints.
            if (!view.calendar.constraints.isSelectionFootprintAllowed(eventFootprints[i].componentFootprint)) {
                return false;
            }
        }
        return true;
    };
    return InteractiveDateComponent;
}(DateComponent_1.default));
exports.default = InteractiveDateComponent;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var RenderQueue_1 = __webpack_require__(229);
var DateProfileGenerator_1 = __webpack_require__(55);
var InteractiveDateComponent_1 = __webpack_require__(42);
var GlobalEmitter_1 = __webpack_require__(23);
var UnzonedRange_1 = __webpack_require__(5);
/* An abstract class from which other views inherit from
----------------------------------------------------------------------------------------------------------------------*/
var View = /** @class */ (function (_super) {
    tslib_1.__extends(View, _super);
    function View(calendar, viewSpec) {
        var _this = _super.call(this, null, viewSpec.options) || this;
        _this.batchRenderDepth = 0;
        _this.isSelected = false; // boolean whether a range of time is user-selected or not
        _this.calendar = calendar;
        _this.viewSpec = viewSpec;
        // shortcuts
        _this.type = viewSpec.type;
        // .name is deprecated
        _this.name = _this.type;
        _this.initRenderQueue();
        _this.initHiddenDays();
        _this.dateProfileGenerator = new _this.dateProfileGeneratorClass(_this);
        _this.bindBaseRenderHandlers();
        _this.eventOrderSpecs = util_1.parseFieldSpecs(_this.opt('eventOrder'));
        // legacy
        if (_this['initialize']) {
            _this['initialize']();
        }
        return _this;
    }
    View.prototype._getView = function () {
        return this;
    };
    // Retrieves an option with the given name
    View.prototype.opt = function (name) {
        return this.options[name];
    };
    /* Render Queue
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.initRenderQueue = function () {
        this.renderQueue = new RenderQueue_1.default({
            event: this.opt('eventRenderWait')
        });
        this.renderQueue.on('start', this.onRenderQueueStart.bind(this));
        this.renderQueue.on('stop', this.onRenderQueueStop.bind(this));
        this.on('before:change', this.startBatchRender);
        this.on('change', this.stopBatchRender);
    };
    View.prototype.onRenderQueueStart = function () {
        this.calendar.freezeContentHeight();
        this.addScroll(this.queryScroll());
    };
    View.prototype.onRenderQueueStop = function () {
        if (this.calendar.updateViewSize()) { // success?
            this.popScroll();
        }
        this.calendar.thawContentHeight();
    };
    View.prototype.startBatchRender = function () {
        if (!(this.batchRenderDepth++)) {
            this.renderQueue.pause();
        }
    };
    View.prototype.stopBatchRender = function () {
        if (!(--this.batchRenderDepth)) {
            this.renderQueue.resume();
        }
    };
    View.prototype.requestRender = function (func, namespace, actionType) {
        this.renderQueue.queue(func, namespace, actionType);
    };
    // given func will auto-bind to `this`
    View.prototype.whenSizeUpdated = function (func) {
        if (this.renderQueue.isRunning) {
            this.renderQueue.one('stop', func.bind(this));
        }
        else {
            func.call(this);
        }
    };
    /* Title and Date Formatting
    ------------------------------------------------------------------------------------------------------------------*/
    // Computes what the title at the top of the calendar should be for this view
    View.prototype.computeTitle = function (dateProfile) {
        var unzonedRange;
        // for views that span a large unit of time, show the proper interval, ignoring stray days before and after
        if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {
            unzonedRange = dateProfile.currentUnzonedRange;
        }
        else { // for day units or smaller, use the actual day range
            unzonedRange = dateProfile.activeUnzonedRange;
        }
        return this.formatRange({
            start: this.calendar.msToMoment(unzonedRange.startMs, dateProfile.isRangeAllDay),
            end: this.calendar.msToMoment(unzonedRange.endMs, dateProfile.isRangeAllDay)
        }, dateProfile.isRangeAllDay, this.opt('titleFormat') || this.computeTitleFormat(dateProfile), this.opt('titleRangeSeparator'));
    };
    // Generates the format string that should be used to generate the title for the current date range.
    // Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
    View.prototype.computeTitleFormat = function (dateProfile) {
        var currentRangeUnit = dateProfile.currentRangeUnit;
        if (currentRangeUnit === 'year') {
            return 'YYYY';
        }
        else if (currentRangeUnit === 'month') {
            return this.opt('monthYearFormat'); // like "September 2014"
        }
        else if (dateProfile.currentUnzonedRange.as('days') > 1) {
            return 'll'; // multi-day range. shorter, like "Sep 9 - 10 2014"
        }
        else {
            return 'LL'; // one day. longer, like "September 9 2014"
        }
    };
    // Date Setting/Unsetting
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.setDate = function (date) {
        var currentDateProfile = this.get('dateProfile');
        var newDateProfile = this.dateProfileGenerator.build(date, undefined, true); // forceToValid=true
        if (!currentDateProfile ||
            !currentDateProfile.activeUnzonedRange.equals(newDateProfile.activeUnzonedRange)) {
            this.set('dateProfile', newDateProfile);
        }
    };
    View.prototype.unsetDate = function () {
        this.unset('dateProfile');
    };
    // Event Data
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.fetchInitialEvents = function (dateProfile) {
        var calendar = this.calendar;
        var forceAllDay = dateProfile.isRangeAllDay && !this.usesMinMaxTime;
        return calendar.requestEvents(calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, forceAllDay), calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, forceAllDay));
    };
    View.prototype.bindEventChanges = function () {
        this.listenTo(this.calendar, 'eventsReset', this.resetEvents); // TODO: make this a real event
    };
    View.prototype.unbindEventChanges = function () {
        this.stopListeningTo(this.calendar, 'eventsReset');
    };
    View.prototype.setEvents = function (eventsPayload) {
        this.set('currentEvents', eventsPayload);
        this.set('hasEvents', true);
    };
    View.prototype.unsetEvents = function () {
        this.unset('currentEvents');
        this.unset('hasEvents');
    };
    View.prototype.resetEvents = function (eventsPayload) {
        this.startBatchRender();
        this.unsetEvents();
        this.setEvents(eventsPayload);
        this.stopBatchRender();
    };
    // Date High-level Rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.requestDateRender = function (dateProfile) {
        var _this = this;
        this.requestRender(function () {
            _this.executeDateRender(dateProfile);
        }, 'date', 'init');
    };
    View.prototype.requestDateUnrender = function () {
        var _this = this;
        this.requestRender(function () {
            _this.executeDateUnrender();
        }, 'date', 'destroy');
    };
    // if dateProfile not specified, uses current
    View.prototype.executeDateRender = function (dateProfile) {
        _super.prototype.executeDateRender.call(this, dateProfile);
        if (this['render']) {
            this['render'](); // TODO: deprecate
        }
        this.trigger('datesRendered');
        this.addScroll({ isDateInit: true });
        this.startNowIndicator(); // shouldn't render yet because updateSize will be called soon
    };
    View.prototype.executeDateUnrender = function () {
        this.unselect();
        this.stopNowIndicator();
        this.trigger('before:datesUnrendered');
        if (this['destroy']) {
            this['destroy'](); // TODO: deprecate
        }
        _super.prototype.executeDateUnrender.call(this);
    };
    // "Base" rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.bindBaseRenderHandlers = function () {
        var _this = this;
        this.on('datesRendered', function () {
            _this.whenSizeUpdated(_this.triggerViewRender);
        });
        this.on('before:datesUnrendered', function () {
            _this.triggerViewDestroy();
        });
    };
    View.prototype.triggerViewRender = function () {
        this.publiclyTrigger('viewRender', {
            context: this,
            args: [this, this.el]
        });
    };
    View.prototype.triggerViewDestroy = function () {
        this.publiclyTrigger('viewDestroy', {
            context: this,
            args: [this, this.el]
        });
    };
    // Event High-level Rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.requestEventsRender = function (eventsPayload) {
        var _this = this;
        this.requestRender(function () {
            _this.executeEventRender(eventsPayload);
            _this.whenSizeUpdated(_this.triggerAfterEventsRendered);
        }, 'event', 'init');
    };
    View.prototype.requestEventsUnrender = function () {
        var _this = this;
        this.requestRender(function () {
            _this.triggerBeforeEventsDestroyed();
            _this.executeEventUnrender();
        }, 'event', 'destroy');
    };
    // Business Hour High-level Rendering
    // -----------------------------------------------------------------------------------------------------------------
    View.prototype.requestBusinessHoursRender = function (businessHourGenerator) {
        var _this = this;
        this.requestRender(function () {
            _this.renderBusinessHours(businessHourGenerator);
        }, 'businessHours', 'init');
    };
    View.prototype.requestBusinessHoursUnrender = function () {
        var _this = this;
        this.requestRender(function () {
            _this.unrenderBusinessHours();
        }, 'businessHours', 'destroy');
    };
    // Misc view rendering utils
    // -----------------------------------------------------------------------------------------------------------------
    // Binds DOM handlers to elements that reside outside the view container, such as the document
    View.prototype.bindGlobalHandlers = function () {
        _super.prototype.bindGlobalHandlers.call(this);
        this.listenTo(GlobalEmitter_1.default.get(), {
            touchstart: this.processUnselect,
            mousedown: this.handleDocumentMousedown
        });
    };
    // Unbinds DOM handlers from elements that reside outside the view container
    View.prototype.unbindGlobalHandlers = function () {
        _super.prototype.unbindGlobalHandlers.call(this);
        this.stopListeningTo(GlobalEmitter_1.default.get());
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/
    // Immediately render the current time indicator and begins re-rendering it at an interval,
    // which is defined by this.getNowIndicatorUnit().
    // TODO: somehow do this for the current whole day's background too
    View.prototype.startNowIndicator = function () {
        var _this = this;
        var unit;
        var update;
        var delay; // ms wait value
        if (this.opt('nowIndicator')) {
            unit = this.getNowIndicatorUnit();
            if (unit) {
                update = util_1.proxy(this, 'updateNowIndicator'); // bind to `this`
                this.initialNowDate = this.calendar.getNow();
                this.initialNowQueriedMs = new Date().valueOf();
                // wait until the beginning of the next interval
                delay = this.initialNowDate.clone().startOf(unit).add(1, unit).valueOf() - this.initialNowDate.valueOf();
                this.nowIndicatorTimeoutID = setTimeout(function () {
                    _this.nowIndicatorTimeoutID = null;
                    update();
                    delay = +moment.duration(1, unit);
                    delay = Math.max(100, delay); // prevent too frequent
                    _this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval
                }, delay);
            }
            // rendering will be initiated in updateSize
        }
    };
    // rerenders the now indicator, computing the new current time from the amount of time that has passed
    // since the initial getNow call.
    View.prototype.updateNowIndicator = function () {
        if (this.isDatesRendered &&
            this.initialNowDate // activated before?
        ) {
            this.unrenderNowIndicator(); // won't unrender if unnecessary
            this.renderNowIndicator(this.initialNowDate.clone().add(new Date().valueOf() - this.initialNowQueriedMs) // add ms
            );
            this.isNowIndicatorRendered = true;
        }
    };
    // Immediately unrenders the view's current time indicator and stops any re-rendering timers.
    // Won't cause side effects if indicator isn't rendered.
    View.prototype.stopNowIndicator = function () {
        if (this.isNowIndicatorRendered) {
            if (this.nowIndicatorTimeoutID) {
                clearTimeout(this.nowIndicatorTimeoutID);
                this.nowIndicatorTimeoutID = null;
            }
            if (this.nowIndicatorIntervalID) {
                clearInterval(this.nowIndicatorIntervalID);
                this.nowIndicatorIntervalID = null;
            }
            this.unrenderNowIndicator();
            this.isNowIndicatorRendered = false;
        }
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        if (this['setHeight']) { // for legacy API
            this['setHeight'](totalHeight, isAuto);
        }
        else {
            _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        }
        this.updateNowIndicator();
    };
    /* Scroller
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.addScroll = function (scroll) {
        var queuedScroll = this.queuedScroll || (this.queuedScroll = {});
        $.extend(queuedScroll, scroll);
    };
    View.prototype.popScroll = function () {
        this.applyQueuedScroll();
        this.queuedScroll = null;
    };
    View.prototype.applyQueuedScroll = function () {
        if (this.queuedScroll) {
            this.applyScroll(this.queuedScroll);
        }
    };
    View.prototype.queryScroll = function () {
        var scroll = {};
        if (this.isDatesRendered) {
            $.extend(scroll, this.queryDateScroll());
        }
        return scroll;
    };
    View.prototype.applyScroll = function (scroll) {
        if (scroll.isDateInit && this.isDatesRendered) {
            $.extend(scroll, this.computeInitialDateScroll());
        }
        if (this.isDatesRendered) {
            this.applyDateScroll(scroll);
        }
    };
    View.prototype.computeInitialDateScroll = function () {
        return {}; // subclasses must implement
    };
    View.prototype.queryDateScroll = function () {
        return {}; // subclasses must implement
    };
    View.prototype.applyDateScroll = function (scroll) {
        // subclasses must implement
    };
    /* Event Drag-n-Drop
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.reportEventDrop = function (eventInstance, eventMutation, el, ev) {
        var eventManager = this.calendar.eventManager;
        var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation);
        var dateMutation = eventMutation.dateMutation;
        // update the EventInstance, for handlers
        if (dateMutation) {
            eventInstance.dateProfile = dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);
        }
        this.triggerEventDrop(eventInstance, 
        // a drop doesn't necessarily mean a date mutation (ex: resource change)
        (dateMutation && dateMutation.dateDelta) || moment.duration(), undoFunc, el, ev);
    };
    // Triggers event-drop handlers that have subscribed via the API
    View.prototype.triggerEventDrop = function (eventInstance, dateDelta, undoFunc, el, ev) {
        this.publiclyTrigger('eventDrop', {
            context: el[0],
            args: [
                eventInstance.toLegacy(),
                dateDelta,
                undoFunc,
                ev,
                {},
                this
            ]
        });
    };
    /* External Element Drag-n-Drop
    ------------------------------------------------------------------------------------------------------------------*/
    // Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
    // `meta` is the parsed data that has been embedded into the dragging event.
    // `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
    View.prototype.reportExternalDrop = function (singleEventDef, isEvent, isSticky, el, ev, ui) {
        if (isEvent) {
            this.calendar.eventManager.addEventDef(singleEventDef, isSticky);
        }
        this.triggerExternalDrop(singleEventDef, isEvent, el, ev, ui);
    };
    // Triggers external-drop handlers that have subscribed via the API
    View.prototype.triggerExternalDrop = function (singleEventDef, isEvent, el, ev, ui) {
        // trigger 'drop' regardless of whether element represents an event
        this.publiclyTrigger('drop', {
            context: el[0],
            args: [
                singleEventDef.dateProfile.start.clone(),
                ev,
                ui,
                this
            ]
        });
        if (isEvent) {
            // signal an external event landed
            this.publiclyTrigger('eventReceive', {
                context: this,
                args: [
                    singleEventDef.buildInstance().toLegacy(),
                    this
                ]
            });
        }
    };
    /* Event Resizing
    ------------------------------------------------------------------------------------------------------------------*/
    // Must be called when an event in the view has been resized to a new length
    View.prototype.reportEventResize = function (eventInstance, eventMutation, el, ev) {
        var eventManager = this.calendar.eventManager;
        var undoFunc = eventManager.mutateEventsWithId(eventInstance.def.id, eventMutation);
        // update the EventInstance, for handlers
        eventInstance.dateProfile = eventMutation.dateMutation.buildNewDateProfile(eventInstance.dateProfile, this.calendar);
        var resizeDelta = eventMutation.dateMutation.endDelta || eventMutation.dateMutation.startDelta;
        this.triggerEventResize(eventInstance, resizeDelta, undoFunc, el, ev);
    };
    // Triggers event-resize handlers that have subscribed via the API
    View.prototype.triggerEventResize = function (eventInstance, resizeDelta, undoFunc, el, ev) {
        this.publiclyTrigger('eventResize', {
            context: el[0],
            args: [
                eventInstance.toLegacy(),
                resizeDelta,
                undoFunc,
                ev,
                {},
                this
            ]
        });
    };
    /* Selection (time range)
    ------------------------------------------------------------------------------------------------------------------*/
    // Selects a date span on the view. `start` and `end` are both Moments.
    // `ev` is the native mouse event that begin the interaction.
    View.prototype.select = function (footprint, ev) {
        this.unselect(ev);
        this.renderSelectionFootprint(footprint);
        this.reportSelection(footprint, ev);
    };
    View.prototype.renderSelectionFootprint = function (footprint) {
        if (this['renderSelection']) { // legacy method in custom view classes
            this['renderSelection'](footprint.toLegacy(this.calendar));
        }
        else {
            _super.prototype.renderSelectionFootprint.call(this, footprint);
        }
    };
    // Called when a new selection is made. Updates internal state and triggers handlers.
    View.prototype.reportSelection = function (footprint, ev) {
        this.isSelected = true;
        this.triggerSelect(footprint, ev);
    };
    // Triggers handlers to 'select'
    View.prototype.triggerSelect = function (footprint, ev) {
        var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of "Event"DateProfile?
        this.publiclyTrigger('select', {
            context: this,
            args: [
                dateProfile.start,
                dateProfile.end,
                ev,
                this
            ]
        });
    };
    // Undoes a selection. updates in the internal state and triggers handlers.
    // `ev` is the native mouse event that began the interaction.
    View.prototype.unselect = function (ev) {
        if (this.isSelected) {
            this.isSelected = false;
            if (this['destroySelection']) {
                this['destroySelection'](); // TODO: deprecate
            }
            this.unrenderSelection();
            this.publiclyTrigger('unselect', {
                context: this,
                args: [ev, this]
            });
        }
    };
    /* Event Selection
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.selectEventInstance = function (eventInstance) {
        if (!this.selectedEventInstance ||
            this.selectedEventInstance !== eventInstance) {
            this.unselectEventInstance();
            this.getEventSegs().forEach(function (seg) {
                if (seg.footprint.eventInstance === eventInstance &&
                    seg.el // necessary?
                ) {
                    seg.el.addClass('fc-selected');
                }
            });
            this.selectedEventInstance = eventInstance;
        }
    };
    View.prototype.unselectEventInstance = function () {
        if (this.selectedEventInstance) {
            this.getEventSegs().forEach(function (seg) {
                if (seg.el) { // necessary?
                    seg.el.removeClass('fc-selected');
                }
            });
            this.selectedEventInstance = null;
        }
    };
    View.prototype.isEventDefSelected = function (eventDef) {
        // event references might change on refetchEvents(), while selectedEventInstance doesn't,
        // so compare IDs
        return this.selectedEventInstance && this.selectedEventInstance.def.id === eventDef.id;
    };
    /* Mouse / Touch Unselecting (time range & event unselection)
    ------------------------------------------------------------------------------------------------------------------*/
    // TODO: move consistently to down/start or up/end?
    // TODO: don't kill previous selection if touch scrolling
    View.prototype.handleDocumentMousedown = function (ev) {
        if (util_1.isPrimaryMouseButton(ev)) {
            this.processUnselect(ev);
        }
    };
    View.prototype.processUnselect = function (ev) {
        this.processRangeUnselect(ev);
        this.processEventUnselect(ev);
    };
    View.prototype.processRangeUnselect = function (ev) {
        var ignore;
        // is there a time-range selection?
        if (this.isSelected && this.opt('unselectAuto')) {
            // only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element
            ignore = this.opt('unselectCancel');
            if (!ignore || !$(ev.target).closest(ignore).length) {
                this.unselect(ev);
            }
        }
    };
    View.prototype.processEventUnselect = function (ev) {
        if (this.selectedEventInstance) {
            if (!$(ev.target).closest('.fc-selected').length) {
                this.unselectEventInstance();
            }
        }
    };
    /* Triggers
    ------------------------------------------------------------------------------------------------------------------*/
    View.prototype.triggerBaseRendered = function () {
        this.publiclyTrigger('viewRender', {
            context: this,
            args: [this, this.el]
        });
    };
    View.prototype.triggerBaseUnrendered = function () {
        this.publiclyTrigger('viewDestroy', {
            context: this,
            args: [this, this.el]
        });
    };
    // Triggers handlers to 'dayClick'
    // Span has start/end of the clicked area. Only the start is useful.
    View.prototype.triggerDayClick = function (footprint, dayEl, ev) {
        var dateProfile = this.calendar.footprintToDateProfile(footprint); // abuse of "Event"DateProfile?
        this.publiclyTrigger('dayClick', {
            context: dayEl,
            args: [dateProfile.start, ev, this]
        });
    };
    /* Date Utils
    ------------------------------------------------------------------------------------------------------------------*/
    // For DateComponent::getDayClasses
    View.prototype.isDateInOtherMonth = function (date, dateProfile) {
        return false;
    };
    // Arguments after name will be forwarded to a hypothetical function value
    // WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.
    // Always clone your objects if you fear mutation.
    View.prototype.getUnzonedRangeOption = function (name) {
        var val = this.opt(name);
        if (typeof val === 'function') {
            val = val.apply(null, Array.prototype.slice.call(arguments, 1));
        }
        if (val) {
            return this.calendar.parseUnzonedRange(val);
        }
    };
    /* Hidden Days
    ------------------------------------------------------------------------------------------------------------------*/
    // Initializes internal variables related to calculating hidden days-of-week
    View.prototype.initHiddenDays = function () {
        var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden
        var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
        var dayCnt = 0;
        var i;
        if (this.opt('weekends') === false) {
            hiddenDays.push(0, 6); // 0=sunday, 6=saturday
        }
        for (i = 0; i < 7; i++) {
            if (!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)) {
                dayCnt++;
            }
        }
        if (!dayCnt) {
            throw new Error('invalid hiddenDays'); // all days were hidden? bad.
        }
        this.isHiddenDayHash = isHiddenDayHash;
    };
    // Remove days from the beginning and end of the range that are computed as hidden.
    // If the whole range is trimmed off, returns null
    View.prototype.trimHiddenDays = function (inputUnzonedRange) {
        var start = inputUnzonedRange.getStart();
        var end = inputUnzonedRange.getEnd();
        if (start) {
            start = this.skipHiddenDays(start);
        }
        if (end) {
            end = this.skipHiddenDays(end, -1, true);
        }
        if (start === null || end === null || start < end) {
            return new UnzonedRange_1.default(start, end);
        }
        return null;
    };
    // Is the current day hidden?
    // `day` is a day-of-week index (0-6), or a Moment
    View.prototype.isHiddenDay = function (day) {
        if (moment.isMoment(day)) {
            day = day.day();
        }
        return this.isHiddenDayHash[day];
    };
    // Incrementing the current day until it is no longer a hidden day, returning a copy.
    // DOES NOT CONSIDER validUnzonedRange!
    // If the initial value of `date` is not a hidden day, don't do anything.
    // Pass `isExclusive` as `true` if you are dealing with an end date.
    // `inc` defaults to `1` (increment one day forward each time)
    View.prototype.skipHiddenDays = function (date, inc, isExclusive) {
        if (inc === void 0) { inc = 1; }
        if (isExclusive === void 0) { isExclusive = false; }
        var out = date.clone();
        while (this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]) {
            out.add(inc, 'days');
        }
        return out;
    };
    return View;
}(InteractiveDateComponent_1.default));
exports.default = View;
View.prototype.usesMinMaxTime = false;
View.prototype.dateProfileGeneratorClass = DateProfileGenerator_1.default;
View.watch('displayingDates', ['isInDom', 'dateProfile'], function (deps) {
    this.requestDateRender(deps.dateProfile);
}, function () {
    this.requestDateUnrender();
});
View.watch('displayingBusinessHours', ['displayingDates', 'businessHourGenerator'], function (deps) {
    this.requestBusinessHoursRender(deps.businessHourGenerator);
}, function () {
    this.requestBusinessHoursUnrender();
});
View.watch('initialEvents', ['dateProfile'], function (deps) {
    return this.fetchInitialEvents(deps.dateProfile);
});
View.watch('bindingEvents', ['initialEvents'], function (deps) {
    this.setEvents(deps.initialEvents);
    this.bindEventChanges();
}, function () {
    this.unbindEventChanges();
    this.unsetEvents();
});
View.watch('displayingEvents', ['displayingDates', 'hasEvents'], function () {
    this.requestEventsRender(this.get('currentEvents'));
}, function () {
    this.requestEventsUnrender();
});
View.watch('title', ['dateProfile'], function (deps) {
    return (this.title = this.computeTitle(deps.dateProfile)); // assign to View for legacy reasons
});
View.watch('legacyDateProps', ['dateProfile'], function (deps) {
    var calendar = this.calendar;
    var dateProfile = deps.dateProfile;
    // DEPRECATED, but we need to keep it updated...
    this.start = calendar.msToMoment(dateProfile.activeUnzonedRange.startMs, dateProfile.isRangeAllDay);
    this.end = calendar.msToMoment(dateProfile.activeUnzonedRange.endMs, dateProfile.isRangeAllDay);
    this.intervalStart = calendar.msToMoment(dateProfile.currentUnzonedRange.startMs, dateProfile.isRangeAllDay);
    this.intervalEnd = calendar.msToMoment(dateProfile.currentUnzonedRange.endMs, dateProfile.isRangeAllDay);
});


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var EventRenderer = /** @class */ (function () {
    function EventRenderer(component, fillRenderer) {
        this.view = component._getView();
        this.component = component;
        this.fillRenderer = fillRenderer;
    }
    EventRenderer.prototype.opt = function (name) {
        return this.view.opt(name);
    };
    // Updates values that rely on options and also relate to range
    EventRenderer.prototype.rangeUpdated = function () {
        var displayEventTime;
        var displayEventEnd;
        this.eventTimeFormat =
            this.opt('eventTimeFormat') ||
                this.opt('timeFormat') || // deprecated
                this.computeEventTimeFormat();
        displayEventTime = this.opt('displayEventTime');
        if (displayEventTime == null) {
            displayEventTime = this.computeDisplayEventTime(); // might be based off of range
        }
        displayEventEnd = this.opt('displayEventEnd');
        if (displayEventEnd == null) {
            displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
        }
        this.displayEventTime = displayEventTime;
        this.displayEventEnd = displayEventEnd;
    };
    EventRenderer.prototype.render = function (eventsPayload) {
        var dateProfile = this.component._getDateProfile();
        var eventDefId;
        var instanceGroup;
        var eventRanges;
        var bgRanges = [];
        var fgRanges = [];
        for (eventDefId in eventsPayload) {
            instanceGroup = eventsPayload[eventDefId];
            eventRanges = instanceGroup.sliceRenderRanges(dateProfile.activeUnzonedRange);
            if (instanceGroup.getEventDef().hasBgRendering()) {
                bgRanges.push.apply(bgRanges, eventRanges);
            }
            else {
                fgRanges.push.apply(fgRanges, eventRanges);
            }
        }
        this.renderBgRanges(bgRanges);
        this.renderFgRanges(fgRanges);
    };
    EventRenderer.prototype.unrender = function () {
        this.unrenderBgRanges();
        this.unrenderFgRanges();
    };
    EventRenderer.prototype.renderFgRanges = function (eventRanges) {
        var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        // render an `.el` on each seg
        // returns a subset of the segs. segs that were actually rendered
        segs = this.renderFgSegEls(segs);
        if (this.renderFgSegs(segs) !== false) { // no failure?
            this.fgSegs = segs;
        }
    };
    EventRenderer.prototype.unrenderFgRanges = function () {
        this.unrenderFgSegs(this.fgSegs || []);
        this.fgSegs = null;
    };
    EventRenderer.prototype.renderBgRanges = function (eventRanges) {
        var eventFootprints = this.component.eventRangesToEventFootprints(eventRanges);
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        if (this.renderBgSegs(segs) !== false) { // no failure?
            this.bgSegs = segs;
        }
    };
    EventRenderer.prototype.unrenderBgRanges = function () {
        this.unrenderBgSegs();
        this.bgSegs = null;
    };
    EventRenderer.prototype.getSegs = function () {
        return (this.bgSegs || []).concat(this.fgSegs || []);
    };
    // Renders foreground event segments onto the grid
    EventRenderer.prototype.renderFgSegs = function (segs) {
        // subclasses must implement
        // segs already has rendered els, and has been filtered.
        return false; // signal failure if not implemented
    };
    // Unrenders all currently rendered foreground segments
    EventRenderer.prototype.unrenderFgSegs = function (segs) {
        // subclasses must implement
    };
    EventRenderer.prototype.renderBgSegs = function (segs) {
        var _this = this;
        if (this.fillRenderer) {
            this.fillRenderer.renderSegs('bgEvent', segs, {
                getClasses: function (seg) {
                    return _this.getBgClasses(seg.footprint.eventDef);
                },
                getCss: function (seg) {
                    return {
                        'background-color': _this.getBgColor(seg.footprint.eventDef)
                    };
                },
                filterEl: function (seg, el) {
                    return _this.filterEventRenderEl(seg.footprint, el);
                }
            });
        }
        else {
            return false; // signal failure if no fillRenderer
        }
    };
    EventRenderer.prototype.unrenderBgSegs = function () {
        if (this.fillRenderer) {
            this.fillRenderer.unrender('bgEvent');
        }
    };
    // Renders and assigns an `el` property for each foreground event segment.
    // Only returns segments that successfully rendered.
    EventRenderer.prototype.renderFgSegEls = function (segs, disableResizing) {
        var _this = this;
        if (disableResizing === void 0) { disableResizing = false; }
        var hasEventRenderHandlers = this.view.hasPublicHandlers('eventRender');
        var html = '';
        var renderedSegs = [];
        var i;
        if (segs.length) { // don't build an empty html string
            // build a large concatenation of event segment HTML
            for (i = 0; i < segs.length; i++) {
                this.beforeFgSegHtml(segs[i]);
                html += this.fgSegHtml(segs[i], disableResizing);
            }
            // Grab individual elements from the combined HTML string. Use each as the default rendering.
            // Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
            $(html).each(function (i, node) {
                var seg = segs[i];
                var el = $(node);
                if (hasEventRenderHandlers) { // optimization
                    el = _this.filterEventRenderEl(seg.footprint, el);
                }
                if (el) {
                    el.data('fc-seg', seg); // used by handlers
                    seg.el = el;
                    renderedSegs.push(seg);
                }
            });
        }
        return renderedSegs;
    };
    EventRenderer.prototype.beforeFgSegHtml = function (seg) {
    };
    // Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
    EventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
        // subclasses should implement
    };
    // Generic utility for generating the HTML classNames for an event segment's element
    EventRenderer.prototype.getSegClasses = function (seg, isDraggable, isResizable) {
        var classes = [
            'fc-event',
            seg.isStart ? 'fc-start' : 'fc-not-start',
            seg.isEnd ? 'fc-end' : 'fc-not-end'
        ].concat(this.getClasses(seg.footprint.eventDef));
        if (isDraggable) {
            classes.push('fc-draggable');
        }
        if (isResizable) {
            classes.push('fc-resizable');
        }
        // event is currently selected? attach a className.
        if (this.view.isEventDefSelected(seg.footprint.eventDef)) {
            classes.push('fc-selected');
        }
        return classes;
    };
    // Given an event and the default element used for rendering, returns the element that should actually be used.
    // Basically runs events and elements through the eventRender hook.
    EventRenderer.prototype.filterEventRenderEl = function (eventFootprint, el) {
        var legacy = eventFootprint.getEventLegacy();
        var custom = this.view.publiclyTrigger('eventRender', {
            context: legacy,
            args: [legacy, el, this.view]
        });
        if (custom === false) { // means don't render at all
            el = null;
        }
        else if (custom && custom !== true) {
            el = $(custom);
        }
        return el;
    };
    // Compute the text that should be displayed on an event's element.
    // `range` can be the Event object itself, or something range-like, with at least a `start`.
    // If event times are disabled, or the event has no time, will return a blank string.
    // If not specified, formatStr will default to the eventTimeFormat setting,
    // and displayEnd will default to the displayEventEnd setting.
    EventRenderer.prototype.getTimeText = function (eventFootprint, formatStr, displayEnd) {
        return this._getTimeText(eventFootprint.eventInstance.dateProfile.start, eventFootprint.eventInstance.dateProfile.end, eventFootprint.componentFootprint.isAllDay, formatStr, displayEnd);
    };
    EventRenderer.prototype._getTimeText = function (start, end, isAllDay, formatStr, displayEnd) {
        if (formatStr == null) {
            formatStr = this.eventTimeFormat;
        }
        if (displayEnd == null) {
            displayEnd = this.displayEventEnd;
        }
        if (this.displayEventTime && !isAllDay) {
            if (displayEnd && end) {
                return this.view.formatRange({ start: start, end: end }, false, // allDay
                formatStr);
            }
            else {
                return start.format(formatStr);
            }
        }
        return '';
    };
    EventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('smallTimeFormat');
    };
    EventRenderer.prototype.computeDisplayEventTime = function () {
        return true;
    };
    EventRenderer.prototype.computeDisplayEventEnd = function () {
        return true;
    };
    EventRenderer.prototype.getBgClasses = function (eventDef) {
        var classNames = this.getClasses(eventDef);
        classNames.push('fc-bgevent');
        return classNames;
    };
    EventRenderer.prototype.getClasses = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var classNames = [];
        for (i = 0; i < objs.length; i++) {
            classNames.push.apply(// append
            classNames, objs[i].eventClassName || objs[i].className || []);
        }
        return classNames;
    };
    // Utility for generating event skin-related CSS properties
    EventRenderer.prototype.getSkinCss = function (eventDef) {
        return {
            'background-color': this.getBgColor(eventDef),
            'border-color': this.getBorderColor(eventDef),
            color: this.getTextColor(eventDef)
        };
    };
    // Queries for caller-specified color, then falls back to default
    EventRenderer.prototype.getBgColor = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var val;
        for (i = 0; i < objs.length && !val; i++) {
            val = objs[i].eventBackgroundColor || objs[i].eventColor ||
                objs[i].backgroundColor || objs[i].color;
        }
        if (!val) {
            val = this.opt('eventBackgroundColor') || this.opt('eventColor');
        }
        return val;
    };
    // Queries for caller-specified color, then falls back to default
    EventRenderer.prototype.getBorderColor = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var val;
        for (i = 0; i < objs.length && !val; i++) {
            val = objs[i].eventBorderColor || objs[i].eventColor ||
                objs[i].borderColor || objs[i].color;
        }
        if (!val) {
            val = this.opt('eventBorderColor') || this.opt('eventColor');
        }
        return val;
    };
    // Queries for caller-specified color, then falls back to default
    EventRenderer.prototype.getTextColor = function (eventDef) {
        var objs = this.getStylingObjs(eventDef);
        var i;
        var val;
        for (i = 0; i < objs.length && !val; i++) {
            val = objs[i].eventTextColor ||
                objs[i].textColor;
        }
        if (!val) {
            val = this.opt('eventTextColor');
        }
        return val;
    };
    EventRenderer.prototype.getStylingObjs = function (eventDef) {
        var objs = this.getFallbackStylingObjs(eventDef);
        objs.unshift(eventDef);
        return objs;
    };
    EventRenderer.prototype.getFallbackStylingObjs = function (eventDef) {
        return [eventDef.source];
    };
    EventRenderer.prototype.sortEventSegs = function (segs) {
        segs.sort(util_1.proxy(this, 'compareEventSegs'));
    };
    // A cmp function for determining which segments should take visual priority
    EventRenderer.prototype.compareEventSegs = function (seg1, seg2) {
        var f1 = seg1.footprint;
        var f2 = seg2.footprint;
        var cf1 = f1.componentFootprint;
        var cf2 = f2.componentFootprint;
        var r1 = cf1.unzonedRange;
        var r2 = cf2.unzonedRange;
        return r1.startMs - r2.startMs || // earlier events go first
            (r2.endMs - r2.startMs) - (r1.endMs - r1.startMs) || // tie? longer events go first
            cf2.isAllDay - cf1.isAllDay || // tie? put all-day events first (booleans cast to 0/1)
            util_1.compareByFieldSpecs(f1.eventDef, f2.eventDef, this.view.eventOrderSpecs, f1.eventDef.miscProps, f2.eventDef.miscProps);
    };
    return EventRenderer;
}());
exports.default = EventRenderer;


/***/ }),
/* 45 */,
/* 46 */,
/* 47 */,
/* 48 */,
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment_ext_1 = __webpack_require__(11);
// Plugin
// -------------------------------------------------------------------------------------------------
moment_ext_1.newMomentProto.format = function () {
    if (this._fullCalendar && arguments[0]) { // an enhanced moment? and a format string provided?
        return formatDate(this, arguments[0]); // our extended formatting
    }
    if (this._ambigTime) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
    }
    if (this._ambigZone) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
    }
    if (this._fullCalendar) { // enhanced non-ambig moment?
        // moment.format() doesn't ensure english, but we want to.
        return moment_ext_1.oldMomentFormat(englishMoment(this));
    }
    return moment_ext_1.oldMomentProto.format.apply(this, arguments);
};
moment_ext_1.newMomentProto.toISOString = function () {
    if (this._ambigTime) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD');
    }
    if (this._ambigZone) {
        return moment_ext_1.oldMomentFormat(englishMoment(this), 'YYYY-MM-DD[T]HH:mm:ss');
    }
    if (this._fullCalendar) { // enhanced non-ambig moment?
        // depending on browser, moment might not output english. ensure english.
        // https://github.com/moment/moment/blob/2.18.1/src/lib/moment/format.js#L22
        return moment_ext_1.oldMomentProto.toISOString.apply(englishMoment(this), arguments);
    }
    return moment_ext_1.oldMomentProto.toISOString.apply(this, arguments);
};
function englishMoment(mom) {
    if (mom.locale() !== 'en') {
        return mom.clone().locale('en');
    }
    return mom;
}
// Config
// ---------------------------------------------------------------------------------------------------------------------
/*
Inserted between chunks in the fake ("intermediate") formatting string.
Important that it passes as whitespace (\s) because moment often identifies non-standalone months
via a regexp with an \s.
*/
var PART_SEPARATOR = '\u000b'; // vertical tab
/*
Inserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,
but rather, a "special" token that has custom rendering (see specialTokens map).
*/
var SPECIAL_TOKEN_MARKER = '\u001f'; // information separator 1
/*
Inserted at the beginning and end of a span of text that must have non-zero numeric characters.
Handling of these markers is done in a post-processing step at the very end of text rendering.
*/
var MAYBE_MARKER = '\u001e'; // information separator 2
var MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global
/*
Addition formatting tokens we want recognized
*/
var specialTokens = {
    t: function (date) {
        return moment_ext_1.oldMomentFormat(date, 'a').charAt(0);
    },
    T: function (date) {
        return moment_ext_1.oldMomentFormat(date, 'A').charAt(0);
    }
};
/*
The first characters of formatting tokens for units that are 1 day or larger.
`value` is for ranking relative size (lower means bigger).
`unit` is a normalized unit, used for comparing moments.
*/
var largeTokenMap = {
    Y: { value: 1, unit: 'year' },
    M: { value: 2, unit: 'month' },
    W: { value: 3, unit: 'week' },
    w: { value: 3, unit: 'week' },
    D: { value: 4, unit: 'day' },
    d: { value: 4, unit: 'day' } // day of week
};
// Single Date Formatting
// ---------------------------------------------------------------------------------------------------------------------
/*
Formats `date` with a Moment formatting string, but allow our non-zero areas and special token
*/
function formatDate(date, formatStr) {
    return renderFakeFormatString(getParsedFormatString(formatStr).fakeFormatString, date);
}
exports.formatDate = formatDate;
// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset
/*
Using a formatting string meant for a single date, generate a range string, like
"Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
If the dates are the same as far as the format string is concerned, just return a single
rendering of one date, without any separator.
*/
function formatRange(date1, date2, formatStr, separator, isRTL) {
    var localeData;
    date1 = moment_ext_1.default.parseZone(date1);
    date2 = moment_ext_1.default.parseZone(date2);
    localeData = date1.localeData();
    // Expand localized format strings, like "LL" -> "MMMM D YYYY".
    // BTW, this is not important for `formatDate` because it is impossible to put custom tokens
    // or non-zero areas in Moment's localized format strings.
    formatStr = localeData.longDateFormat(formatStr) || formatStr;
    return renderParsedFormat(getParsedFormatString(formatStr), date1, date2, separator || ' - ', isRTL);
}
exports.formatRange = formatRange;
/*
Renders a range with an already-parsed format string.
*/
function renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {
    var sameUnits = parsedFormat.sameUnits;
    var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons
    var unzonedDate2 = date2.clone().stripZone(); // "
    var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);
    var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);
    var leftI;
    var leftStr = '';
    var rightI;
    var rightStr = '';
    var middleI;
    var middleStr1 = '';
    var middleStr2 = '';
    var middleStr = '';
    // Start at the leftmost side of the formatting string and continue until you hit a token
    // that is not the same between dates.
    for (leftI = 0; leftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI])); leftI++) {
        leftStr += renderedParts1[leftI];
    }
    // Similarly, start at the rightmost side of the formatting string and move left
    for (rightI = sameUnits.length - 1; rightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI])); rightI--) {
        // If current chunk is on the boundary of unique date-content, and is a special-case
        // date-formatting postfix character, then don't consume it. Consider it unique date-content.
        // TODO: make configurable
        if (rightI - 1 === leftI && renderedParts1[rightI] === '.') {
            break;
        }
        rightStr = renderedParts1[rightI] + rightStr;
    }
    // The area in the middle is different for both of the dates.
    // Collect them distinctly so we can jam them together later.
    for (middleI = leftI; middleI <= rightI; middleI++) {
        middleStr1 += renderedParts1[middleI];
        middleStr2 += renderedParts2[middleI];
    }
    if (middleStr1 || middleStr2) {
        if (isRTL) {
            middleStr = middleStr2 + separator + middleStr1;
        }
        else {
            middleStr = middleStr1 + separator + middleStr2;
        }
    }
    return processMaybeMarkers(leftStr + middleStr + rightStr);
}
// Format String Parsing
// ---------------------------------------------------------------------------------------------------------------------
var parsedFormatStrCache = {};
/*
Returns a parsed format string, leveraging a cache.
*/
function getParsedFormatString(formatStr) {
    return parsedFormatStrCache[formatStr] ||
        (parsedFormatStrCache[formatStr] = parseFormatString(formatStr));
}
/*
Parses a format string into the following:
- fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.
- sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like "day"),
  that indicates how similar a range's start & end must be in order to share the same formatted text.
  If not a token, then the value is null.
  Always a flat array (not nested liked "chunks").
*/
function parseFormatString(formatStr) {
    var chunks = chunkFormatString(formatStr);
    return {
        fakeFormatString: buildFakeFormatString(chunks),
        sameUnits: buildSameUnits(chunks)
    };
}
/*
Break the formatting string into an array of chunks.
A 'maybe' chunk will have nested chunks.
*/
function chunkFormatString(formatStr) {
    var chunks = [];
    var match;
    // TODO: more descrimination
    // \4 is a backreference to the first character of a multi-character set.
    var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g;
    while ((match = chunker.exec(formatStr))) {
        if (match[1]) { // a literal string inside [ ... ]
            chunks.push.apply(chunks, // append
            splitStringLiteral(match[1]));
        }
        else if (match[2]) { // non-zero formatting inside ( ... )
            chunks.push({ maybe: chunkFormatString(match[2]) });
        }
        else if (match[3]) { // a formatting token
            chunks.push({ token: match[3] });
        }
        else if (match[5]) { // an unenclosed literal string
            chunks.push.apply(chunks, // append
            splitStringLiteral(match[5]));
        }
    }
    return chunks;
}
/*
Potentially splits a literal-text string into multiple parts. For special cases.
*/
function splitStringLiteral(s) {
    if (s === '. ') {
        return ['.', ' ']; // for locales with periods bound to the end of each year/month/date
    }
    else {
        return [s];
    }
}
/*
Given chunks parsed from a real format string, generate a fake (aka "intermediate") format string with special control
characters that will eventually be given to moment for formatting, and then post-processed.
*/
function buildFakeFormatString(chunks) {
    var parts = [];
    var i;
    var chunk;
    for (i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        if (typeof chunk === 'string') {
            parts.push('[' + chunk + ']');
        }
        else if (chunk.token) {
            if (chunk.token in specialTokens) {
                parts.push(SPECIAL_TOKEN_MARKER + // useful during post-processing
                    '[' + chunk.token + ']' // preserve as literal text
                );
            }
            else {
                parts.push(chunk.token); // unprotected text implies a format string
            }
        }
        else if (chunk.maybe) {
            parts.push(MAYBE_MARKER + // useful during post-processing
                buildFakeFormatString(chunk.maybe) +
                MAYBE_MARKER);
        }
    }
    return parts.join(PART_SEPARATOR);
}
/*
Given parsed chunks from a real formatting string, generates an array of unit strings (like "day") that indicate
in which regard two dates must be similar in order to share range formatting text.
The `chunks` can be nested (because of "maybe" chunks), however, the returned array will be flat.
*/
function buildSameUnits(chunks) {
    var units = [];
    var i;
    var chunk;
    var tokenInfo;
    for (i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        if (chunk.token) {
            tokenInfo = largeTokenMap[chunk.token.charAt(0)];
            units.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second
        }
        else if (chunk.maybe) {
            units.push.apply(units, // append
            buildSameUnits(chunk.maybe));
        }
        else {
            units.push(null);
        }
    }
    return units;
}
// Rendering to text
// ---------------------------------------------------------------------------------------------------------------------
/*
Formats a date with a fake format string, post-processes the control characters, then returns.
*/
function renderFakeFormatString(fakeFormatString, date) {
    return processMaybeMarkers(renderFakeFormatStringParts(fakeFormatString, date).join(''));
}
/*
Formats a date into parts that will have been post-processed, EXCEPT for the "maybe" markers.
*/
function renderFakeFormatStringParts(fakeFormatString, date) {
    var parts = [];
    var fakeRender = moment_ext_1.oldMomentFormat(date, fakeFormatString);
    var fakeParts = fakeRender.split(PART_SEPARATOR);
    var i;
    var fakePart;
    for (i = 0; i < fakeParts.length; i++) {
        fakePart = fakeParts[i];
        if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {
            parts.push(
            // the literal string IS the token's name.
            // call special token's registered function.
            specialTokens[fakePart.substring(1)](date));
        }
        else {
            parts.push(fakePart);
        }
    }
    return parts;
}
/*
Accepts an almost-finally-formatted string and processes the "maybe" control characters, returning a new string.
*/
function processMaybeMarkers(s) {
    return s.replace(MAYBE_REGEXP, function (m0, m1) {
        if (m1.match(/[1-9]/)) { // any non-zero numeric characters?
            return m1;
        }
        else {
            return '';
        }
    });
}
// Misc Utils
// -------------------------------------------------------------------------------------------------
/*
Returns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.
*/
function queryMostGranularFormatUnit(formatStr) {
    var chunks = chunkFormatString(formatStr);
    var i;
    var chunk;
    var candidate;
    var best;
    for (i = 0; i < chunks.length; i++) {
        chunk = chunks[i];
        if (chunk.token) {
            candidate = largeTokenMap[chunk.token.charAt(0)];
            if (candidate) {
                if (!best || candidate.value > best.value) {
                    best = candidate;
                }
            }
        }
    }
    if (best) {
        return best.unit;
    }
    return null;
}
exports.queryMostGranularFormatUnit = queryMostGranularFormatUnit;


/***/ }),
/* 50 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventRange = /** @class */ (function () {
    function EventRange(unzonedRange, eventDef, eventInstance) {
        this.unzonedRange = unzonedRange;
        this.eventDef = eventDef;
        if (eventInstance) {
            this.eventInstance = eventInstance;
        }
    }
    return EventRange;
}());
exports.default = EventRange;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Class_1 = __webpack_require__(35);
var EmitterMixin_1 = __webpack_require__(13);
var ListenerMixin_1 = __webpack_require__(7);
var Model = /** @class */ (function (_super) {
    tslib_1.__extends(Model, _super);
    function Model() {
        var _this = _super.call(this) || this;
        _this._watchers = {};
        _this._props = {};
        _this.applyGlobalWatchers();
        _this.constructed();
        return _this;
    }
    Model.watch = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        // subclasses should make a masked-copy of the superclass's map
        // TODO: write test
        if (!this.prototype.hasOwnProperty('_globalWatchArgs')) {
            this.prototype._globalWatchArgs = Object.create(this.prototype._globalWatchArgs);
        }
        this.prototype._globalWatchArgs[name] = args;
    };
    Model.prototype.constructed = function () {
        // useful for monkeypatching. TODO: BaseClass?
    };
    Model.prototype.applyGlobalWatchers = function () {
        var map = this._globalWatchArgs;
        var name;
        for (name in map) {
            this.watch.apply(this, [name].concat(map[name]));
        }
    };
    Model.prototype.has = function (name) {
        return name in this._props;
    };
    Model.prototype.get = function (name) {
        if (name === undefined) {
            return this._props;
        }
        return this._props[name];
    };
    Model.prototype.set = function (name, val) {
        var newProps;
        if (typeof name === 'string') {
            newProps = {};
            newProps[name] = val === undefined ? null : val;
        }
        else {
            newProps = name;
        }
        this.setProps(newProps);
    };
    Model.prototype.reset = function (newProps) {
        var oldProps = this._props;
        var changeset = {}; // will have undefined's to signal unsets
        var name;
        for (name in oldProps) {
            changeset[name] = undefined;
        }
        for (name in newProps) {
            changeset[name] = newProps[name];
        }
        this.setProps(changeset);
    };
    Model.prototype.unset = function (name) {
        var newProps = {};
        var names;
        var i;
        if (typeof name === 'string') {
            names = [name];
        }
        else {
            names = name;
        }
        for (i = 0; i < names.length; i++) {
            newProps[names[i]] = undefined;
        }
        this.setProps(newProps);
    };
    Model.prototype.setProps = function (newProps) {
        var changedProps = {};
        var changedCnt = 0;
        var name;
        var val;
        for (name in newProps) {
            val = newProps[name];
            // a change in value?
            // if an object, don't check equality, because might have been mutated internally.
            // TODO: eventually enforce immutability.
            if (typeof val === 'object' ||
                val !== this._props[name]) {
                changedProps[name] = val;
                changedCnt++;
            }
        }
        if (changedCnt) {
            this.trigger('before:batchChange', changedProps);
            for (name in changedProps) {
                val = changedProps[name];
                this.trigger('before:change', name, val);
                this.trigger('before:change:' + name, val);
            }
            for (name in changedProps) {
                val = changedProps[name];
                if (val === undefined) {
                    delete this._props[name];
                }
                else {
                    this._props[name] = val;
                }
                this.trigger('change:' + name, val);
                this.trigger('change', name, val);
            }
            this.trigger('batchChange', changedProps);
        }
    };
    Model.prototype.watch = function (name, depList, startFunc, stopFunc) {
        var _this = this;
        this.unwatch(name);
        this._watchers[name] = this._watchDeps(depList, function (deps) {
            var res = startFunc.call(_this, deps);
            if (res && res.then) {
                _this.unset(name); // put in an unset state while resolving
                res.then(function (val) {
                    _this.set(name, val);
                });
            }
            else {
                _this.set(name, res);
            }
        }, function (deps) {
            _this.unset(name);
            if (stopFunc) {
                stopFunc.call(_this, deps);
            }
        });
    };
    Model.prototype.unwatch = function (name) {
        var watcher = this._watchers[name];
        if (watcher) {
            delete this._watchers[name];
            watcher.teardown();
        }
    };
    Model.prototype._watchDeps = function (depList, startFunc, stopFunc) {
        var _this = this;
        var queuedChangeCnt = 0;
        var depCnt = depList.length;
        var satisfyCnt = 0;
        var values = {}; // what's passed as the `deps` arguments
        var bindTuples = []; // array of [ eventName, handlerFunc ] arrays
        var isCallingStop = false;
        var onBeforeDepChange = function (depName, val, isOptional) {
            queuedChangeCnt++;
            if (queuedChangeCnt === 1) { // first change to cause a "stop" ?
                if (satisfyCnt === depCnt) { // all deps previously satisfied?
                    isCallingStop = true;
                    stopFunc(values);
                    isCallingStop = false;
                }
            }
        };
        var onDepChange = function (depName, val, isOptional) {
            if (val === undefined) { // unsetting a value?
                // required dependency that was previously set?
                if (!isOptional && values[depName] !== undefined) {
                    satisfyCnt--;
                }
                delete values[depName];
            }
            else { // setting a value?
                // required dependency that was previously unset?
                if (!isOptional && values[depName] === undefined) {
                    satisfyCnt++;
                }
                values[depName] = val;
            }
            queuedChangeCnt--;
            if (!queuedChangeCnt) { // last change to cause a "start"?
                // now finally satisfied or satisfied all along?
                if (satisfyCnt === depCnt) {
                    // if the stopFunc initiated another value change, ignore it.
                    // it will be processed by another change event anyway.
                    if (!isCallingStop) {
                        startFunc(values);
                    }
                }
            }
        };
        // intercept for .on() that remembers handlers
        var bind = function (eventName, handler) {
            _this.on(eventName, handler);
            bindTuples.push([eventName, handler]);
        };
        // listen to dependency changes
        depList.forEach(function (depName) {
            var isOptional = false;
            if (depName.charAt(0) === '?') { // TODO: more DRY
                depName = depName.substring(1);
                isOptional = true;
            }
            bind('before:change:' + depName, function (val) {
                onBeforeDepChange(depName, val, isOptional);
            });
            bind('change:' + depName, function (val) {
                onDepChange(depName, val, isOptional);
            });
        });
        // process current dependency values
        depList.forEach(function (depName) {
            var isOptional = false;
            if (depName.charAt(0) === '?') { // TODO: more DRY
                depName = depName.substring(1);
                isOptional = true;
            }
            if (_this.has(depName)) {
                values[depName] = _this.get(depName);
                satisfyCnt++;
            }
            else if (isOptional) {
                satisfyCnt++;
            }
        });
        // initially satisfied
        if (satisfyCnt === depCnt) {
            startFunc(values);
        }
        return {
            teardown: function () {
                // remove all handlers
                for (var i = 0; i < bindTuples.length; i++) {
                    _this.off(bindTuples[i][0], bindTuples[i][1]);
                }
                bindTuples = null;
                // was satisfied, so call stopFunc
                if (satisfyCnt === depCnt) {
                    stopFunc();
                }
            },
            flash: function () {
                if (satisfyCnt === depCnt) {
                    stopFunc();
                    startFunc(values);
                }
            }
        };
    };
    Model.prototype.flash = function (name) {
        var watcher = this._watchers[name];
        if (watcher) {
            watcher.flash();
        }
    };
    return Model;
}(Class_1.default));
exports.default = Model;
Model.prototype._globalWatchArgs = {}; // mutation protection in Model.watch
EmitterMixin_1.default.mixInto(Model);
ListenerMixin_1.default.mixInto(Model);


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

/*
USAGE:
  import { default as ParsableModelMixin, ParsableModelInterface } from './ParsableModelMixin'
in class:
  applyProps: ParsableModelInterface['applyProps']
  applyManualStandardProps: ParsableModelInterface['applyManualStandardProps']
  applyMiscProps: ParsableModelInterface['applyMiscProps']
  isStandardProp: ParsableModelInterface['isStandardProp']
  static defineStandardProps = ParsableModelMixin.defineStandardProps
  static copyVerbatimStandardProps = ParsableModelMixin.copyVerbatimStandardProps
after class:
  ParsableModelMixin.mixInto(TheClass)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var Mixin_1 = __webpack_require__(15);
var ParsableModelMixin = /** @class */ (function (_super) {
    tslib_1.__extends(ParsableModelMixin, _super);
    function ParsableModelMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ParsableModelMixin.defineStandardProps = function (propDefs) {
        var proto = this.prototype;
        if (!proto.hasOwnProperty('standardPropMap')) {
            proto.standardPropMap = Object.create(proto.standardPropMap);
        }
        util_1.copyOwnProps(propDefs, proto.standardPropMap);
    };
    ParsableModelMixin.copyVerbatimStandardProps = function (src, dest) {
        var map = this.prototype.standardPropMap;
        var propName;
        for (propName in map) {
            if (src[propName] != null && // in the src object?
                map[propName] === true // false means "copy verbatim"
            ) {
                dest[propName] = src[propName];
            }
        }
    };
    /*
    Returns true/false for success.
    Meant to be only called ONCE, at object creation.
    */
    ParsableModelMixin.prototype.applyProps = function (rawProps) {
        var standardPropMap = this.standardPropMap;
        var manualProps = {};
        var miscProps = {};
        var propName;
        for (propName in rawProps) {
            if (standardPropMap[propName] === true) { // copy verbatim
                this[propName] = rawProps[propName];
            }
            else if (standardPropMap[propName] === false) {
                manualProps[propName] = rawProps[propName];
            }
            else {
                miscProps[propName] = rawProps[propName];
            }
        }
        this.applyMiscProps(miscProps);
        return this.applyManualStandardProps(manualProps);
    };
    /*
    If subclasses override, they must call this supermethod and return the boolean response.
    Meant to be only called ONCE, at object creation.
    */
    ParsableModelMixin.prototype.applyManualStandardProps = function (rawProps) {
        return true;
    };
    /*
    Can be called even after initial object creation.
    */
    ParsableModelMixin.prototype.applyMiscProps = function (rawProps) {
        // subclasses can implement
    };
    /*
    TODO: why is this a method when defineStandardProps is static
    */
    ParsableModelMixin.prototype.isStandardProp = function (propName) {
        return propName in this.standardPropMap;
    };
    return ParsableModelMixin;
}(Mixin_1.default));
exports.default = ParsableModelMixin;
ParsableModelMixin.prototype.standardPropMap = {}; // will be cloned by defineStandardProps


/***/ }),
/* 53 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventInstance = /** @class */ (function () {
    function EventInstance(def, dateProfile) {
        this.def = def;
        this.dateProfile = dateProfile;
    }
    EventInstance.prototype.toLegacy = function () {
        var dateProfile = this.dateProfile;
        var obj = this.def.toLegacy();
        obj.start = dateProfile.start.clone();
        obj.end = dateProfile.end ? dateProfile.end.clone() : null;
        return obj;
    };
    return EventInstance;
}());
exports.default = EventInstance;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var EventDef_1 = __webpack_require__(37);
var EventInstance_1 = __webpack_require__(53);
var EventDateProfile_1 = __webpack_require__(16);
var RecurringEventDef = /** @class */ (function (_super) {
    tslib_1.__extends(RecurringEventDef, _super);
    function RecurringEventDef() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RecurringEventDef.prototype.isAllDay = function () {
        return !this.startTime && !this.endTime;
    };
    RecurringEventDef.prototype.buildInstances = function (unzonedRange) {
        var calendar = this.source.calendar;
        var unzonedDate = unzonedRange.getStart();
        var unzonedEnd = unzonedRange.getEnd();
        var zonedDayStart;
        var instanceStart;
        var instanceEnd;
        var instances = [];
        while (unzonedDate.isBefore(unzonedEnd)) {
            // if everyday, or this particular day-of-week
            if (!this.dowHash || this.dowHash[unzonedDate.day()]) {
                zonedDayStart = calendar.applyTimezone(unzonedDate);
                instanceStart = zonedDayStart.clone();
                instanceEnd = null;
                if (this.startTime) {
                    instanceStart.time(this.startTime);
                }
                else {
                    instanceStart.stripTime();
                }
                if (this.endTime) {
                    instanceEnd = zonedDayStart.clone().time(this.endTime);
                }
                instances.push(new EventInstance_1.default(this, // definition
                new EventDateProfile_1.default(instanceStart, instanceEnd, calendar)));
            }
            unzonedDate.add(1, 'days');
        }
        return instances;
    };
    RecurringEventDef.prototype.setDow = function (dowNumbers) {
        if (!this.dowHash) {
            this.dowHash = {};
        }
        for (var i = 0; i < dowNumbers.length; i++) {
            this.dowHash[dowNumbers[i]] = true;
        }
    };
    RecurringEventDef.prototype.clone = function () {
        var def = _super.prototype.clone.call(this);
        if (def.startTime) {
            def.startTime = moment.duration(this.startTime);
        }
        if (def.endTime) {
            def.endTime = moment.duration(this.endTime);
        }
        if (this.dowHash) {
            def.dowHash = $.extend({}, this.dowHash);
        }
        return def;
    };
    return RecurringEventDef;
}(EventDef_1.default));
exports.default = RecurringEventDef;
/*
HACK to work with TypeScript mixins
NOTE: if super-method fails, should still attempt to apply
*/
RecurringEventDef.prototype.applyProps = function (rawProps) {
    var superSuccess = EventDef_1.default.prototype.applyProps.call(this, rawProps);
    if (rawProps.start) {
        this.startTime = moment.duration(rawProps.start);
    }
    if (rawProps.end) {
        this.endTime = moment.duration(rawProps.end);
    }
    if (rawProps.dow) {
        this.setDow(rawProps.dow);
    }
    return superSuccess;
};
// Parsing
// ---------------------------------------------------------------------------------------------------------------------
RecurringEventDef.defineStandardProps({
    start: false,
    end: false,
    dow: false
});


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var UnzonedRange_1 = __webpack_require__(5);
var DateProfileGenerator = /** @class */ (function () {
    function DateProfileGenerator(_view) {
        this._view = _view;
    }
    DateProfileGenerator.prototype.opt = function (name) {
        return this._view.opt(name);
    };
    DateProfileGenerator.prototype.trimHiddenDays = function (unzonedRange) {
        return this._view.trimHiddenDays(unzonedRange);
    };
    DateProfileGenerator.prototype.msToUtcMoment = function (ms, forceAllDay) {
        return this._view.calendar.msToUtcMoment(ms, forceAllDay);
    };
    /* Date Range Computation
    ------------------------------------------------------------------------------------------------------------------*/
    // Builds a structure with info about what the dates/ranges will be for the "prev" view.
    DateProfileGenerator.prototype.buildPrev = function (currentDateProfile) {
        var prevDate = currentDateProfile.date.clone()
            .startOf(currentDateProfile.currentRangeUnit)
            .subtract(currentDateProfile.dateIncrement);
        return this.build(prevDate, -1);
    };
    // Builds a structure with info about what the dates/ranges will be for the "next" view.
    DateProfileGenerator.prototype.buildNext = function (currentDateProfile) {
        var nextDate = currentDateProfile.date.clone()
            .startOf(currentDateProfile.currentRangeUnit)
            .add(currentDateProfile.dateIncrement);
        return this.build(nextDate, 1);
    };
    // Builds a structure holding dates/ranges for rendering around the given date.
    // Optional direction param indicates whether the date is being incremented/decremented
    // from its previous value. decremented = -1, incremented = 1 (default).
    DateProfileGenerator.prototype.build = function (date, direction, forceToValid) {
        if (forceToValid === void 0) { forceToValid = false; }
        var isDateAllDay = !date.hasTime();
        var validUnzonedRange;
        var minTime = null;
        var maxTime = null;
        var currentInfo;
        var isRangeAllDay;
        var renderUnzonedRange;
        var activeUnzonedRange;
        var isValid;
        validUnzonedRange = this.buildValidRange();
        validUnzonedRange = this.trimHiddenDays(validUnzonedRange);
        if (forceToValid) {
            date = this.msToUtcMoment(validUnzonedRange.constrainDate(date), // returns MS
            isDateAllDay);
        }
        currentInfo = this.buildCurrentRangeInfo(date, direction);
        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);
        renderUnzonedRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.unzonedRange), currentInfo.unit, isRangeAllDay);
        renderUnzonedRange = this.trimHiddenDays(renderUnzonedRange);
        activeUnzonedRange = renderUnzonedRange.clone();
        if (!this.opt('showNonCurrentDates')) {
            activeUnzonedRange = activeUnzonedRange.intersect(currentInfo.unzonedRange);
        }
        minTime = moment.duration(this.opt('minTime'));
        maxTime = moment.duration(this.opt('maxTime'));
        activeUnzonedRange = this.adjustActiveRange(activeUnzonedRange, minTime, maxTime);
        activeUnzonedRange = activeUnzonedRange.intersect(validUnzonedRange); // might return null
        if (activeUnzonedRange) {
            date = this.msToUtcMoment(activeUnzonedRange.constrainDate(date), // returns MS
            isDateAllDay);
        }
        // it's invalid if the originally requested date is not contained,
        // or if the range is completely outside of the valid range.
        isValid = currentInfo.unzonedRange.intersectsWith(validUnzonedRange);
        return {
            // constraint for where prev/next operations can go and where events can be dragged/resized to.
            // an object with optional start and end properties.
            validUnzonedRange: validUnzonedRange,
            // range the view is formally responsible for.
            // for example, a month view might have 1st-31st, excluding padded dates
            currentUnzonedRange: currentInfo.unzonedRange,
            // name of largest unit being displayed, like "month" or "week"
            currentRangeUnit: currentInfo.unit,
            isRangeAllDay: isRangeAllDay,
            // dates that display events and accept drag-n-drop
            // will be `null` if no dates accept events
            activeUnzonedRange: activeUnzonedRange,
            // date range with a rendered skeleton
            // includes not-active days that need some sort of DOM
            renderUnzonedRange: renderUnzonedRange,
            // Duration object that denotes the first visible time of any given day
            minTime: minTime,
            // Duration object that denotes the exclusive visible end time of any given day
            maxTime: maxTime,
            isValid: isValid,
            date: date,
            // how far the current date will move for a prev/next operation
            dateIncrement: this.buildDateIncrement(currentInfo.duration)
            // pass a fallback (might be null) ^
        };
    };
    // Builds an object with optional start/end properties.
    // Indicates the minimum/maximum dates to display.
    // not responsible for trimming hidden days.
    DateProfileGenerator.prototype.buildValidRange = function () {
        return this._view.getUnzonedRangeOption('validRange', this._view.calendar.getNow()) ||
            new UnzonedRange_1.default(); // completely open-ended
    };
    // Builds a structure with info about the "current" range, the range that is
    // highlighted as being the current month for example.
    // See build() for a description of `direction`.
    // Guaranteed to have `range` and `unit` properties. `duration` is optional.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildCurrentRangeInfo = function (date, direction) {
        var viewSpec = this._view.viewSpec;
        var duration = null;
        var unit = null;
        var unzonedRange = null;
        var dayCount;
        if (viewSpec.duration) {
            duration = viewSpec.duration;
            unit = viewSpec.durationUnit;
            unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);
        }
        else if ((dayCount = this.opt('dayCount'))) {
            unit = 'day';
            unzonedRange = this.buildRangeFromDayCount(date, direction, dayCount);
        }
        else if ((unzonedRange = this.buildCustomVisibleRange(date))) {
            unit = util_1.computeGreatestUnit(unzonedRange.getStart(), unzonedRange.getEnd());
        }
        else {
            duration = this.getFallbackDuration();
            unit = util_1.computeGreatestUnit(duration);
            unzonedRange = this.buildRangeFromDuration(date, direction, duration, unit);
        }
        return { duration: duration, unit: unit, unzonedRange: unzonedRange };
    };
    DateProfileGenerator.prototype.getFallbackDuration = function () {
        return moment.duration({ days: 1 });
    };
    // Returns a new activeUnzonedRange to have time values (un-ambiguate)
    // minTime or maxTime causes the range to expand.
    DateProfileGenerator.prototype.adjustActiveRange = function (unzonedRange, minTime, maxTime) {
        var start = unzonedRange.getStart();
        var end = unzonedRange.getEnd();
        if (this._view.usesMinMaxTime) {
            if (minTime < 0) {
                start.time(0).add(minTime);
            }
            if (maxTime > 24 * 60 * 60 * 1000) { // beyond 24 hours?
                end.time(maxTime - (24 * 60 * 60 * 1000));
            }
        }
        return new UnzonedRange_1.default(start, end);
    };
    // Builds the "current" range when it is specified as an explicit duration.
    // `unit` is the already-computed computeGreatestUnit value of duration.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildRangeFromDuration = function (date, direction, duration, unit) {
        var alignment = this.opt('dateAlignment');
        var dateIncrementInput;
        var dateIncrementDuration;
        var start;
        var end;
        var res;
        // compute what the alignment should be
        if (!alignment) {
            dateIncrementInput = this.opt('dateIncrement');
            if (dateIncrementInput) {
                dateIncrementDuration = moment.duration(dateIncrementInput);
                // use the smaller of the two units
                if (dateIncrementDuration < duration) {
                    alignment = util_1.computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);
                }
                else {
                    alignment = unit;
                }
            }
            else {
                alignment = unit;
            }
        }
        // if the view displays a single day or smaller
        if (duration.as('days') <= 1) {
            if (this._view.isHiddenDay(start)) {
                start = this._view.skipHiddenDays(start, direction);
                start.startOf('day');
            }
        }
        function computeRes() {
            start = date.clone().startOf(alignment);
            end = start.clone().add(duration);
            res = new UnzonedRange_1.default(start, end);
        }
        computeRes();
        // if range is completely enveloped by hidden days, go past the hidden days
        if (!this.trimHiddenDays(res)) {
            date = this._view.skipHiddenDays(date, direction);
            computeRes();
        }
        return res;
    };
    // Builds the "current" range when a dayCount is specified.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildRangeFromDayCount = function (date, direction, dayCount) {
        var customAlignment = this.opt('dateAlignment');
        var runningCount = 0;
        var start;
        var end;
        if (customAlignment || direction !== -1) {
            start = date.clone();
            if (customAlignment) {
                start.startOf(customAlignment);
            }
            start.startOf('day');
            start = this._view.skipHiddenDays(start);
            end = start.clone();
            do {
                end.add(1, 'day');
                if (!this._view.isHiddenDay(end)) {
                    runningCount++;
                }
            } while (runningCount < dayCount);
        }
        else {
            end = date.clone().startOf('day').add(1, 'day');
            end = this._view.skipHiddenDays(end, -1, true);
            start = end.clone();
            do {
                start.add(-1, 'day');
                if (!this._view.isHiddenDay(start)) {
                    runningCount++;
                }
            } while (runningCount < dayCount);
        }
        return new UnzonedRange_1.default(start, end);
    };
    // Builds a normalized range object for the "visible" range,
    // which is a way to define the currentUnzonedRange and activeUnzonedRange at the same time.
    // TODO: accept a MS-time instead of a moment `date`?
    DateProfileGenerator.prototype.buildCustomVisibleRange = function (date) {
        var visibleUnzonedRange = this._view.getUnzonedRangeOption('visibleRange', this._view.calendar.applyTimezone(date) // correct zone. also generates new obj that avoids mutations
        );
        if (visibleUnzonedRange && (visibleUnzonedRange.startMs == null || visibleUnzonedRange.endMs == null)) {
            return null;
        }
        return visibleUnzonedRange;
    };
    // Computes the range that will represent the element/cells for *rendering*,
    // but which may have voided days/times.
    // not responsible for trimming hidden days.
    DateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
        return currentUnzonedRange.clone();
    };
    // Compute the duration value that should be added/substracted to the current date
    // when a prev/next operation happens.
    DateProfileGenerator.prototype.buildDateIncrement = function (fallback) {
        var dateIncrementInput = this.opt('dateIncrement');
        var customAlignment;
        if (dateIncrementInput) {
            return moment.duration(dateIncrementInput);
        }
        else if ((customAlignment = this.opt('dateAlignment'))) {
            return moment.duration(1, customAlignment);
        }
        else if (fallback) {
            return fallback;
        }
        else {
            return moment.duration({ days: 1 });
        }
    };
    return DateProfileGenerator;
}());
exports.default = DateProfileGenerator;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var Promise_1 = __webpack_require__(21);
var EventSource_1 = __webpack_require__(6);
var SingleEventDef_1 = __webpack_require__(9);
var ArrayEventSource = /** @class */ (function (_super) {
    tslib_1.__extends(ArrayEventSource, _super);
    function ArrayEventSource(calendar) {
        var _this = _super.call(this, calendar) || this;
        _this.eventDefs = []; // for if setRawEventDefs is never called
        return _this;
    }
    ArrayEventSource.parse = function (rawInput, calendar) {
        var rawProps;
        // normalize raw input
        if ($.isArray(rawInput.events)) { // extended form
            rawProps = rawInput;
        }
        else if ($.isArray(rawInput)) { // short form
            rawProps = { events: rawInput };
        }
        if (rawProps) {
            return EventSource_1.default.parse.call(this, rawProps, calendar);
        }
        return false;
    };
    ArrayEventSource.prototype.setRawEventDefs = function (rawEventDefs) {
        this.rawEventDefs = rawEventDefs;
        this.eventDefs = this.parseEventDefs(rawEventDefs);
    };
    ArrayEventSource.prototype.fetch = function (start, end, timezone) {
        var eventDefs = this.eventDefs;
        var i;
        if (this.currentTimezone != null &&
            this.currentTimezone !== timezone) {
            for (i = 0; i < eventDefs.length; i++) {
                if (eventDefs[i] instanceof SingleEventDef_1.default) {
                    eventDefs[i].rezone();
                }
            }
        }
        this.currentTimezone = timezone;
        return Promise_1.default.resolve(eventDefs);
    };
    ArrayEventSource.prototype.addEventDef = function (eventDef) {
        this.eventDefs.push(eventDef);
    };
    /*
    eventDefId already normalized to a string
    */
    ArrayEventSource.prototype.removeEventDefsById = function (eventDefId) {
        return util_1.removeMatching(this.eventDefs, function (eventDef) {
            return eventDef.id === eventDefId;
        });
    };
    ArrayEventSource.prototype.removeAllEventDefs = function () {
        this.eventDefs = [];
    };
    ArrayEventSource.prototype.getPrimitive = function () {
        return this.rawEventDefs;
    };
    ArrayEventSource.prototype.applyManualStandardProps = function (rawProps) {
        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
        this.setRawEventDefs(rawProps.events);
        return superSuccess;
    };
    return ArrayEventSource;
}(EventSource_1.default));
exports.default = ArrayEventSource;
ArrayEventSource.defineStandardProps({
    events: false // don't automatically transfer
});


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var StandardTheme_1 = __webpack_require__(221);
var JqueryUiTheme_1 = __webpack_require__(222);
var themeClassHash = {};
function defineThemeSystem(themeName, themeClass) {
    themeClassHash[themeName] = themeClass;
}
exports.defineThemeSystem = defineThemeSystem;
function getThemeSystemClass(themeSetting) {
    if (!themeSetting) {
        return StandardTheme_1.default;
    }
    else if (themeSetting === true) {
        return JqueryUiTheme_1.default;
    }
    else {
        return themeClassHash[themeSetting];
    }
}
exports.getThemeSystemClass = getThemeSystemClass;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
/*
A cache for the left/right/top/bottom/width/height values for one or more elements.
Works with both offset (from topleft document) and position (from offsetParent).

options:
- els
- isHorizontal
- isVertical
*/
var CoordCache = /** @class */ (function () {
    function CoordCache(options) {
        this.isHorizontal = false; // whether to query for left/right/width
        this.isVertical = false; // whether to query for top/bottom/height
        this.els = $(options.els);
        this.isHorizontal = options.isHorizontal;
        this.isVertical = options.isVertical;
        this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;
    }
    // Queries the els for coordinates and stores them.
    // Call this method before using and of the get* methods below.
    CoordCache.prototype.build = function () {
        var offsetParentEl = this.forcedOffsetParentEl;
        if (!offsetParentEl && this.els.length > 0) {
            offsetParentEl = this.els.eq(0).offsetParent();
        }
        this.origin = offsetParentEl ?
            offsetParentEl.offset() :
            null;
        this.boundingRect = this.queryBoundingRect();
        if (this.isHorizontal) {
            this.buildElHorizontals();
        }
        if (this.isVertical) {
            this.buildElVerticals();
        }
    };
    // Destroys all internal data about coordinates, freeing memory
    CoordCache.prototype.clear = function () {
        this.origin = null;
        this.boundingRect = null;
        this.lefts = null;
        this.rights = null;
        this.tops = null;
        this.bottoms = null;
    };
    // When called, if coord caches aren't built, builds them
    CoordCache.prototype.ensureBuilt = function () {
        if (!this.origin) {
            this.build();
        }
    };
    // Populates the left/right internal coordinate arrays
    CoordCache.prototype.buildElHorizontals = function () {
        var lefts = [];
        var rights = [];
        this.els.each(function (i, node) {
            var el = $(node);
            var left = el.offset().left;
            var width = el.outerWidth();
            lefts.push(left);
            rights.push(left + width);
        });
        this.lefts = lefts;
        this.rights = rights;
    };
    // Populates the top/bottom internal coordinate arrays
    CoordCache.prototype.buildElVerticals = function () {
        var tops = [];
        var bottoms = [];
        this.els.each(function (i, node) {
            var el = $(node);
            var top = el.offset().top;
            var height = el.outerHeight();
            tops.push(top);
            bottoms.push(top + height);
        });
        this.tops = tops;
        this.bottoms = bottoms;
    };
    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.
    // If no intersection is made, returns undefined.
    CoordCache.prototype.getHorizontalIndex = function (leftOffset) {
        this.ensureBuilt();
        var lefts = this.lefts;
        var rights = this.rights;
        var len = lefts.length;
        var i;
        for (i = 0; i < len; i++) {
            if (leftOffset >= lefts[i] && leftOffset < rights[i]) {
                return i;
            }
        }
    };
    // Given a top offset (from document top), returns the index of the el that it vertically intersects.
    // If no intersection is made, returns undefined.
    CoordCache.prototype.getVerticalIndex = function (topOffset) {
        this.ensureBuilt();
        var tops = this.tops;
        var bottoms = this.bottoms;
        var len = tops.length;
        var i;
        for (i = 0; i < len; i++) {
            if (topOffset >= tops[i] && topOffset < bottoms[i]) {
                return i;
            }
        }
    };
    // Gets the left offset (from document left) of the element at the given index
    CoordCache.prototype.getLeftOffset = function (leftIndex) {
        this.ensureBuilt();
        return this.lefts[leftIndex];
    };
    // Gets the left position (from offsetParent left) of the element at the given index
    CoordCache.prototype.getLeftPosition = function (leftIndex) {
        this.ensureBuilt();
        return this.lefts[leftIndex] - this.origin.left;
    };
    // Gets the right offset (from document left) of the element at the given index.
    // This value is NOT relative to the document's right edge, like the CSS concept of "right" would be.
    CoordCache.prototype.getRightOffset = function (leftIndex) {
        this.ensureBuilt();
        return this.rights[leftIndex];
    };
    // Gets the right position (from offsetParent left) of the element at the given index.
    // This value is NOT relative to the offsetParent's right edge, like the CSS concept of "right" would be.
    CoordCache.prototype.getRightPosition = function (leftIndex) {
        this.ensureBuilt();
        return this.rights[leftIndex] - this.origin.left;
    };
    // Gets the width of the element at the given index
    CoordCache.prototype.getWidth = function (leftIndex) {
        this.ensureBuilt();
        return this.rights[leftIndex] - this.lefts[leftIndex];
    };
    // Gets the top offset (from document top) of the element at the given index
    CoordCache.prototype.getTopOffset = function (topIndex) {
        this.ensureBuilt();
        return this.tops[topIndex];
    };
    // Gets the top position (from offsetParent top) of the element at the given position
    CoordCache.prototype.getTopPosition = function (topIndex) {
        this.ensureBuilt();
        return this.tops[topIndex] - this.origin.top;
    };
    // Gets the bottom offset (from the document top) of the element at the given index.
    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
    CoordCache.prototype.getBottomOffset = function (topIndex) {
        this.ensureBuilt();
        return this.bottoms[topIndex];
    };
    // Gets the bottom position (from the offsetParent top) of the element at the given index.
    // This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
    CoordCache.prototype.getBottomPosition = function (topIndex) {
        this.ensureBuilt();
        return this.bottoms[topIndex] - this.origin.top;
    };
    // Gets the height of the element at the given index
    CoordCache.prototype.getHeight = function (topIndex) {
        this.ensureBuilt();
        return this.bottoms[topIndex] - this.tops[topIndex];
    };
    // Bounding Rect
    // TODO: decouple this from CoordCache
    // Compute and return what the elements' bounding rectangle is, from the user's perspective.
    // Right now, only returns a rectangle if constrained by an overflow:scroll element.
    // Returns null if there are no elements
    CoordCache.prototype.queryBoundingRect = function () {
        var scrollParentEl;
        if (this.els.length > 0) {
            scrollParentEl = util_1.getScrollParent(this.els.eq(0));
            if (!scrollParentEl.is(document) &&
                !scrollParentEl.is('html,body') // don't consider these bounding rects. solves issue 3615
            ) {
                return util_1.getClientRect(scrollParentEl);
            }
        }
        return null;
    };
    CoordCache.prototype.isPointInBounds = function (leftOffset, topOffset) {
        return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);
    };
    CoordCache.prototype.isLeftInBounds = function (leftOffset) {
        return !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);
    };
    CoordCache.prototype.isTopInBounds = function (topOffset) {
        return !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);
    };
    return CoordCache;
}());
exports.default = CoordCache;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var ListenerMixin_1 = __webpack_require__(7);
var GlobalEmitter_1 = __webpack_require__(23);
/* Tracks a drag's mouse movement, firing various handlers
----------------------------------------------------------------------------------------------------------------------*/
// TODO: use Emitter
var DragListener = /** @class */ (function () {
    function DragListener(options) {
        this.isInteracting = false;
        this.isDistanceSurpassed = false;
        this.isDelayEnded = false;
        this.isDragging = false;
        this.isTouch = false;
        this.isGeneric = false; // initiated by 'dragstart' (jqui)
        this.shouldCancelTouchScroll = true;
        this.scrollAlwaysKills = false;
        this.isAutoScroll = false;
        // defaults
        this.scrollSensitivity = 30; // pixels from edge for scrolling to start
        this.scrollSpeed = 200; // pixels per second, at maximum speed
        this.scrollIntervalMs = 50; // millisecond wait between scroll increment
        this.options = options || {};
    }
    // Interaction (high-level)
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.startInteraction = function (ev, extraOptions) {
        if (extraOptions === void 0) { extraOptions = {}; }
        if (ev.type === 'mousedown') {
            if (GlobalEmitter_1.default.get().shouldIgnoreMouse()) {
                return;
            }
            else if (!util_1.isPrimaryMouseButton(ev)) {
                return;
            }
            else {
                ev.preventDefault(); // prevents native selection in most browsers
            }
        }
        if (!this.isInteracting) {
            // process options
            this.delay = util_1.firstDefined(extraOptions.delay, this.options.delay, 0);
            this.minDistance = util_1.firstDefined(extraOptions.distance, this.options.distance, 0);
            this.subjectEl = this.options.subjectEl;
            util_1.preventSelection($('body'));
            this.isInteracting = true;
            this.isTouch = util_1.getEvIsTouch(ev);
            this.isGeneric = ev.type === 'dragstart';
            this.isDelayEnded = false;
            this.isDistanceSurpassed = false;
            this.originX = util_1.getEvX(ev);
            this.originY = util_1.getEvY(ev);
            this.scrollEl = util_1.getScrollParent($(ev.target));
            this.bindHandlers();
            this.initAutoScroll();
            this.handleInteractionStart(ev);
            this.startDelay(ev);
            if (!this.minDistance) {
                this.handleDistanceSurpassed(ev);
            }
        }
    };
    DragListener.prototype.handleInteractionStart = function (ev) {
        this.trigger('interactionStart', ev);
    };
    DragListener.prototype.endInteraction = function (ev, isCancelled) {
        if (this.isInteracting) {
            this.endDrag(ev);
            if (this.delayTimeoutId) {
                clearTimeout(this.delayTimeoutId);
                this.delayTimeoutId = null;
            }
            this.destroyAutoScroll();
            this.unbindHandlers();
            this.isInteracting = false;
            this.handleInteractionEnd(ev, isCancelled);
            util_1.allowSelection($('body'));
        }
    };
    DragListener.prototype.handleInteractionEnd = function (ev, isCancelled) {
        this.trigger('interactionEnd', ev, isCancelled || false);
    };
    // Binding To DOM
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.bindHandlers = function () {
        // some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,
        // so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.
        var globalEmitter = GlobalEmitter_1.default.get();
        if (this.isGeneric) {
            this.listenTo($(document), {
                drag: this.handleMove,
                dragstop: this.endInteraction
            });
        }
        else if (this.isTouch) {
            this.listenTo(globalEmitter, {
                touchmove: this.handleTouchMove,
                touchend: this.endInteraction,
                scroll: this.handleTouchScroll
            });
        }
        else {
            this.listenTo(globalEmitter, {
                mousemove: this.handleMouseMove,
                mouseup: this.endInteraction
            });
        }
        this.listenTo(globalEmitter, {
            selectstart: util_1.preventDefault,
            contextmenu: util_1.preventDefault // long taps would open menu on Chrome dev tools
        });
    };
    DragListener.prototype.unbindHandlers = function () {
        this.stopListeningTo(GlobalEmitter_1.default.get());
        this.stopListeningTo($(document)); // for isGeneric
    };
    // Drag (high-level)
    // -----------------------------------------------------------------------------------------------------------------
    // extraOptions ignored if drag already started
    DragListener.prototype.startDrag = function (ev, extraOptions) {
        this.startInteraction(ev, extraOptions); // ensure interaction began
        if (!this.isDragging) {
            this.isDragging = true;
            this.handleDragStart(ev);
        }
    };
    DragListener.prototype.handleDragStart = function (ev) {
        this.trigger('dragStart', ev);
    };
    DragListener.prototype.handleMove = function (ev) {
        var dx = util_1.getEvX(ev) - this.originX;
        var dy = util_1.getEvY(ev) - this.originY;
        var minDistance = this.minDistance;
        var distanceSq; // current distance from the origin, squared
        if (!this.isDistanceSurpassed) {
            distanceSq = dx * dx + dy * dy;
            if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem
                this.handleDistanceSurpassed(ev);
            }
        }
        if (this.isDragging) {
            this.handleDrag(dx, dy, ev);
        }
    };
    // Called while the mouse is being moved and when we know a legitimate drag is taking place
    DragListener.prototype.handleDrag = function (dx, dy, ev) {
        this.trigger('drag', dx, dy, ev);
        this.updateAutoScroll(ev); // will possibly cause scrolling
    };
    DragListener.prototype.endDrag = function (ev) {
        if (this.isDragging) {
            this.isDragging = false;
            this.handleDragEnd(ev);
        }
    };
    DragListener.prototype.handleDragEnd = function (ev) {
        this.trigger('dragEnd', ev);
    };
    // Delay
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.startDelay = function (initialEv) {
        var _this = this;
        if (this.delay) {
            this.delayTimeoutId = setTimeout(function () {
                _this.handleDelayEnd(initialEv);
            }, this.delay);
        }
        else {
            this.handleDelayEnd(initialEv);
        }
    };
    DragListener.prototype.handleDelayEnd = function (initialEv) {
        this.isDelayEnded = true;
        if (this.isDistanceSurpassed) {
            this.startDrag(initialEv);
        }
    };
    // Distance
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.handleDistanceSurpassed = function (ev) {
        this.isDistanceSurpassed = true;
        if (this.isDelayEnded) {
            this.startDrag(ev);
        }
    };
    // Mouse / Touch
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.handleTouchMove = function (ev) {
        // prevent inertia and touchmove-scrolling while dragging
        if (this.isDragging && this.shouldCancelTouchScroll) {
            ev.preventDefault();
        }
        this.handleMove(ev);
    };
    DragListener.prototype.handleMouseMove = function (ev) {
        this.handleMove(ev);
    };
    // Scrolling (unrelated to auto-scroll)
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.handleTouchScroll = function (ev) {
        // if the drag is being initiated by touch, but a scroll happens before
        // the drag-initiating delay is over, cancel the drag
        if (!this.isDragging || this.scrollAlwaysKills) {
            this.endInteraction(ev, true); // isCancelled=true
        }
    };
    // Utils
    // -----------------------------------------------------------------------------------------------------------------
    // Triggers a callback. Calls a function in the option hash of the same name.
    // Arguments beyond the first `name` are forwarded on.
    DragListener.prototype.trigger = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (this.options[name]) {
            this.options[name].apply(this, args);
        }
        // makes _methods callable by event name. TODO: kill this
        if (this['_' + name]) {
            this['_' + name].apply(this, args);
        }
    };
    // Auto-scroll
    // -----------------------------------------------------------------------------------------------------------------
    DragListener.prototype.initAutoScroll = function () {
        var scrollEl = this.scrollEl;
        this.isAutoScroll =
            this.options.scroll &&
                scrollEl &&
                !scrollEl.is(window) &&
                !scrollEl.is(document);
        if (this.isAutoScroll) {
            // debounce makes sure rapid calls don't happen
            this.listenTo(scrollEl, 'scroll', util_1.debounce(this.handleDebouncedScroll, 100));
        }
    };
    DragListener.prototype.destroyAutoScroll = function () {
        this.endAutoScroll(); // kill any animation loop
        // remove the scroll handler if there is a scrollEl
        if (this.isAutoScroll) {
            this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(
        }
    };
    // Computes and stores the bounding rectangle of scrollEl
    DragListener.prototype.computeScrollBounds = function () {
        if (this.isAutoScroll) {
            this.scrollBounds = util_1.getOuterRect(this.scrollEl);
            // TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
        }
    };
    // Called when the dragging is in progress and scrolling should be updated
    DragListener.prototype.updateAutoScroll = function (ev) {
        var sensitivity = this.scrollSensitivity;
        var bounds = this.scrollBounds;
        var topCloseness;
        var bottomCloseness;
        var leftCloseness;
        var rightCloseness;
        var topVel = 0;
        var leftVel = 0;
        if (bounds) { // only scroll if scrollEl exists
            // compute closeness to edges. valid range is from 0.0 - 1.0
            topCloseness = (sensitivity - (util_1.getEvY(ev) - bounds.top)) / sensitivity;
            bottomCloseness = (sensitivity - (bounds.bottom - util_1.getEvY(ev))) / sensitivity;
            leftCloseness = (sensitivity - (util_1.getEvX(ev) - bounds.left)) / sensitivity;
            rightCloseness = (sensitivity - (bounds.right - util_1.getEvX(ev))) / sensitivity;
            // translate vertical closeness into velocity.
            // mouse must be completely in bounds for velocity to happen.
            if (topCloseness >= 0 && topCloseness <= 1) {
                topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up
            }
            else if (bottomCloseness >= 0 && bottomCloseness <= 1) {
                topVel = bottomCloseness * this.scrollSpeed;
            }
            // translate horizontal closeness into velocity
            if (leftCloseness >= 0 && leftCloseness <= 1) {
                leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left
            }
            else if (rightCloseness >= 0 && rightCloseness <= 1) {
                leftVel = rightCloseness * this.scrollSpeed;
            }
        }
        this.setScrollVel(topVel, leftVel);
    };
    // Sets the speed-of-scrolling for the scrollEl
    DragListener.prototype.setScrollVel = function (topVel, leftVel) {
        this.scrollTopVel = topVel;
        this.scrollLeftVel = leftVel;
        this.constrainScrollVel(); // massages into realistic values
        // if there is non-zero velocity, and an animation loop hasn't already started, then START
        if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {
            this.scrollIntervalId = setInterval(util_1.proxy(this, 'scrollIntervalFunc'), // scope to `this`
            this.scrollIntervalMs);
        }
    };
    // Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
    DragListener.prototype.constrainScrollVel = function () {
        var el = this.scrollEl;
        if (this.scrollTopVel < 0) { // scrolling up?
            if (el.scrollTop() <= 0) { // already scrolled all the way up?
                this.scrollTopVel = 0;
            }
        }
        else if (this.scrollTopVel > 0) { // scrolling down?
            if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) { // already scrolled all the way down?
                this.scrollTopVel = 0;
            }
        }
        if (this.scrollLeftVel < 0) { // scrolling left?
            if (el.scrollLeft() <= 0) { // already scrolled all the left?
                this.scrollLeftVel = 0;
            }
        }
        else if (this.scrollLeftVel > 0) { // scrolling right?
            if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) { // already scrolled all the way right?
                this.scrollLeftVel = 0;
            }
        }
    };
    // This function gets called during every iteration of the scrolling animation loop
    DragListener.prototype.scrollIntervalFunc = function () {
        var el = this.scrollEl;
        var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by
        // change the value of scrollEl's scroll
        if (this.scrollTopVel) {
            el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
        }
        if (this.scrollLeftVel) {
            el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
        }
        this.constrainScrollVel(); // since the scroll values changed, recompute the velocities
        // if scrolled all the way, which causes the vels to be zero, stop the animation loop
        if (!this.scrollTopVel && !this.scrollLeftVel) {
            this.endAutoScroll();
        }
    };
    // Kills any existing scrolling animation loop
    DragListener.prototype.endAutoScroll = function () {
        if (this.scrollIntervalId) {
            clearInterval(this.scrollIntervalId);
            this.scrollIntervalId = null;
            this.handleScrollEnd();
        }
    };
    // Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
    DragListener.prototype.handleDebouncedScroll = function () {
        // recompute all coordinates, but *only* if this is *not* part of our scrolling animation
        if (!this.scrollIntervalId) {
            this.handleScrollEnd();
        }
    };
    DragListener.prototype.handleScrollEnd = function () {
        // Called when scrolling has stopped, whether through auto scroll, or the user scrolling
    };
    return DragListener;
}());
exports.default = DragListener;
ListenerMixin_1.default.mixInto(DragListener);


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var Mixin_1 = __webpack_require__(15);
/*
A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.
Prerequisite: the object being mixed into needs to be a *Grid*
*/
var DayTableMixin = /** @class */ (function (_super) {
    tslib_1.__extends(DayTableMixin, _super);
    function DayTableMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Populates internal variables used for date calculation and rendering
    DayTableMixin.prototype.updateDayTable = function () {
        var t = this;
        var view = t.view;
        var calendar = view.calendar;
        var date = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.startMs, true);
        var end = calendar.msToUtcMoment(t.dateProfile.renderUnzonedRange.endMs, true);
        var dayIndex = -1;
        var dayIndices = [];
        var dayDates = [];
        var daysPerRow;
        var firstDay;
        var rowCnt;
        while (date.isBefore(end)) { // loop each day from start to end
            if (view.isHiddenDay(date)) {
                dayIndices.push(dayIndex + 0.5); // mark that it's between indices
            }
            else {
                dayIndex++;
                dayIndices.push(dayIndex);
                dayDates.push(date.clone());
            }
            date.add(1, 'days');
        }
        if (this.breakOnWeeks) {
            // count columns until the day-of-week repeats
            firstDay = dayDates[0].day();
            for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {
                if (dayDates[daysPerRow].day() === firstDay) {
                    break;
                }
            }
            rowCnt = Math.ceil(dayDates.length / daysPerRow);
        }
        else {
            rowCnt = 1;
            daysPerRow = dayDates.length;
        }
        this.dayDates = dayDates;
        this.dayIndices = dayIndices;
        this.daysPerRow = daysPerRow;
        this.rowCnt = rowCnt;
        this.updateDayTableCols();
    };
    // Computes and assigned the colCnt property and updates any options that may be computed from it
    DayTableMixin.prototype.updateDayTableCols = function () {
        this.colCnt = this.computeColCnt();
        this.colHeadFormat =
            this.opt('columnHeaderFormat') ||
                this.opt('columnFormat') || // deprecated
                this.computeColHeadFormat();
    };
    // Determines how many columns there should be in the table
    DayTableMixin.prototype.computeColCnt = function () {
        return this.daysPerRow;
    };
    // Computes the ambiguously-timed moment for the given cell
    DayTableMixin.prototype.getCellDate = function (row, col) {
        return this.dayDates[this.getCellDayIndex(row, col)].clone();
    };
    // Computes the ambiguously-timed date range for the given cell
    DayTableMixin.prototype.getCellRange = function (row, col) {
        var start = this.getCellDate(row, col);
        var end = start.clone().add(1, 'days');
        return { start: start, end: end };
    };
    // Returns the number of day cells, chronologically, from the first of the grid (0-based)
    DayTableMixin.prototype.getCellDayIndex = function (row, col) {
        return row * this.daysPerRow + this.getColDayIndex(col);
    };
    // Returns the numner of day cells, chronologically, from the first cell in *any given row*
    DayTableMixin.prototype.getColDayIndex = function (col) {
        if (this.isRTL) {
            return this.colCnt - 1 - col;
        }
        else {
            return col;
        }
    };
    // Given a date, returns its chronolocial cell-index from the first cell of the grid.
    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
    // If before the first offset, returns a negative number.
    // If after the last offset, returns an offset past the last cell offset.
    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
    DayTableMixin.prototype.getDateDayIndex = function (date) {
        var dayIndices = this.dayIndices;
        var dayOffset = date.diff(this.dayDates[0], 'days');
        if (dayOffset < 0) {
            return dayIndices[0] - 1;
        }
        else if (dayOffset >= dayIndices.length) {
            return dayIndices[dayIndices.length - 1] + 1;
        }
        else {
            return dayIndices[dayOffset];
        }
    };
    /* Options
    ------------------------------------------------------------------------------------------------------------------*/
    // Computes a default column header formatting string if `colFormat` is not explicitly defined
    DayTableMixin.prototype.computeColHeadFormat = function () {
        // if more than one week row, or if there are a lot of columns with not much space,
        // put just the day numbers will be in each cell
        if (this.rowCnt > 1 || this.colCnt > 10) {
            return 'ddd'; // "Sat"
        }
        else if (this.colCnt > 1) {
            return this.opt('dayOfMonthFormat'); // "Sat 12/10"
        }
        else {
            return 'dddd'; // "Saturday"
        }
    };
    /* Slicing
    ------------------------------------------------------------------------------------------------------------------*/
    // Slices up a date range into a segment for every week-row it intersects with
    DayTableMixin.prototype.sliceRangeByRow = function (unzonedRange) {
        var daysPerRow = this.daysPerRow;
        var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold
        var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
        var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
        var segs = [];
        var row;
        var rowFirst;
        var rowLast; // inclusive day-index range for current row
        var segFirst;
        var segLast; // inclusive day-index range for segment
        for (row = 0; row < this.rowCnt; row++) {
            rowFirst = row * daysPerRow;
            rowLast = rowFirst + daysPerRow - 1;
            // intersect segment's offset range with the row's
            segFirst = Math.max(rangeFirst, rowFirst);
            segLast = Math.min(rangeLast, rowLast);
            // deal with in-between indices
            segFirst = Math.ceil(segFirst); // in-between starts round to next cell
            segLast = Math.floor(segLast); // in-between ends round to prev cell
            if (segFirst <= segLast) { // was there any intersection with the current row?
                segs.push({
                    row: row,
                    // normalize to start of row
                    firstRowDayIndex: segFirst - rowFirst,
                    lastRowDayIndex: segLast - rowFirst,
                    // must be matching integers to be the segment's start/end
                    isStart: segFirst === rangeFirst,
                    isEnd: segLast === rangeLast
                });
            }
        }
        return segs;
    };
    // Slices up a date range into a segment for every day-cell it intersects with.
    // TODO: make more DRY with sliceRangeByRow somehow.
    DayTableMixin.prototype.sliceRangeByDay = function (unzonedRange) {
        var daysPerRow = this.daysPerRow;
        var normalRange = this.view.computeDayRange(unzonedRange); // make whole-day range, considering nextDayThreshold
        var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
        var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
        var segs = [];
        var row;
        var rowFirst;
        var rowLast; // inclusive day-index range for current row
        var i;
        var segFirst;
        var segLast; // inclusive day-index range for segment
        for (row = 0; row < this.rowCnt; row++) {
            rowFirst = row * daysPerRow;
            rowLast = rowFirst + daysPerRow - 1;
            for (i = rowFirst; i <= rowLast; i++) {
                // intersect segment's offset range with the row's
                segFirst = Math.max(rangeFirst, i);
                segLast = Math.min(rangeLast, i);
                // deal with in-between indices
                segFirst = Math.ceil(segFirst); // in-between starts round to next cell
                segLast = Math.floor(segLast); // in-between ends round to prev cell
                if (segFirst <= segLast) { // was there any intersection with the current row?
                    segs.push({
                        row: row,
                        // normalize to start of row
                        firstRowDayIndex: segFirst - rowFirst,
                        lastRowDayIndex: segLast - rowFirst,
                        // must be matching integers to be the segment's start/end
                        isStart: segFirst === rangeFirst,
                        isEnd: segLast === rangeLast
                    });
                }
            }
        }
        return segs;
    };
    /* Header Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayTableMixin.prototype.renderHeadHtml = function () {
        var theme = this.view.calendar.theme;
        return '' +
            '<div class="fc-row ' + theme.getClass('headerRow') + '">' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            '<thead>' +
            this.renderHeadTrHtml() +
            '</thead>' +
            '</table>' +
            '</div>';
    };
    DayTableMixin.prototype.renderHeadIntroHtml = function () {
        return this.renderIntroHtml(); // fall back to generic
    };
    DayTableMixin.prototype.renderHeadTrHtml = function () {
        return '' +
            '<tr>' +
            (this.isRTL ? '' : this.renderHeadIntroHtml()) +
            this.renderHeadDateCellsHtml() +
            (this.isRTL ? this.renderHeadIntroHtml() : '') +
            '</tr>';
    };
    DayTableMixin.prototype.renderHeadDateCellsHtml = function () {
        var htmls = [];
        var col;
        var date;
        for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(0, col);
            htmls.push(this.renderHeadDateCellHtml(date));
        }
        return htmls.join('');
    };
    // TODO: when internalApiVersion, accept an object for HTML attributes
    // (colspan should be no different)
    DayTableMixin.prototype.renderHeadDateCellHtml = function (date, colspan, otherAttrs) {
        var t = this;
        var view = t.view;
        var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
        var classNames = [
            'fc-day-header',
            view.calendar.theme.getClass('widgetHeader')
        ];
        var innerHtml;
        if (typeof t.opt('columnHeaderHtml') === 'function') {
            innerHtml = t.opt('columnHeaderHtml')(date);
        }
        else if (typeof t.opt('columnHeaderText') === 'function') {
            innerHtml = util_1.htmlEscape(t.opt('columnHeaderText')(date));
        }
        else {
            innerHtml = util_1.htmlEscape(date.format(t.colHeadFormat));
        }
        // if only one row of days, the classNames on the header can represent the specific days beneath
        if (t.rowCnt === 1) {
            classNames = classNames.concat(
            // includes the day-of-week class
            // noThemeHighlight=true (don't highlight the header)
            t.getDayClasses(date, true));
        }
        else {
            classNames.push('fc-' + util_1.dayIDs[date.day()]); // only add the day-of-week class
        }
        return '' +
            '<th class="' + classNames.join(' ') + '"' +
            ((isDateValid && t.rowCnt) === 1 ?
                ' data-date="' + date.format('YYYY-MM-DD') + '"' :
                '') +
            (colspan > 1 ?
                ' colspan="' + colspan + '"' :
                '') +
            (otherAttrs ?
                ' ' + otherAttrs :
                '') +
            '>' +
            (isDateValid ?
                // don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)
                view.buildGotoAnchorHtml({ date: date, forceOff: t.rowCnt > 1 || t.colCnt === 1 }, innerHtml) :
                // if not valid, display text, but no link
                innerHtml) +
            '</th>';
    };
    /* Background Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayTableMixin.prototype.renderBgTrHtml = function (row) {
        return '' +
            '<tr>' +
            (this.isRTL ? '' : this.renderBgIntroHtml(row)) +
            this.renderBgCellsHtml(row) +
            (this.isRTL ? this.renderBgIntroHtml(row) : '') +
            '</tr>';
    };
    DayTableMixin.prototype.renderBgIntroHtml = function (row) {
        return this.renderIntroHtml(); // fall back to generic
    };
    DayTableMixin.prototype.renderBgCellsHtml = function (row) {
        var htmls = [];
        var col;
        var date;
        for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(row, col);
            htmls.push(this.renderBgCellHtml(date));
        }
        return htmls.join('');
    };
    DayTableMixin.prototype.renderBgCellHtml = function (date, otherAttrs) {
        var t = this;
        var view = t.view;
        var isDateValid = t.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
        var classes = t.getDayClasses(date);
        classes.unshift('fc-day', view.calendar.theme.getClass('widgetContent'));
        return '<td class="' + classes.join(' ') + '"' +
            (isDateValid ?
                ' data-date="' + date.format('YYYY-MM-DD') + '"' : // if date has a time, won't format it
                '') +
            (otherAttrs ?
                ' ' + otherAttrs :
                '') +
            '></td>';
    };
    /* Generic
    ------------------------------------------------------------------------------------------------------------------*/
    DayTableMixin.prototype.renderIntroHtml = function () {
        // Generates the default HTML intro for any row. User classes should override
    };
    // TODO: a generic method for dealing with <tr>, RTL, intro
    // when increment internalApiVersion
    // wrapTr (scheduler)
    /* Utils
    ------------------------------------------------------------------------------------------------------------------*/
    // Applies the generic "intro" and "outro" HTML to the given cells.
    // Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
    DayTableMixin.prototype.bookendCells = function (trEl) {
        var introHtml = this.renderIntroHtml();
        if (introHtml) {
            if (this.isRTL) {
                trEl.append(introHtml);
            }
            else {
                trEl.prepend(introHtml);
            }
        }
    };
    return DayTableMixin;
}(Mixin_1.default));
exports.default = DayTableMixin;


/***/ }),
/* 61 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var BusinessHourRenderer = /** @class */ (function () {
    /*
    component implements:
      - eventRangesToEventFootprints
      - eventFootprintsToSegs
    */
    function BusinessHourRenderer(component, fillRenderer) {
        this.component = component;
        this.fillRenderer = fillRenderer;
    }
    BusinessHourRenderer.prototype.render = function (businessHourGenerator) {
        var component = this.component;
        var unzonedRange = component._getDateProfile().activeUnzonedRange;
        var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(component.hasAllDayBusinessHours, unzonedRange);
        var eventFootprints = eventInstanceGroup ?
            component.eventRangesToEventFootprints(eventInstanceGroup.sliceRenderRanges(unzonedRange)) :
            [];
        this.renderEventFootprints(eventFootprints);
    };
    BusinessHourRenderer.prototype.renderEventFootprints = function (eventFootprints) {
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        this.renderSegs(segs);
        this.segs = segs;
    };
    BusinessHourRenderer.prototype.renderSegs = function (segs) {
        if (this.fillRenderer) {
            this.fillRenderer.renderSegs('businessHours', segs, {
                getClasses: function (seg) {
                    return ['fc-nonbusiness', 'fc-bgevent'];
                }
            });
        }
    };
    BusinessHourRenderer.prototype.unrender = function () {
        if (this.fillRenderer) {
            this.fillRenderer.unrender('businessHours');
        }
        this.segs = null;
    };
    BusinessHourRenderer.prototype.getSegs = function () {
        return this.segs || [];
    };
    return BusinessHourRenderer;
}());
exports.default = BusinessHourRenderer;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var FillRenderer = /** @class */ (function () {
    function FillRenderer(component) {
        this.fillSegTag = 'div';
        this.component = component;
        this.elsByFill = {};
    }
    FillRenderer.prototype.renderFootprint = function (type, componentFootprint, props) {
        this.renderSegs(type, this.component.componentFootprintToSegs(componentFootprint), props);
    };
    FillRenderer.prototype.renderSegs = function (type, segs, props) {
        var els;
        segs = this.buildSegEls(type, segs, props); // assignes `.el` to each seg. returns successfully rendered segs
        els = this.attachSegEls(type, segs);
        if (els) {
            this.reportEls(type, els);
        }
        return segs;
    };
    // Unrenders a specific type of fill that is currently rendered on the grid
    FillRenderer.prototype.unrender = function (type) {
        var el = this.elsByFill[type];
        if (el) {
            el.remove();
            delete this.elsByFill[type];
        }
    };
    // Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
    // Only returns segments that successfully rendered.
    FillRenderer.prototype.buildSegEls = function (type, segs, props) {
        var _this = this;
        var html = '';
        var renderedSegs = [];
        var i;
        if (segs.length) {
            // build a large concatenation of segment HTML
            for (i = 0; i < segs.length; i++) {
                html += this.buildSegHtml(type, segs[i], props);
            }
            // Grab individual elements from the combined HTML string. Use each as the default rendering.
            // Then, compute the 'el' for each segment.
            $(html).each(function (i, node) {
                var seg = segs[i];
                var el = $(node);
                // allow custom filter methods per-type
                if (props.filterEl) {
                    el = props.filterEl(seg, el);
                }
                if (el) { // custom filters did not cancel the render
                    el = $(el); // allow custom filter to return raw DOM node
                    // correct element type? (would be bad if a non-TD were inserted into a table for example)
                    if (el.is(_this.fillSegTag)) {
                        seg.el = el;
                        renderedSegs.push(seg);
                    }
                }
            });
        }
        return renderedSegs;
    };
    // Builds the HTML needed for one fill segment. Generic enough to work with different types.
    FillRenderer.prototype.buildSegHtml = function (type, seg, props) {
        // custom hooks per-type
        var classes = props.getClasses ? props.getClasses(seg) : [];
        var css = util_1.cssToStr(props.getCss ? props.getCss(seg) : {});
        return '<' + this.fillSegTag +
            (classes.length ? ' class="' + classes.join(' ') + '"' : '') +
            (css ? ' style="' + css + '"' : '') +
            '></' + this.fillSegTag + '>';
    };
    // Should return wrapping DOM structure
    FillRenderer.prototype.attachSegEls = function (type, segs) {
        // subclasses must implement
    };
    FillRenderer.prototype.reportEls = function (type, nodes) {
        if (this.elsByFill[type]) {
            this.elsByFill[type] = this.elsByFill[type].add(nodes);
        }
        else {
            this.elsByFill[type] = $(nodes);
        }
    };
    return FillRenderer;
}());
exports.default = FillRenderer;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var SingleEventDef_1 = __webpack_require__(9);
var EventFootprint_1 = __webpack_require__(34);
var EventSource_1 = __webpack_require__(6);
var HelperRenderer = /** @class */ (function () {
    function HelperRenderer(component, eventRenderer) {
        this.view = component._getView();
        this.component = component;
        this.eventRenderer = eventRenderer;
    }
    HelperRenderer.prototype.renderComponentFootprint = function (componentFootprint) {
        this.renderEventFootprints([
            this.fabricateEventFootprint(componentFootprint)
        ]);
    };
    HelperRenderer.prototype.renderEventDraggingFootprints = function (eventFootprints, sourceSeg, isTouch) {
        this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-dragging', isTouch ? null : this.view.opt('dragOpacity'));
    };
    HelperRenderer.prototype.renderEventResizingFootprints = function (eventFootprints, sourceSeg, isTouch) {
        this.renderEventFootprints(eventFootprints, sourceSeg, 'fc-resizing');
    };
    HelperRenderer.prototype.renderEventFootprints = function (eventFootprints, sourceSeg, extraClassNames, opacity) {
        var segs = this.component.eventFootprintsToSegs(eventFootprints);
        var classNames = 'fc-helper ' + (extraClassNames || '');
        var i;
        // assigns each seg's el and returns a subset of segs that were rendered
        segs = this.eventRenderer.renderFgSegEls(segs);
        for (i = 0; i < segs.length; i++) {
            segs[i].el.addClass(classNames);
        }
        if (opacity != null) {
            for (i = 0; i < segs.length; i++) {
                segs[i].el.css('opacity', opacity);
            }
        }
        this.helperEls = this.renderSegs(segs, sourceSeg);
    };
    /*
    Must return all mock event elements
    */
    HelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
        // Subclasses must implement
    };
    HelperRenderer.prototype.unrender = function () {
        if (this.helperEls) {
            this.helperEls.remove();
            this.helperEls = null;
        }
    };
    HelperRenderer.prototype.fabricateEventFootprint = function (componentFootprint) {
        var calendar = this.view.calendar;
        var eventDateProfile = calendar.footprintToDateProfile(componentFootprint);
        var dummyEvent = new SingleEventDef_1.default(new EventSource_1.default(calendar));
        var dummyInstance;
        dummyEvent.dateProfile = eventDateProfile;
        dummyInstance = dummyEvent.buildInstance();
        return new EventFootprint_1.default(componentFootprint, dummyEvent, dummyInstance);
    };
    return HelperRenderer;
}());
exports.default = HelperRenderer;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var GlobalEmitter_1 = __webpack_require__(23);
var Interaction_1 = __webpack_require__(14);
var EventPointing = /** @class */ (function (_super) {
    tslib_1.__extends(EventPointing, _super);
    function EventPointing() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /*
    component must implement:
      - publiclyTrigger
    */
    EventPointing.prototype.bindToEl = function (el) {
        var component = this.component;
        component.bindSegHandlerToEl(el, 'click', this.handleClick.bind(this));
        component.bindSegHandlerToEl(el, 'mouseenter', this.handleMouseover.bind(this));
        component.bindSegHandlerToEl(el, 'mouseleave', this.handleMouseout.bind(this));
    };
    EventPointing.prototype.handleClick = function (seg, ev) {
        var res = this.component.publiclyTrigger('eventClick', {
            context: seg.el[0],
            args: [seg.footprint.getEventLegacy(), ev, this.view]
        });
        if (res === false) {
            ev.preventDefault();
        }
    };
    // Updates internal state and triggers handlers for when an event element is moused over
    EventPointing.prototype.handleMouseover = function (seg, ev) {
        if (!GlobalEmitter_1.default.get().shouldIgnoreMouse() &&
            !this.mousedOverSeg) {
            this.mousedOverSeg = seg;
            // TODO: move to EventSelecting's responsibility
            if (this.view.isEventDefResizable(seg.footprint.eventDef)) {
                seg.el.addClass('fc-allow-mouse-resize');
            }
            this.component.publiclyTrigger('eventMouseover', {
                context: seg.el[0],
                args: [seg.footprint.getEventLegacy(), ev, this.view]
            });
        }
    };
    // Updates internal state and triggers handlers for when an event element is moused out.
    // Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
    EventPointing.prototype.handleMouseout = function (seg, ev) {
        if (this.mousedOverSeg) {
            this.mousedOverSeg = null;
            // TODO: move to EventSelecting's responsibility
            if (this.view.isEventDefResizable(seg.footprint.eventDef)) {
                seg.el.removeClass('fc-allow-mouse-resize');
            }
            this.component.publiclyTrigger('eventMouseout', {
                context: seg.el[0],
                args: [
                    seg.footprint.getEventLegacy(),
                    ev || {},
                    this.view
                ]
            });
        }
    };
    EventPointing.prototype.end = function () {
        if (this.mousedOverSeg) {
            this.handleMouseout(this.mousedOverSeg);
        }
    };
    return EventPointing;
}(Interaction_1.default));
exports.default = EventPointing;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Mixin_1 = __webpack_require__(15);
var DateClicking_1 = __webpack_require__(237);
var DateSelecting_1 = __webpack_require__(236);
var EventPointing_1 = __webpack_require__(64);
var EventDragging_1 = __webpack_require__(235);
var EventResizing_1 = __webpack_require__(234);
var ExternalDropping_1 = __webpack_require__(233);
var StandardInteractionsMixin = /** @class */ (function (_super) {
    tslib_1.__extends(StandardInteractionsMixin, _super);
    function StandardInteractionsMixin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StandardInteractionsMixin;
}(Mixin_1.default));
exports.default = StandardInteractionsMixin;
StandardInteractionsMixin.prototype.dateClickingClass = DateClicking_1.default;
StandardInteractionsMixin.prototype.dateSelectingClass = DateSelecting_1.default;
StandardInteractionsMixin.prototype.eventPointingClass = EventPointing_1.default;
StandardInteractionsMixin.prototype.eventDraggingClass = EventDragging_1.default;
StandardInteractionsMixin.prototype.eventResizingClass = EventResizing_1.default;
StandardInteractionsMixin.prototype.externalDroppingClass = ExternalDropping_1.default;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var CoordCache_1 = __webpack_require__(58);
var Popover_1 = __webpack_require__(227);
var UnzonedRange_1 = __webpack_require__(5);
var ComponentFootprint_1 = __webpack_require__(12);
var EventFootprint_1 = __webpack_require__(34);
var BusinessHourRenderer_1 = __webpack_require__(61);
var StandardInteractionsMixin_1 = __webpack_require__(65);
var InteractiveDateComponent_1 = __webpack_require__(42);
var DayTableMixin_1 = __webpack_require__(60);
var DayGridEventRenderer_1 = __webpack_require__(243);
var DayGridHelperRenderer_1 = __webpack_require__(244);
var DayGridFillRenderer_1 = __webpack_require__(245);
/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
----------------------------------------------------------------------------------------------------------------------*/
var DayGrid = /** @class */ (function (_super) {
    tslib_1.__extends(DayGrid, _super);
    function DayGrid(view) {
        var _this = _super.call(this, view) || this;
        _this.cellWeekNumbersVisible = false; // display week numbers in day cell?
        _this.bottomCoordPadding = 0; // hack for extending the hit area for the last row of the coordinate grid
        // isRigid determines whether the individual rows should ignore the contents and be a constant height.
        // Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
        _this.isRigid = false;
        _this.hasAllDayBusinessHours = true;
        return _this;
    }
    // Slices up the given span (unzoned start/end with other misc data) into an array of segments
    DayGrid.prototype.componentFootprintToSegs = function (componentFootprint) {
        var segs = this.sliceRangeByRow(componentFootprint.unzonedRange);
        var i;
        var seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (this.isRTL) {
                seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;
                seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;
            }
            else {
                seg.leftCol = seg.firstRowDayIndex;
                seg.rightCol = seg.lastRowDayIndex;
            }
        }
        return segs;
    };
    /* Date Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.renderDates = function (dateProfile) {
        this.dateProfile = dateProfile;
        this.updateDayTable();
        this.renderGrid();
    };
    DayGrid.prototype.unrenderDates = function () {
        this.removeSegPopover();
    };
    // Renders the rows and columns into the component's `this.el`, which should already be assigned.
    DayGrid.prototype.renderGrid = function () {
        var view = this.view;
        var rowCnt = this.rowCnt;
        var colCnt = this.colCnt;
        var html = '';
        var row;
        var col;
        if (this.headContainerEl) {
            this.headContainerEl.html(this.renderHeadHtml());
        }
        for (row = 0; row < rowCnt; row++) {
            html += this.renderDayRowHtml(row, this.isRigid);
        }
        this.el.html(html);
        this.rowEls = this.el.find('.fc-row');
        this.cellEls = this.el.find('.fc-day, .fc-disabled-day');
        this.rowCoordCache = new CoordCache_1.default({
            els: this.rowEls,
            isVertical: true
        });
        this.colCoordCache = new CoordCache_1.default({
            els: this.cellEls.slice(0, this.colCnt),
            isHorizontal: true
        });
        // trigger dayRender with each cell's element
        for (row = 0; row < rowCnt; row++) {
            for (col = 0; col < colCnt; col++) {
                this.publiclyTrigger('dayRender', {
                    context: view,
                    args: [
                        this.getCellDate(row, col),
                        this.getCellEl(row, col),
                        view
                    ]
                });
            }
        }
    };
    // Generates the HTML for a single row, which is a div that wraps a table.
    // `row` is the row number.
    DayGrid.prototype.renderDayRowHtml = function (row, isRigid) {
        var theme = this.view.calendar.theme;
        var classes = ['fc-row', 'fc-week', theme.getClass('dayRow')];
        if (isRigid) {
            classes.push('fc-rigid');
        }
        return '' +
            '<div class="' + classes.join(' ') + '">' +
            '<div class="fc-bg">' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            this.renderBgTrHtml(row) +
            '</table>' +
            '</div>' +
            '<div class="fc-content-skeleton">' +
            '<table>' +
            (this.getIsNumbersVisible() ?
                '<thead>' +
                    this.renderNumberTrHtml(row) +
                    '</thead>' :
                '') +
            '</table>' +
            '</div>' +
            '</div>';
    };
    DayGrid.prototype.getIsNumbersVisible = function () {
        return this.getIsDayNumbersVisible() || this.cellWeekNumbersVisible;
    };
    DayGrid.prototype.getIsDayNumbersVisible = function () {
        return this.rowCnt > 1;
    };
    /* Grid Number Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.renderNumberTrHtml = function (row) {
        return '' +
            '<tr>' +
            (this.isRTL ? '' : this.renderNumberIntroHtml(row)) +
            this.renderNumberCellsHtml(row) +
            (this.isRTL ? this.renderNumberIntroHtml(row) : '') +
            '</tr>';
    };
    DayGrid.prototype.renderNumberIntroHtml = function (row) {
        return this.renderIntroHtml();
    };
    DayGrid.prototype.renderNumberCellsHtml = function (row) {
        var htmls = [];
        var col;
        var date;
        for (col = 0; col < this.colCnt; col++) {
            date = this.getCellDate(row, col);
            htmls.push(this.renderNumberCellHtml(date));
        }
        return htmls.join('');
    };
    // Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
    // The number row will only exist if either day numbers or week numbers are turned on.
    DayGrid.prototype.renderNumberCellHtml = function (date) {
        var view = this.view;
        var html = '';
        var isDateValid = this.dateProfile.activeUnzonedRange.containsDate(date); // TODO: called too frequently. cache somehow.
        var isDayNumberVisible = this.getIsDayNumbersVisible() && isDateValid;
        var classes;
        var weekCalcFirstDoW;
        if (!isDayNumberVisible && !this.cellWeekNumbersVisible) {
            // no numbers in day cell (week number must be along the side)
            return '<td></td>'; //  will create an empty space above events :(
        }
        classes = this.getDayClasses(date);
        classes.unshift('fc-day-top');
        if (this.cellWeekNumbersVisible) {
            // To determine the day of week number change under ISO, we cannot
            // rely on moment.js methods such as firstDayOfWeek() or weekday(),
            // because they rely on the locale's dow (possibly overridden by
            // our firstDay option), which may not be Monday. We cannot change
            // dow, because that would affect the calendar start day as well.
            if (date._locale._fullCalendar_weekCalc === 'ISO') {
                weekCalcFirstDoW = 1; // Monday by ISO 8601 definition
            }
            else {
                weekCalcFirstDoW = date._locale.firstDayOfWeek();
            }
        }
        html += '<td class="' + classes.join(' ') + '"' +
            (isDateValid ?
                ' data-date="' + date.format() + '"' :
                '') +
            '>';
        if (this.cellWeekNumbersVisible && (date.day() === weekCalcFirstDoW)) {
            html += view.buildGotoAnchorHtml({ date: date, type: 'week' }, { 'class': 'fc-week-number' }, date.format('w') // inner HTML
            );
        }
        if (isDayNumberVisible) {
            html += view.buildGotoAnchorHtml(date, { 'class': 'fc-day-number' }, date.format('D') // inner HTML
            );
        }
        html += '</td>';
        return html;
    };
    /* Hit System
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.prepareHits = function () {
        this.colCoordCache.build();
        this.rowCoordCache.build();
        this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
    };
    DayGrid.prototype.releaseHits = function () {
        this.colCoordCache.clear();
        this.rowCoordCache.clear();
    };
    DayGrid.prototype.queryHit = function (leftOffset, topOffset) {
        if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {
            var col = this.colCoordCache.getHorizontalIndex(leftOffset);
            var row = this.rowCoordCache.getVerticalIndex(topOffset);
            if (row != null && col != null) {
                return this.getCellHit(row, col);
            }
        }
    };
    DayGrid.prototype.getHitFootprint = function (hit) {
        var range = this.getCellRange(hit.row, hit.col);
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(range.start, range.end), true // all-day?
        );
    };
    DayGrid.prototype.getHitEl = function (hit) {
        return this.getCellEl(hit.row, hit.col);
    };
    /* Cell System
    ------------------------------------------------------------------------------------------------------------------*/
    // FYI: the first column is the leftmost column, regardless of date
    DayGrid.prototype.getCellHit = function (row, col) {
        return {
            row: row,
            col: col,
            component: this,
            left: this.colCoordCache.getLeftOffset(col),
            right: this.colCoordCache.getRightOffset(col),
            top: this.rowCoordCache.getTopOffset(row),
            bottom: this.rowCoordCache.getBottomOffset(row)
        };
    };
    DayGrid.prototype.getCellEl = function (row, col) {
        return this.cellEls.eq(row * this.colCnt + col);
    };
    /* Event Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    // Unrenders all events currently rendered on the grid
    DayGrid.prototype.executeEventUnrender = function () {
        this.removeSegPopover(); // removes the "more.." events popover
        _super.prototype.executeEventUnrender.call(this);
    };
    // Retrieves all rendered segment objects currently rendered on the grid
    DayGrid.prototype.getOwnEventSegs = function () {
        // append the segments from the "more..." popover
        return _super.prototype.getOwnEventSegs.call(this).concat(this.popoverSegs || []);
    };
    /* Event Drag Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event or external element being dragged.
    // `eventLocation` has zoned start and end (optional)
    DayGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            this.renderHighlight(eventFootprints[i].componentFootprint);
        }
        // render drags from OTHER components as helpers
        if (eventFootprints.length && seg && seg.component !== this) {
            this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);
            return true; // signal helpers rendered
        }
    };
    // Unrenders any visual indication of a hovering event
    DayGrid.prototype.unrenderDrag = function () {
        this.unrenderHighlight();
        this.helperRenderer.unrender();
    };
    /* Event Resize Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event being resized
    DayGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            this.renderHighlight(eventFootprints[i].componentFootprint);
        }
        this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);
    };
    // Unrenders a visual indication of an event being resized
    DayGrid.prototype.unrenderEventResize = function () {
        this.unrenderHighlight();
        this.helperRenderer.unrender();
    };
    /* More+ Link Popover
    ------------------------------------------------------------------------------------------------------------------*/
    DayGrid.prototype.removeSegPopover = function () {
        if (this.segPopover) {
            this.segPopover.hide(); // in handler, will call segPopover's removeElement
        }
    };
    // Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
    // `levelLimit` can be false (don't limit), a number, or true (should be computed).
    DayGrid.prototype.limitRows = function (levelLimit) {
        var rowStructs = this.eventRenderer.rowStructs || [];
        var row; // row #
        var rowLevelLimit;
        for (row = 0; row < rowStructs.length; row++) {
            this.unlimitRow(row);
            if (!levelLimit) {
                rowLevelLimit = false;
            }
            else if (typeof levelLimit === 'number') {
                rowLevelLimit = levelLimit;
            }
            else {
                rowLevelLimit = this.computeRowLevelLimit(row);
            }
            if (rowLevelLimit !== false) {
                this.limitRow(row, rowLevelLimit);
            }
        }
    };
    // Computes the number of levels a row will accomodate without going outside its bounds.
    // Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
    // `row` is the row number.
    DayGrid.prototype.computeRowLevelLimit = function (row) {
        var rowEl = this.rowEls.eq(row); // the containing "fake" row div
        var rowHeight = rowEl.height(); // TODO: cache somehow?
        var trEls = this.eventRenderer.rowStructs[row].tbodyEl.children();
        var i;
        var trEl;
        var trHeight;
        function iterInnerHeights(i, childNode) {
            trHeight = Math.max(trHeight, $(childNode).outerHeight());
        }
        // Reveal one level <tr> at a time and stop when we find one out of bounds
        for (i = 0; i < trEls.length; i++) {
            trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)
            // with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,
            // so instead, find the tallest inner content element.
            trHeight = 0;
            trEl.find('> td > :first-child').each(iterInnerHeights);
            if (trEl.position().top + trHeight > rowHeight) {
                return i;
            }
        }
        return false; // should not limit at all
    };
    // Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
    // `row` is the row number.
    // `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
    DayGrid.prototype.limitRow = function (row, levelLimit) {
        var _this = this;
        var rowStruct = this.eventRenderer.rowStructs[row];
        var moreNodes = []; // array of "more" <a> links and <td> DOM nodes
        var col = 0; // col #, left-to-right (not chronologically)
        var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
        var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row
        var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes
        var i;
        var seg;
        var segsBelow; // array of segment objects below `seg` in the current `col`
        var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
        var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)
        var td;
        var rowspan;
        var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell
        var j;
        var moreTd;
        var moreWrap;
        var moreLink;
        // Iterates through empty level cells and places "more" links inside if need be
        var emptyCellsUntil = function (endCol) {
            while (col < endCol) {
                segsBelow = _this.getCellSegs(row, col, levelLimit);
                if (segsBelow.length) {
                    td = cellMatrix[levelLimit - 1][col];
                    moreLink = _this.renderMoreLink(row, col, segsBelow);
                    moreWrap = $('<div>').append(moreLink);
                    td.append(moreWrap);
                    moreNodes.push(moreWrap[0]);
                }
                col++;
            }
        };
        if (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?
            levelSegs = rowStruct.segLevels[levelLimit - 1];
            cellMatrix = rowStruct.cellMatrix;
            limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit
                .addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array
            // iterate though segments in the last allowable level
            for (i = 0; i < levelSegs.length; i++) {
                seg = levelSegs[i];
                emptyCellsUntil(seg.leftCol); // process empty cells before the segment
                // determine *all* segments below `seg` that occupy the same columns
                colSegsBelow = [];
                totalSegsBelow = 0;
                while (col <= seg.rightCol) {
                    segsBelow = this.getCellSegs(row, col, levelLimit);
                    colSegsBelow.push(segsBelow);
                    totalSegsBelow += segsBelow.length;
                    col++;
                }
                if (totalSegsBelow) { // do we need to replace this segment with one or many "more" links?
                    td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell
                    rowspan = td.attr('rowspan') || 1;
                    segMoreNodes = [];
                    // make a replacement <td> for each column the segment occupies. will be one for each colspan
                    for (j = 0; j < colSegsBelow.length; j++) {
                        moreTd = $('<td class="fc-more-cell">').attr('rowspan', rowspan);
                        segsBelow = colSegsBelow[j];
                        moreLink = this.renderMoreLink(row, seg.leftCol + j, [seg].concat(segsBelow) // count seg as hidden too
                        );
                        moreWrap = $('<div>').append(moreLink);
                        moreTd.append(moreWrap);
                        segMoreNodes.push(moreTd[0]);
                        moreNodes.push(moreTd[0]);
                    }
                    td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements
                    limitedNodes.push(td[0]);
                }
            }
            emptyCellsUntil(this.colCnt); // finish off the level
            rowStruct.moreEls = $(moreNodes); // for easy undoing later
            rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
        }
    };
    // Reveals all levels and removes all "more"-related elements for a grid's row.
    // `row` is a row number.
    DayGrid.prototype.unlimitRow = function (row) {
        var rowStruct = this.eventRenderer.rowStructs[row];
        if (rowStruct.moreEls) {
            rowStruct.moreEls.remove();
            rowStruct.moreEls = null;
        }
        if (rowStruct.limitedEls) {
            rowStruct.limitedEls.removeClass('fc-limited');
            rowStruct.limitedEls = null;
        }
    };
    // Renders an <a> element that represents hidden event element for a cell.
    // Responsible for attaching click handler as well.
    DayGrid.prototype.renderMoreLink = function (row, col, hiddenSegs) {
        var _this = this;
        var view = this.view;
        return $('<a class="fc-more">')
            .text(this.getMoreLinkText(hiddenSegs.length))
            .on('click', function (ev) {
            var clickOption = _this.opt('eventLimitClick');
            var date = _this.getCellDate(row, col);
            var moreEl = $(ev.currentTarget);
            var dayEl = _this.getCellEl(row, col);
            var allSegs = _this.getCellSegs(row, col);
            // rescope the segments to be within the cell's date
            var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
            var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);
            if (typeof clickOption === 'function') {
                // the returned value can be an atomic option
                clickOption = _this.publiclyTrigger('eventLimitClick', {
                    context: view,
                    args: [
                        {
                            date: date.clone(),
                            dayEl: dayEl,
                            moreEl: moreEl,
                            segs: reslicedAllSegs,
                            hiddenSegs: reslicedHiddenSegs
                        },
                        ev,
                        view
                    ]
                });
            }
            if (clickOption === 'popover') {
                _this.showSegPopover(row, col, moreEl, reslicedAllSegs);
            }
            else if (typeof clickOption === 'string') { // a view name
                view.calendar.zoomTo(date, clickOption);
            }
        });
    };
    // Reveals the popover that displays all events within a cell
    DayGrid.prototype.showSegPopover = function (row, col, moreLink, segs) {
        var _this = this;
        var view = this.view;
        var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>
        var topEl; // the element we want to match the top coordinate of
        var options;
        if (this.rowCnt === 1) {
            topEl = view.el; // will cause the popover to cover any sort of header
        }
        else {
            topEl = this.rowEls.eq(row); // will align with top of row
        }
        options = {
            className: 'fc-more-popover ' + view.calendar.theme.getClass('popover'),
            content: this.renderSegPopoverContent(row, col, segs),
            parentEl: view.el,
            top: topEl.offset().top,
            autoHide: true,
            viewportConstrain: this.opt('popoverViewportConstrain'),
            hide: function () {
                // kill everything when the popover is hidden
                // notify events to be removed
                if (_this.popoverSegs) {
                    _this.triggerBeforeEventSegsDestroyed(_this.popoverSegs);
                }
                _this.segPopover.removeElement();
                _this.segPopover = null;
                _this.popoverSegs = null;
            }
        };
        // Determine horizontal coordinate.
        // We use the moreWrap instead of the <td> to avoid border confusion.
        if (this.isRTL) {
            options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
        }
        else {
            options.left = moreWrap.offset().left - 1; // -1 to be over cell border
        }
        this.segPopover = new Popover_1.default(options);
        this.segPopover.show();
        // the popover doesn't live within the grid's container element, and thus won't get the event
        // delegated-handlers for free. attach event-related handlers to the popover.
        this.bindAllSegHandlersToEl(this.segPopover.el);
        this.triggerAfterEventSegsRendered(segs);
    };
    // Builds the inner DOM contents of the segment popover
    DayGrid.prototype.renderSegPopoverContent = function (row, col, segs) {
        var view = this.view;
        var theme = view.calendar.theme;
        var title = this.getCellDate(row, col).format(this.opt('dayPopoverFormat'));
        var content = $('<div class="fc-header ' + theme.getClass('popoverHeader') + '">' +
            '<span class="fc-close ' + theme.getIconClass('close') + '"></span>' +
            '<span class="fc-title">' +
            util_1.htmlEscape(title) +
            '</span>' +
            '<div class="fc-clear"></div>' +
            '</div>' +
            '<div class="fc-body ' + theme.getClass('popoverContent') + '">' +
            '<div class="fc-event-container"></div>' +
            '</div>');
        var segContainer = content.find('.fc-event-container');
        var i;
        // render each seg's `el` and only return the visible segs
        segs = this.eventRenderer.renderFgSegEls(segs, true); // disableResizing=true
        this.popoverSegs = segs;
        for (i = 0; i < segs.length; i++) {
            // because segments in the popover are not part of a grid coordinate system, provide a hint to any
            // grids that want to do drag-n-drop about which cell it came from
            this.hitsNeeded();
            segs[i].hit = this.getCellHit(row, col);
            this.hitsNotNeeded();
            segContainer.append(segs[i].el);
        }
        return content;
    };
    // Given the events within an array of segment objects, reslice them to be in a single day
    DayGrid.prototype.resliceDaySegs = function (segs, dayDate) {
        var dayStart = dayDate.clone();
        var dayEnd = dayStart.clone().add(1, 'days');
        var dayRange = new UnzonedRange_1.default(dayStart, dayEnd);
        var newSegs = [];
        var i;
        var seg;
        var slicedRange;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            slicedRange = seg.footprint.componentFootprint.unzonedRange.intersect(dayRange);
            if (slicedRange) {
                newSegs.push($.extend({}, seg, {
                    footprint: new EventFootprint_1.default(new ComponentFootprint_1.default(slicedRange, seg.footprint.componentFootprint.isAllDay), seg.footprint.eventDef, seg.footprint.eventInstance),
                    isStart: seg.isStart && slicedRange.isStart,
                    isEnd: seg.isEnd && slicedRange.isEnd
                }));
            }
        }
        // force an order because eventsToSegs doesn't guarantee one
        // TODO: research if still needed
        this.eventRenderer.sortEventSegs(newSegs);
        return newSegs;
    };
    // Generates the text that should be inside a "more" link, given the number of events it represents
    DayGrid.prototype.getMoreLinkText = function (num) {
        var opt = this.opt('eventLimitText');
        if (typeof opt === 'function') {
            return opt(num);
        }
        else {
            return '+' + num + ' ' + opt;
        }
    };
    // Returns segments within a given cell.
    // If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
    DayGrid.prototype.getCellSegs = function (row, col, startLevel) {
        var segMatrix = this.eventRenderer.rowStructs[row].segMatrix;
        var level = startLevel || 0;
        var segs = [];
        var seg;
        while (level < segMatrix.length) {
            seg = segMatrix[level][col];
            if (seg) {
                segs.push(seg);
            }
            level++;
        }
        return segs;
    };
    return DayGrid;
}(InteractiveDateComponent_1.default));
exports.default = DayGrid;
DayGrid.prototype.eventRendererClass = DayGridEventRenderer_1.default;
DayGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;
DayGrid.prototype.helperRendererClass = DayGridHelperRenderer_1.default;
DayGrid.prototype.fillRendererClass = DayGridFillRenderer_1.default;
StandardInteractionsMixin_1.default.mixInto(DayGrid);
DayTableMixin_1.default.mixInto(DayGrid);


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var Scroller_1 = __webpack_require__(41);
var View_1 = __webpack_require__(43);
var BasicViewDateProfileGenerator_1 = __webpack_require__(68);
var DayGrid_1 = __webpack_require__(66);
/* An abstract class for the "basic" views, as well as month view. Renders one or more rows of day cells.
----------------------------------------------------------------------------------------------------------------------*/
// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.
var BasicView = /** @class */ (function (_super) {
    tslib_1.__extends(BasicView, _super);
    function BasicView(calendar, viewSpec) {
        var _this = _super.call(this, calendar, viewSpec) || this;
        _this.dayGrid = _this.instantiateDayGrid();
        _this.dayGrid.isRigid = _this.hasRigidRows();
        if (_this.opt('weekNumbers')) {
            if (_this.opt('weekNumbersWithinDays')) {
                _this.dayGrid.cellWeekNumbersVisible = true;
                _this.dayGrid.colWeekNumbersVisible = false;
            }
            else {
                _this.dayGrid.cellWeekNumbersVisible = false;
                _this.dayGrid.colWeekNumbersVisible = true;
            }
        }
        _this.addChild(_this.dayGrid);
        _this.scroller = new Scroller_1.default({
            overflowX: 'hidden',
            overflowY: 'auto'
        });
        return _this;
    }
    // Generates the DayGrid object this view needs. Draws from this.dayGridClass
    BasicView.prototype.instantiateDayGrid = function () {
        // generate a subclass on the fly with BasicView-specific behavior
        // TODO: cache this subclass
        var subclass = makeDayGridSubclass(this.dayGridClass);
        return new subclass(this);
    };
    BasicView.prototype.executeDateRender = function (dateProfile) {
        this.dayGrid.breakOnWeeks = /year|month|week/.test(dateProfile.currentRangeUnit);
        _super.prototype.executeDateRender.call(this, dateProfile);
    };
    BasicView.prototype.renderSkeleton = function () {
        var dayGridContainerEl;
        var dayGridEl;
        this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());
        this.scroller.render();
        dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');
        dayGridEl = $('<div class="fc-day-grid">').appendTo(dayGridContainerEl);
        this.el.find('.fc-body > tr > td').append(dayGridContainerEl);
        this.dayGrid.headContainerEl = this.el.find('.fc-head-container');
        this.dayGrid.setElement(dayGridEl);
    };
    BasicView.prototype.unrenderSkeleton = function () {
        this.dayGrid.removeElement();
        this.scroller.destroy();
    };
    // Builds the HTML skeleton for the view.
    // The day-grid component will render inside of a container defined by this HTML.
    BasicView.prototype.renderSkeletonHtml = function () {
        var theme = this.calendar.theme;
        return '' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            (this.opt('columnHeader') ?
                '<thead class="fc-head">' +
                    '<tr>' +
                    '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' +
                    '</tr>' +
                    '</thead>' :
                '') +
            '<tbody class="fc-body">' +
            '<tr>' +
            '<td class="' + theme.getClass('widgetContent') + '"></td>' +
            '</tr>' +
            '</tbody>' +
            '</table>';
    };
    // Generates an HTML attribute string for setting the width of the week number column, if it is known
    BasicView.prototype.weekNumberStyleAttr = function () {
        if (this.weekNumberWidth != null) {
            return 'style="width:' + this.weekNumberWidth + 'px"';
        }
        return '';
    };
    // Determines whether each row should have a constant height
    BasicView.prototype.hasRigidRows = function () {
        var eventLimit = this.opt('eventLimit');
        return eventLimit && typeof eventLimit !== 'number';
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/
    // Refreshes the horizontal dimensions of the view
    BasicView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        var eventLimit = this.opt('eventLimit');
        var headRowEl = this.dayGrid.headContainerEl.find('.fc-row');
        var scrollerHeight;
        var scrollbarWidths;
        // hack to give the view some height prior to dayGrid's columns being rendered
        // TODO: separate setting height from scroller VS dayGrid.
        if (!this.dayGrid.rowEls) {
            if (!isAuto) {
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            return;
        }
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        if (this.dayGrid.colWeekNumbersVisible) {
            // Make sure all week number cells running down the side have the same width.
            // Record the width for cells created later.
            this.weekNumberWidth = util_1.matchCellWidths(this.el.find('.fc-week-number'));
        }
        // reset all heights to be natural
        this.scroller.clear();
        util_1.uncompensateScroll(headRowEl);
        this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed
        // is the event limit a constant level number?
        if (eventLimit && typeof eventLimit === 'number') {
            this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
        }
        // distribute the height to the rows
        // (totalHeight is a "recommended" value if isAuto)
        scrollerHeight = this.computeScrollerHeight(totalHeight);
        this.setGridHeight(scrollerHeight, isAuto);
        // is the event limit dynamically calculated?
        if (eventLimit && typeof eventLimit !== 'number') {
            this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
        }
        if (!isAuto) { // should we force dimensions of the scroll container?
            this.scroller.setHeight(scrollerHeight);
            scrollbarWidths = this.scroller.getScrollbarWidths();
            if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?
                util_1.compensateScroll(headRowEl, scrollbarWidths);
                // doing the scrollbar compensation might have created text overflow which created more height. redo
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            // guarantees the same scrollbar widths
            this.scroller.lockOverflow(scrollbarWidths);
        }
    };
    // given a desired total height of the view, returns what the height of the scroller should be
    BasicView.prototype.computeScrollerHeight = function (totalHeight) {
        return totalHeight -
            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };
    // Sets the height of just the DayGrid component in this view
    BasicView.prototype.setGridHeight = function (height, isAuto) {
        if (isAuto) {
            util_1.undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
        }
        else {
            util_1.distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
        }
    };
    /* Scroll
    ------------------------------------------------------------------------------------------------------------------*/
    BasicView.prototype.computeInitialDateScroll = function () {
        return { top: 0 };
    };
    BasicView.prototype.queryDateScroll = function () {
        return { top: this.scroller.getScrollTop() };
    };
    BasicView.prototype.applyDateScroll = function (scroll) {
        if (scroll.top !== undefined) {
            this.scroller.setScrollTop(scroll.top);
        }
    };
    return BasicView;
}(View_1.default));
exports.default = BasicView;
BasicView.prototype.dateProfileGeneratorClass = BasicViewDateProfileGenerator_1.default;
BasicView.prototype.dayGridClass = DayGrid_1.default;
// customize the rendering behavior of BasicView's dayGrid
function makeDayGridSubclass(SuperClass) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(SubClass, _super);
        function SubClass() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.colWeekNumbersVisible = false; // display week numbers along the side?
            return _this;
        }
        // Generates the HTML that will go before the day-of week header cells
        SubClass.prototype.renderHeadIntroHtml = function () {
            var view = this.view;
            if (this.colWeekNumbersVisible) {
                return '' +
                    '<th class="fc-week-number ' + view.calendar.theme.getClass('widgetHeader') + '" ' + view.weekNumberStyleAttr() + '>' +
                    '<span>' + // needed for matchCellWidths
                    util_1.htmlEscape(this.opt('weekNumberTitle')) +
                    '</span>' +
                    '</th>';
            }
            return '';
        };
        // Generates the HTML that will go before content-skeleton cells that display the day/week numbers
        SubClass.prototype.renderNumberIntroHtml = function (row) {
            var view = this.view;
            var weekStart = this.getCellDate(row, 0);
            if (this.colWeekNumbersVisible) {
                return '' +
                    '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '>' +
                    view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths
                    { date: weekStart, type: 'week', forceOff: this.colCnt === 1 }, weekStart.format('w') // inner HTML
                    ) +
                    '</td>';
            }
            return '';
        };
        // Generates the HTML that goes before the day bg cells for each day-row
        SubClass.prototype.renderBgIntroHtml = function () {
            var view = this.view;
            if (this.colWeekNumbersVisible) {
                return '<td class="fc-week-number ' + view.calendar.theme.getClass('widgetContent') + '" ' +
                    view.weekNumberStyleAttr() + '></td>';
            }
            return '';
        };
        // Generates the HTML that goes before every other type of row generated by DayGrid.
        // Affects helper-skeleton and highlight-skeleton rows.
        SubClass.prototype.renderIntroHtml = function () {
            var view = this.view;
            if (this.colWeekNumbersVisible) {
                return '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '></td>';
            }
            return '';
        };
        SubClass.prototype.getIsNumbersVisible = function () {
            return DayGrid_1.default.prototype.getIsNumbersVisible.apply(this, arguments) || this.colWeekNumbersVisible;
        };
        return SubClass;
    }(SuperClass));
}


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var UnzonedRange_1 = __webpack_require__(5);
var DateProfileGenerator_1 = __webpack_require__(55);
var BasicViewDateProfileGenerator = /** @class */ (function (_super) {
    tslib_1.__extends(BasicViewDateProfileGenerator, _super);
    function BasicViewDateProfileGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Computes the date range that will be rendered.
    BasicViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
        var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay); // an UnzonedRange
        var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);
        var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);
        // year and month views should be aligned with weeks. this is already done for week
        if (/^(year|month)$/.test(currentRangeUnit)) {
            start.startOf('week');
            // make end-of-week if not already
            if (end.weekday()) {
                end.add(1, 'week').startOf('week'); // exclusively move backwards
            }
        }
        return new UnzonedRange_1.default(start, end);
    };
    return BasicViewDateProfileGenerator;
}(DateProfileGenerator_1.default));
exports.default = BasicViewDateProfileGenerator;


/***/ }),
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */,
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var UnzonedRange_1 = __webpack_require__(5);
var ComponentFootprint_1 = __webpack_require__(12);
var EventDefParser_1 = __webpack_require__(36);
var EventSource_1 = __webpack_require__(6);
var util_1 = __webpack_require__(19);
var Constraints = /** @class */ (function () {
    function Constraints(eventManager, _calendar) {
        this.eventManager = eventManager;
        this._calendar = _calendar;
    }
    Constraints.prototype.opt = function (name) {
        return this._calendar.opt(name);
    };
    /*
    determines if eventInstanceGroup is allowed,
    in relation to other EVENTS and business hours.
    */
    Constraints.prototype.isEventInstanceGroupAllowed = function (eventInstanceGroup) {
        var eventDef = eventInstanceGroup.getEventDef();
        var eventFootprints = this.eventRangesToEventFootprints(eventInstanceGroup.getAllEventRanges());
        var i;
        var peerEventInstances = this.getPeerEventInstances(eventDef);
        var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);
        var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);
        var constraintVal = eventDef.getConstraint();
        var overlapVal = eventDef.getOverlap();
        var eventAllowFunc = this.opt('eventAllow');
        for (i = 0; i < eventFootprints.length; i++) {
            if (!this.isFootprintAllowed(eventFootprints[i].componentFootprint, peerEventFootprints, constraintVal, overlapVal, eventFootprints[i].eventInstance)) {
                return false;
            }
        }
        if (eventAllowFunc) {
            for (i = 0; i < eventFootprints.length; i++) {
                if (eventAllowFunc(eventFootprints[i].componentFootprint.toLegacy(this._calendar), eventFootprints[i].getEventLegacy()) === false) {
                    return false;
                }
            }
        }
        return true;
    };
    Constraints.prototype.getPeerEventInstances = function (eventDef) {
        return this.eventManager.getEventInstancesWithoutId(eventDef.id);
    };
    Constraints.prototype.isSelectionFootprintAllowed = function (componentFootprint) {
        var peerEventInstances = this.eventManager.getEventInstances();
        var peerEventRanges = peerEventInstances.map(util_1.eventInstanceToEventRange);
        var peerEventFootprints = this.eventRangesToEventFootprints(peerEventRanges);
        var selectAllowFunc;
        if (this.isFootprintAllowed(componentFootprint, peerEventFootprints, this.opt('selectConstraint'), this.opt('selectOverlap'))) {
            selectAllowFunc = this.opt('selectAllow');
            if (selectAllowFunc) {
                return selectAllowFunc(componentFootprint.toLegacy(this._calendar)) !== false;
            }
            else {
                return true;
            }
        }
        return false;
    };
    Constraints.prototype.isFootprintAllowed = function (componentFootprint, peerEventFootprints, constraintVal, overlapVal, subjectEventInstance // optional
    ) {
        var constraintFootprints; // ComponentFootprint[]
        var overlapEventFootprints; // EventFootprint[]
        if (constraintVal != null) {
            constraintFootprints = this.constraintValToFootprints(constraintVal, componentFootprint.isAllDay);
            if (!this.isFootprintWithinConstraints(componentFootprint, constraintFootprints)) {
                return false;
            }
        }
        overlapEventFootprints = this.collectOverlapEventFootprints(peerEventFootprints, componentFootprint);
        if (overlapVal === false) {
            if (overlapEventFootprints.length) {
                return false;
            }
        }
        else if (typeof overlapVal === 'function') {
            if (!isOverlapsAllowedByFunc(overlapEventFootprints, overlapVal, subjectEventInstance)) {
                return false;
            }
        }
        if (subjectEventInstance) {
            if (!isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance)) {
                return false;
            }
        }
        return true;
    };
    // Constraint
    // ------------------------------------------------------------------------------------------------
    Constraints.prototype.isFootprintWithinConstraints = function (componentFootprint, constraintFootprints) {
        var i;
        for (i = 0; i < constraintFootprints.length; i++) {
            if (this.footprintContainsFootprint(constraintFootprints[i], componentFootprint)) {
                return true;
            }
        }
        return false;
    };
    Constraints.prototype.constraintValToFootprints = function (constraintVal, isAllDay) {
        var eventInstances;
        if (constraintVal === 'businessHours') {
            return this.buildCurrentBusinessFootprints(isAllDay);
        }
        else if (typeof constraintVal === 'object') {
            eventInstances = this.parseEventDefToInstances(constraintVal); // handles recurring events
            if (!eventInstances) { // invalid input. fallback to parsing footprint directly
                return this.parseFootprints(constraintVal);
            }
            else {
                return this.eventInstancesToFootprints(eventInstances);
            }
        }
        else if (constraintVal != null) { // an ID
            eventInstances = this.eventManager.getEventInstancesWithId(constraintVal);
            return this.eventInstancesToFootprints(eventInstances);
        }
    };
    // returns ComponentFootprint[]
    // uses current view's range
    Constraints.prototype.buildCurrentBusinessFootprints = function (isAllDay) {
        var view = this._calendar.view;
        var businessHourGenerator = view.get('businessHourGenerator');
        var unzonedRange = view.dateProfile.activeUnzonedRange;
        var eventInstanceGroup = businessHourGenerator.buildEventInstanceGroup(isAllDay, unzonedRange);
        if (eventInstanceGroup) {
            return this.eventInstancesToFootprints(eventInstanceGroup.eventInstances);
        }
        else {
            return [];
        }
    };
    // conversion util
    Constraints.prototype.eventInstancesToFootprints = function (eventInstances) {
        var eventRanges = eventInstances.map(util_1.eventInstanceToEventRange);
        var eventFootprints = this.eventRangesToEventFootprints(eventRanges);
        return eventFootprints.map(util_1.eventFootprintToComponentFootprint);
    };
    // Overlap
    // ------------------------------------------------------------------------------------------------
    Constraints.prototype.collectOverlapEventFootprints = function (peerEventFootprints, targetFootprint) {
        var overlapEventFootprints = [];
        var i;
        for (i = 0; i < peerEventFootprints.length; i++) {
            if (this.footprintsIntersect(targetFootprint, peerEventFootprints[i].componentFootprint)) {
                overlapEventFootprints.push(peerEventFootprints[i]);
            }
        }
        return overlapEventFootprints;
    };
    // Conversion: eventDefs -> eventInstances -> eventRanges -> eventFootprints -> componentFootprints
    // ------------------------------------------------------------------------------------------------
    // NOTE: this might seem like repetitive code with the Grid class, however, this code is related to
    // constraints whereas the Grid code is related to rendering. Each approach might want to convert
    // eventRanges -> eventFootprints in a different way. Regardless, there are opportunities to make
    // this more DRY.
    /*
    Returns false on invalid input.
    */
    Constraints.prototype.parseEventDefToInstances = function (eventInput) {
        var eventManager = this.eventManager;
        var eventDef = EventDefParser_1.default.parse(eventInput, new EventSource_1.default(this._calendar));
        if (!eventDef) { // invalid
            return false;
        }
        return eventDef.buildInstances(eventManager.currentPeriod.unzonedRange);
    };
    Constraints.prototype.eventRangesToEventFootprints = function (eventRanges) {
        var i;
        var eventFootprints = [];
        for (i = 0; i < eventRanges.length; i++) {
            eventFootprints.push.apply(// footprints
            eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));
        }
        return eventFootprints;
    };
    Constraints.prototype.eventRangeToEventFootprints = function (eventRange) {
        return [util_1.eventRangeToEventFootprint(eventRange)];
    };
    /*
    Parses footprints directly.
    Very similar to EventDateProfile::parse :(
    */
    Constraints.prototype.parseFootprints = function (rawInput) {
        var start;
        var end;
        if (rawInput.start) {
            start = this._calendar.moment(rawInput.start);
            if (!start.isValid()) {
                start = null;
            }
        }
        if (rawInput.end) {
            end = this._calendar.moment(rawInput.end);
            if (!end.isValid()) {
                end = null;
            }
        }
        return [
            new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), (start && !start.hasTime()) || (end && !end.hasTime()) // isAllDay
            )
        ];
    };
    // Footprint Utils
    // ----------------------------------------------------------------------------------------
    Constraints.prototype.footprintContainsFootprint = function (outerFootprint, innerFootprint) {
        return outerFootprint.unzonedRange.containsRange(innerFootprint.unzonedRange);
    };
    Constraints.prototype.footprintsIntersect = function (footprint0, footprint1) {
        return footprint0.unzonedRange.intersectsWith(footprint1.unzonedRange);
    };
    return Constraints;
}());
exports.default = Constraints;
// optional subjectEventInstance
function isOverlapsAllowedByFunc(overlapEventFootprints, overlapFunc, subjectEventInstance) {
    var i;
    for (i = 0; i < overlapEventFootprints.length; i++) {
        if (!overlapFunc(overlapEventFootprints[i].eventInstance.toLegacy(), subjectEventInstance ? subjectEventInstance.toLegacy() : null)) {
            return false;
        }
    }
    return true;
}
function isOverlapEventInstancesAllowed(overlapEventFootprints, subjectEventInstance) {
    var subjectLegacyInstance = subjectEventInstance.toLegacy();
    var i;
    var overlapEventInstance;
    var overlapEventDef;
    var overlapVal;
    for (i = 0; i < overlapEventFootprints.length; i++) {
        overlapEventInstance = overlapEventFootprints[i].eventInstance;
        overlapEventDef = overlapEventInstance.def;
        // don't need to pass in calendar, because don't want to consider global eventOverlap property,
        // because we already considered that earlier in the process.
        overlapVal = overlapEventDef.getOverlap();
        if (overlapVal === false) {
            return false;
        }
        else if (typeof overlapVal === 'function') {
            if (!overlapVal(overlapEventInstance.toLegacy(), subjectLegacyInstance)) {
                return false;
            }
        }
    }
    return true;
}


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(19);
var EventInstanceGroup_1 = __webpack_require__(20);
var RecurringEventDef_1 = __webpack_require__(54);
var EventSource_1 = __webpack_require__(6);
var BUSINESS_HOUR_EVENT_DEFAULTS = {
    start: '09:00',
    end: '17:00',
    dow: [1, 2, 3, 4, 5],
    rendering: 'inverse-background'
    // classNames are defined in businessHoursSegClasses
};
var BusinessHourGenerator = /** @class */ (function () {
    function BusinessHourGenerator(rawComplexDef, calendar) {
        this.rawComplexDef = rawComplexDef;
        this.calendar = calendar;
    }
    BusinessHourGenerator.prototype.buildEventInstanceGroup = function (isAllDay, unzonedRange) {
        var eventDefs = this.buildEventDefs(isAllDay);
        var eventInstanceGroup;
        if (eventDefs.length) {
            eventInstanceGroup = new EventInstanceGroup_1.default(util_1.eventDefsToEventInstances(eventDefs, unzonedRange));
            // so that inverse-background rendering can happen even when no eventRanges in view
            eventInstanceGroup.explicitEventDef = eventDefs[0];
            return eventInstanceGroup;
        }
    };
    BusinessHourGenerator.prototype.buildEventDefs = function (isAllDay) {
        var rawComplexDef = this.rawComplexDef;
        var rawDefs = [];
        var requireDow = false;
        var i;
        var defs = [];
        if (rawComplexDef === true) {
            rawDefs = [{}]; // will get BUSINESS_HOUR_EVENT_DEFAULTS verbatim
        }
        else if ($.isPlainObject(rawComplexDef)) {
            rawDefs = [rawComplexDef];
        }
        else if ($.isArray(rawComplexDef)) {
            rawDefs = rawComplexDef;
            requireDow = true; // every sub-definition NEEDS a day-of-week
        }
        for (i = 0; i < rawDefs.length; i++) {
            if (!requireDow || rawDefs[i].dow) {
                defs.push(this.buildEventDef(isAllDay, rawDefs[i]));
            }
        }
        return defs;
    };
    BusinessHourGenerator.prototype.buildEventDef = function (isAllDay, rawDef) {
        var fullRawDef = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, rawDef);
        if (isAllDay) {
            fullRawDef.start = null;
            fullRawDef.end = null;
        }
        return RecurringEventDef_1.default.parse(fullRawDef, new EventSource_1.default(this.calendar) // dummy source
        );
    };
    return BusinessHourGenerator;
}());
exports.default = BusinessHourGenerator;


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var Promise_1 = __webpack_require__(21);
var EmitterMixin_1 = __webpack_require__(13);
var UnzonedRange_1 = __webpack_require__(5);
var EventInstanceGroup_1 = __webpack_require__(20);
var EventPeriod = /** @class */ (function () {
    function EventPeriod(start, end, timezone) {
        this.pendingCnt = 0;
        this.freezeDepth = 0;
        this.stuntedReleaseCnt = 0;
        this.releaseCnt = 0;
        this.start = start;
        this.end = end;
        this.timezone = timezone;
        this.unzonedRange = new UnzonedRange_1.default(start.clone().stripZone(), end.clone().stripZone());
        this.requestsByUid = {};
        this.eventDefsByUid = {};
        this.eventDefsById = {};
        this.eventInstanceGroupsById = {};
    }
    EventPeriod.prototype.isWithinRange = function (start, end) {
        // TODO: use a range util function?
        return !start.isBefore(this.start) && !end.isAfter(this.end);
    };
    // Requesting and Purging
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.requestSources = function (sources) {
        this.freeze();
        for (var i = 0; i < sources.length; i++) {
            this.requestSource(sources[i]);
        }
        this.thaw();
    };
    EventPeriod.prototype.requestSource = function (source) {
        var _this = this;
        var request = { source: source, status: 'pending', eventDefs: null };
        this.requestsByUid[source.uid] = request;
        this.pendingCnt += 1;
        source.fetch(this.start, this.end, this.timezone).then(function (eventDefs) {
            if (request.status !== 'cancelled') {
                request.status = 'completed';
                request.eventDefs = eventDefs;
                _this.addEventDefs(eventDefs);
                _this.pendingCnt--;
                _this.tryRelease();
            }
        }, function () {
            if (request.status !== 'cancelled') {
                request.status = 'failed';
                _this.pendingCnt--;
                _this.tryRelease();
            }
        });
    };
    EventPeriod.prototype.purgeSource = function (source) {
        var request = this.requestsByUid[source.uid];
        if (request) {
            delete this.requestsByUid[source.uid];
            if (request.status === 'pending') {
                request.status = 'cancelled';
                this.pendingCnt--;
                this.tryRelease();
            }
            else if (request.status === 'completed') {
                request.eventDefs.forEach(this.removeEventDef.bind(this));
            }
        }
    };
    EventPeriod.prototype.purgeAllSources = function () {
        var requestsByUid = this.requestsByUid;
        var uid;
        var request;
        var completedCnt = 0;
        for (uid in requestsByUid) {
            request = requestsByUid[uid];
            if (request.status === 'pending') {
                request.status = 'cancelled';
            }
            else if (request.status === 'completed') {
                completedCnt++;
            }
        }
        this.requestsByUid = {};
        this.pendingCnt = 0;
        if (completedCnt) {
            this.removeAllEventDefs(); // might release
        }
    };
    // Event Definitions
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.getEventDefByUid = function (eventDefUid) {
        return this.eventDefsByUid[eventDefUid];
    };
    EventPeriod.prototype.getEventDefsById = function (eventDefId) {
        var a = this.eventDefsById[eventDefId];
        if (a) {
            return a.slice(); // clone
        }
        return [];
    };
    EventPeriod.prototype.addEventDefs = function (eventDefs) {
        for (var i = 0; i < eventDefs.length; i++) {
            this.addEventDef(eventDefs[i]);
        }
    };
    EventPeriod.prototype.addEventDef = function (eventDef) {
        var eventDefsById = this.eventDefsById;
        var eventDefId = eventDef.id;
        var eventDefs = eventDefsById[eventDefId] || (eventDefsById[eventDefId] = []);
        var eventInstances = eventDef.buildInstances(this.unzonedRange);
        var i;
        eventDefs.push(eventDef);
        this.eventDefsByUid[eventDef.uid] = eventDef;
        for (i = 0; i < eventInstances.length; i++) {
            this.addEventInstance(eventInstances[i], eventDefId);
        }
    };
    EventPeriod.prototype.removeEventDefsById = function (eventDefId) {
        var _this = this;
        this.getEventDefsById(eventDefId).forEach(function (eventDef) {
            _this.removeEventDef(eventDef);
        });
    };
    EventPeriod.prototype.removeAllEventDefs = function () {
        var isEmpty = $.isEmptyObject(this.eventDefsByUid);
        this.eventDefsByUid = {};
        this.eventDefsById = {};
        this.eventInstanceGroupsById = {};
        if (!isEmpty) {
            this.tryRelease();
        }
    };
    EventPeriod.prototype.removeEventDef = function (eventDef) {
        var eventDefsById = this.eventDefsById;
        var eventDefs = eventDefsById[eventDef.id];
        delete this.eventDefsByUid[eventDef.uid];
        if (eventDefs) {
            util_1.removeExact(eventDefs, eventDef);
            if (!eventDefs.length) {
                delete eventDefsById[eventDef.id];
            }
            this.removeEventInstancesForDef(eventDef);
        }
    };
    // Event Instances
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.getEventInstances = function () {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var eventInstances = [];
        var id;
        for (id in eventInstanceGroupsById) {
            eventInstances.push.apply(eventInstances, // append
            eventInstanceGroupsById[id].eventInstances);
        }
        return eventInstances;
    };
    EventPeriod.prototype.getEventInstancesWithId = function (eventDefId) {
        var eventInstanceGroup = this.eventInstanceGroupsById[eventDefId];
        if (eventInstanceGroup) {
            return eventInstanceGroup.eventInstances.slice(); // clone
        }
        return [];
    };
    EventPeriod.prototype.getEventInstancesWithoutId = function (eventDefId) {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var matchingInstances = [];
        var id;
        for (id in eventInstanceGroupsById) {
            if (id !== eventDefId) {
                matchingInstances.push.apply(matchingInstances, // append
                eventInstanceGroupsById[id].eventInstances);
            }
        }
        return matchingInstances;
    };
    EventPeriod.prototype.addEventInstance = function (eventInstance, eventDefId) {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var eventInstanceGroup = eventInstanceGroupsById[eventDefId] ||
            (eventInstanceGroupsById[eventDefId] = new EventInstanceGroup_1.default());
        eventInstanceGroup.eventInstances.push(eventInstance);
        this.tryRelease();
    };
    EventPeriod.prototype.removeEventInstancesForDef = function (eventDef) {
        var eventInstanceGroupsById = this.eventInstanceGroupsById;
        var eventInstanceGroup = eventInstanceGroupsById[eventDef.id];
        var removeCnt;
        if (eventInstanceGroup) {
            removeCnt = util_1.removeMatching(eventInstanceGroup.eventInstances, function (currentEventInstance) {
                return currentEventInstance.def === eventDef;
            });
            if (!eventInstanceGroup.eventInstances.length) {
                delete eventInstanceGroupsById[eventDef.id];
            }
            if (removeCnt) {
                this.tryRelease();
            }
        }
    };
    // Releasing and Freezing
    // -----------------------------------------------------------------------------------------------------------------
    EventPeriod.prototype.tryRelease = function () {
        if (!this.pendingCnt) {
            if (!this.freezeDepth) {
                this.release();
            }
            else {
                this.stuntedReleaseCnt++;
            }
        }
    };
    EventPeriod.prototype.release = function () {
        this.releaseCnt++;
        this.trigger('release', this.eventInstanceGroupsById);
    };
    EventPeriod.prototype.whenReleased = function () {
        var _this = this;
        if (this.releaseCnt) {
            return Promise_1.default.resolve(this.eventInstanceGroupsById);
        }
        else {
            return Promise_1.default.construct(function (onResolve) {
                _this.one('release', onResolve);
            });
        }
    };
    EventPeriod.prototype.freeze = function () {
        if (!(this.freezeDepth++)) {
            this.stuntedReleaseCnt = 0;
        }
    };
    EventPeriod.prototype.thaw = function () {
        if (!(--this.freezeDepth) && this.stuntedReleaseCnt && !this.pendingCnt) {
            this.release();
        }
    };
    return EventPeriod;
}());
exports.default = EventPeriod;
EmitterMixin_1.default.mixInto(EventPeriod);


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var EventPeriod_1 = __webpack_require__(219);
var ArrayEventSource_1 = __webpack_require__(56);
var EventSource_1 = __webpack_require__(6);
var EventSourceParser_1 = __webpack_require__(38);
var SingleEventDef_1 = __webpack_require__(9);
var EventInstanceGroup_1 = __webpack_require__(20);
var EmitterMixin_1 = __webpack_require__(13);
var ListenerMixin_1 = __webpack_require__(7);
var EventManager = /** @class */ (function () {
    function EventManager(calendar) {
        this.calendar = calendar;
        this.stickySource = new ArrayEventSource_1.default(calendar);
        this.otherSources = [];
    }
    EventManager.prototype.requestEvents = function (start, end, timezone, force) {
        if (force ||
            !this.currentPeriod ||
            !this.currentPeriod.isWithinRange(start, end) ||
            timezone !== this.currentPeriod.timezone) {
            this.setPeriod(// will change this.currentPeriod
            new EventPeriod_1.default(start, end, timezone));
        }
        return this.currentPeriod.whenReleased();
    };
    // Source Adding/Removing
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.addSource = function (eventSource) {
        this.otherSources.push(eventSource);
        if (this.currentPeriod) {
            this.currentPeriod.requestSource(eventSource); // might release
        }
    };
    EventManager.prototype.removeSource = function (doomedSource) {
        util_1.removeExact(this.otherSources, doomedSource);
        if (this.currentPeriod) {
            this.currentPeriod.purgeSource(doomedSource); // might release
        }
    };
    EventManager.prototype.removeAllSources = function () {
        this.otherSources = [];
        if (this.currentPeriod) {
            this.currentPeriod.purgeAllSources(); // might release
        }
    };
    // Source Refetching
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.refetchSource = function (eventSource) {
        var currentPeriod = this.currentPeriod;
        if (currentPeriod) {
            currentPeriod.freeze();
            currentPeriod.purgeSource(eventSource);
            currentPeriod.requestSource(eventSource);
            currentPeriod.thaw();
        }
    };
    EventManager.prototype.refetchAllSources = function () {
        var currentPeriod = this.currentPeriod;
        if (currentPeriod) {
            currentPeriod.freeze();
            currentPeriod.purgeAllSources();
            currentPeriod.requestSources(this.getSources());
            currentPeriod.thaw();
        }
    };
    // Source Querying
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.getSources = function () {
        return [this.stickySource].concat(this.otherSources);
    };
    // like querySources, but accepts multple match criteria (like multiple IDs)
    EventManager.prototype.multiQuerySources = function (matchInputs) {
        // coerce into an array
        if (!matchInputs) {
            matchInputs = [];
        }
        else if (!$.isArray(matchInputs)) {
            matchInputs = [matchInputs];
        }
        var matchingSources = [];
        var i;
        // resolve raw inputs to real event source objects
        for (i = 0; i < matchInputs.length; i++) {
            matchingSources.push.apply(// append
            matchingSources, this.querySources(matchInputs[i]));
        }
        return matchingSources;
    };
    // matchInput can either by a real event source object, an ID, or the function/URL for the source.
    // returns an array of matching source objects.
    EventManager.prototype.querySources = function (matchInput) {
        var sources = this.otherSources;
        var i;
        var source;
        // given a proper event source object
        for (i = 0; i < sources.length; i++) {
            source = sources[i];
            if (source === matchInput) {
                return [source];
            }
        }
        // an ID match
        source = this.getSourceById(EventSource_1.default.normalizeId(matchInput));
        if (source) {
            return [source];
        }
        // parse as an event source
        matchInput = EventSourceParser_1.default.parse(matchInput, this.calendar);
        if (matchInput) {
            return $.grep(sources, function (source) {
                return isSourcesEquivalent(matchInput, source);
            });
        }
    };
    /*
    ID assumed to already be normalized
    */
    EventManager.prototype.getSourceById = function (id) {
        return $.grep(this.otherSources, function (source) {
            return source.id && source.id === id;
        })[0];
    };
    // Event-Period
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.setPeriod = function (eventPeriod) {
        if (this.currentPeriod) {
            this.unbindPeriod(this.currentPeriod);
            this.currentPeriod = null;
        }
        this.currentPeriod = eventPeriod;
        this.bindPeriod(eventPeriod);
        eventPeriod.requestSources(this.getSources());
    };
    EventManager.prototype.bindPeriod = function (eventPeriod) {
        this.listenTo(eventPeriod, 'release', function (eventsPayload) {
            this.trigger('release', eventsPayload);
        });
    };
    EventManager.prototype.unbindPeriod = function (eventPeriod) {
        this.stopListeningTo(eventPeriod);
    };
    // Event Getting/Adding/Removing
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.getEventDefByUid = function (uid) {
        if (this.currentPeriod) {
            return this.currentPeriod.getEventDefByUid(uid);
        }
    };
    EventManager.prototype.addEventDef = function (eventDef, isSticky) {
        if (isSticky) {
            this.stickySource.addEventDef(eventDef);
        }
        if (this.currentPeriod) {
            this.currentPeriod.addEventDef(eventDef); // might release
        }
    };
    EventManager.prototype.removeEventDefsById = function (eventId) {
        this.getSources().forEach(function (eventSource) {
            eventSource.removeEventDefsById(eventId);
        });
        if (this.currentPeriod) {
            this.currentPeriod.removeEventDefsById(eventId); // might release
        }
    };
    EventManager.prototype.removeAllEventDefs = function () {
        this.getSources().forEach(function (eventSource) {
            eventSource.removeAllEventDefs();
        });
        if (this.currentPeriod) {
            this.currentPeriod.removeAllEventDefs();
        }
    };
    // Event Mutating
    // -----------------------------------------------------------------------------------------------------------------
    /*
    Returns an undo function.
    */
    EventManager.prototype.mutateEventsWithId = function (eventDefId, eventDefMutation) {
        var currentPeriod = this.currentPeriod;
        var eventDefs;
        var undoFuncs = [];
        if (currentPeriod) {
            currentPeriod.freeze();
            eventDefs = currentPeriod.getEventDefsById(eventDefId);
            eventDefs.forEach(function (eventDef) {
                // add/remove esp because id might change
                currentPeriod.removeEventDef(eventDef);
                undoFuncs.push(eventDefMutation.mutateSingle(eventDef));
                currentPeriod.addEventDef(eventDef);
            });
            currentPeriod.thaw();
            return function () {
                currentPeriod.freeze();
                for (var i = 0; i < eventDefs.length; i++) {
                    currentPeriod.removeEventDef(eventDefs[i]);
                    undoFuncs[i]();
                    currentPeriod.addEventDef(eventDefs[i]);
                }
                currentPeriod.thaw();
            };
        }
        return function () { };
    };
    /*
    copies and then mutates
    */
    EventManager.prototype.buildMutatedEventInstanceGroup = function (eventDefId, eventDefMutation) {
        var eventDefs = this.getEventDefsById(eventDefId);
        var i;
        var defCopy;
        var allInstances = [];
        for (i = 0; i < eventDefs.length; i++) {
            defCopy = eventDefs[i].clone();
            if (defCopy instanceof SingleEventDef_1.default) {
                eventDefMutation.mutateSingle(defCopy);
                allInstances.push.apply(allInstances, // append
                defCopy.buildInstances());
            }
        }
        return new EventInstanceGroup_1.default(allInstances);
    };
    // Freezing
    // -----------------------------------------------------------------------------------------------------------------
    EventManager.prototype.freeze = function () {
        if (this.currentPeriod) {
            this.currentPeriod.freeze();
        }
    };
    EventManager.prototype.thaw = function () {
        if (this.currentPeriod) {
            this.currentPeriod.thaw();
        }
    };
    // methods that simply forward to EventPeriod
    EventManager.prototype.getEventDefsById = function (eventDefId) {
        return this.currentPeriod.getEventDefsById(eventDefId);
    };
    EventManager.prototype.getEventInstances = function () {
        return this.currentPeriod.getEventInstances();
    };
    EventManager.prototype.getEventInstancesWithId = function (eventDefId) {
        return this.currentPeriod.getEventInstancesWithId(eventDefId);
    };
    EventManager.prototype.getEventInstancesWithoutId = function (eventDefId) {
        return this.currentPeriod.getEventInstancesWithoutId(eventDefId);
    };
    return EventManager;
}());
exports.default = EventManager;
EmitterMixin_1.default.mixInto(EventManager);
ListenerMixin_1.default.mixInto(EventManager);
function isSourcesEquivalent(source0, source1) {
    return source0.getPrimitive() === source1.getPrimitive();
}


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Theme_1 = __webpack_require__(22);
var StandardTheme = /** @class */ (function (_super) {
    tslib_1.__extends(StandardTheme, _super);
    function StandardTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return StandardTheme;
}(Theme_1.default));
exports.default = StandardTheme;
StandardTheme.prototype.classes = {
    widget: 'fc-unthemed',
    widgetHeader: 'fc-widget-header',
    widgetContent: 'fc-widget-content',
    buttonGroup: 'fc-button-group',
    button: 'fc-button',
    cornerLeft: 'fc-corner-left',
    cornerRight: 'fc-corner-right',
    stateDefault: 'fc-state-default',
    stateActive: 'fc-state-active',
    stateDisabled: 'fc-state-disabled',
    stateHover: 'fc-state-hover',
    stateDown: 'fc-state-down',
    popoverHeader: 'fc-widget-header',
    popoverContent: 'fc-widget-content',
    // day grid
    headerRow: 'fc-widget-header',
    dayRow: 'fc-widget-content',
    // list view
    listView: 'fc-widget-content'
};
StandardTheme.prototype.baseIconClass = 'fc-icon';
StandardTheme.prototype.iconClasses = {
    close: 'fc-icon-x',
    prev: 'fc-icon-left-single-arrow',
    next: 'fc-icon-right-single-arrow',
    prevYear: 'fc-icon-left-double-arrow',
    nextYear: 'fc-icon-right-double-arrow'
};
StandardTheme.prototype.iconOverrideOption = 'buttonIcons';
StandardTheme.prototype.iconOverrideCustomButtonOption = 'icon';
StandardTheme.prototype.iconOverridePrefix = 'fc-icon-';


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Theme_1 = __webpack_require__(22);
var JqueryUiTheme = /** @class */ (function (_super) {
    tslib_1.__extends(JqueryUiTheme, _super);
    function JqueryUiTheme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return JqueryUiTheme;
}(Theme_1.default));
exports.default = JqueryUiTheme;
JqueryUiTheme.prototype.classes = {
    widget: 'ui-widget',
    widgetHeader: 'ui-widget-header',
    widgetContent: 'ui-widget-content',
    buttonGroup: 'fc-button-group',
    button: 'ui-button',
    cornerLeft: 'ui-corner-left',
    cornerRight: 'ui-corner-right',
    stateDefault: 'ui-state-default',
    stateActive: 'ui-state-active',
    stateDisabled: 'ui-state-disabled',
    stateHover: 'ui-state-hover',
    stateDown: 'ui-state-down',
    today: 'ui-state-highlight',
    popoverHeader: 'ui-widget-header',
    popoverContent: 'ui-widget-content',
    // day grid
    headerRow: 'ui-widget-header',
    dayRow: 'ui-widget-content',
    // list view
    listView: 'ui-widget-content'
};
JqueryUiTheme.prototype.baseIconClass = 'ui-icon';
JqueryUiTheme.prototype.iconClasses = {
    close: 'ui-icon-closethick',
    prev: 'ui-icon-circle-triangle-w',
    next: 'ui-icon-circle-triangle-e',
    prevYear: 'ui-icon-seek-prev',
    nextYear: 'ui-icon-seek-next'
};
JqueryUiTheme.prototype.iconOverrideOption = 'themeButtonIcons';
JqueryUiTheme.prototype.iconOverrideCustomButtonOption = 'themeIcon';
JqueryUiTheme.prototype.iconOverridePrefix = 'ui-icon-';


/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var Promise_1 = __webpack_require__(21);
var EventSource_1 = __webpack_require__(6);
var FuncEventSource = /** @class */ (function (_super) {
    tslib_1.__extends(FuncEventSource, _super);
    function FuncEventSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FuncEventSource.parse = function (rawInput, calendar) {
        var rawProps;
        // normalize raw input
        if ($.isFunction(rawInput.events)) { // extended form
            rawProps = rawInput;
        }
        else if ($.isFunction(rawInput)) { // short form
            rawProps = { events: rawInput };
        }
        if (rawProps) {
            return EventSource_1.default.parse.call(this, rawProps, calendar);
        }
        return false;
    };
    FuncEventSource.prototype.fetch = function (start, end, timezone) {
        var _this = this;
        this.calendar.pushLoading();
        return Promise_1.default.construct(function (onResolve) {
            _this.func.call(_this.calendar, start.clone(), end.clone(), timezone, function (rawEventDefs) {
                _this.calendar.popLoading();
                onResolve(_this.parseEventDefs(rawEventDefs));
            });
        });
    };
    FuncEventSource.prototype.getPrimitive = function () {
        return this.func;
    };
    FuncEventSource.prototype.applyManualStandardProps = function (rawProps) {
        var superSuccess = _super.prototype.applyManualStandardProps.call(this, rawProps);
        this.func = rawProps.events;
        return superSuccess;
    };
    return FuncEventSource;
}(EventSource_1.default));
exports.default = FuncEventSource;
FuncEventSource.defineStandardProps({
    events: false // don't automatically transfer
});


/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var Promise_1 = __webpack_require__(21);
var EventSource_1 = __webpack_require__(6);
var JsonFeedEventSource = /** @class */ (function (_super) {
    tslib_1.__extends(JsonFeedEventSource, _super);
    function JsonFeedEventSource() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    JsonFeedEventSource.parse = function (rawInput, calendar) {
        var rawProps;
        // normalize raw input
        if (typeof rawInput.url === 'string') { // extended form
            rawProps = rawInput;
        }
        else if (typeof rawInput === 'string') { // short form
            rawProps = { url: rawInput };
        }
        if (rawProps) {
            return EventSource_1.default.parse.call(this, rawProps, calendar);
        }
        return false;
    };
    JsonFeedEventSource.prototype.fetch = function (start, end, timezone) {
        var _this = this;
        var ajaxSettings = this.ajaxSettings;
        var onSuccess = ajaxSettings.success;
        var onError = ajaxSettings.error;
        var requestParams = this.buildRequestParams(start, end, timezone);
        // todo: eventually handle the promise's then,
        // don't intercept success/error
        // tho will be a breaking API change
        this.calendar.pushLoading();
        return Promise_1.default.construct(function (onResolve, onReject) {
            $.ajax($.extend({}, // destination
            JsonFeedEventSource.AJAX_DEFAULTS, ajaxSettings, {
                url: _this.url,
                data: requestParams,
                success: function (rawEventDefs, status, xhr) {
                    var callbackRes;
                    _this.calendar.popLoading();
                    if (rawEventDefs) {
                        callbackRes = util_1.applyAll(onSuccess, _this, [rawEventDefs, status, xhr]); // redirect `this`
                        if ($.isArray(callbackRes)) {
                            rawEventDefs = callbackRes;
                        }
                        onResolve(_this.parseEventDefs(rawEventDefs));
                    }
                    else {
                        onReject();
                    }
                },
                error: function (xhr, statusText, errorThrown) {
                    _this.calendar.popLoading();
                    util_1.applyAll(onError, _this, [xhr, statusText, errorThrown]); // redirect `this`
                    onReject();
                }
            }));
        });
    };
    JsonFeedEventSource.prototype.buildRequestParams = function (start, end, timezone) {
        var calendar = this.calendar;
        var ajaxSettings = this.ajaxSettings;
        var startParam;
        var endParam;
        var timezoneParam;
        var customRequestParams;
        var params = {};
        startParam = this.startParam;
        if (startParam == null) {
            startParam = calendar.opt('startParam');
        }
        endParam = this.endParam;
        if (endParam == null) {
            endParam = calendar.opt('endParam');
        }
        timezoneParam = this.timezoneParam;
        if (timezoneParam == null) {
            timezoneParam = calendar.opt('timezoneParam');
        }
        // retrieve any outbound GET/POST $.ajax data from the options
        if ($.isFunction(ajaxSettings.data)) {
            // supplied as a function that returns a key/value object
            customRequestParams = ajaxSettings.data();
        }
        else {
            // probably supplied as a straight key/value object
            customRequestParams = ajaxSettings.data || {};
        }
        $.extend(params, customRequestParams);
        params[startParam] = start.format();
        params[endParam] = end.format();
        if (timezone && timezone !== 'local') {
            params[timezoneParam] = timezone;
        }
        return params;
    };
    JsonFeedEventSource.prototype.getPrimitive = function () {
        return this.url;
    };
    JsonFeedEventSource.prototype.applyMiscProps = function (rawProps) {
        this.ajaxSettings = rawProps;
    };
    JsonFeedEventSource.AJAX_DEFAULTS = {
        dataType: 'json',
        cache: false
    };
    return JsonFeedEventSource;
}(EventSource_1.default));
exports.default = JsonFeedEventSource;
JsonFeedEventSource.defineStandardProps({
    // automatically transfer (true)...
    url: true,
    startParam: true,
    endParam: true,
    timezoneParam: true
});


/***/ }),
/* 225 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });
var Iterator = /** @class */ (function () {
    function Iterator(items) {
        this.items = items || [];
    }
    /* Calls a method on every item passing the arguments through */
    Iterator.prototype.proxyCall = function (methodName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var results = [];
        this.items.forEach(function (item) {
            results.push(item[methodName].apply(item, args));
        });
        return results;
    };
    return Iterator;
}());
exports.default = Iterator;


/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var ListenerMixin_1 = __webpack_require__(7);
/* Creates a clone of an element and lets it track the mouse as it moves
----------------------------------------------------------------------------------------------------------------------*/
var MouseFollower = /** @class */ (function () {
    function MouseFollower(sourceEl, options) {
        this.isFollowing = false;
        this.isHidden = false;
        this.isAnimating = false; // doing the revert animation?
        this.options = options = options || {};
        this.sourceEl = sourceEl;
        this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent
    }
    // Causes the element to start following the mouse
    MouseFollower.prototype.start = function (ev) {
        if (!this.isFollowing) {
            this.isFollowing = true;
            this.y0 = util_1.getEvY(ev);
            this.x0 = util_1.getEvX(ev);
            this.topDelta = 0;
            this.leftDelta = 0;
            if (!this.isHidden) {
                this.updatePosition();
            }
            if (util_1.getEvIsTouch(ev)) {
                this.listenTo($(document), 'touchmove', this.handleMove);
            }
            else {
                this.listenTo($(document), 'mousemove', this.handleMove);
            }
        }
    };
    // Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
    // `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
    MouseFollower.prototype.stop = function (shouldRevert, callback) {
        var _this = this;
        var revertDuration = this.options.revertDuration;
        var complete = function () {
            _this.isAnimating = false;
            _this.removeElement();
            _this.top0 = _this.left0 = null; // reset state for future updatePosition calls
            if (callback) {
                callback();
            }
        };
        if (this.isFollowing && !this.isAnimating) { // disallow more than one stop animation at a time
            this.isFollowing = false;
            this.stopListeningTo($(document));
            if (shouldRevert && revertDuration && !this.isHidden) { // do a revert animation?
                this.isAnimating = true;
                this.el.animate({
                    top: this.top0,
                    left: this.left0
                }, {
                    duration: revertDuration,
                    complete: complete
                });
            }
            else {
                complete();
            }
        }
    };
    // Gets the tracking element. Create it if necessary
    MouseFollower.prototype.getEl = function () {
        var el = this.el;
        if (!el) {
            el = this.el = this.sourceEl.clone()
                .addClass(this.options.additionalClass || '')
                .css({
                position: 'absolute',
                visibility: '',
                display: this.isHidden ? 'none' : '',
                margin: 0,
                right: 'auto',
                bottom: 'auto',
                width: this.sourceEl.width(),
                height: this.sourceEl.height(),
                opacity: this.options.opacity || '',
                zIndex: this.options.zIndex
            });
            // we don't want long taps or any mouse interaction causing selection/menus.
            // would use preventSelection(), but that prevents selectstart, causing problems.
            el.addClass('fc-unselectable');
            el.appendTo(this.parentEl);
        }
        return el;
    };
    // Removes the tracking element if it has already been created
    MouseFollower.prototype.removeElement = function () {
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
    };
    // Update the CSS position of the tracking element
    MouseFollower.prototype.updatePosition = function () {
        var sourceOffset;
        var origin;
        this.getEl(); // ensure this.el
        // make sure origin info was computed
        if (this.top0 == null) {
            sourceOffset = this.sourceEl.offset();
            origin = this.el.offsetParent().offset();
            this.top0 = sourceOffset.top - origin.top;
            this.left0 = sourceOffset.left - origin.left;
        }
        this.el.css({
            top: this.top0 + this.topDelta,
            left: this.left0 + this.leftDelta
        });
    };
    // Gets called when the user moves the mouse
    MouseFollower.prototype.handleMove = function (ev) {
        this.topDelta = util_1.getEvY(ev) - this.y0;
        this.leftDelta = util_1.getEvX(ev) - this.x0;
        if (!this.isHidden) {
            this.updatePosition();
        }
    };
    // Temporarily makes the tracking element invisible. Can be called before following starts
    MouseFollower.prototype.hide = function () {
        if (!this.isHidden) {
            this.isHidden = true;
            if (this.el) {
                this.el.hide();
            }
        }
    };
    // Show the tracking element after it has been temporarily hidden
    MouseFollower.prototype.show = function () {
        if (this.isHidden) {
            this.isHidden = false;
            this.updatePosition();
            this.getEl().show();
        }
    };
    return MouseFollower;
}());
exports.default = MouseFollower;
ListenerMixin_1.default.mixInto(MouseFollower);


/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

/* A rectangular panel that is absolutely positioned over other content
------------------------------------------------------------------------------------------------------------------------
Options:
  - className (string)
  - content (HTML string or jQuery element set)
  - parentEl
  - top
  - left
  - right (the x coord of where the right edge should be. not a "CSS" right)
  - autoHide (boolean)
  - show (callback)
  - hide (callback)
*/
Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var ListenerMixin_1 = __webpack_require__(7);
var Popover = /** @class */ (function () {
    function Popover(options) {
        this.isHidden = true;
        this.margin = 10; // the space required between the popover and the edges of the scroll container
        this.options = options || {};
    }
    // Shows the popover on the specified position. Renders it if not already
    Popover.prototype.show = function () {
        if (this.isHidden) {
            if (!this.el) {
                this.render();
            }
            this.el.show();
            this.position();
            this.isHidden = false;
            this.trigger('show');
        }
    };
    // Hides the popover, through CSS, but does not remove it from the DOM
    Popover.prototype.hide = function () {
        if (!this.isHidden) {
            this.el.hide();
            this.isHidden = true;
            this.trigger('hide');
        }
    };
    // Creates `this.el` and renders content inside of it
    Popover.prototype.render = function () {
        var _this = this;
        var options = this.options;
        this.el = $('<div class="fc-popover">')
            .addClass(options.className || '')
            .css({
            // position initially to the top left to avoid creating scrollbars
            top: 0,
            left: 0
        })
            .append(options.content)
            .appendTo(options.parentEl);
        // when a click happens on anything inside with a 'fc-close' className, hide the popover
        this.el.on('click', '.fc-close', function () {
            _this.hide();
        });
        if (options.autoHide) {
            this.listenTo($(document), 'mousedown', this.documentMousedown);
        }
    };
    // Triggered when the user clicks *anywhere* in the document, for the autoHide feature
    Popover.prototype.documentMousedown = function (ev) {
        // only hide the popover if the click happened outside the popover
        if (this.el && !$(ev.target).closest(this.el).length) {
            this.hide();
        }
    };
    // Hides and unregisters any handlers
    Popover.prototype.removeElement = function () {
        this.hide();
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
        this.stopListeningTo($(document), 'mousedown');
    };
    // Positions the popover optimally, using the top/left/right options
    Popover.prototype.position = function () {
        var options = this.options;
        var origin = this.el.offsetParent().offset();
        var width = this.el.outerWidth();
        var height = this.el.outerHeight();
        var windowEl = $(window);
        var viewportEl = util_1.getScrollParent(this.el);
        var viewportTop;
        var viewportLeft;
        var viewportOffset;
        var top; // the "position" (not "offset") values for the popover
        var left; //
        // compute top and left
        top = options.top || 0;
        if (options.left !== undefined) {
            left = options.left;
        }
        else if (options.right !== undefined) {
            left = options.right - width; // derive the left value from the right value
        }
        else {
            left = 0;
        }
        if (viewportEl.is(window) || viewportEl.is(document)) { // normalize getScrollParent's result
            viewportEl = windowEl;
            viewportTop = 0; // the window is always at the top left
            viewportLeft = 0; // (and .offset() won't work if called here)
        }
        else {
            viewportOffset = viewportEl.offset();
            viewportTop = viewportOffset.top;
            viewportLeft = viewportOffset.left;
        }
        // if the window is scrolled, it causes the visible area to be further down
        viewportTop += windowEl.scrollTop();
        viewportLeft += windowEl.scrollLeft();
        // constrain to the view port. if constrained by two edges, give precedence to top/left
        if (options.viewportConstrain !== false) {
            top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
            top = Math.max(top, viewportTop + this.margin);
            left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
            left = Math.max(left, viewportLeft + this.margin);
        }
        this.el.css({
            top: top - origin.top,
            left: left - origin.left
        });
    };
    // Triggers a callback. Calls a function in the option hash of the same name.
    // Arguments beyond the first `name` are forwarded on.
    // TODO: better code reuse for this. Repeat code
    Popover.prototype.trigger = function (name) {
        if (this.options[name]) {
            this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
        }
    };
    return Popover;
}());
exports.default = Popover;
ListenerMixin_1.default.mixInto(Popover);


/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var EmitterMixin_1 = __webpack_require__(13);
var TaskQueue = /** @class */ (function () {
    function TaskQueue() {
        this.q = [];
        this.isPaused = false;
        this.isRunning = false;
    }
    TaskQueue.prototype.queue = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.q.push.apply(this.q, args); // append
        this.tryStart();
    };
    TaskQueue.prototype.pause = function () {
        this.isPaused = true;
    };
    TaskQueue.prototype.resume = function () {
        this.isPaused = false;
        this.tryStart();
    };
    TaskQueue.prototype.getIsIdle = function () {
        return !this.isRunning && !this.isPaused;
    };
    TaskQueue.prototype.tryStart = function () {
        if (!this.isRunning && this.canRunNext()) {
            this.isRunning = true;
            this.trigger('start');
            this.runRemaining();
        }
    };
    TaskQueue.prototype.canRunNext = function () {
        return !this.isPaused && this.q.length;
    };
    TaskQueue.prototype.runRemaining = function () {
        var _this = this;
        var task;
        var res;
        do {
            task = this.q.shift(); // always freshly reference q. might have been reassigned.
            res = this.runTask(task);
            if (res && res.then) {
                res.then(function () {
                    if (_this.canRunNext()) {
                        _this.runRemaining();
                    }
                });
                return; // prevent marking as stopped
            }
        } while (this.canRunNext());
        this.trigger('stop'); // not really a 'stop' ... more of a 'drained'
        this.isRunning = false;
        // if 'stop' handler added more tasks.... TODO: write test for this
        this.tryStart();
    };
    TaskQueue.prototype.runTask = function (task) {
        return task(); // task *is* the function, but subclasses can change the format of a task
    };
    return TaskQueue;
}());
exports.default = TaskQueue;
EmitterMixin_1.default.mixInto(TaskQueue);


/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var TaskQueue_1 = __webpack_require__(228);
var RenderQueue = /** @class */ (function (_super) {
    tslib_1.__extends(RenderQueue, _super);
    function RenderQueue(waitsByNamespace) {
        var _this = _super.call(this) || this;
        _this.waitsByNamespace = waitsByNamespace || {};
        return _this;
    }
    RenderQueue.prototype.queue = function (taskFunc, namespace, type) {
        var task = {
            func: taskFunc,
            namespace: namespace,
            type: type
        };
        var waitMs;
        if (namespace) {
            waitMs = this.waitsByNamespace[namespace];
        }
        if (this.waitNamespace) {
            if (namespace === this.waitNamespace && waitMs != null) {
                this.delayWait(waitMs);
            }
            else {
                this.clearWait();
                this.tryStart();
            }
        }
        if (this.compoundTask(task)) { // appended to queue?
            if (!this.waitNamespace && waitMs != null) {
                this.startWait(namespace, waitMs);
            }
            else {
                this.tryStart();
            }
        }
    };
    RenderQueue.prototype.startWait = function (namespace, waitMs) {
        this.waitNamespace = namespace;
        this.spawnWait(waitMs);
    };
    RenderQueue.prototype.delayWait = function (waitMs) {
        clearTimeout(this.waitId);
        this.spawnWait(waitMs);
    };
    RenderQueue.prototype.spawnWait = function (waitMs) {
        var _this = this;
        this.waitId = setTimeout(function () {
            _this.waitNamespace = null;
            _this.tryStart();
        }, waitMs);
    };
    RenderQueue.prototype.clearWait = function () {
        if (this.waitNamespace) {
            clearTimeout(this.waitId);
            this.waitId = null;
            this.waitNamespace = null;
        }
    };
    RenderQueue.prototype.canRunNext = function () {
        if (!_super.prototype.canRunNext.call(this)) {
            return false;
        }
        // waiting for a certain namespace to stop receiving tasks?
        if (this.waitNamespace) {
            var q = this.q;
            // if there was a different namespace task in the meantime,
            // that forces all previously-waiting tasks to suddenly execute.
            // TODO: find a way to do this in constant time.
            for (var i = 0; i < q.length; i++) {
                if (q[i].namespace !== this.waitNamespace) {
                    return true; // allow execution
                }
            }
            return false;
        }
        return true;
    };
    RenderQueue.prototype.runTask = function (task) {
        task.func();
    };
    RenderQueue.prototype.compoundTask = function (newTask) {
        var q = this.q;
        var shouldAppend = true;
        var i;
        var task;
        if (newTask.namespace && newTask.type === 'destroy') {
            // remove all init/add/remove ops with same namespace, regardless of order
            for (i = q.length - 1; i >= 0; i--) {
                task = q[i];
                if (task.namespace === newTask.namespace) {
                    switch (task.type) {
                        case 'init':
                            shouldAppend = false;
                        // the latest destroy is cancelled out by not doing the init
                        /* falls through */
                        case 'add':
                        /* falls through */
                        case 'remove':
                            q.splice(i, 1); // remove task
                    }
                }
            }
        }
        if (shouldAppend) {
            q.push(newTask);
        }
        return shouldAppend;
    };
    return RenderQueue;
}(TaskQueue_1.default));
exports.default = RenderQueue;


/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Model_1 = __webpack_require__(51);
var Component = /** @class */ (function (_super) {
    tslib_1.__extends(Component, _super);
    function Component() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Component.prototype.setElement = function (el) {
        this.el = el;
        this.bindGlobalHandlers();
        this.renderSkeleton();
        this.set('isInDom', true);
    };
    Component.prototype.removeElement = function () {
        this.unset('isInDom');
        this.unrenderSkeleton();
        this.unbindGlobalHandlers();
        this.el.remove();
        // NOTE: don't null-out this.el in case the View was destroyed within an API callback.
        // We don't null-out the View's other jQuery element references upon destroy,
        //  so we shouldn't kill this.el either.
    };
    Component.prototype.bindGlobalHandlers = function () {
        // subclasses can override
    };
    Component.prototype.unbindGlobalHandlers = function () {
        // subclasses can override
    };
    /*
    NOTE: Can't have a `render` method. Read the deprecation notice in View::executeDateRender
    */
    // Renders the basic structure of the view before any content is rendered
    Component.prototype.renderSkeleton = function () {
        // subclasses should implement
    };
    // Unrenders the basic structure of the view
    Component.prototype.unrenderSkeleton = function () {
        // subclasses should implement
    };
    return Component;
}(Model_1.default));
exports.default = Component;


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var moment_ext_1 = __webpack_require__(11);
var date_formatting_1 = __webpack_require__(49);
var Component_1 = __webpack_require__(230);
var util_2 = __webpack_require__(19);
var DateComponent = /** @class */ (function (_super) {
    tslib_1.__extends(DateComponent, _super);
    function DateComponent(_view, _options) {
        var _this = _super.call(this) || this;
        _this.isRTL = false; // frequently accessed options
        _this.hitsNeededDepth = 0; // necessary because multiple callers might need the same hits
        _this.hasAllDayBusinessHours = false; // TODO: unify with largeUnit and isTimeScale?
        _this.isDatesRendered = false;
        // hack to set options prior to the this.opt calls
        if (_view) {
            _this['view'] = _view;
        }
        if (_options) {
            _this['options'] = _options;
        }
        _this.uid = String(DateComponent.guid++);
        _this.childrenByUid = {};
        _this.nextDayThreshold = moment.duration(_this.opt('nextDayThreshold'));
        _this.isRTL = _this.opt('isRTL');
        if (_this.fillRendererClass) {
            _this.fillRenderer = new _this.fillRendererClass(_this);
        }
        if (_this.eventRendererClass) { // fillRenderer is optional -----v
            _this.eventRenderer = new _this.eventRendererClass(_this, _this.fillRenderer);
        }
        if (_this.helperRendererClass && _this.eventRenderer) {
            _this.helperRenderer = new _this.helperRendererClass(_this, _this.eventRenderer);
        }
        if (_this.businessHourRendererClass && _this.fillRenderer) {
            _this.businessHourRenderer = new _this.businessHourRendererClass(_this, _this.fillRenderer);
        }
        return _this;
    }
    DateComponent.prototype.addChild = function (child) {
        if (!this.childrenByUid[child.uid]) {
            this.childrenByUid[child.uid] = child;
            return true;
        }
        return false;
    };
    DateComponent.prototype.removeChild = function (child) {
        if (this.childrenByUid[child.uid]) {
            delete this.childrenByUid[child.uid];
            return true;
        }
        return false;
    };
    // TODO: only do if isInDom?
    // TODO: make part of Component, along with children/batch-render system?
    DateComponent.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        this.callChildren('updateSize', arguments);
    };
    // Options
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.opt = function (name) {
        return this._getView().opt(name); // default implementation
    };
    DateComponent.prototype.publiclyTrigger = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var calendar = this._getCalendar();
        return calendar.publiclyTrigger.apply(calendar, args);
    };
    DateComponent.prototype.hasPublicHandlers = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var calendar = this._getCalendar();
        return calendar.hasPublicHandlers.apply(calendar, args);
    };
    // Date
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.executeDateRender = function (dateProfile) {
        this.dateProfile = dateProfile; // for rendering
        this.renderDates(dateProfile);
        this.isDatesRendered = true;
        this.callChildren('executeDateRender', arguments);
    };
    DateComponent.prototype.executeDateUnrender = function () {
        this.callChildren('executeDateUnrender', arguments);
        this.dateProfile = null;
        this.unrenderDates();
        this.isDatesRendered = false;
    };
    // date-cell content only
    DateComponent.prototype.renderDates = function (dateProfile) {
        // subclasses should implement
    };
    // date-cell content only
    DateComponent.prototype.unrenderDates = function () {
        // subclasses should override
    };
    // Now-Indicator
    // -----------------------------------------------------------------------------------------------------------------
    // Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator
    // should be refreshed. If something falsy is returned, no time indicator is rendered at all.
    DateComponent.prototype.getNowIndicatorUnit = function () {
        // subclasses should implement
    };
    // Renders a current time indicator at the given datetime
    DateComponent.prototype.renderNowIndicator = function (date) {
        this.callChildren('renderNowIndicator', arguments);
    };
    // Undoes the rendering actions from renderNowIndicator
    DateComponent.prototype.unrenderNowIndicator = function () {
        this.callChildren('unrenderNowIndicator', arguments);
    };
    // Business Hours
    // ---------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.renderBusinessHours = function (businessHourGenerator) {
        if (this.businessHourRenderer) {
            this.businessHourRenderer.render(businessHourGenerator);
        }
        this.callChildren('renderBusinessHours', arguments);
    };
    // Unrenders previously-rendered business-hours
    DateComponent.prototype.unrenderBusinessHours = function () {
        this.callChildren('unrenderBusinessHours', arguments);
        if (this.businessHourRenderer) {
            this.businessHourRenderer.unrender();
        }
    };
    // Event Displaying
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.executeEventRender = function (eventsPayload) {
        if (this.eventRenderer) {
            this.eventRenderer.rangeUpdated(); // poorly named now
            this.eventRenderer.render(eventsPayload);
        }
        else if (this['renderEvents']) { // legacy
            this['renderEvents'](convertEventsPayloadToLegacyArray(eventsPayload));
        }
        this.callChildren('executeEventRender', arguments);
    };
    DateComponent.prototype.executeEventUnrender = function () {
        this.callChildren('executeEventUnrender', arguments);
        if (this.eventRenderer) {
            this.eventRenderer.unrender();
        }
        else if (this['destroyEvents']) { // legacy
            this['destroyEvents']();
        }
    };
    DateComponent.prototype.getBusinessHourSegs = function () {
        var segs = this.getOwnBusinessHourSegs();
        this.iterChildren(function (child) {
            segs.push.apply(segs, child.getBusinessHourSegs());
        });
        return segs;
    };
    DateComponent.prototype.getOwnBusinessHourSegs = function () {
        if (this.businessHourRenderer) {
            return this.businessHourRenderer.getSegs();
        }
        return [];
    };
    DateComponent.prototype.getEventSegs = function () {
        var segs = this.getOwnEventSegs();
        this.iterChildren(function (child) {
            segs.push.apply(segs, child.getEventSegs());
        });
        return segs;
    };
    DateComponent.prototype.getOwnEventSegs = function () {
        if (this.eventRenderer) {
            return this.eventRenderer.getSegs();
        }
        return [];
    };
    // Event Rendering Triggering
    // -----------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.triggerAfterEventsRendered = function () {
        this.triggerAfterEventSegsRendered(this.getEventSegs());
        this.publiclyTrigger('eventAfterAllRender', {
            context: this,
            args: [this]
        });
    };
    DateComponent.prototype.triggerAfterEventSegsRendered = function (segs) {
        var _this = this;
        // an optimization, because getEventLegacy is expensive
        if (this.hasPublicHandlers('eventAfterRender')) {
            segs.forEach(function (seg) {
                var legacy;
                if (seg.el) { // necessary?
                    legacy = seg.footprint.getEventLegacy();
                    _this.publiclyTrigger('eventAfterRender', {
                        context: legacy,
                        args: [legacy, seg.el, _this]
                    });
                }
            });
        }
    };
    DateComponent.prototype.triggerBeforeEventsDestroyed = function () {
        this.triggerBeforeEventSegsDestroyed(this.getEventSegs());
    };
    DateComponent.prototype.triggerBeforeEventSegsDestroyed = function (segs) {
        var _this = this;
        if (this.hasPublicHandlers('eventDestroy')) {
            segs.forEach(function (seg) {
                var legacy;
                if (seg.el) { // necessary?
                    legacy = seg.footprint.getEventLegacy();
                    _this.publiclyTrigger('eventDestroy', {
                        context: legacy,
                        args: [legacy, seg.el, _this]
                    });
                }
            });
        }
    };
    // Event Rendering Utils
    // -----------------------------------------------------------------------------------------------------------------
    // Hides all rendered event segments linked to the given event
    // RECURSIVE with subcomponents
    DateComponent.prototype.showEventsWithId = function (eventDefId) {
        this.getEventSegs().forEach(function (seg) {
            if (seg.footprint.eventDef.id === eventDefId &&
                seg.el // necessary?
            ) {
                seg.el.css('visibility', '');
            }
        });
        this.callChildren('showEventsWithId', arguments);
    };
    // Shows all rendered event segments linked to the given event
    // RECURSIVE with subcomponents
    DateComponent.prototype.hideEventsWithId = function (eventDefId) {
        this.getEventSegs().forEach(function (seg) {
            if (seg.footprint.eventDef.id === eventDefId &&
                seg.el // necessary?
            ) {
                seg.el.css('visibility', 'hidden');
            }
        });
        this.callChildren('hideEventsWithId', arguments);
    };
    // Drag-n-Drop Rendering (for both events and external elements)
    // ---------------------------------------------------------------------------------------------------------------
    // Renders a visual indication of a event or external-element drag over the given drop zone.
    // If an external-element, seg will be `null`.
    // Must return elements used for any mock events.
    DateComponent.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var renderedHelper = false;
        this.iterChildren(function (child) {
            if (child.renderDrag(eventFootprints, seg, isTouch)) {
                renderedHelper = true;
            }
        });
        return renderedHelper;
    };
    // Unrenders a visual indication of an event or external-element being dragged.
    DateComponent.prototype.unrenderDrag = function () {
        this.callChildren('unrenderDrag', arguments);
    };
    // Event Resizing
    // ---------------------------------------------------------------------------------------------------------------
    // Renders a visual indication of an event being resized.
    DateComponent.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        this.callChildren('renderEventResize', arguments);
    };
    // Unrenders a visual indication of an event being resized.
    DateComponent.prototype.unrenderEventResize = function () {
        this.callChildren('unrenderEventResize', arguments);
    };
    // Selection
    // ---------------------------------------------------------------------------------------------------------------
    // Renders a visual indication of the selection
    // TODO: rename to `renderSelection` after legacy is gone
    DateComponent.prototype.renderSelectionFootprint = function (componentFootprint) {
        this.renderHighlight(componentFootprint);
        this.callChildren('renderSelectionFootprint', arguments);
    };
    // Unrenders a visual indication of selection
    DateComponent.prototype.unrenderSelection = function () {
        this.unrenderHighlight();
        this.callChildren('unrenderSelection', arguments);
    };
    // Highlight
    // ---------------------------------------------------------------------------------------------------------------
    // Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)
    DateComponent.prototype.renderHighlight = function (componentFootprint) {
        if (this.fillRenderer) {
            this.fillRenderer.renderFootprint('highlight', componentFootprint, {
                getClasses: function () {
                    return ['fc-highlight'];
                }
            });
        }
        this.callChildren('renderHighlight', arguments);
    };
    // Unrenders the emphasis on a date range
    DateComponent.prototype.unrenderHighlight = function () {
        if (this.fillRenderer) {
            this.fillRenderer.unrender('highlight');
        }
        this.callChildren('unrenderHighlight', arguments);
    };
    // Hit Areas
    // ---------------------------------------------------------------------------------------------------------------
    // just because all DateComponents support this interface
    // doesn't mean they need to have their own internal coord system. they can defer to sub-components.
    DateComponent.prototype.hitsNeeded = function () {
        if (!(this.hitsNeededDepth++)) {
            this.prepareHits();
        }
        this.callChildren('hitsNeeded', arguments);
    };
    DateComponent.prototype.hitsNotNeeded = function () {
        if (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {
            this.releaseHits();
        }
        this.callChildren('hitsNotNeeded', arguments);
    };
    DateComponent.prototype.prepareHits = function () {
        // subclasses can implement
    };
    DateComponent.prototype.releaseHits = function () {
        // subclasses can implement
    };
    // Given coordinates from the topleft of the document, return data about the date-related area underneath.
    // Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).
    // Must have a `grid` property, a reference to this current grid. TODO: avoid this
    // The returned object will be processed by getHitFootprint and getHitEl.
    DateComponent.prototype.queryHit = function (leftOffset, topOffset) {
        var childrenByUid = this.childrenByUid;
        var uid;
        var hit;
        for (uid in childrenByUid) {
            hit = childrenByUid[uid].queryHit(leftOffset, topOffset);
            if (hit) {
                break;
            }
        }
        return hit;
    };
    DateComponent.prototype.getSafeHitFootprint = function (hit) {
        var footprint = this.getHitFootprint(hit);
        if (!this.dateProfile.activeUnzonedRange.containsRange(footprint.unzonedRange)) {
            return null;
        }
        return footprint;
    };
    DateComponent.prototype.getHitFootprint = function (hit) {
        // what about being abstract!?
    };
    // Given position-level information about a date-related area within the grid,
    // should return a jQuery element that best represents it. passed to dayClick callback.
    DateComponent.prototype.getHitEl = function (hit) {
        // what about being abstract!?
    };
    /* Converting eventRange -> eventFootprint
    ------------------------------------------------------------------------------------------------------------------*/
    DateComponent.prototype.eventRangesToEventFootprints = function (eventRanges) {
        var eventFootprints = [];
        var i;
        for (i = 0; i < eventRanges.length; i++) {
            eventFootprints.push.apply(// append
            eventFootprints, this.eventRangeToEventFootprints(eventRanges[i]));
        }
        return eventFootprints;
    };
    DateComponent.prototype.eventRangeToEventFootprints = function (eventRange) {
        return [util_2.eventRangeToEventFootprint(eventRange)];
    };
    /* Converting componentFootprint/eventFootprint -> segs
    ------------------------------------------------------------------------------------------------------------------*/
    DateComponent.prototype.eventFootprintsToSegs = function (eventFootprints) {
        var segs = [];
        var i;
        for (i = 0; i < eventFootprints.length; i++) {
            segs.push.apply(segs, this.eventFootprintToSegs(eventFootprints[i]));
        }
        return segs;
    };
    // Given an event's span (unzoned start/end and other misc data), and the event itself,
    // slices into segments and attaches event-derived properties to them.
    // eventSpan - { start, end, isStart, isEnd, otherthings... }
    DateComponent.prototype.eventFootprintToSegs = function (eventFootprint) {
        var unzonedRange = eventFootprint.componentFootprint.unzonedRange;
        var segs;
        var i;
        var seg;
        segs = this.componentFootprintToSegs(eventFootprint.componentFootprint);
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (!unzonedRange.isStart) {
                seg.isStart = false;
            }
            if (!unzonedRange.isEnd) {
                seg.isEnd = false;
            }
            seg.footprint = eventFootprint;
            // TODO: rename to seg.eventFootprint
        }
        return segs;
    };
    DateComponent.prototype.componentFootprintToSegs = function (componentFootprint) {
        return [];
    };
    // Utils
    // ---------------------------------------------------------------------------------------------------------------
    DateComponent.prototype.callChildren = function (methodName, args) {
        this.iterChildren(function (child) {
            child[methodName].apply(child, args);
        });
    };
    DateComponent.prototype.iterChildren = function (func) {
        var childrenByUid = this.childrenByUid;
        var uid;
        for (uid in childrenByUid) {
            func(childrenByUid[uid]);
        }
    };
    DateComponent.prototype._getCalendar = function () {
        var t = this;
        return t.calendar || t.view.calendar;
    };
    DateComponent.prototype._getView = function () {
        return this.view;
    };
    DateComponent.prototype._getDateProfile = function () {
        return this._getView().get('dateProfile');
    };
    // Generates HTML for an anchor to another view into the calendar.
    // Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.
    // `gotoOptions` can either be a moment input, or an object with the form:
    // { date, type, forceOff }
    // `type` is a view-type like "day" or "week". default value is "day".
    // `attrs` and `innerHtml` are use to generate the rest of the HTML tag.
    DateComponent.prototype.buildGotoAnchorHtml = function (gotoOptions, attrs, innerHtml) {
        var date;
        var type;
        var forceOff;
        var finalOptions;
        if ($.isPlainObject(gotoOptions)) {
            date = gotoOptions.date;
            type = gotoOptions.type;
            forceOff = gotoOptions.forceOff;
        }
        else {
            date = gotoOptions; // a single moment input
        }
        date = moment_ext_1.default(date); // if a string, parse it
        finalOptions = {
            date: date.format('YYYY-MM-DD'),
            type: type || 'day'
        };
        if (typeof attrs === 'string') {
            innerHtml = attrs;
            attrs = null;
        }
        attrs = attrs ? ' ' + util_1.attrsToStr(attrs) : ''; // will have a leading space
        innerHtml = innerHtml || '';
        if (!forceOff && this.opt('navLinks')) {
            return '<a' + attrs +
                ' data-goto="' + util_1.htmlEscape(JSON.stringify(finalOptions)) + '">' +
                innerHtml +
                '</a>';
        }
        else {
            return '<span' + attrs + '>' +
                innerHtml +
                '</span>';
        }
    };
    DateComponent.prototype.getAllDayHtml = function () {
        return this.opt('allDayHtml') || util_1.htmlEscape(this.opt('allDayText'));
    };
    // Computes HTML classNames for a single-day element
    DateComponent.prototype.getDayClasses = function (date, noThemeHighlight) {
        var view = this._getView();
        var classes = [];
        var today;
        if (!this.dateProfile.activeUnzonedRange.containsDate(date)) {
            classes.push('fc-disabled-day'); // TODO: jQuery UI theme?
        }
        else {
            classes.push('fc-' + util_1.dayIDs[date.day()]);
            if (view.isDateInOtherMonth(date, this.dateProfile)) { // TODO: use DateComponent subclass somehow
                classes.push('fc-other-month');
            }
            today = view.calendar.getNow();
            if (date.isSame(today, 'day')) {
                classes.push('fc-today');
                if (noThemeHighlight !== true) {
                    classes.push(view.calendar.theme.getClass('today'));
                }
            }
            else if (date < today) {
                classes.push('fc-past');
            }
            else {
                classes.push('fc-future');
            }
        }
        return classes;
    };
    // Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
    // Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
    // The timezones of the dates within `range` will be respected.
    DateComponent.prototype.formatRange = function (range, isAllDay, formatStr, separator) {
        var end = range.end;
        if (isAllDay) {
            end = end.clone().subtract(1); // convert to inclusive. last ms of previous day
        }
        return date_formatting_1.formatRange(range.start, end, formatStr, separator, this.isRTL);
    };
    // Compute the number of the give units in the "current" range.
    // Will return a floating-point number. Won't round.
    DateComponent.prototype.currentRangeAs = function (unit) {
        return this._getDateProfile().currentUnzonedRange.as(unit);
    };
    // Returns the date range of the full days the given range visually appears to occupy.
    // Returns a plain object with start/end, NOT an UnzonedRange!
    DateComponent.prototype.computeDayRange = function (unzonedRange) {
        var calendar = this._getCalendar();
        var startDay = calendar.msToUtcMoment(unzonedRange.startMs, true); // the beginning of the day the range starts
        var end = calendar.msToUtcMoment(unzonedRange.endMs);
        var endTimeMS = +end.time(); // # of milliseconds into `endDay`
        var endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends
        // If the end time is actually inclusively part of the next day and is equal to or
        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
        if (endTimeMS && endTimeMS >= this.nextDayThreshold) {
            endDay.add(1, 'days');
        }
        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.
        if (endDay <= startDay) {
            endDay = startDay.clone().add(1, 'days');
        }
        return { start: startDay, end: endDay };
    };
    // Does the given range visually appear to occupy more than one day?
    DateComponent.prototype.isMultiDayRange = function (unzonedRange) {
        var dayRange = this.computeDayRange(unzonedRange);
        return dayRange.end.diff(dayRange.start, 'days') > 1;
    };
    DateComponent.guid = 0; // TODO: better system for this?
    return DateComponent;
}(Component_1.default));
exports.default = DateComponent;
// legacy
function convertEventsPayloadToLegacyArray(eventsPayload) {
    var eventDefId;
    var eventInstances;
    var legacyEvents = [];
    var i;
    for (eventDefId in eventsPayload) {
        eventInstances = eventsPayload[eventDefId].eventInstances;
        for (i = 0; i < eventInstances.length; i++) {
            legacyEvents.push(eventInstances[i].toLegacy());
        }
    }
    return legacyEvents;
}


/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var options_1 = __webpack_require__(33);
var Iterator_1 = __webpack_require__(225);
var GlobalEmitter_1 = __webpack_require__(23);
var EmitterMixin_1 = __webpack_require__(13);
var ListenerMixin_1 = __webpack_require__(7);
var Toolbar_1 = __webpack_require__(257);
var OptionsManager_1 = __webpack_require__(258);
var ViewSpecManager_1 = __webpack_require__(259);
var Constraints_1 = __webpack_require__(217);
var locale_1 = __webpack_require__(32);
var moment_ext_1 = __webpack_require__(11);
var UnzonedRange_1 = __webpack_require__(5);
var ComponentFootprint_1 = __webpack_require__(12);
var EventDateProfile_1 = __webpack_require__(16);
var EventManager_1 = __webpack_require__(220);
var BusinessHourGenerator_1 = __webpack_require__(218);
var EventSourceParser_1 = __webpack_require__(38);
var EventDefParser_1 = __webpack_require__(36);
var SingleEventDef_1 = __webpack_require__(9);
var EventDefMutation_1 = __webpack_require__(39);
var EventSource_1 = __webpack_require__(6);
var ThemeRegistry_1 = __webpack_require__(57);
var Calendar = /** @class */ (function () {
    function Calendar(el, overrides) {
        this.loadingLevel = 0; // number of simultaneous loading tasks
        this.ignoreUpdateViewSize = 0;
        this.freezeContentHeightDepth = 0;
        // declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.
        // unneeded() is called in destroy.
        GlobalEmitter_1.default.needed();
        this.el = el;
        this.viewsByType = {};
        this.optionsManager = new OptionsManager_1.default(this, overrides);
        this.viewSpecManager = new ViewSpecManager_1.default(this.optionsManager, this);
        this.initMomentInternals(); // needs to happen after options hash initialized
        this.initCurrentDate();
        this.initEventManager();
        this.constraints = new Constraints_1.default(this.eventManager, this);
        this.constructed();
    }
    Calendar.prototype.constructed = function () {
        // useful for monkeypatching. used?
    };
    Calendar.prototype.getView = function () {
        return this.view;
    };
    Calendar.prototype.publiclyTrigger = function (name, triggerInfo) {
        var optHandler = this.opt(name);
        var context;
        var args;
        if ($.isPlainObject(triggerInfo)) {
            context = triggerInfo.context;
            args = triggerInfo.args;
        }
        else if ($.isArray(triggerInfo)) {
            args = triggerInfo;
        }
        if (context == null) {
            context = this.el[0]; // fallback context
        }
        if (!args) {
            args = [];
        }
        this.triggerWith(name, context, args); // Emitter's method
        if (optHandler) {
            return optHandler.apply(context, args);
        }
    };
    Calendar.prototype.hasPublicHandlers = function (name) {
        return this.hasHandlers(name) ||
            this.opt(name); // handler specified in options
    };
    // Options Public API
    // -----------------------------------------------------------------------------------------------------------------
    // public getter/setter
    Calendar.prototype.option = function (name, value) {
        var newOptionHash;
        if (typeof name === 'string') {
            if (value === undefined) { // getter
                return this.optionsManager.get(name);
            }
            else { // setter for individual option
                newOptionHash = {};
                newOptionHash[name] = value;
                this.optionsManager.add(newOptionHash);
            }
        }
        else if (typeof name === 'object') { // compound setter with object input
            this.optionsManager.add(name);
        }
    };
    // private getter
    Calendar.prototype.opt = function (name) {
        return this.optionsManager.get(name);
    };
    // View
    // -----------------------------------------------------------------------------------------------------------------
    // Given a view name for a custom view or a standard view, creates a ready-to-go View object
    Calendar.prototype.instantiateView = function (viewType) {
        var spec = this.viewSpecManager.getViewSpec(viewType);
        if (!spec) {
            throw new Error("View type \"" + viewType + "\" is not valid");
        }
        return new spec['class'](this, spec);
    };
    // Returns a boolean about whether the view is okay to instantiate at some point
    Calendar.prototype.isValidViewType = function (viewType) {
        return Boolean(this.viewSpecManager.getViewSpec(viewType));
    };
    Calendar.prototype.changeView = function (viewName, dateOrRange) {
        if (dateOrRange) {
            if (dateOrRange.start && dateOrRange.end) { // a range
                this.optionsManager.recordOverrides({
                    visibleRange: dateOrRange
                });
            }
            else { // a date
                this.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate
            }
        }
        this.renderView(viewName);
    };
    // Forces navigation to a view for the given date.
    // `viewType` can be a specific view name or a generic one like "week" or "day".
    Calendar.prototype.zoomTo = function (newDate, viewType) {
        var spec;
        viewType = viewType || 'day'; // day is default zoom
        spec = this.viewSpecManager.getViewSpec(viewType) ||
            this.viewSpecManager.getUnitViewSpec(viewType);
        this.currentDate = newDate.clone();
        this.renderView(spec ? spec.type : null);
    };
    // Current Date
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initCurrentDate = function () {
        var defaultDateInput = this.opt('defaultDate');
        // compute the initial ambig-timezone date
        if (defaultDateInput != null) {
            this.currentDate = this.moment(defaultDateInput).stripZone();
        }
        else {
            this.currentDate = this.getNow(); // getNow already returns unzoned
        }
    };
    Calendar.prototype.prev = function () {
        var view = this.view;
        var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));
        if (prevInfo.isValid) {
            this.currentDate = prevInfo.date;
            this.renderView();
        }
    };
    Calendar.prototype.next = function () {
        var view = this.view;
        var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));
        if (nextInfo.isValid) {
            this.currentDate = nextInfo.date;
            this.renderView();
        }
    };
    Calendar.prototype.prevYear = function () {
        this.currentDate.add(-1, 'years');
        this.renderView();
    };
    Calendar.prototype.nextYear = function () {
        this.currentDate.add(1, 'years');
        this.renderView();
    };
    Calendar.prototype.today = function () {
        this.currentDate = this.getNow(); // should deny like prev/next?
        this.renderView();
    };
    Calendar.prototype.gotoDate = function (zonedDateInput) {
        this.currentDate = this.moment(zonedDateInput).stripZone();
        this.renderView();
    };
    Calendar.prototype.incrementDate = function (delta) {
        this.currentDate.add(moment.duration(delta));
        this.renderView();
    };
    // for external API
    Calendar.prototype.getDate = function () {
        return this.applyTimezone(this.currentDate); // infuse the calendar's timezone
    };
    // Loading Triggering
    // -----------------------------------------------------------------------------------------------------------------
    // Should be called when any type of async data fetching begins
    Calendar.prototype.pushLoading = function () {
        if (!(this.loadingLevel++)) {
            this.publiclyTrigger('loading', [true, this.view]);
        }
    };
    // Should be called when any type of async data fetching completes
    Calendar.prototype.popLoading = function () {
        if (!(--this.loadingLevel)) {
            this.publiclyTrigger('loading', [false, this.view]);
        }
    };
    // High-level Rendering
    // -----------------------------------------------------------------------------------
    Calendar.prototype.render = function () {
        if (!this.contentEl) {
            this.initialRender();
        }
        else if (this.elementVisible()) {
            // mainly for the public API
            this.calcSize();
            this.updateViewSize();
        }
    };
    Calendar.prototype.initialRender = function () {
        var _this = this;
        var el = this.el;
        el.addClass('fc');
        // event delegation for nav links
        el.on('click.fc', 'a[data-goto]', function (ev) {
            var anchorEl = $(ev.currentTarget);
            var gotoOptions = anchorEl.data('goto'); // will automatically parse JSON
            var date = _this.moment(gotoOptions.date);
            var viewType = gotoOptions.type;
            // property like "navLinkDayClick". might be a string or a function
            var customAction = _this.view.opt('navLink' + util_1.capitaliseFirstLetter(viewType) + 'Click');
            if (typeof customAction === 'function') {
                customAction(date, ev);
            }
            else {
                if (typeof customAction === 'string') {
                    viewType = customAction;
                }
                _this.zoomTo(date, viewType);
            }
        });
        // called immediately, and upon option change
        this.optionsManager.watch('settingTheme', ['?theme', '?themeSystem'], function (opts) {
            var themeClass = ThemeRegistry_1.getThemeSystemClass(opts.themeSystem || opts.theme);
            var theme = new themeClass(_this.optionsManager);
            var widgetClass = theme.getClass('widget');
            _this.theme = theme;
            if (widgetClass) {
                el.addClass(widgetClass);
            }
        }, function () {
            var widgetClass = _this.theme.getClass('widget');
            _this.theme = null;
            if (widgetClass) {
                el.removeClass(widgetClass);
            }
        });
        this.optionsManager.watch('settingBusinessHourGenerator', ['?businessHours'], function (deps) {
            _this.businessHourGenerator = new BusinessHourGenerator_1.default(deps.businessHours, _this);
            if (_this.view) {
                _this.view.set('businessHourGenerator', _this.businessHourGenerator);
            }
        }, function () {
            _this.businessHourGenerator = null;
        });
        // called immediately, and upon option change.
        // HACK: locale often affects isRTL, so we explicitly listen to that too.
        this.optionsManager.watch('applyingDirClasses', ['?isRTL', '?locale'], function (opts) {
            el.toggleClass('fc-ltr', !opts.isRTL);
            el.toggleClass('fc-rtl', opts.isRTL);
        });
        this.contentEl = $("<div class='fc-view-container'>").prependTo(el);
        this.initToolbars();
        this.renderHeader();
        this.renderFooter();
        this.renderView(this.opt('defaultView'));
        if (this.opt('handleWindowResize')) {
            $(window).resize(this.windowResizeProxy = util_1.debounce(// prevents rapid calls
            this.windowResize.bind(this), this.opt('windowResizeDelay')));
        }
    };
    Calendar.prototype.destroy = function () {
        if (this.view) {
            this.clearView();
        }
        this.toolbarsManager.proxyCall('removeElement');
        this.contentEl.remove();
        this.el.removeClass('fc fc-ltr fc-rtl');
        // removes theme-related root className
        this.optionsManager.unwatch('settingTheme');
        this.optionsManager.unwatch('settingBusinessHourGenerator');
        this.el.off('.fc'); // unbind nav link handlers
        if (this.windowResizeProxy) {
            $(window).unbind('resize', this.windowResizeProxy);
            this.windowResizeProxy = null;
        }
        GlobalEmitter_1.default.unneeded();
    };
    Calendar.prototype.elementVisible = function () {
        return this.el.is(':visible');
    };
    // Render Queue
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.bindViewHandlers = function (view) {
        var _this = this;
        view.watch('titleForCalendar', ['title'], function (deps) {
            if (view === _this.view) { // hack
                _this.setToolbarsTitle(deps.title);
            }
        });
        view.watch('dateProfileForCalendar', ['dateProfile'], function (deps) {
            if (view === _this.view) { // hack
                _this.currentDate = deps.dateProfile.date; // might have been constrained by view dates
                _this.updateToolbarButtons(deps.dateProfile);
            }
        });
    };
    Calendar.prototype.unbindViewHandlers = function (view) {
        view.unwatch('titleForCalendar');
        view.unwatch('dateProfileForCalendar');
    };
    // View Rendering
    // -----------------------------------------------------------------------------------
    // Renders a view because of a date change, view-type change, or for the first time.
    // If not given a viewType, keep the current view but render different dates.
    // Accepts an optional scroll state to restore to.
    Calendar.prototype.renderView = function (viewType) {
        var oldView = this.view;
        var newView;
        this.freezeContentHeight();
        if (oldView && viewType && oldView.type !== viewType) {
            this.clearView();
        }
        // if viewType changed, or the view was never created, create a fresh view
        if (!this.view && viewType) {
            newView = this.view =
                this.viewsByType[viewType] ||
                    (this.viewsByType[viewType] = this.instantiateView(viewType));
            this.bindViewHandlers(newView);
            newView.startBatchRender(); // so that setElement+setDate rendering are joined
            newView.setElement($("<div class='fc-view fc-" + viewType + "-view'>").appendTo(this.contentEl));
            this.toolbarsManager.proxyCall('activateButton', viewType);
        }
        if (this.view) {
            // prevent unnecessary change firing
            if (this.view.get('businessHourGenerator') !== this.businessHourGenerator) {
                this.view.set('businessHourGenerator', this.businessHourGenerator);
            }
            this.view.setDate(this.currentDate);
            if (newView) {
                newView.stopBatchRender();
            }
        }
        this.thawContentHeight();
    };
    // Unrenders the current view and reflects this change in the Header.
    // Unregsiters the `view`, but does not remove from viewByType hash.
    Calendar.prototype.clearView = function () {
        var currentView = this.view;
        this.toolbarsManager.proxyCall('deactivateButton', currentView.type);
        this.unbindViewHandlers(currentView);
        currentView.removeElement();
        currentView.unsetDate(); // so bindViewHandlers doesn't fire with old values next time
        this.view = null;
    };
    // Destroys the view, including the view object. Then, re-instantiates it and renders it.
    // Maintains the same scroll state.
    // TODO: maintain any other user-manipulated state.
    Calendar.prototype.reinitView = function () {
        var oldView = this.view;
        var scroll = oldView.queryScroll(); // wouldn't be so complicated if Calendar owned the scroll
        this.freezeContentHeight();
        this.clearView();
        this.calcSize();
        this.renderView(oldView.type); // needs the type to freshly render
        this.view.applyScroll(scroll);
        this.thawContentHeight();
    };
    // Resizing
    // -----------------------------------------------------------------------------------
    Calendar.prototype.getSuggestedViewHeight = function () {
        if (this.suggestedViewHeight == null) {
            this.calcSize();
        }
        return this.suggestedViewHeight;
    };
    Calendar.prototype.isHeightAuto = function () {
        return this.opt('contentHeight') === 'auto' || this.opt('height') === 'auto';
    };
    Calendar.prototype.updateViewSize = function (isResize) {
        if (isResize === void 0) { isResize = false; }
        var view = this.view;
        var scroll;
        if (!this.ignoreUpdateViewSize && view) {
            if (isResize) {
                this.calcSize();
                scroll = view.queryScroll();
            }
            this.ignoreUpdateViewSize++;
            view.updateSize(this.getSuggestedViewHeight(), this.isHeightAuto(), isResize);
            this.ignoreUpdateViewSize--;
            if (isResize) {
                view.applyScroll(scroll);
            }
            return true; // signal success
        }
    };
    Calendar.prototype.calcSize = function () {
        if (this.elementVisible()) {
            this._calcSize();
        }
    };
    Calendar.prototype._calcSize = function () {
        var contentHeightInput = this.opt('contentHeight');
        var heightInput = this.opt('height');
        if (typeof contentHeightInput === 'number') { // exists and not 'auto'
            this.suggestedViewHeight = contentHeightInput;
        }
        else if (typeof contentHeightInput === 'function') { // exists and is a function
            this.suggestedViewHeight = contentHeightInput();
        }
        else if (typeof heightInput === 'number') { // exists and not 'auto'
            this.suggestedViewHeight = heightInput - this.queryToolbarsHeight();
        }
        else if (typeof heightInput === 'function') { // exists and is a function
            this.suggestedViewHeight = heightInput() - this.queryToolbarsHeight();
        }
        else if (heightInput === 'parent') { // set to height of parent element
            this.suggestedViewHeight = this.el.parent().height() - this.queryToolbarsHeight();
        }
        else {
            this.suggestedViewHeight = Math.round(this.contentEl.width() /
                Math.max(this.opt('aspectRatio'), .5));
        }
    };
    Calendar.prototype.windowResize = function (ev) {
        if (
        // the purpose: so we don't process jqui "resize" events that have bubbled up
        // cast to any because .target, which is Element, can't be compared to window for some reason.
        ev.target === window &&
            this.view &&
            this.view.isDatesRendered) {
            if (this.updateViewSize(true)) { // isResize=true, returns true on success
                this.publiclyTrigger('windowResize', [this.view]);
            }
        }
    };
    /* Height "Freezing"
    -----------------------------------------------------------------------------*/
    Calendar.prototype.freezeContentHeight = function () {
        if (!(this.freezeContentHeightDepth++)) {
            this.forceFreezeContentHeight();
        }
    };
    Calendar.prototype.forceFreezeContentHeight = function () {
        this.contentEl.css({
            width: '100%',
            height: this.contentEl.height(),
            overflow: 'hidden'
        });
    };
    Calendar.prototype.thawContentHeight = function () {
        this.freezeContentHeightDepth--;
        // always bring back to natural height
        this.contentEl.css({
            width: '',
            height: '',
            overflow: ''
        });
        // but if there are future thaws, re-freeze
        if (this.freezeContentHeightDepth) {
            this.forceFreezeContentHeight();
        }
    };
    // Toolbar
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initToolbars = function () {
        this.header = new Toolbar_1.default(this, this.computeHeaderOptions());
        this.footer = new Toolbar_1.default(this, this.computeFooterOptions());
        this.toolbarsManager = new Iterator_1.default([this.header, this.footer]);
    };
    Calendar.prototype.computeHeaderOptions = function () {
        return {
            extraClasses: 'fc-header-toolbar',
            layout: this.opt('header')
        };
    };
    Calendar.prototype.computeFooterOptions = function () {
        return {
            extraClasses: 'fc-footer-toolbar',
            layout: this.opt('footer')
        };
    };
    // can be called repeatedly and Header will rerender
    Calendar.prototype.renderHeader = function () {
        var header = this.header;
        header.setToolbarOptions(this.computeHeaderOptions());
        header.render();
        if (header.el) {
            this.el.prepend(header.el);
        }
    };
    // can be called repeatedly and Footer will rerender
    Calendar.prototype.renderFooter = function () {
        var footer = this.footer;
        footer.setToolbarOptions(this.computeFooterOptions());
        footer.render();
        if (footer.el) {
            this.el.append(footer.el);
        }
    };
    Calendar.prototype.setToolbarsTitle = function (title) {
        this.toolbarsManager.proxyCall('updateTitle', title);
    };
    Calendar.prototype.updateToolbarButtons = function (dateProfile) {
        var now = this.getNow();
        var view = this.view;
        var todayInfo = view.dateProfileGenerator.build(now);
        var prevInfo = view.dateProfileGenerator.buildPrev(view.get('dateProfile'));
        var nextInfo = view.dateProfileGenerator.buildNext(view.get('dateProfile'));
        this.toolbarsManager.proxyCall((todayInfo.isValid && !dateProfile.currentUnzonedRange.containsDate(now)) ?
            'enableButton' :
            'disableButton', 'today');
        this.toolbarsManager.proxyCall(prevInfo.isValid ?
            'enableButton' :
            'disableButton', 'prev');
        this.toolbarsManager.proxyCall(nextInfo.isValid ?
            'enableButton' :
            'disableButton', 'next');
    };
    Calendar.prototype.queryToolbarsHeight = function () {
        return this.toolbarsManager.items.reduce(function (accumulator, toolbar) {
            var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin
            return accumulator + toolbarHeight;
        }, 0);
    };
    // Selection
    // -----------------------------------------------------------------------------------------------------------------
    // this public method receives start/end dates in any format, with any timezone
    Calendar.prototype.select = function (zonedStartInput, zonedEndInput) {
        this.view.select(this.buildSelectFootprint.apply(this, arguments));
    };
    Calendar.prototype.unselect = function () {
        if (this.view) {
            this.view.unselect();
        }
    };
    // Given arguments to the select method in the API, returns a span (unzoned start/end and other info)
    Calendar.prototype.buildSelectFootprint = function (zonedStartInput, zonedEndInput) {
        var start = this.moment(zonedStartInput).stripZone();
        var end;
        if (zonedEndInput) {
            end = this.moment(zonedEndInput).stripZone();
        }
        else if (start.hasTime()) {
            end = start.clone().add(this.defaultTimedEventDuration);
        }
        else {
            end = start.clone().add(this.defaultAllDayEventDuration);
        }
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), !start.hasTime());
    };
    // Date Utils
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initMomentInternals = function () {
        var _this = this;
        this.defaultAllDayEventDuration = moment.duration(this.opt('defaultAllDayEventDuration'));
        this.defaultTimedEventDuration = moment.duration(this.opt('defaultTimedEventDuration'));
        // Called immediately, and when any of the options change.
        // Happens before any internal objects rebuild or rerender, because this is very core.
        this.optionsManager.watch('buildingMomentLocale', [
            '?locale', '?monthNames', '?monthNamesShort', '?dayNames', '?dayNamesShort',
            '?firstDay', '?weekNumberCalculation'
        ], function (opts) {
            var weekNumberCalculation = opts.weekNumberCalculation;
            var firstDay = opts.firstDay;
            var _week;
            // normalize
            if (weekNumberCalculation === 'iso') {
                weekNumberCalculation = 'ISO'; // normalize
            }
            var localeData = Object.create(// make a cheap copy
            locale_1.getMomentLocaleData(opts.locale) // will fall back to en
            );
            if (opts.monthNames) {
                localeData._months = opts.monthNames;
            }
            if (opts.monthNamesShort) {
                localeData._monthsShort = opts.monthNamesShort;
            }
            if (opts.dayNames) {
                localeData._weekdays = opts.dayNames;
            }
            if (opts.dayNamesShort) {
                localeData._weekdaysShort = opts.dayNamesShort;
            }
            if (firstDay == null && weekNumberCalculation === 'ISO') {
                firstDay = 1;
            }
            if (firstDay != null) {
                _week = Object.create(localeData._week); // _week: { dow: # }
                _week.dow = firstDay;
                localeData._week = _week;
            }
            if ( // whitelist certain kinds of input
            weekNumberCalculation === 'ISO' ||
                weekNumberCalculation === 'local' ||
                typeof weekNumberCalculation === 'function') {
                localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it
            }
            _this.localeData = localeData;
            // If the internal current date object already exists, move to new locale.
            // We do NOT need to do this technique for event dates, because this happens when converting to "segments".
            if (_this.currentDate) {
                _this.localizeMoment(_this.currentDate); // sets to localeData
            }
        });
    };
    // Builds a moment using the settings of the current calendar: timezone and locale.
    // Accepts anything the vanilla moment() constructor accepts.
    Calendar.prototype.moment = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var mom;
        if (this.opt('timezone') === 'local') {
            mom = moment_ext_1.default.apply(null, args);
            // Force the moment to be local, because momentExt doesn't guarantee it.
            if (mom.hasTime()) { // don't give ambiguously-timed moments a local zone
                mom.local();
            }
        }
        else if (this.opt('timezone') === 'UTC') {
            mom = moment_ext_1.default.utc.apply(null, args); // process as UTC
        }
        else {
            mom = moment_ext_1.default.parseZone.apply(null, args); // let the input decide the zone
        }
        this.localizeMoment(mom); // TODO
        return mom;
    };
    Calendar.prototype.msToMoment = function (ms, forceAllDay) {
        var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC
        if (forceAllDay) {
            mom.stripTime();
        }
        else {
            mom = this.applyTimezone(mom); // may or may not apply locale
        }
        this.localizeMoment(mom);
        return mom;
    };
    Calendar.prototype.msToUtcMoment = function (ms, forceAllDay) {
        var mom = moment_ext_1.default.utc(ms); // TODO: optimize by using Date.UTC
        if (forceAllDay) {
            mom.stripTime();
        }
        this.localizeMoment(mom);
        return mom;
    };
    // Updates the given moment's locale settings to the current calendar locale settings.
    Calendar.prototype.localizeMoment = function (mom) {
        mom._locale = this.localeData;
    };
    // Returns a boolean about whether or not the calendar knows how to calculate
    // the timezone offset of arbitrary dates in the current timezone.
    Calendar.prototype.getIsAmbigTimezone = function () {
        return this.opt('timezone') !== 'local' && this.opt('timezone') !== 'UTC';
    };
    // Returns a copy of the given date in the current timezone. Has no effect on dates without times.
    Calendar.prototype.applyTimezone = function (date) {
        if (!date.hasTime()) {
            return date.clone();
        }
        var zonedDate = this.moment(date.toArray());
        var timeAdjust = date.time().asMilliseconds() - zonedDate.time().asMilliseconds();
        var adjustedZonedDate;
        // Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)
        if (timeAdjust) { // is the time result different than expected?
            adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds
            if (date.time().asMilliseconds() - adjustedZonedDate.time().asMilliseconds() === 0) { // does it match perfectly now?
                zonedDate = adjustedZonedDate;
            }
        }
        return zonedDate;
    };
    /*
    Assumes the footprint is non-open-ended.
    */
    Calendar.prototype.footprintToDateProfile = function (componentFootprint, ignoreEnd) {
        if (ignoreEnd === void 0) { ignoreEnd = false; }
        var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs);
        var end;
        if (!ignoreEnd) {
            end = moment_ext_1.default.utc(componentFootprint.unzonedRange.endMs);
        }
        if (componentFootprint.isAllDay) {
            start.stripTime();
            if (end) {
                end.stripTime();
            }
        }
        else {
            start = this.applyTimezone(start);
            if (end) {
                end = this.applyTimezone(end);
            }
        }
        this.localizeMoment(start);
        if (end) {
            this.localizeMoment(end);
        }
        return new EventDateProfile_1.default(start, end, this);
    };
    // Returns a moment for the current date, as defined by the client's computer or from the `now` option.
    // Will return an moment with an ambiguous timezone.
    Calendar.prototype.getNow = function () {
        var now = this.opt('now');
        if (typeof now === 'function') {
            now = now();
        }
        return this.moment(now).stripZone();
    };
    // Produces a human-readable string for the given duration.
    // Side-effect: changes the locale of the given duration.
    Calendar.prototype.humanizeDuration = function (duration) {
        return duration.locale(this.opt('locale')).humanize();
    };
    // will return `null` if invalid range
    Calendar.prototype.parseUnzonedRange = function (rangeInput) {
        var start = null;
        var end = null;
        if (rangeInput.start) {
            start = this.moment(rangeInput.start).stripZone();
        }
        if (rangeInput.end) {
            end = this.moment(rangeInput.end).stripZone();
        }
        if (!start && !end) {
            return null;
        }
        if (start && end && end.isBefore(start)) {
            return null;
        }
        return new UnzonedRange_1.default(start, end);
    };
    // Event-Date Utilities
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.initEventManager = function () {
        var _this = this;
        var eventManager = new EventManager_1.default(this);
        var rawSources = this.opt('eventSources') || [];
        var singleRawSource = this.opt('events');
        this.eventManager = eventManager;
        if (singleRawSource) {
            rawSources.unshift(singleRawSource);
        }
        eventManager.on('release', function (eventsPayload) {
            _this.trigger('eventsReset', eventsPayload);
        });
        eventManager.freeze();
        rawSources.forEach(function (rawSource) {
            var source = EventSourceParser_1.default.parse(rawSource, _this);
            if (source) {
                eventManager.addSource(source);
            }
        });
        eventManager.thaw();
    };
    Calendar.prototype.requestEvents = function (start, end) {
        return this.eventManager.requestEvents(start, end, this.opt('timezone'), !this.opt('lazyFetching'));
    };
    // Get an event's normalized end date. If not present, calculate it from the defaults.
    Calendar.prototype.getEventEnd = function (event) {
        if (event.end) {
            return event.end.clone();
        }
        else {
            return this.getDefaultEventEnd(event.allDay, event.start);
        }
    };
    // Given an event's allDay status and start date, return what its fallback end date should be.
    // TODO: rename to computeDefaultEventEnd
    Calendar.prototype.getDefaultEventEnd = function (allDay, zonedStart) {
        var end = zonedStart.clone();
        if (allDay) {
            end.stripTime().add(this.defaultAllDayEventDuration);
        }
        else {
            end.add(this.defaultTimedEventDuration);
        }
        if (this.getIsAmbigTimezone()) {
            end.stripZone(); // we don't know what the tzo should be
        }
        return end;
    };
    // Public Events API
    // -----------------------------------------------------------------------------------------------------------------
    Calendar.prototype.rerenderEvents = function () {
        this.view.flash('displayingEvents');
    };
    Calendar.prototype.refetchEvents = function () {
        this.eventManager.refetchAllSources();
    };
    Calendar.prototype.renderEvents = function (eventInputs, isSticky) {
        this.eventManager.freeze();
        for (var i = 0; i < eventInputs.length; i++) {
            this.renderEvent(eventInputs[i], isSticky);
        }
        this.eventManager.thaw();
    };
    Calendar.prototype.renderEvent = function (eventInput, isSticky) {
        if (isSticky === void 0) { isSticky = false; }
        var eventManager = this.eventManager;
        var eventDef = EventDefParser_1.default.parse(eventInput, eventInput.source || eventManager.stickySource);
        if (eventDef) {
            eventManager.addEventDef(eventDef, isSticky);
        }
    };
    // legacyQuery operates on legacy event instance objects
    Calendar.prototype.removeEvents = function (legacyQuery) {
        var eventManager = this.eventManager;
        var legacyInstances = [];
        var idMap = {};
        var eventDef;
        var i;
        if (legacyQuery == null) { // shortcut for removing all
            eventManager.removeAllEventDefs(); // persist=true
        }
        else {
            eventManager.getEventInstances().forEach(function (eventInstance) {
                legacyInstances.push(eventInstance.toLegacy());
            });
            legacyInstances = filterLegacyEventInstances(legacyInstances, legacyQuery);
            // compute unique IDs
            for (i = 0; i < legacyInstances.length; i++) {
                eventDef = this.eventManager.getEventDefByUid(legacyInstances[i]._id);
                idMap[eventDef.id] = true;
            }
            eventManager.freeze();
            for (i in idMap) { // reuse `i` as an "id"
                eventManager.removeEventDefsById(i); // persist=true
            }
            eventManager.thaw();
        }
    };
    // legacyQuery operates on legacy event instance objects
    Calendar.prototype.clientEvents = function (legacyQuery) {
        var legacyEventInstances = [];
        this.eventManager.getEventInstances().forEach(function (eventInstance) {
            legacyEventInstances.push(eventInstance.toLegacy());
        });
        return filterLegacyEventInstances(legacyEventInstances, legacyQuery);
    };
    Calendar.prototype.updateEvents = function (eventPropsArray) {
        this.eventManager.freeze();
        for (var i = 0; i < eventPropsArray.length; i++) {
            this.updateEvent(eventPropsArray[i]);
        }
        this.eventManager.thaw();
    };
    Calendar.prototype.updateEvent = function (eventProps) {
        var eventDef = this.eventManager.getEventDefByUid(eventProps._id);
        var eventInstance;
        var eventDefMutation;
        if (eventDef instanceof SingleEventDef_1.default) {
            eventInstance = eventDef.buildInstance();
            eventDefMutation = EventDefMutation_1.default.createFromRawProps(eventInstance, eventProps, // raw props
            null // largeUnit -- who uses it?
            );
            this.eventManager.mutateEventsWithId(eventDef.id, eventDefMutation); // will release
        }
    };
    // Public Event Sources API
    // ------------------------------------------------------------------------------------
    Calendar.prototype.getEventSources = function () {
        return this.eventManager.otherSources.slice(); // clone
    };
    Calendar.prototype.getEventSourceById = function (id) {
        return this.eventManager.getSourceById(EventSource_1.default.normalizeId(id));
    };
    Calendar.prototype.addEventSource = function (sourceInput) {
        var source = EventSourceParser_1.default.parse(sourceInput, this);
        if (source) {
            this.eventManager.addSource(source);
        }
    };
    Calendar.prototype.removeEventSources = function (sourceMultiQuery) {
        var eventManager = this.eventManager;
        var sources;
        var i;
        if (sourceMultiQuery == null) {
            this.eventManager.removeAllSources();
        }
        else {
            sources = eventManager.multiQuerySources(sourceMultiQuery);
            eventManager.freeze();
            for (i = 0; i < sources.length; i++) {
                eventManager.removeSource(sources[i]);
            }
            eventManager.thaw();
        }
    };
    Calendar.prototype.removeEventSource = function (sourceQuery) {
        var eventManager = this.eventManager;
        var sources = eventManager.querySources(sourceQuery);
        var i;
        eventManager.freeze();
        for (i = 0; i < sources.length; i++) {
            eventManager.removeSource(sources[i]);
        }
        eventManager.thaw();
    };
    Calendar.prototype.refetchEventSources = function (sourceMultiQuery) {
        var eventManager = this.eventManager;
        var sources = eventManager.multiQuerySources(sourceMultiQuery);
        var i;
        eventManager.freeze();
        for (i = 0; i < sources.length; i++) {
            eventManager.refetchSource(sources[i]);
        }
        eventManager.thaw();
    };
    // not for internal use. use options module directly instead.
    Calendar.defaults = options_1.globalDefaults;
    Calendar.englishDefaults = options_1.englishDefaults;
    Calendar.rtlDefaults = options_1.rtlDefaults;
    return Calendar;
}());
exports.default = Calendar;
EmitterMixin_1.default.mixInto(Calendar);
ListenerMixin_1.default.mixInto(Calendar);
function filterLegacyEventInstances(legacyEventInstances, legacyQuery) {
    if (legacyQuery == null) {
        return legacyEventInstances;
    }
    else if ($.isFunction(legacyQuery)) {
        return legacyEventInstances.filter(legacyQuery);
    }
    else { // an event ID
        legacyQuery += ''; // normalize to string
        return legacyEventInstances.filter(function (legacyEventInstance) {
            // soft comparison because id not be normalized to string
            // tslint:disable-next-line
            return legacyEventInstance.id == legacyQuery ||
                legacyEventInstance._id === legacyQuery; // can specify internal id, but must exactly match
        });
    }
}


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var exportHooks = __webpack_require__(18);
var util_1 = __webpack_require__(4);
var moment_ext_1 = __webpack_require__(11);
var ListenerMixin_1 = __webpack_require__(7);
var HitDragListener_1 = __webpack_require__(17);
var SingleEventDef_1 = __webpack_require__(9);
var EventInstanceGroup_1 = __webpack_require__(20);
var EventSource_1 = __webpack_require__(6);
var Interaction_1 = __webpack_require__(14);
var ExternalDropping = /** @class */ (function (_super) {
    tslib_1.__extends(ExternalDropping, _super);
    function ExternalDropping() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.isDragging = false; // jqui-dragging an external element? boolean
        return _this;
    }
    /*
    component impements:
      - eventRangesToEventFootprints
      - isEventInstanceGroupAllowed
      - isExternalInstanceGroupAllowed
      - renderDrag
      - unrenderDrag
    */
    ExternalDropping.prototype.end = function () {
        if (this.dragListener) {
            this.dragListener.endInteraction();
        }
    };
    ExternalDropping.prototype.bindToDocument = function () {
        this.listenTo($(document), {
            dragstart: this.handleDragStart,
            sortstart: this.handleDragStart // jqui
        });
    };
    ExternalDropping.prototype.unbindFromDocument = function () {
        this.stopListeningTo($(document));
    };
    // Called when a jQuery UI drag is initiated anywhere in the DOM
    ExternalDropping.prototype.handleDragStart = function (ev, ui) {
        var el;
        var accept;
        if (this.opt('droppable')) { // only listen if this setting is on
            el = $((ui ? ui.item : null) || ev.target);
            // Test that the dragged element passes the dropAccept selector or filter function.
            // FYI, the default is "*" (matches all)
            accept = this.opt('dropAccept');
            if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
                if (!this.isDragging) { // prevent double-listening if fired twice
                    this.listenToExternalDrag(el, ev, ui);
                }
            }
        }
    };
    // Called when a jQuery UI drag starts and it needs to be monitored for dropping
    ExternalDropping.prototype.listenToExternalDrag = function (el, ev, ui) {
        var _this = this;
        var component = this.component;
        var view = this.view;
        var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create
        var singleEventDef; // a null value signals an unsuccessful drag
        // listener that tracks mouse movement over date-associated pixel regions
        var dragListener = this.dragListener = new HitDragListener_1.default(component, {
            interactionStart: function () {
                _this.isDragging = true;
            },
            hitOver: function (hit) {
                var isAllowed = true;
                var hitFootprint = hit.component.getSafeHitFootprint(hit); // hit might not belong to this grid
                var mutatedEventInstanceGroup;
                if (hitFootprint) {
                    singleEventDef = _this.computeExternalDrop(hitFootprint, meta);
                    if (singleEventDef) {
                        mutatedEventInstanceGroup = new EventInstanceGroup_1.default(singleEventDef.buildInstances());
                        isAllowed = meta.eventProps ? // isEvent?
                            component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup) :
                            component.isExternalInstanceGroupAllowed(mutatedEventInstanceGroup);
                    }
                    else {
                        isAllowed = false;
                    }
                }
                else {
                    isAllowed = false;
                }
                if (!isAllowed) {
                    singleEventDef = null;
                    util_1.disableCursor();
                }
                if (singleEventDef) {
                    component.renderDrag(// called without a seg parameter
                    component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, view.calendar)));
                }
            },
            hitOut: function () {
                singleEventDef = null; // signal unsuccessful
            },
            hitDone: function () {
                util_1.enableCursor();
                component.unrenderDrag();
            },
            interactionEnd: function (ev) {
                if (singleEventDef) { // element was dropped on a valid hit
                    view.reportExternalDrop(singleEventDef, Boolean(meta.eventProps), // isEvent
                    Boolean(meta.stick), // isSticky
                    el, ev, ui);
                }
                _this.isDragging = false;
                _this.dragListener = null;
            }
        });
        dragListener.startDrag(ev); // start listening immediately
    };
    // Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
    // returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.
    // Returning a null value signals an invalid drop hit.
    // DOES NOT consider overlap/constraint.
    // Assumes both footprints are non-open-ended.
    ExternalDropping.prototype.computeExternalDrop = function (componentFootprint, meta) {
        var calendar = this.view.calendar;
        var start = moment_ext_1.default.utc(componentFootprint.unzonedRange.startMs).stripZone();
        var end;
        var eventDef;
        if (componentFootprint.isAllDay) {
            // if dropped on an all-day span, and element's metadata specified a time, set it
            if (meta.startTime) {
                start.time(meta.startTime);
            }
            else {
                start.stripTime();
            }
        }
        if (meta.duration) {
            end = start.clone().add(meta.duration);
        }
        start = calendar.applyTimezone(start);
        if (end) {
            end = calendar.applyTimezone(end);
        }
        eventDef = SingleEventDef_1.default.parse($.extend({}, meta.eventProps, {
            start: start,
            end: end
        }), new EventSource_1.default(calendar));
        return eventDef;
    };
    return ExternalDropping;
}(Interaction_1.default));
exports.default = ExternalDropping;
ListenerMixin_1.default.mixInto(ExternalDropping);
/* External-Dragging-Element Data
----------------------------------------------------------------------------------------------------------------------*/
// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.
exportHooks.dataAttrPrefix = '';
// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
function getDraggedElMeta(el) {
    var prefix = exportHooks.dataAttrPrefix;
    var eventProps; // properties for creating the event, not related to date/time
    var startTime; // a Duration
    var duration;
    var stick;
    if (prefix) {
        prefix += '-';
    }
    eventProps = el.data(prefix + 'event') || null;
    if (eventProps) {
        if (typeof eventProps === 'object') {
            eventProps = $.extend({}, eventProps); // make a copy
        }
        else { // something like 1 or true. still signal event creation
            eventProps = {};
        }
        // pluck special-cased date/time properties
        startTime = eventProps.start;
        if (startTime == null) {
            startTime = eventProps.time;
        } // accept 'time' as well
        duration = eventProps.duration;
        stick = eventProps.stick;
        delete eventProps.start;
        delete eventProps.time;
        delete eventProps.duration;
        delete eventProps.stick;
    }
    // fallback to standalone attribute values for each of the date/time properties
    if (startTime == null) {
        startTime = el.data(prefix + 'start');
    }
    if (startTime == null) {
        startTime = el.data(prefix + 'time');
    } // accept 'time' as well
    if (duration == null) {
        duration = el.data(prefix + 'duration');
    }
    if (stick == null) {
        stick = el.data(prefix + 'stick');
    }
    // massage into correct data types
    startTime = startTime != null ? moment.duration(startTime) : null;
    duration = duration != null ? moment.duration(duration) : null;
    stick = Boolean(stick);
    return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };
}


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var EventDefMutation_1 = __webpack_require__(39);
var EventDefDateMutation_1 = __webpack_require__(40);
var HitDragListener_1 = __webpack_require__(17);
var Interaction_1 = __webpack_require__(14);
var EventResizing = /** @class */ (function (_super) {
    tslib_1.__extends(EventResizing, _super);
    /*
    component impements:
      - bindSegHandlerToEl
      - publiclyTrigger
      - diffDates
      - eventRangesToEventFootprints
      - isEventInstanceGroupAllowed
      - getSafeHitFootprint
    */
    function EventResizing(component, eventPointing) {
        var _this = _super.call(this, component) || this;
        _this.isResizing = false;
        _this.eventPointing = eventPointing;
        return _this;
    }
    EventResizing.prototype.end = function () {
        if (this.dragListener) {
            this.dragListener.endInteraction();
        }
    };
    EventResizing.prototype.bindToEl = function (el) {
        var component = this.component;
        component.bindSegHandlerToEl(el, 'mousedown', this.handleMouseDown.bind(this));
        component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));
    };
    EventResizing.prototype.handleMouseDown = function (seg, ev) {
        if (this.component.canStartResize(seg, ev)) {
            this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))
                .startInteraction(ev, { distance: 5 });
        }
    };
    EventResizing.prototype.handleTouchStart = function (seg, ev) {
        if (this.component.canStartResize(seg, ev)) {
            this.buildDragListener(seg, $(ev.target).is('.fc-start-resizer'))
                .startInteraction(ev);
        }
    };
    // Creates a listener that tracks the user as they resize an event segment.
    // Generic enough to work with any type of Grid.
    EventResizing.prototype.buildDragListener = function (seg, isStart) {
        var _this = this;
        var component = this.component;
        var view = this.view;
        var calendar = view.calendar;
        var eventManager = calendar.eventManager;
        var el = seg.el;
        var eventDef = seg.footprint.eventDef;
        var eventInstance = seg.footprint.eventInstance;
        var isDragging;
        var resizeMutation; // zoned event date properties. falsy if invalid resize
        // Tracks mouse movement over the *grid's* coordinate map
        var dragListener = this.dragListener = new HitDragListener_1.default(component, {
            scroll: this.opt('dragScroll'),
            subjectEl: el,
            interactionStart: function () {
                isDragging = false;
            },
            dragStart: function (ev) {
                isDragging = true;
                // ensure a mouseout on the manipulated event has been reported
                _this.eventPointing.handleMouseout(seg, ev);
                _this.segResizeStart(seg, ev);
            },
            hitOver: function (hit, isOrig, origHit) {
                var isAllowed = true;
                var origHitFootprint = component.getSafeHitFootprint(origHit);
                var hitFootprint = component.getSafeHitFootprint(hit);
                var mutatedEventInstanceGroup;
                if (origHitFootprint && hitFootprint) {
                    resizeMutation = isStart ?
                        _this.computeEventStartResizeMutation(origHitFootprint, hitFootprint, seg.footprint) :
                        _this.computeEventEndResizeMutation(origHitFootprint, hitFootprint, seg.footprint);
                    if (resizeMutation) {
                        mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, resizeMutation);
                        isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);
                    }
                    else {
                        isAllowed = false;
                    }
                }
                else {
                    isAllowed = false;
                }
                if (!isAllowed) {
                    resizeMutation = null;
                    util_1.disableCursor();
                }
                else if (resizeMutation.isEmpty()) {
                    // no change. (FYI, event dates might have zones)
                    resizeMutation = null;
                }
                if (resizeMutation) {
                    view.hideEventsWithId(seg.footprint.eventDef.id);
                    view.renderEventResize(component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg);
                }
            },
            hitOut: function () {
                resizeMutation = null;
            },
            hitDone: function () {
                view.unrenderEventResize(seg);
                view.showEventsWithId(seg.footprint.eventDef.id);
                util_1.enableCursor();
            },
            interactionEnd: function (ev) {
                if (isDragging) {
                    _this.segResizeStop(seg, ev);
                }
                if (resizeMutation) { // valid date to resize to?
                    // no need to re-show original, will rerender all anyways. esp important if eventRenderWait
                    view.reportEventResize(eventInstance, resizeMutation, el, ev);
                }
                _this.dragListener = null;
            }
        });
        return dragListener;
    };
    // Called before event segment resizing starts
    EventResizing.prototype.segResizeStart = function (seg, ev) {
        this.isResizing = true;
        this.component.publiclyTrigger('eventResizeStart', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // Called after event segment resizing stops
    EventResizing.prototype.segResizeStop = function (seg, ev) {
        this.isResizing = false;
        this.component.publiclyTrigger('eventResizeStop', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // Returns new date-information for an event segment being resized from its start
    EventResizing.prototype.computeEventStartResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {
        var origRange = origEventFootprint.componentFootprint.unzonedRange;
        var startDelta = this.component.diffDates(endFootprint.unzonedRange.getStart(), startFootprint.unzonedRange.getStart());
        var dateMutation;
        var eventDefMutation;
        if (origRange.getStart().add(startDelta) < origRange.getEnd()) {
            dateMutation = new EventDefDateMutation_1.default();
            dateMutation.setStartDelta(startDelta);
            eventDefMutation = new EventDefMutation_1.default();
            eventDefMutation.setDateMutation(dateMutation);
            return eventDefMutation;
        }
        return false;
    };
    // Returns new date-information for an event segment being resized from its end
    EventResizing.prototype.computeEventEndResizeMutation = function (startFootprint, endFootprint, origEventFootprint) {
        var origRange = origEventFootprint.componentFootprint.unzonedRange;
        var endDelta = this.component.diffDates(endFootprint.unzonedRange.getEnd(), startFootprint.unzonedRange.getEnd());
        var dateMutation;
        var eventDefMutation;
        if (origRange.getEnd().add(endDelta) > origRange.getStart()) {
            dateMutation = new EventDefDateMutation_1.default();
            dateMutation.setEndDelta(endDelta);
            eventDefMutation = new EventDefMutation_1.default();
            eventDefMutation.setDateMutation(dateMutation);
            return eventDefMutation;
        }
        return false;
    };
    return EventResizing;
}(Interaction_1.default));
exports.default = EventResizing;


/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var EventDefMutation_1 = __webpack_require__(39);
var EventDefDateMutation_1 = __webpack_require__(40);
var DragListener_1 = __webpack_require__(59);
var HitDragListener_1 = __webpack_require__(17);
var MouseFollower_1 = __webpack_require__(226);
var Interaction_1 = __webpack_require__(14);
var EventDragging = /** @class */ (function (_super) {
    tslib_1.__extends(EventDragging, _super);
    /*
    component implements:
      - bindSegHandlerToEl
      - publiclyTrigger
      - diffDates
      - eventRangesToEventFootprints
      - isEventInstanceGroupAllowed
    */
    function EventDragging(component, eventPointing) {
        var _this = _super.call(this, component) || this;
        _this.isDragging = false;
        _this.eventPointing = eventPointing;
        return _this;
    }
    EventDragging.prototype.end = function () {
        if (this.dragListener) {
            this.dragListener.endInteraction();
        }
    };
    EventDragging.prototype.getSelectionDelay = function () {
        var delay = this.opt('eventLongPressDelay');
        if (delay == null) {
            delay = this.opt('longPressDelay'); // fallback
        }
        return delay;
    };
    EventDragging.prototype.bindToEl = function (el) {
        var component = this.component;
        component.bindSegHandlerToEl(el, 'mousedown', this.handleMousedown.bind(this));
        component.bindSegHandlerToEl(el, 'touchstart', this.handleTouchStart.bind(this));
    };
    EventDragging.prototype.handleMousedown = function (seg, ev) {
        if (!this.component.shouldIgnoreMouse() &&
            this.component.canStartDrag(seg, ev)) {
            this.buildDragListener(seg).startInteraction(ev, { distance: 5 });
        }
    };
    EventDragging.prototype.handleTouchStart = function (seg, ev) {
        var component = this.component;
        var settings = {
            delay: this.view.isEventDefSelected(seg.footprint.eventDef) ? // already selected?
                0 : this.getSelectionDelay()
        };
        if (component.canStartDrag(seg, ev)) {
            this.buildDragListener(seg).startInteraction(ev, settings);
        }
        else if (component.canStartSelection(seg, ev)) {
            this.buildSelectListener(seg).startInteraction(ev, settings);
        }
    };
    // seg isn't draggable, but let's use a generic DragListener
    // simply for the delay, so it can be selected.
    // Has side effect of setting/unsetting `dragListener`
    EventDragging.prototype.buildSelectListener = function (seg) {
        var _this = this;
        var view = this.view;
        var eventDef = seg.footprint.eventDef;
        var eventInstance = seg.footprint.eventInstance; // null for inverse-background events
        if (this.dragListener) {
            return this.dragListener;
        }
        var dragListener = this.dragListener = new DragListener_1.default({
            dragStart: function (ev) {
                if (dragListener.isTouch &&
                    !view.isEventDefSelected(eventDef) &&
                    eventInstance) {
                    // if not previously selected, will fire after a delay. then, select the event
                    view.selectEventInstance(eventInstance);
                }
            },
            interactionEnd: function (ev) {
                _this.dragListener = null;
            }
        });
        return dragListener;
    };
    // Builds a listener that will track user-dragging on an event segment.
    // Generic enough to work with any type of Grid.
    // Has side effect of setting/unsetting `dragListener`
    EventDragging.prototype.buildDragListener = function (seg) {
        var _this = this;
        var component = this.component;
        var view = this.view;
        var calendar = view.calendar;
        var eventManager = calendar.eventManager;
        var el = seg.el;
        var eventDef = seg.footprint.eventDef;
        var eventInstance = seg.footprint.eventInstance; // null for inverse-background events
        var isDragging;
        var mouseFollower; // A clone of the original element that will move with the mouse
        var eventDefMutation;
        if (this.dragListener) {
            return this.dragListener;
        }
        // Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents
        // of the view.
        var dragListener = this.dragListener = new HitDragListener_1.default(view, {
            scroll: this.opt('dragScroll'),
            subjectEl: el,
            subjectCenter: true,
            interactionStart: function (ev) {
                seg.component = component; // for renderDrag
                isDragging = false;
                mouseFollower = new MouseFollower_1.default(seg.el, {
                    additionalClass: 'fc-dragging',
                    parentEl: view.el,
                    opacity: dragListener.isTouch ? null : _this.opt('dragOpacity'),
                    revertDuration: _this.opt('dragRevertDuration'),
                    zIndex: 2 // one above the .fc-view
                });
                mouseFollower.hide(); // don't show until we know this is a real drag
                mouseFollower.start(ev);
            },
            dragStart: function (ev) {
                if (dragListener.isTouch &&
                    !view.isEventDefSelected(eventDef) &&
                    eventInstance) {
                    // if not previously selected, will fire after a delay. then, select the event
                    view.selectEventInstance(eventInstance);
                }
                isDragging = true;
                // ensure a mouseout on the manipulated event has been reported
                _this.eventPointing.handleMouseout(seg, ev);
                _this.segDragStart(seg, ev);
                view.hideEventsWithId(seg.footprint.eventDef.id);
            },
            hitOver: function (hit, isOrig, origHit) {
                var isAllowed = true;
                var origFootprint;
                var footprint;
                var mutatedEventInstanceGroup;
                // starting hit could be forced (DayGrid.limit)
                if (seg.hit) {
                    origHit = seg.hit;
                }
                // hit might not belong to this grid, so query origin grid
                origFootprint = origHit.component.getSafeHitFootprint(origHit);
                footprint = hit.component.getSafeHitFootprint(hit);
                if (origFootprint && footprint) {
                    eventDefMutation = _this.computeEventDropMutation(origFootprint, footprint, eventDef);
                    if (eventDefMutation) {
                        mutatedEventInstanceGroup = eventManager.buildMutatedEventInstanceGroup(eventDef.id, eventDefMutation);
                        isAllowed = component.isEventInstanceGroupAllowed(mutatedEventInstanceGroup);
                    }
                    else {
                        isAllowed = false;
                    }
                }
                else {
                    isAllowed = false;
                }
                if (!isAllowed) {
                    eventDefMutation = null;
                    util_1.disableCursor();
                }
                // if a valid drop location, have the subclass render a visual indication
                if (eventDefMutation &&
                    view.renderDrag(// truthy if rendered something
                    component.eventRangesToEventFootprints(mutatedEventInstanceGroup.sliceRenderRanges(component.dateProfile.renderUnzonedRange, calendar)), seg, dragListener.isTouch)) {
                    mouseFollower.hide(); // if the subclass is already using a mock event "helper", hide our own
                }
                else {
                    mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)
                }
                if (isOrig) {
                    // needs to have moved hits to be a valid drop
                    eventDefMutation = null;
                }
            },
            hitOut: function () {
                view.unrenderDrag(seg); // unrender whatever was done in renderDrag
                mouseFollower.show(); // show in case we are moving out of all hits
                eventDefMutation = null;
            },
            hitDone: function () {
                util_1.enableCursor();
            },
            interactionEnd: function (ev) {
                delete seg.component; // prevent side effects
                // do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
                mouseFollower.stop(!eventDefMutation, function () {
                    if (isDragging) {
                        view.unrenderDrag(seg);
                        _this.segDragStop(seg, ev);
                    }
                    view.showEventsWithId(seg.footprint.eventDef.id);
                    if (eventDefMutation) {
                        // no need to re-show original, will rerender all anyways. esp important if eventRenderWait
                        view.reportEventDrop(eventInstance, eventDefMutation, el, ev);
                    }
                });
                _this.dragListener = null;
            }
        });
        return dragListener;
    };
    // Called before event segment dragging starts
    EventDragging.prototype.segDragStart = function (seg, ev) {
        this.isDragging = true;
        this.component.publiclyTrigger('eventDragStart', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // Called after event segment dragging stops
    EventDragging.prototype.segDragStop = function (seg, ev) {
        this.isDragging = false;
        this.component.publiclyTrigger('eventDragStop', {
            context: seg.el[0],
            args: [
                seg.footprint.getEventLegacy(),
                ev,
                {},
                this.view
            ]
        });
    };
    // DOES NOT consider overlap/constraint
    EventDragging.prototype.computeEventDropMutation = function (startFootprint, endFootprint, eventDef) {
        var eventDefMutation = new EventDefMutation_1.default();
        eventDefMutation.setDateMutation(this.computeEventDateMutation(startFootprint, endFootprint));
        return eventDefMutation;
    };
    EventDragging.prototype.computeEventDateMutation = function (startFootprint, endFootprint) {
        var date0 = startFootprint.unzonedRange.getStart();
        var date1 = endFootprint.unzonedRange.getStart();
        var clearEnd = false;
        var forceTimed = false;
        var forceAllDay = false;
        var dateDelta;
        var dateMutation;
        if (startFootprint.isAllDay !== endFootprint.isAllDay) {
            clearEnd = true;
            if (endFootprint.isAllDay) {
                forceAllDay = true;
                date0.stripTime();
            }
            else {
                forceTimed = true;
            }
        }
        dateDelta = this.component.diffDates(date1, date0);
        dateMutation = new EventDefDateMutation_1.default();
        dateMutation.clearEnd = clearEnd;
        dateMutation.forceTimed = forceTimed;
        dateMutation.forceAllDay = forceAllDay;
        dateMutation.setDateDelta(dateDelta);
        return dateMutation;
    };
    return EventDragging;
}(Interaction_1.default));
exports.default = EventDragging;


/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var HitDragListener_1 = __webpack_require__(17);
var ComponentFootprint_1 = __webpack_require__(12);
var UnzonedRange_1 = __webpack_require__(5);
var Interaction_1 = __webpack_require__(14);
var DateSelecting = /** @class */ (function (_super) {
    tslib_1.__extends(DateSelecting, _super);
    /*
    component must implement:
      - bindDateHandlerToEl
      - getSafeHitFootprint
      - renderHighlight
      - unrenderHighlight
    */
    function DateSelecting(component) {
        var _this = _super.call(this, component) || this;
        _this.dragListener = _this.buildDragListener();
        return _this;
    }
    DateSelecting.prototype.end = function () {
        this.dragListener.endInteraction();
    };
    DateSelecting.prototype.getDelay = function () {
        var delay = this.opt('selectLongPressDelay');
        if (delay == null) {
            delay = this.opt('longPressDelay'); // fallback
        }
        return delay;
    };
    DateSelecting.prototype.bindToEl = function (el) {
        var _this = this;
        var component = this.component;
        var dragListener = this.dragListener;
        component.bindDateHandlerToEl(el, 'mousedown', function (ev) {
            if (_this.opt('selectable') && !component.shouldIgnoreMouse()) {
                dragListener.startInteraction(ev, {
                    distance: _this.opt('selectMinDistance')
                });
            }
        });
        component.bindDateHandlerToEl(el, 'touchstart', function (ev) {
            if (_this.opt('selectable') && !component.shouldIgnoreTouch()) {
                dragListener.startInteraction(ev, {
                    delay: _this.getDelay()
                });
            }
        });
        util_1.preventSelection(el);
    };
    // Creates a listener that tracks the user's drag across day elements, for day selecting.
    DateSelecting.prototype.buildDragListener = function () {
        var _this = this;
        var component = this.component;
        var selectionFootprint; // null if invalid selection
        var dragListener = new HitDragListener_1.default(component, {
            scroll: this.opt('dragScroll'),
            interactionStart: function () {
                selectionFootprint = null;
            },
            dragStart: function (ev) {
                _this.view.unselect(ev); // since we could be rendering a new selection, we want to clear any old one
            },
            hitOver: function (hit, isOrig, origHit) {
                var origHitFootprint;
                var hitFootprint;
                if (origHit) { // click needs to have started on a hit
                    origHitFootprint = component.getSafeHitFootprint(origHit);
                    hitFootprint = component.getSafeHitFootprint(hit);
                    if (origHitFootprint && hitFootprint) {
                        selectionFootprint = _this.computeSelection(origHitFootprint, hitFootprint);
                    }
                    else {
                        selectionFootprint = null;
                    }
                    if (selectionFootprint) {
                        component.renderSelectionFootprint(selectionFootprint);
                    }
                    else if (selectionFootprint === false) {
                        util_1.disableCursor();
                    }
                }
            },
            hitOut: function () {
                selectionFootprint = null;
                component.unrenderSelection();
            },
            hitDone: function () {
                util_1.enableCursor();
            },
            interactionEnd: function (ev, isCancelled) {
                if (!isCancelled && selectionFootprint) {
                    // the selection will already have been rendered. just report it
                    _this.view.reportSelection(selectionFootprint, ev);
                }
            }
        });
        return dragListener;
    };
    // Given the first and last date-spans of a selection, returns another date-span object.
    // Subclasses can override and provide additional data in the span object. Will be passed to renderSelectionFootprint().
    // Will return false if the selection is invalid and this should be indicated to the user.
    // Will return null/undefined if a selection invalid but no error should be reported.
    DateSelecting.prototype.computeSelection = function (footprint0, footprint1) {
        var wholeFootprint = this.computeSelectionFootprint(footprint0, footprint1);
        if (wholeFootprint && !this.isSelectionFootprintAllowed(wholeFootprint)) {
            return false;
        }
        return wholeFootprint;
    };
    // Given two spans, must return the combination of the two.
    // TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.
    // Assumes both footprints are non-open-ended.
    DateSelecting.prototype.computeSelectionFootprint = function (footprint0, footprint1) {
        var ms = [
            footprint0.unzonedRange.startMs,
            footprint0.unzonedRange.endMs,
            footprint1.unzonedRange.startMs,
            footprint1.unzonedRange.endMs
        ];
        ms.sort(util_1.compareNumbers);
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(ms[0], ms[3]), footprint0.isAllDay);
    };
    DateSelecting.prototype.isSelectionFootprintAllowed = function (componentFootprint) {
        return this.component.dateProfile.validUnzonedRange.containsRange(componentFootprint.unzonedRange) &&
            this.view.calendar.constraints.isSelectionFootprintAllowed(componentFootprint);
    };
    return DateSelecting;
}(Interaction_1.default));
exports.default = DateSelecting;


/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var HitDragListener_1 = __webpack_require__(17);
var Interaction_1 = __webpack_require__(14);
var DateClicking = /** @class */ (function (_super) {
    tslib_1.__extends(DateClicking, _super);
    /*
    component must implement:
      - bindDateHandlerToEl
      - getSafeHitFootprint
      - getHitEl
    */
    function DateClicking(component) {
        var _this = _super.call(this, component) || this;
        _this.dragListener = _this.buildDragListener();
        return _this;
    }
    DateClicking.prototype.end = function () {
        this.dragListener.endInteraction();
    };
    DateClicking.prototype.bindToEl = function (el) {
        var component = this.component;
        var dragListener = this.dragListener;
        component.bindDateHandlerToEl(el, 'mousedown', function (ev) {
            if (!component.shouldIgnoreMouse()) {
                dragListener.startInteraction(ev);
            }
        });
        component.bindDateHandlerToEl(el, 'touchstart', function (ev) {
            if (!component.shouldIgnoreTouch()) {
                dragListener.startInteraction(ev);
            }
        });
    };
    // Creates a listener that tracks the user's drag across day elements, for day clicking.
    DateClicking.prototype.buildDragListener = function () {
        var _this = this;
        var component = this.component;
        var dayClickHit; // null if invalid dayClick
        var dragListener = new HitDragListener_1.default(component, {
            scroll: this.opt('dragScroll'),
            interactionStart: function () {
                dayClickHit = dragListener.origHit;
            },
            hitOver: function (hit, isOrig, origHit) {
                // if user dragged to another cell at any point, it can no longer be a dayClick
                if (!isOrig) {
                    dayClickHit = null;
                }
            },
            hitOut: function () {
                dayClickHit = null;
            },
            interactionEnd: function (ev, isCancelled) {
                var componentFootprint;
                if (!isCancelled && dayClickHit) {
                    componentFootprint = component.getSafeHitFootprint(dayClickHit);
                    if (componentFootprint) {
                        _this.view.triggerDayClick(componentFootprint, component.getHitEl(dayClickHit), ev);
                    }
                }
            }
        });
        // because dragListener won't be called with any time delay, "dragging" will begin immediately,
        // which will kill any touchmoving/scrolling. Prevent this.
        dragListener.shouldCancelTouchScroll = false;
        dragListener.scrollAlwaysKills = true;
        return dragListener;
    };
    return DateClicking;
}(Interaction_1.default));
exports.default = DateClicking;


/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var moment = __webpack_require__(0);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var Scroller_1 = __webpack_require__(41);
var View_1 = __webpack_require__(43);
var TimeGrid_1 = __webpack_require__(239);
var DayGrid_1 = __webpack_require__(66);
var AGENDA_ALL_DAY_EVENT_LIMIT = 5;
var agendaTimeGridMethods;
var agendaDayGridMethods;
/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
----------------------------------------------------------------------------------------------------------------------*/
// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.
var AgendaView = /** @class */ (function (_super) {
    tslib_1.__extends(AgendaView, _super);
    function AgendaView(calendar, viewSpec) {
        var _this = _super.call(this, calendar, viewSpec) || this;
        _this.usesMinMaxTime = true; // indicates that minTime/maxTime affects rendering
        _this.timeGrid = _this.instantiateTimeGrid();
        _this.addChild(_this.timeGrid);
        if (_this.opt('allDaySlot')) { // should we display the "all-day" area?
            _this.dayGrid = _this.instantiateDayGrid(); // the all-day subcomponent of this view
            _this.addChild(_this.dayGrid);
        }
        _this.scroller = new Scroller_1.default({
            overflowX: 'hidden',
            overflowY: 'auto'
        });
        return _this;
    }
    // Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass
    AgendaView.prototype.instantiateTimeGrid = function () {
        var timeGrid = new this.timeGridClass(this);
        util_1.copyOwnProps(agendaTimeGridMethods, timeGrid);
        return timeGrid;
    };
    // Instantiates the DayGrid object this view might need. Draws from this.dayGridClass
    AgendaView.prototype.instantiateDayGrid = function () {
        var dayGrid = new this.dayGridClass(this);
        util_1.copyOwnProps(agendaDayGridMethods, dayGrid);
        return dayGrid;
    };
    /* Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    AgendaView.prototype.renderSkeleton = function () {
        var timeGridWrapEl;
        var timeGridEl;
        this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());
        this.scroller.render();
        timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');
        timeGridEl = $('<div class="fc-time-grid">').appendTo(timeGridWrapEl);
        this.el.find('.fc-body > tr > td').append(timeGridWrapEl);
        this.timeGrid.headContainerEl = this.el.find('.fc-head-container');
        this.timeGrid.setElement(timeGridEl);
        if (this.dayGrid) {
            this.dayGrid.setElement(this.el.find('.fc-day-grid'));
            // have the day-grid extend it's coordinate area over the <hr> dividing the two grids
            this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();
        }
    };
    AgendaView.prototype.unrenderSkeleton = function () {
        this.timeGrid.removeElement();
        if (this.dayGrid) {
            this.dayGrid.removeElement();
        }
        this.scroller.destroy();
    };
    // Builds the HTML skeleton for the view.
    // The day-grid and time-grid components will render inside containers defined by this HTML.
    AgendaView.prototype.renderSkeletonHtml = function () {
        var theme = this.calendar.theme;
        return '' +
            '<table class="' + theme.getClass('tableGrid') + '">' +
            (this.opt('columnHeader') ?
                '<thead class="fc-head">' +
                    '<tr>' +
                    '<td class="fc-head-container ' + theme.getClass('widgetHeader') + '">&nbsp;</td>' +
                    '</tr>' +
                    '</thead>' :
                '') +
            '<tbody class="fc-body">' +
            '<tr>' +
            '<td class="' + theme.getClass('widgetContent') + '">' +
            (this.dayGrid ?
                '<div class="fc-day-grid"></div>' +
                    '<hr class="fc-divider ' + theme.getClass('widgetHeader') + '"></hr>' :
                '') +
            '</td>' +
            '</tr>' +
            '</tbody>' +
            '</table>';
    };
    // Generates an HTML attribute string for setting the width of the axis, if it is known
    AgendaView.prototype.axisStyleAttr = function () {
        if (this.axisWidth != null) {
            return 'style="width:' + this.axisWidth + 'px"';
        }
        return '';
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/
    AgendaView.prototype.getNowIndicatorUnit = function () {
        return this.timeGrid.getNowIndicatorUnit();
    };
    /* Dimensions
    ------------------------------------------------------------------------------------------------------------------*/
    // Adjusts the vertical dimensions of the view to the specified values
    AgendaView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        var eventLimit;
        var scrollerHeight;
        var scrollbarWidths;
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        // make all axis cells line up, and record the width so newly created axis cells will have it
        this.axisWidth = util_1.matchCellWidths(this.el.find('.fc-axis'));
        // hack to give the view some height prior to timeGrid's columns being rendered
        // TODO: separate setting height from scroller VS timeGrid.
        if (!this.timeGrid.colEls) {
            if (!isAuto) {
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            return;
        }
        // set of fake row elements that must compensate when scroller has scrollbars
        var noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)');
        // reset all dimensions back to the original state
        this.timeGrid.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary
        this.scroller.clear(); // sets height to 'auto' and clears overflow
        util_1.uncompensateScroll(noScrollRowEls);
        // limit number of events in the all-day area
        if (this.dayGrid) {
            this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed
            eventLimit = this.opt('eventLimit');
            if (eventLimit && typeof eventLimit !== 'number') {
                eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
            }
            if (eventLimit) {
                this.dayGrid.limitRows(eventLimit);
            }
        }
        if (!isAuto) { // should we force dimensions of the scroll container?
            scrollerHeight = this.computeScrollerHeight(totalHeight);
            this.scroller.setHeight(scrollerHeight);
            scrollbarWidths = this.scroller.getScrollbarWidths();
            if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?
                // make the all-day and header rows lines up
                util_1.compensateScroll(noScrollRowEls, scrollbarWidths);
                // the scrollbar compensation might have changed text flow, which might affect height, so recalculate
                // and reapply the desired height to the scroller.
                scrollerHeight = this.computeScrollerHeight(totalHeight);
                this.scroller.setHeight(scrollerHeight);
            }
            // guarantees the same scrollbar widths
            this.scroller.lockOverflow(scrollbarWidths);
            // if there's any space below the slats, show the horizontal rule.
            // this won't cause any new overflow, because lockOverflow already called.
            if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {
                this.timeGrid.bottomRuleEl.show();
            }
        }
    };
    // given a desired total height of the view, returns what the height of the scroller should be
    AgendaView.prototype.computeScrollerHeight = function (totalHeight) {
        return totalHeight -
            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };
    /* Scroll
    ------------------------------------------------------------------------------------------------------------------*/
    // Computes the initial pre-configured scroll state prior to allowing the user to change it
    AgendaView.prototype.computeInitialDateScroll = function () {
        var scrollTime = moment.duration(this.opt('scrollTime'));
        var top = this.timeGrid.computeTimeTop(scrollTime);
        // zoom can give weird floating-point values. rather scroll a little bit further
        top = Math.ceil(top);
        if (top) {
            top++; // to overcome top border that slots beyond the first have. looks better
        }
        return { top: top };
    };
    AgendaView.prototype.queryDateScroll = function () {
        return { top: this.scroller.getScrollTop() };
    };
    AgendaView.prototype.applyDateScroll = function (scroll) {
        if (scroll.top !== undefined) {
            this.scroller.setScrollTop(scroll.top);
        }
    };
    /* Hit Areas
    ------------------------------------------------------------------------------------------------------------------*/
    // forward all hit-related method calls to the grids (dayGrid might not be defined)
    AgendaView.prototype.getHitFootprint = function (hit) {
        // TODO: hit.component is set as a hack to identify where the hit came from
        return hit.component.getHitFootprint(hit);
    };
    AgendaView.prototype.getHitEl = function (hit) {
        // TODO: hit.component is set as a hack to identify where the hit came from
        return hit.component.getHitEl(hit);
    };
    /* Event Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    AgendaView.prototype.executeEventRender = function (eventsPayload) {
        var dayEventsPayload = {};
        var timedEventsPayload = {};
        var id;
        var eventInstanceGroup;
        // separate the events into all-day and timed
        for (id in eventsPayload) {
            eventInstanceGroup = eventsPayload[id];
            if (eventInstanceGroup.getEventDef().isAllDay()) {
                dayEventsPayload[id] = eventInstanceGroup;
            }
            else {
                timedEventsPayload[id] = eventInstanceGroup;
            }
        }
        this.timeGrid.executeEventRender(timedEventsPayload);
        if (this.dayGrid) {
            this.dayGrid.executeEventRender(dayEventsPayload);
        }
    };
    /* Dragging/Resizing Routing
    ------------------------------------------------------------------------------------------------------------------*/
    // A returned value of `true` signals that a mock "helper" event has been rendered.
    AgendaView.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var groups = groupEventFootprintsByAllDay(eventFootprints);
        var renderedHelper = false;
        renderedHelper = this.timeGrid.renderDrag(groups.timed, seg, isTouch);
        if (this.dayGrid) {
            renderedHelper = this.dayGrid.renderDrag(groups.allDay, seg, isTouch) || renderedHelper;
        }
        return renderedHelper;
    };
    AgendaView.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        var groups = groupEventFootprintsByAllDay(eventFootprints);
        this.timeGrid.renderEventResize(groups.timed, seg, isTouch);
        if (this.dayGrid) {
            this.dayGrid.renderEventResize(groups.allDay, seg, isTouch);
        }
    };
    /* Selection
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of a selection
    AgendaView.prototype.renderSelectionFootprint = function (componentFootprint) {
        if (!componentFootprint.isAllDay) {
            this.timeGrid.renderSelectionFootprint(componentFootprint);
        }
        else if (this.dayGrid) {
            this.dayGrid.renderSelectionFootprint(componentFootprint);
        }
    };
    return AgendaView;
}(View_1.default));
exports.default = AgendaView;
AgendaView.prototype.timeGridClass = TimeGrid_1.default;
AgendaView.prototype.dayGridClass = DayGrid_1.default;
// Will customize the rendering behavior of the AgendaView's timeGrid
agendaTimeGridMethods = {
    // Generates the HTML that will go before the day-of week header cells
    renderHeadIntroHtml: function () {
        var view = this.view;
        var calendar = view.calendar;
        var weekStart = calendar.msToUtcMoment(this.dateProfile.renderUnzonedRange.startMs, true);
        var weekText;
        if (this.opt('weekNumbers')) {
            weekText = weekStart.format(this.opt('smallWeekFormat'));
            return '' +
                '<th class="fc-axis fc-week-number ' + calendar.theme.getClass('widgetHeader') + '" ' + view.axisStyleAttr() + '>' +
                view.buildGotoAnchorHtml(// aside from link, important for matchCellWidths
                { date: weekStart, type: 'week', forceOff: this.colCnt > 1 }, util_1.htmlEscape(weekText) // inner HTML
                ) +
                '</th>';
        }
        else {
            return '<th class="fc-axis ' + calendar.theme.getClass('widgetHeader') + '" ' + view.axisStyleAttr() + '></th>';
        }
    },
    // Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
    renderBgIntroHtml: function () {
        var view = this.view;
        return '<td class="fc-axis ' + view.calendar.theme.getClass('widgetContent') + '" ' + view.axisStyleAttr() + '></td>';
    },
    // Generates the HTML that goes before all other types of cells.
    // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
    renderIntroHtml: function () {
        var view = this.view;
        return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
    }
};
// Will customize the rendering behavior of the AgendaView's dayGrid
agendaDayGridMethods = {
    // Generates the HTML that goes before the all-day cells
    renderBgIntroHtml: function () {
        var view = this.view;
        return '' +
            '<td class="fc-axis ' + view.calendar.theme.getClass('widgetContent') + '" ' + view.axisStyleAttr() + '>' +
            '<span>' + // needed for matchCellWidths
            view.getAllDayHtml() +
            '</span>' +
            '</td>';
    },
    // Generates the HTML that goes before all other types of cells.
    // Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
    renderIntroHtml: function () {
        var view = this.view;
        return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
    }
};
function groupEventFootprintsByAllDay(eventFootprints) {
    var allDay = [];
    var timed = [];
    var i;
    for (i = 0; i < eventFootprints.length; i++) {
        if (eventFootprints[i].componentFootprint.isAllDay) {
            allDay.push(eventFootprints[i]);
        }
        else {
            timed.push(eventFootprints[i]);
        }
    }
    return { allDay: allDay, timed: timed };
}


/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var InteractiveDateComponent_1 = __webpack_require__(42);
var BusinessHourRenderer_1 = __webpack_require__(61);
var StandardInteractionsMixin_1 = __webpack_require__(65);
var DayTableMixin_1 = __webpack_require__(60);
var CoordCache_1 = __webpack_require__(58);
var UnzonedRange_1 = __webpack_require__(5);
var ComponentFootprint_1 = __webpack_require__(12);
var TimeGridEventRenderer_1 = __webpack_require__(240);
var TimeGridHelperRenderer_1 = __webpack_require__(241);
var TimeGridFillRenderer_1 = __webpack_require__(242);
/* A component that renders one or more columns of vertical time slots
----------------------------------------------------------------------------------------------------------------------*/
// We mixin DayTable, even though there is only a single row of days
// potential nice values for the slot-duration and interval-duration
// from largest to smallest
var AGENDA_STOCK_SUB_DURATIONS = [
    { hours: 1 },
    { minutes: 30 },
    { minutes: 15 },
    { seconds: 30 },
    { seconds: 15 }
];
var TimeGrid = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGrid, _super);
    function TimeGrid(view) {
        var _this = _super.call(this, view) || this;
        _this.processOptions();
        return _this;
    }
    // Slices up the given span (unzoned start/end with other misc data) into an array of segments
    TimeGrid.prototype.componentFootprintToSegs = function (componentFootprint) {
        var segs = this.sliceRangeByTimes(componentFootprint.unzonedRange);
        var i;
        for (i = 0; i < segs.length; i++) {
            if (this.isRTL) {
                segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;
            }
            else {
                segs[i].col = segs[i].dayIndex;
            }
        }
        return segs;
    };
    /* Date Handling
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.sliceRangeByTimes = function (unzonedRange) {
        var segs = [];
        var segRange;
        var dayIndex;
        for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {
            segRange = unzonedRange.intersect(this.dayRanges[dayIndex]);
            if (segRange) {
                segs.push({
                    startMs: segRange.startMs,
                    endMs: segRange.endMs,
                    isStart: segRange.isStart,
                    isEnd: segRange.isEnd,
                    dayIndex: dayIndex
                });
            }
        }
        return segs;
    };
    /* Options
    ------------------------------------------------------------------------------------------------------------------*/
    // Parses various options into properties of this object
    TimeGrid.prototype.processOptions = function () {
        var slotDuration = this.opt('slotDuration');
        var snapDuration = this.opt('snapDuration');
        var input;
        slotDuration = moment.duration(slotDuration);
        snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;
        this.slotDuration = slotDuration;
        this.snapDuration = snapDuration;
        this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?
        // might be an array value (for TimelineView).
        // if so, getting the most granular entry (the last one probably).
        input = this.opt('slotLabelFormat');
        if ($.isArray(input)) {
            input = input[input.length - 1];
        }
        this.labelFormat = input ||
            this.opt('smallTimeFormat'); // the computed default
        input = this.opt('slotLabelInterval');
        this.labelInterval = input ?
            moment.duration(input) :
            this.computeLabelInterval(slotDuration);
    };
    // Computes an automatic value for slotLabelInterval
    TimeGrid.prototype.computeLabelInterval = function (slotDuration) {
        var i;
        var labelInterval;
        var slotsPerLabel;
        // find the smallest stock label interval that results in more than one slots-per-label
        for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
            labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
            slotsPerLabel = util_1.divideDurationByDuration(labelInterval, slotDuration);
            if (util_1.isInt(slotsPerLabel) && slotsPerLabel > 1) {
                return labelInterval;
            }
        }
        return moment.duration(slotDuration); // fall back. clone
    };
    /* Date Rendering
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.renderDates = function (dateProfile) {
        this.dateProfile = dateProfile;
        this.updateDayTable();
        this.renderSlats();
        this.renderColumns();
    };
    TimeGrid.prototype.unrenderDates = function () {
        // this.unrenderSlats(); // don't need this because repeated .html() calls clear
        this.unrenderColumns();
    };
    TimeGrid.prototype.renderSkeleton = function () {
        var theme = this.view.calendar.theme;
        this.el.html('<div class="fc-bg"></div>' +
            '<div class="fc-slats"></div>' +
            '<hr class="fc-divider ' + theme.getClass('widgetHeader') + '" style="display:none"></hr>');
        this.bottomRuleEl = this.el.find('hr');
    };
    TimeGrid.prototype.renderSlats = function () {
        var theme = this.view.calendar.theme;
        this.slatContainerEl = this.el.find('> .fc-slats')
            .html(// avoids needing ::unrenderSlats()
        '<table class="' + theme.getClass('tableGrid') + '">' +
            this.renderSlatRowHtml() +
            '</table>');
        this.slatEls = this.slatContainerEl.find('tr');
        this.slatCoordCache = new CoordCache_1.default({
            els: this.slatEls,
            isVertical: true
        });
    };
    // Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
    TimeGrid.prototype.renderSlatRowHtml = function () {
        var view = this.view;
        var calendar = view.calendar;
        var theme = calendar.theme;
        var isRTL = this.isRTL;
        var dateProfile = this.dateProfile;
        var html = '';
        var slotTime = moment.duration(+dateProfile.minTime); // wish there was .clone() for durations
        var slotIterator = moment.duration(0);
        var slotDate; // will be on the view's first day, but we only care about its time
        var isLabeled;
        var axisHtml;
        // Calculate the time for each slot
        while (slotTime < dateProfile.maxTime) {
            slotDate = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs).time(slotTime);
            isLabeled = util_1.isInt(util_1.divideDurationByDuration(slotIterator, this.labelInterval));
            axisHtml =
                '<td class="fc-axis fc-time ' + theme.getClass('widgetContent') + '" ' + view.axisStyleAttr() + '>' +
                    (isLabeled ?
                        '<span>' + // for matchCellWidths
                            util_1.htmlEscape(slotDate.format(this.labelFormat)) +
                            '</span>' :
                        '') +
                    '</td>';
            html +=
                '<tr data-time="' + slotDate.format('HH:mm:ss') + '"' +
                    (isLabeled ? '' : ' class="fc-minor"') +
                    '>' +
                    (!isRTL ? axisHtml : '') +
                    '<td class="' + theme.getClass('widgetContent') + '"></td>' +
                    (isRTL ? axisHtml : '') +
                    '</tr>';
            slotTime.add(this.slotDuration);
            slotIterator.add(this.slotDuration);
        }
        return html;
    };
    TimeGrid.prototype.renderColumns = function () {
        var dateProfile = this.dateProfile;
        var theme = this.view.calendar.theme;
        this.dayRanges = this.dayDates.map(function (dayDate) {
            return new UnzonedRange_1.default(dayDate.clone().add(dateProfile.minTime), dayDate.clone().add(dateProfile.maxTime));
        });
        if (this.headContainerEl) {
            this.headContainerEl.html(this.renderHeadHtml());
        }
        this.el.find('> .fc-bg').html('<table class="' + theme.getClass('tableGrid') + '">' +
            this.renderBgTrHtml(0) + // row=0
            '</table>');
        this.colEls = this.el.find('.fc-day, .fc-disabled-day');
        this.colCoordCache = new CoordCache_1.default({
            els: this.colEls,
            isHorizontal: true
        });
        this.renderContentSkeleton();
    };
    TimeGrid.prototype.unrenderColumns = function () {
        this.unrenderContentSkeleton();
    };
    /* Content Skeleton
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders the DOM that the view's content will live in
    TimeGrid.prototype.renderContentSkeleton = function () {
        var cellHtml = '';
        var i;
        var skeletonEl;
        for (i = 0; i < this.colCnt; i++) {
            cellHtml +=
                '<td>' +
                    '<div class="fc-content-col">' +
                    '<div class="fc-event-container fc-helper-container"></div>' +
                    '<div class="fc-event-container"></div>' +
                    '<div class="fc-highlight-container"></div>' +
                    '<div class="fc-bgevent-container"></div>' +
                    '<div class="fc-business-container"></div>' +
                    '</div>' +
                    '</td>';
        }
        skeletonEl = this.contentSkeletonEl = $('<div class="fc-content-skeleton">' +
            '<table>' +
            '<tr>' + cellHtml + '</tr>' +
            '</table>' +
            '</div>');
        this.colContainerEls = skeletonEl.find('.fc-content-col');
        this.helperContainerEls = skeletonEl.find('.fc-helper-container');
        this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');
        this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');
        this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');
        this.businessContainerEls = skeletonEl.find('.fc-business-container');
        this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level
        this.el.append(skeletonEl);
    };
    TimeGrid.prototype.unrenderContentSkeleton = function () {
        if (this.contentSkeletonEl) { // defensive :(
            this.contentSkeletonEl.remove();
            this.contentSkeletonEl = null;
            this.colContainerEls = null;
            this.helperContainerEls = null;
            this.fgContainerEls = null;
            this.bgContainerEls = null;
            this.highlightContainerEls = null;
            this.businessContainerEls = null;
        }
    };
    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
    TimeGrid.prototype.groupSegsByCol = function (segs) {
        var segsByCol = [];
        var i;
        for (i = 0; i < this.colCnt; i++) {
            segsByCol.push([]);
        }
        for (i = 0; i < segs.length; i++) {
            segsByCol[segs[i].col].push(segs[i]);
        }
        return segsByCol;
    };
    // Given segments grouped by column, insert the segments' elements into a parallel array of container
    // elements, each living within a column.
    TimeGrid.prototype.attachSegsByCol = function (segsByCol, containerEls) {
        var col;
        var segs;
        var i;
        for (col = 0; col < this.colCnt; col++) { // iterate each column grouping
            segs = segsByCol[col];
            for (i = 0; i < segs.length; i++) {
                containerEls.eq(col).append(segs[i].el);
            }
        }
    };
    /* Now Indicator
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.getNowIndicatorUnit = function () {
        return 'minute'; // will refresh on the minute
    };
    TimeGrid.prototype.renderNowIndicator = function (date) {
        // HACK: if date columns not ready for some reason (scheduler)
        if (!this.colContainerEls) {
            return;
        }
        // seg system might be overkill, but it handles scenario where line needs to be rendered
        //  more than once because of columns with the same date (resources columns for example)
        var segs = this.componentFootprintToSegs(new ComponentFootprint_1.default(new UnzonedRange_1.default(date, date.valueOf() + 1), // protect against null range
        false // all-day
        ));
        var top = this.computeDateTop(date, date);
        var nodes = [];
        var i;
        // render lines within the columns
        for (i = 0; i < segs.length; i++) {
            nodes.push($('<div class="fc-now-indicator fc-now-indicator-line"></div>')
                .css('top', top)
                .appendTo(this.colContainerEls.eq(segs[i].col))[0]);
        }
        // render an arrow over the axis
        if (segs.length > 0) { // is the current time in view?
            nodes.push($('<div class="fc-now-indicator fc-now-indicator-arrow"></div>')
                .css('top', top)
                .appendTo(this.el.find('.fc-content-skeleton'))[0]);
        }
        this.nowIndicatorEls = $(nodes);
    };
    TimeGrid.prototype.unrenderNowIndicator = function () {
        if (this.nowIndicatorEls) {
            this.nowIndicatorEls.remove();
            this.nowIndicatorEls = null;
        }
    };
    /* Coordinates
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        this.slatCoordCache.build();
        if (isResize) {
            this.updateSegVerticals([].concat(this.eventRenderer.getSegs(), this.businessSegs || []));
        }
    };
    TimeGrid.prototype.getTotalSlatHeight = function () {
        return this.slatContainerEl.outerHeight();
    };
    // Computes the top coordinate, relative to the bounds of the grid, of the given date.
    // `ms` can be a millisecond UTC time OR a UTC moment.
    // A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
    TimeGrid.prototype.computeDateTop = function (ms, startOfDayDate) {
        return this.computeTimeTop(moment.duration(ms - startOfDayDate.clone().stripTime()));
    };
    // Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
    TimeGrid.prototype.computeTimeTop = function (time) {
        var len = this.slatEls.length;
        var dateProfile = this.dateProfile;
        var slatCoverage = (time - dateProfile.minTime) / this.slotDuration; // floating-point value of # of slots covered
        var slatIndex;
        var slatRemainder;
        // compute a floating-point number for how many slats should be progressed through.
        // from 0 to number of slats (inclusive)
        // constrained because minTime/maxTime might be customized.
        slatCoverage = Math.max(0, slatCoverage);
        slatCoverage = Math.min(len, slatCoverage);
        // an integer index of the furthest whole slat
        // from 0 to number slats (*exclusive*, so len-1)
        slatIndex = Math.floor(slatCoverage);
        slatIndex = Math.min(slatIndex, len - 1);
        // how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
        // could be 1.0 if slatCoverage is covering *all* the slots
        slatRemainder = slatCoverage - slatIndex;
        return this.slatCoordCache.getTopPosition(slatIndex) +
            this.slatCoordCache.getHeight(slatIndex) * slatRemainder;
    };
    // Refreshes the CSS top/bottom coordinates for each segment element.
    // Works when called after initial render, after a window resize/zoom for example.
    TimeGrid.prototype.updateSegVerticals = function (segs) {
        this.computeSegVerticals(segs);
        this.assignSegVerticals(segs);
    };
    // For each segment in an array, computes and assigns its top and bottom properties
    TimeGrid.prototype.computeSegVerticals = function (segs) {
        var eventMinHeight = this.opt('agendaEventMinHeight');
        var i;
        var seg;
        var dayDate;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            dayDate = this.dayDates[seg.dayIndex];
            seg.top = this.computeDateTop(seg.startMs, dayDate);
            seg.bottom = Math.max(seg.top + eventMinHeight, this.computeDateTop(seg.endMs, dayDate));
        }
    };
    // Given segments that already have their top/bottom properties computed, applies those values to
    // the segments' elements.
    TimeGrid.prototype.assignSegVerticals = function (segs) {
        var i;
        var seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            seg.el.css(this.generateSegVerticalCss(seg));
        }
    };
    // Generates an object with CSS properties for the top/bottom coordinates of a segment element
    TimeGrid.prototype.generateSegVerticalCss = function (seg) {
        return {
            top: seg.top,
            bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
        };
    };
    /* Hit System
    ------------------------------------------------------------------------------------------------------------------*/
    TimeGrid.prototype.prepareHits = function () {
        this.colCoordCache.build();
        this.slatCoordCache.build();
    };
    TimeGrid.prototype.releaseHits = function () {
        this.colCoordCache.clear();
        // NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop
    };
    TimeGrid.prototype.queryHit = function (leftOffset, topOffset) {
        var snapsPerSlot = this.snapsPerSlot;
        var colCoordCache = this.colCoordCache;
        var slatCoordCache = this.slatCoordCache;
        if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {
            var colIndex = colCoordCache.getHorizontalIndex(leftOffset);
            var slatIndex = slatCoordCache.getVerticalIndex(topOffset);
            if (colIndex != null && slatIndex != null) {
                var slatTop = slatCoordCache.getTopOffset(slatIndex);
                var slatHeight = slatCoordCache.getHeight(slatIndex);
                var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1
                var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
                var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
                var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;
                var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;
                return {
                    col: colIndex,
                    snap: snapIndex,
                    component: this,
                    left: colCoordCache.getLeftOffset(colIndex),
                    right: colCoordCache.getRightOffset(colIndex),
                    top: snapTop,
                    bottom: snapBottom
                };
            }
        }
    };
    TimeGrid.prototype.getHitFootprint = function (hit) {
        var start = this.getCellDate(0, hit.col); // row=0
        var time = this.computeSnapTime(hit.snap); // pass in the snap-index
        var end;
        start.time(time);
        end = start.clone().add(this.snapDuration);
        return new ComponentFootprint_1.default(new UnzonedRange_1.default(start, end), false // all-day?
        );
    };
    // Given a row number of the grid, representing a "snap", returns a time (Duration) from its start-of-day
    TimeGrid.prototype.computeSnapTime = function (snapIndex) {
        return moment.duration(this.dateProfile.minTime + this.snapDuration * snapIndex);
    };
    TimeGrid.prototype.getHitEl = function (hit) {
        return this.colEls.eq(hit.col);
    };
    /* Event Drag Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event being dragged over the specified date(s).
    // A returned value of `true` signals that a mock "helper" event has been rendered.
    TimeGrid.prototype.renderDrag = function (eventFootprints, seg, isTouch) {
        var i;
        if (seg) { // if there is event information for this drag, render a helper event
            if (eventFootprints.length) {
                this.helperRenderer.renderEventDraggingFootprints(eventFootprints, seg, isTouch);
                // signal that a helper has been rendered
                return true;
            }
        }
        else { // otherwise, just render a highlight
            for (i = 0; i < eventFootprints.length; i++) {
                this.renderHighlight(eventFootprints[i].componentFootprint);
            }
        }
    };
    // Unrenders any visual indication of an event being dragged
    TimeGrid.prototype.unrenderDrag = function () {
        this.unrenderHighlight();
        this.helperRenderer.unrender();
    };
    /* Event Resize Visualization
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of an event being resized
    TimeGrid.prototype.renderEventResize = function (eventFootprints, seg, isTouch) {
        this.helperRenderer.renderEventResizingFootprints(eventFootprints, seg, isTouch);
    };
    // Unrenders any visual indication of an event being resized
    TimeGrid.prototype.unrenderEventResize = function () {
        this.helperRenderer.unrender();
    };
    /* Selection
    ------------------------------------------------------------------------------------------------------------------*/
    // Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
    TimeGrid.prototype.renderSelectionFootprint = function (componentFootprint) {
        if (this.opt('selectHelper')) { // this setting signals that a mock helper event should be rendered
            this.helperRenderer.renderComponentFootprint(componentFootprint);
        }
        else {
            this.renderHighlight(componentFootprint);
        }
    };
    // Unrenders any visual indication of a selection
    TimeGrid.prototype.unrenderSelection = function () {
        this.helperRenderer.unrender();
        this.unrenderHighlight();
    };
    return TimeGrid;
}(InteractiveDateComponent_1.default));
exports.default = TimeGrid;
TimeGrid.prototype.eventRendererClass = TimeGridEventRenderer_1.default;
TimeGrid.prototype.businessHourRendererClass = BusinessHourRenderer_1.default;
TimeGrid.prototype.helperRendererClass = TimeGridHelperRenderer_1.default;
TimeGrid.prototype.fillRendererClass = TimeGridFillRenderer_1.default;
StandardInteractionsMixin_1.default.mixInto(TimeGrid);
DayTableMixin_1.default.mixInto(TimeGrid);


/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var EventRenderer_1 = __webpack_require__(44);
/*
Only handles foreground segs.
Does not own rendering. Use for low-level util methods by TimeGrid.
*/
var TimeGridEventRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGridEventRenderer, _super);
    function TimeGridEventRenderer(timeGrid, fillRenderer) {
        var _this = _super.call(this, timeGrid, fillRenderer) || this;
        _this.timeGrid = timeGrid;
        return _this;
    }
    TimeGridEventRenderer.prototype.renderFgSegs = function (segs) {
        this.renderFgSegsIntoContainers(segs, this.timeGrid.fgContainerEls);
    };
    // Given an array of foreground segments, render a DOM element for each, computes position,
    // and attaches to the column inner-container elements.
    TimeGridEventRenderer.prototype.renderFgSegsIntoContainers = function (segs, containerEls) {
        var segsByCol;
        var col;
        segsByCol = this.timeGrid.groupSegsByCol(segs);
        for (col = 0; col < this.timeGrid.colCnt; col++) {
            this.updateFgSegCoords(segsByCol[col]);
        }
        this.timeGrid.attachSegsByCol(segsByCol, containerEls);
    };
    TimeGridEventRenderer.prototype.unrenderFgSegs = function () {
        if (this.fgSegs) { // hack
            this.fgSegs.forEach(function (seg) {
                seg.el.remove();
            });
        }
    };
    // Computes a default event time formatting string if `timeFormat` is not explicitly defined
    TimeGridEventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('noMeridiemTimeFormat'); // like "6:30" (no AM/PM)
    };
    // Computes a default `displayEventEnd` value if one is not expliclty defined
    TimeGridEventRenderer.prototype.computeDisplayEventEnd = function () {
        return true;
    };
    // Renders the HTML for a single event segment's default rendering
    TimeGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
        var view = this.view;
        var calendar = view.calendar;
        var componentFootprint = seg.footprint.componentFootprint;
        var isAllDay = componentFootprint.isAllDay;
        var eventDef = seg.footprint.eventDef;
        var isDraggable = view.isEventDefDraggable(eventDef);
        var isResizableFromStart = !disableResizing && seg.isStart && view.isEventDefResizableFromStart(eventDef);
        var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventDefResizableFromEnd(eventDef);
        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
        var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));
        var timeText;
        var fullTimeText; // more verbose time text. for the print stylesheet
        var startTimeText; // just the start time text
        classes.unshift('fc-time-grid-event', 'fc-v-event');
        // if the event appears to span more than one day...
        if (view.isMultiDayRange(componentFootprint.unzonedRange)) {
            // Don't display time text on segments that run entirely through a day.
            // That would appear as midnight-midnight and would look dumb.
            // Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
            if (seg.isStart || seg.isEnd) {
                var zonedStart = calendar.msToMoment(seg.startMs);
                var zonedEnd = calendar.msToMoment(seg.endMs);
                timeText = this._getTimeText(zonedStart, zonedEnd, isAllDay);
                fullTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, 'LT');
                startTimeText = this._getTimeText(zonedStart, zonedEnd, isAllDay, null, false); // displayEnd=false
            }
        }
        else {
            // Display the normal time text for the *event's* times
            timeText = this.getTimeText(seg.footprint);
            fullTimeText = this.getTimeText(seg.footprint, 'LT');
            startTimeText = this.getTimeText(seg.footprint, null, false); // displayEnd=false
        }
        return '<a class="' + classes.join(' ') + '"' +
            (eventDef.url ?
                ' href="' + util_1.htmlEscape(eventDef.url) + '"' :
                '') +
            (skinCss ?
                ' style="' + skinCss + '"' :
                '') +
            '>' +
            '<div class="fc-content">' +
            (timeText ?
                '<div class="fc-time"' +
                    ' data-start="' + util_1.htmlEscape(startTimeText) + '"' +
                    ' data-full="' + util_1.htmlEscape(fullTimeText) + '"' +
                    '>' +
                    '<span>' + util_1.htmlEscape(timeText) + '</span>' +
                    '</div>' :
                '') +
            (eventDef.title ?
                '<div class="fc-title">' +
                    util_1.htmlEscape(eventDef.title) +
                    '</div>' :
                '') +
            '</div>' +
            '<div class="fc-bg"></div>' +
            /* TODO: write CSS for this
            (isResizableFromStart ?
              '<div class="fc-resizer fc-start-resizer"></div>' :
              ''
              ) +
            */
            (isResizableFromEnd ?
                '<div class="fc-resizer fc-end-resizer"></div>' :
                '') +
            '</a>';
    };
    // Given segments that are assumed to all live in the *same column*,
    // compute their verical/horizontal coordinates and assign to their elements.
    TimeGridEventRenderer.prototype.updateFgSegCoords = function (segs) {
        this.timeGrid.computeSegVerticals(segs); // horizontals relies on this
        this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array
        this.timeGrid.assignSegVerticals(segs);
        this.assignFgSegHorizontals(segs);
    };
    // Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
    // NOTE: Also reorders the given array by date!
    TimeGridEventRenderer.prototype.computeFgSegHorizontals = function (segs) {
        var levels;
        var level0;
        var i;
        this.sortEventSegs(segs); // order by certain criteria
        levels = buildSlotSegLevels(segs);
        computeForwardSlotSegs(levels);
        if ((level0 = levels[0])) {
            for (i = 0; i < level0.length; i++) {
                computeSlotSegPressures(level0[i]);
            }
            for (i = 0; i < level0.length; i++) {
                this.computeFgSegForwardBack(level0[i], 0, 0);
            }
        }
    };
    // Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
    // from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
    // seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
    //
    // The segment might be part of a "series", which means consecutive segments with the same pressure
    // who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
    // segments behind this one in the current series, and `seriesBackwardCoord` is the starting
    // coordinate of the first segment in the series.
    TimeGridEventRenderer.prototype.computeFgSegForwardBack = function (seg, seriesBackwardPressure, seriesBackwardCoord) {
        var forwardSegs = seg.forwardSegs;
        var i;
        if (seg.forwardCoord === undefined) { // not already computed
            if (!forwardSegs.length) {
                // if there are no forward segments, this segment should butt up against the edge
                seg.forwardCoord = 1;
            }
            else {
                // sort highest pressure first
                this.sortForwardSegs(forwardSegs);
                // this segment's forwardCoord will be calculated from the backwardCoord of the
                // highest-pressure forward segment.
                this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
                seg.forwardCoord = forwardSegs[0].backwardCoord;
            }
            // calculate the backwardCoord from the forwardCoord. consider the series
            seg.backwardCoord = seg.forwardCoord -
                (seg.forwardCoord - seriesBackwardCoord) / // available width for series
                    (seriesBackwardPressure + 1); // # of segments in the series
            // use this segment's coordinates to computed the coordinates of the less-pressurized
            // forward segments
            for (i = 0; i < forwardSegs.length; i++) {
                this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
            }
        }
    };
    TimeGridEventRenderer.prototype.sortForwardSegs = function (forwardSegs) {
        forwardSegs.sort(util_1.proxy(this, 'compareForwardSegs'));
    };
    // A cmp function for determining which forward segment to rely on more when computing coordinates.
    TimeGridEventRenderer.prototype.compareForwardSegs = function (seg1, seg2) {
        // put higher-pressure first
        return seg2.forwardPressure - seg1.forwardPressure ||
            // put segments that are closer to initial edge first (and favor ones with no coords yet)
            (seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
            // do normal sorting...
            this.compareEventSegs(seg1, seg2);
    };
    // Given foreground event segments that have already had their position coordinates computed,
    // assigns position-related CSS values to their elements.
    TimeGridEventRenderer.prototype.assignFgSegHorizontals = function (segs) {
        var i;
        var seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            seg.el.css(this.generateFgSegHorizontalCss(seg));
            // if the event is short that the title will be cut off,
            // attach a className that condenses the title into the time area.
            if (seg.footprint.eventDef.title && seg.bottom - seg.top < 30) {
                seg.el.addClass('fc-short'); // TODO: "condensed" is a better name
            }
        }
    };
    // Generates an object with CSS properties/values that should be applied to an event segment element.
    // Contains important positioning-related properties that should be applied to any event element, customized or not.
    TimeGridEventRenderer.prototype.generateFgSegHorizontalCss = function (seg) {
        var shouldOverlap = this.opt('slotEventOverlap');
        var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
        var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
        var props = this.timeGrid.generateSegVerticalCss(seg); // get top/bottom first
        var isRTL = this.timeGrid.isRTL;
        var left; // amount of space from left edge, a fraction of the total width
        var right; // amount of space from right edge, a fraction of the total width
        if (shouldOverlap) {
            // double the width, but don't go beyond the maximum forward coordinate (1.0)
            forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
        }
        if (isRTL) {
            left = 1 - forwardCoord;
            right = backwardCoord;
        }
        else {
            left = backwardCoord;
            right = 1 - forwardCoord;
        }
        props.zIndex = seg.level + 1; // convert from 0-base to 1-based
        props.left = left * 100 + '%';
        props.right = right * 100 + '%';
        if (shouldOverlap && seg.forwardPressure) {
            // add padding to the edge so that forward stacked events don't cover the resizer's icon
            props[isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
        }
        return props;
    };
    return TimeGridEventRenderer;
}(EventRenderer_1.default));
exports.default = TimeGridEventRenderer;
// Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
function buildSlotSegLevels(segs) {
    var levels = [];
    var i;
    var seg;
    var j;
    for (i = 0; i < segs.length; i++) {
        seg = segs[i];
        // go through all the levels and stop on the first level where there are no collisions
        for (j = 0; j < levels.length; j++) {
            if (!computeSlotSegCollisions(seg, levels[j]).length) {
                break;
            }
        }
        seg.level = j;
        (levels[j] || (levels[j] = [])).push(seg);
    }
    return levels;
}
// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function computeForwardSlotSegs(levels) {
    var i;
    var level;
    var j;
    var seg;
    var k;
    for (i = 0; i < levels.length; i++) {
        level = levels[i];
        for (j = 0; j < level.length; j++) {
            seg = level[j];
            seg.forwardSegs = [];
            for (k = i + 1; k < levels.length; k++) {
                computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
            }
        }
    }
}
// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function computeSlotSegPressures(seg) {
    var forwardSegs = seg.forwardSegs;
    var forwardPressure = 0;
    var i;
    var forwardSeg;
    if (seg.forwardPressure === undefined) { // not already computed
        for (i = 0; i < forwardSegs.length; i++) {
            forwardSeg = forwardSegs[i];
            // figure out the child's maximum forward path
            computeSlotSegPressures(forwardSeg);
            // either use the existing maximum, or use the child's forward pressure
            // plus one (for the forwardSeg itself)
            forwardPressure = Math.max(forwardPressure, 1 + forwardSeg.forwardPressure);
        }
        seg.forwardPressure = forwardPressure;
    }
}
// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function computeSlotSegCollisions(seg, otherSegs, results) {
    if (results === void 0) { results = []; }
    for (var i = 0; i < otherSegs.length; i++) {
        if (isSlotSegCollision(seg, otherSegs[i])) {
            results.push(otherSegs[i]);
        }
    }
    return results;
}
// Do these segments occupy the same vertical space?
function isSlotSegCollision(seg1, seg2) {
    return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
}


/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var HelperRenderer_1 = __webpack_require__(63);
var TimeGridHelperRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGridHelperRenderer, _super);
    function TimeGridHelperRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
        var helperNodes = [];
        var i;
        var seg;
        var sourceEl;
        // TODO: not good to call eventRenderer this way
        this.eventRenderer.renderFgSegsIntoContainers(segs, this.component.helperContainerEls);
        // Try to make the segment that is in the same row as sourceSeg look the same
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            if (sourceSeg && sourceSeg.col === seg.col) {
                sourceEl = sourceSeg.el;
                seg.el.css({
                    left: sourceEl.css('left'),
                    right: sourceEl.css('right'),
                    'margin-left': sourceEl.css('margin-left'),
                    'margin-right': sourceEl.css('margin-right')
                });
            }
            helperNodes.push(seg.el[0]);
        }
        return $(helperNodes); // must return the elements rendered
    };
    return TimeGridHelperRenderer;
}(HelperRenderer_1.default));
exports.default = TimeGridHelperRenderer;


/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var FillRenderer_1 = __webpack_require__(62);
var TimeGridFillRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(TimeGridFillRenderer, _super);
    function TimeGridFillRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TimeGridFillRenderer.prototype.attachSegEls = function (type, segs) {
        var timeGrid = this.component;
        var containerEls;
        // TODO: more efficient lookup
        if (type === 'bgEvent') {
            containerEls = timeGrid.bgContainerEls;
        }
        else if (type === 'businessHours') {
            containerEls = timeGrid.businessContainerEls;
        }
        else if (type === 'highlight') {
            containerEls = timeGrid.highlightContainerEls;
        }
        timeGrid.updateSegVerticals(segs);
        timeGrid.attachSegsByCol(timeGrid.groupSegsByCol(segs), containerEls);
        return segs.map(function (seg) {
            return seg.el[0];
        });
    };
    return TimeGridFillRenderer;
}(FillRenderer_1.default));
exports.default = TimeGridFillRenderer;


/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var EventRenderer_1 = __webpack_require__(44);
/* Event-rendering methods for the DayGrid class
----------------------------------------------------------------------------------------------------------------------*/
var DayGridEventRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(DayGridEventRenderer, _super);
    function DayGridEventRenderer(dayGrid, fillRenderer) {
        var _this = _super.call(this, dayGrid, fillRenderer) || this;
        _this.dayGrid = dayGrid;
        return _this;
    }
    DayGridEventRenderer.prototype.renderBgRanges = function (eventRanges) {
        // don't render timed background events
        eventRanges = $.grep(eventRanges, function (eventRange) {
            return eventRange.eventDef.isAllDay();
        });
        _super.prototype.renderBgRanges.call(this, eventRanges);
    };
    // Renders the given foreground event segments onto the grid
    DayGridEventRenderer.prototype.renderFgSegs = function (segs) {
        var rowStructs = this.rowStructs = this.renderSegRows(segs);
        // append to each row's content skeleton
        this.dayGrid.rowEls.each(function (i, rowNode) {
            $(rowNode).find('.fc-content-skeleton > table').append(rowStructs[i].tbodyEl);
        });
    };
    // Unrenders all currently rendered foreground event segments
    DayGridEventRenderer.prototype.unrenderFgSegs = function () {
        var rowStructs = this.rowStructs || [];
        var rowStruct;
        while ((rowStruct = rowStructs.pop())) {
            rowStruct.tbodyEl.remove();
        }
        this.rowStructs = null;
    };
    // Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
    // Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
    // PRECONDITION: each segment shoud already have a rendered and assigned `.el`
    DayGridEventRenderer.prototype.renderSegRows = function (segs) {
        var rowStructs = [];
        var segRows;
        var row;
        segRows = this.groupSegRows(segs); // group into nested arrays
        // iterate each row of segment groupings
        for (row = 0; row < segRows.length; row++) {
            rowStructs.push(this.renderSegRow(row, segRows[row]));
        }
        return rowStructs;
    };
    // Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
    // the segments. Returns object with a bunch of internal data about how the render was calculated.
    // NOTE: modifies rowSegs
    DayGridEventRenderer.prototype.renderSegRow = function (row, rowSegs) {
        var colCnt = this.dayGrid.colCnt;
        var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
        var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
        var tbody = $('<tbody>');
        var segMatrix = []; // lookup for which segments are rendered into which level+col cells
        var cellMatrix = []; // lookup for all <td> elements of the level+col matrix
        var loneCellMatrix = []; // lookup for <td> elements that only take up a single column
        var i;
        var levelSegs;
        var col;
        var tr;
        var j;
        var seg;
        var td;
        // populates empty cells from the current column (`col`) to `endCol`
        function emptyCellsUntil(endCol) {
            while (col < endCol) {
                // try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
                td = (loneCellMatrix[i - 1] || [])[col];
                if (td) {
                    td.attr('rowspan', parseInt(td.attr('rowspan') || 1, 10) + 1);
                }
                else {
                    td = $('<td>');
                    tr.append(td);
                }
                cellMatrix[i][col] = td;
                loneCellMatrix[i][col] = td;
                col++;
            }
        }
        for (i = 0; i < levelCnt; i++) { // iterate through all levels
            levelSegs = segLevels[i];
            col = 0;
            tr = $('<tr>');
            segMatrix.push([]);
            cellMatrix.push([]);
            loneCellMatrix.push([]);
            // levelCnt might be 1 even though there are no actual levels. protect against this.
            // this single empty row is useful for styling.
            if (levelSegs) {
                for (j = 0; j < levelSegs.length; j++) { // iterate through segments in level
                    seg = levelSegs[j];
                    emptyCellsUntil(seg.leftCol);
                    // create a container that occupies or more columns. append the event element.
                    td = $('<td class="fc-event-container">').append(seg.el);
                    if (seg.leftCol !== seg.rightCol) {
                        td.attr('colspan', seg.rightCol - seg.leftCol + 1);
                    }
                    else { // a single-column segment
                        loneCellMatrix[i][col] = td;
                    }
                    while (col <= seg.rightCol) {
                        cellMatrix[i][col] = td;
                        segMatrix[i][col] = seg;
                        col++;
                    }
                    tr.append(td);
                }
            }
            emptyCellsUntil(colCnt); // finish off the row
            this.dayGrid.bookendCells(tr);
            tbody.append(tr);
        }
        return {
            row: row,
            tbodyEl: tbody,
            cellMatrix: cellMatrix,
            segMatrix: segMatrix,
            segLevels: segLevels,
            segs: rowSegs
        };
    };
    // Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
    // NOTE: modifies segs
    DayGridEventRenderer.prototype.buildSegLevels = function (segs) {
        var levels = [];
        var i;
        var seg;
        var j;
        // Give preference to elements with certain criteria, so they have
        // a chance to be closer to the top.
        this.sortEventSegs(segs);
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            // loop through levels, starting with the topmost, until the segment doesn't collide with other segments
            for (j = 0; j < levels.length; j++) {
                if (!isDaySegCollision(seg, levels[j])) {
                    break;
                }
            }
            // `j` now holds the desired subrow index
            seg.level = j;
            // create new level array if needed and append segment
            (levels[j] || (levels[j] = [])).push(seg);
        }
        // order segments left-to-right. very important if calendar is RTL
        for (j = 0; j < levels.length; j++) {
            levels[j].sort(compareDaySegCols);
        }
        return levels;
    };
    // Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
    DayGridEventRenderer.prototype.groupSegRows = function (segs) {
        var segRows = [];
        var i;
        for (i = 0; i < this.dayGrid.rowCnt; i++) {
            segRows.push([]);
        }
        for (i = 0; i < segs.length; i++) {
            segRows[segs[i].row].push(segs[i]);
        }
        return segRows;
    };
    // Computes a default event time formatting string if `timeFormat` is not explicitly defined
    DayGridEventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('extraSmallTimeFormat'); // like "6p" or "6:30p"
    };
    // Computes a default `displayEventEnd` value if one is not expliclty defined
    DayGridEventRenderer.prototype.computeDisplayEventEnd = function () {
        return this.dayGrid.colCnt === 1; // we'll likely have space if there's only one day
    };
    // Builds the HTML to be used for the default element for an individual segment
    DayGridEventRenderer.prototype.fgSegHtml = function (seg, disableResizing) {
        var view = this.view;
        var eventDef = seg.footprint.eventDef;
        var isAllDay = seg.footprint.componentFootprint.isAllDay;
        var isDraggable = view.isEventDefDraggable(eventDef);
        var isResizableFromStart = !disableResizing && isAllDay &&
            seg.isStart && view.isEventDefResizableFromStart(eventDef);
        var isResizableFromEnd = !disableResizing && isAllDay &&
            seg.isEnd && view.isEventDefResizableFromEnd(eventDef);
        var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
        var skinCss = util_1.cssToStr(this.getSkinCss(eventDef));
        var timeHtml = '';
        var timeText;
        var titleHtml;
        classes.unshift('fc-day-grid-event', 'fc-h-event');
        // Only display a timed events time if it is the starting segment
        if (seg.isStart) {
            timeText = this.getTimeText(seg.footprint);
            if (timeText) {
                timeHtml = '<span class="fc-time">' + util_1.htmlEscape(timeText) + '</span>';
            }
        }
        titleHtml =
            '<span class="fc-title">' +
                (util_1.htmlEscape(eventDef.title || '') || '&nbsp;') + // we always want one line of height
                '</span>';
        return '<a class="' + classes.join(' ') + '"' +
            (eventDef.url ?
                ' href="' + util_1.htmlEscape(eventDef.url) + '"' :
                '') +
            (skinCss ?
                ' style="' + skinCss + '"' :
                '') +
            '>' +
            '<div class="fc-content">' +
            (this.dayGrid.isRTL ?
                titleHtml + ' ' + timeHtml : // put a natural space in between
                timeHtml + ' ' + titleHtml //
            ) +
            '</div>' +
            (isResizableFromStart ?
                '<div class="fc-resizer fc-start-resizer"></div>' :
                '') +
            (isResizableFromEnd ?
                '<div class="fc-resizer fc-end-resizer"></div>' :
                '') +
            '</a>';
    };
    return DayGridEventRenderer;
}(EventRenderer_1.default));
exports.default = DayGridEventRenderer;
// Computes whether two segments' columns collide. They are assumed to be in the same row.
function isDaySegCollision(seg, otherSegs) {
    var i;
    var otherSeg;
    for (i = 0; i < otherSegs.length; i++) {
        otherSeg = otherSegs[i];
        if (otherSeg.leftCol <= seg.rightCol &&
            otherSeg.rightCol >= seg.leftCol) {
            return true;
        }
    }
    return false;
}
// A cmp function for determining the leftmost event
function compareDaySegCols(a, b) {
    return a.leftCol - b.leftCol;
}


/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var HelperRenderer_1 = __webpack_require__(63);
var DayGridHelperRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(DayGridHelperRenderer, _super);
    function DayGridHelperRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Renders a mock "helper" event. `sourceSeg` is the associated internal segment object. It can be null.
    DayGridHelperRenderer.prototype.renderSegs = function (segs, sourceSeg) {
        var helperNodes = [];
        var rowStructs;
        // TODO: not good to call eventRenderer this way
        rowStructs = this.eventRenderer.renderSegRows(segs);
        // inject each new event skeleton into each associated row
        this.component.rowEls.each(function (row, rowNode) {
            var rowEl = $(rowNode); // the .fc-row
            var skeletonEl = $('<div class="fc-helper-skeleton"><table></table></div>'); // will be absolutely positioned
            var skeletonTopEl;
            var skeletonTop;
            // If there is an original segment, match the top position. Otherwise, put it at the row's top level
            if (sourceSeg && sourceSeg.row === row) {
                skeletonTop = sourceSeg.el.position().top;
            }
            else {
                skeletonTopEl = rowEl.find('.fc-content-skeleton tbody');
                if (!skeletonTopEl.length) { // when no events
                    skeletonTopEl = rowEl.find('.fc-content-skeleton table');
                }
                skeletonTop = skeletonTopEl.position().top;
            }
            skeletonEl.css('top', skeletonTop)
                .find('table')
                .append(rowStructs[row].tbodyEl);
            rowEl.append(skeletonEl);
            helperNodes.push(skeletonEl[0]);
        });
        return $(helperNodes); // must return the elements rendered
    };
    return DayGridHelperRenderer;
}(HelperRenderer_1.default));
exports.default = DayGridHelperRenderer;


/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var FillRenderer_1 = __webpack_require__(62);
var DayGridFillRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(DayGridFillRenderer, _super);
    function DayGridFillRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.fillSegTag = 'td'; // override the default tag name
        return _this;
    }
    DayGridFillRenderer.prototype.attachSegEls = function (type, segs) {
        var nodes = [];
        var i;
        var seg;
        var skeletonEl;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            skeletonEl = this.renderFillRow(type, seg);
            this.component.rowEls.eq(seg.row).append(skeletonEl);
            nodes.push(skeletonEl[0]);
        }
        return nodes;
    };
    // Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
    DayGridFillRenderer.prototype.renderFillRow = function (type, seg) {
        var colCnt = this.component.colCnt;
        var startCol = seg.leftCol;
        var endCol = seg.rightCol + 1;
        var className;
        var skeletonEl;
        var trEl;
        if (type === 'businessHours') {
            className = 'bgevent';
        }
        else {
            className = type.toLowerCase();
        }
        skeletonEl = $('<div class="fc-' + className + '-skeleton">' +
            '<table><tr></tr></table>' +
            '</div>');
        trEl = skeletonEl.find('tr');
        if (startCol > 0) {
            trEl.append(
            // will create (startCol + 1) td's
            new Array(startCol + 1).join('<td></td>'));
        }
        trEl.append(seg.el.attr('colspan', endCol - startCol));
        if (endCol < colCnt) {
            trEl.append(
            // will create (colCnt - endCol) td's
            new Array(colCnt - endCol + 1).join('<td></td>'));
        }
        this.component.bookendCells(trEl);
        return skeletonEl;
    };
    return DayGridFillRenderer;
}(FillRenderer_1.default));
exports.default = DayGridFillRenderer;


/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var moment = __webpack_require__(0);
var util_1 = __webpack_require__(4);
var BasicView_1 = __webpack_require__(67);
var MonthViewDateProfileGenerator_1 = __webpack_require__(247);
/* A month view with day cells running in rows (one-per-week) and columns
----------------------------------------------------------------------------------------------------------------------*/
var MonthView = /** @class */ (function (_super) {
    tslib_1.__extends(MonthView, _super);
    function MonthView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Overrides the default BasicView behavior to have special multi-week auto-height logic
    MonthView.prototype.setGridHeight = function (height, isAuto) {
        // if auto, make the height of each row the height that it would be if there were 6 weeks
        if (isAuto) {
            height *= this.dayGrid.rowCnt / 6;
        }
        util_1.distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
    };
    MonthView.prototype.isDateInOtherMonth = function (date, dateProfile) {
        return date.month() !== moment.utc(dateProfile.currentUnzonedRange.startMs).month(); // TODO: optimize
    };
    return MonthView;
}(BasicView_1.default));
exports.default = MonthView;
MonthView.prototype.dateProfileGeneratorClass = MonthViewDateProfileGenerator_1.default;


/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var BasicViewDateProfileGenerator_1 = __webpack_require__(68);
var UnzonedRange_1 = __webpack_require__(5);
var MonthViewDateProfileGenerator = /** @class */ (function (_super) {
    tslib_1.__extends(MonthViewDateProfileGenerator, _super);
    function MonthViewDateProfileGenerator() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // Computes the date range that will be rendered.
    MonthViewDateProfileGenerator.prototype.buildRenderRange = function (currentUnzonedRange, currentRangeUnit, isRangeAllDay) {
        var renderUnzonedRange = _super.prototype.buildRenderRange.call(this, currentUnzonedRange, currentRangeUnit, isRangeAllDay);
        var start = this.msToUtcMoment(renderUnzonedRange.startMs, isRangeAllDay);
        var end = this.msToUtcMoment(renderUnzonedRange.endMs, isRangeAllDay);
        var rowCnt;
        // ensure 6 weeks
        if (this.opt('fixedWeekCount')) {
            rowCnt = Math.ceil(// could be partial weeks due to hiddenDays
            end.diff(start, 'weeks', true) // dontRound=true
            );
            end.add(6 - rowCnt, 'weeks');
        }
        return new UnzonedRange_1.default(start, end);
    };
    return MonthViewDateProfileGenerator;
}(BasicViewDateProfileGenerator_1.default));
exports.default = MonthViewDateProfileGenerator;


/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var UnzonedRange_1 = __webpack_require__(5);
var View_1 = __webpack_require__(43);
var Scroller_1 = __webpack_require__(41);
var ListEventRenderer_1 = __webpack_require__(249);
var ListEventPointing_1 = __webpack_require__(250);
/*
Responsible for the scroller, and forwarding event-related actions into the "grid".
*/
var ListView = /** @class */ (function (_super) {
    tslib_1.__extends(ListView, _super);
    function ListView(calendar, viewSpec) {
        var _this = _super.call(this, calendar, viewSpec) || this;
        _this.segSelector = '.fc-list-item'; // which elements accept event actions
        _this.scroller = new Scroller_1.default({
            overflowX: 'hidden',
            overflowY: 'auto'
        });
        return _this;
    }
    ListView.prototype.renderSkeleton = function () {
        this.el.addClass('fc-list-view ' +
            this.calendar.theme.getClass('listView'));
        this.scroller.render();
        this.scroller.el.appendTo(this.el);
        this.contentEl = this.scroller.scrollEl; // shortcut
    };
    ListView.prototype.unrenderSkeleton = function () {
        this.scroller.destroy(); // will remove the Grid too
    };
    ListView.prototype.updateSize = function (totalHeight, isAuto, isResize) {
        _super.prototype.updateSize.call(this, totalHeight, isAuto, isResize);
        this.scroller.clear(); // sets height to 'auto' and clears overflow
        if (!isAuto) {
            this.scroller.setHeight(this.computeScrollerHeight(totalHeight));
        }
    };
    ListView.prototype.computeScrollerHeight = function (totalHeight) {
        return totalHeight -
            util_1.subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
    };
    ListView.prototype.renderDates = function (dateProfile) {
        var calendar = this.calendar;
        var dayStart = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.startMs, true);
        var viewEnd = calendar.msToUtcMoment(dateProfile.renderUnzonedRange.endMs, true);
        var dayDates = [];
        var dayRanges = [];
        while (dayStart < viewEnd) {
            dayDates.push(dayStart.clone());
            dayRanges.push(new UnzonedRange_1.default(dayStart, dayStart.clone().add(1, 'day')));
            dayStart.add(1, 'day');
        }
        this.dayDates = dayDates;
        this.dayRanges = dayRanges;
        // all real rendering happens in EventRenderer
    };
    // slices by day
    ListView.prototype.componentFootprintToSegs = function (footprint) {
        var dayRanges = this.dayRanges;
        var dayIndex;
        var segRange;
        var seg;
        var segs = [];
        for (dayIndex = 0; dayIndex < dayRanges.length; dayIndex++) {
            segRange = footprint.unzonedRange.intersect(dayRanges[dayIndex]);
            if (segRange) {
                seg = {
                    startMs: segRange.startMs,
                    endMs: segRange.endMs,
                    isStart: segRange.isStart,
                    isEnd: segRange.isEnd,
                    dayIndex: dayIndex
                };
                segs.push(seg);
                // detect when footprint won't go fully into the next day,
                // and mutate the latest seg to the be the end.
                if (!seg.isEnd && !footprint.isAllDay &&
                    dayIndex + 1 < dayRanges.length &&
                    footprint.unzonedRange.endMs < dayRanges[dayIndex + 1].startMs + this.nextDayThreshold) {
                    seg.endMs = footprint.unzonedRange.endMs;
                    seg.isEnd = true;
                    break;
                }
            }
        }
        return segs;
    };
    ListView.prototype.renderEmptyMessage = function () {
        this.contentEl.html('<div class="fc-list-empty-wrap2">' + // TODO: try less wraps
            '<div class="fc-list-empty-wrap1">' +
            '<div class="fc-list-empty">' +
            util_1.htmlEscape(this.opt('noEventsMessage')) +
            '</div>' +
            '</div>' +
            '</div>');
    };
    // render the event segments in the view
    ListView.prototype.renderSegList = function (allSegs) {
        var segsByDay = this.groupSegsByDay(allSegs); // sparse array
        var dayIndex;
        var daySegs;
        var i;
        var tableEl = $('<table class="fc-list-table ' + this.calendar.theme.getClass('tableList') + '"><tbody></tbody></table>');
        var tbodyEl = tableEl.find('tbody');
        for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {
            daySegs = segsByDay[dayIndex];
            if (daySegs) { // sparse array, so might be undefined
                // append a day header
                tbodyEl.append(this.dayHeaderHtml(this.dayDates[dayIndex]));
                this.eventRenderer.sortEventSegs(daySegs);
                for (i = 0; i < daySegs.length; i++) {
                    tbodyEl.append(daySegs[i].el); // append event row
                }
            }
        }
        this.contentEl.empty().append(tableEl);
    };
    // Returns a sparse array of arrays, segs grouped by their dayIndex
    ListView.prototype.groupSegsByDay = function (segs) {
        var segsByDay = []; // sparse array
        var i;
        var seg;
        for (i = 0; i < segs.length; i++) {
            seg = segs[i];
            (segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))
                .push(seg);
        }
        return segsByDay;
    };
    // generates the HTML for the day headers that live amongst the event rows
    ListView.prototype.dayHeaderHtml = function (dayDate) {
        var mainFormat = this.opt('listDayFormat');
        var altFormat = this.opt('listDayAltFormat');
        return '<tr class="fc-list-heading" data-date="' + dayDate.format('YYYY-MM-DD') + '">' +
            '<td class="' + (this.calendar.theme.getClass('tableListHeading') ||
            this.calendar.theme.getClass('widgetHeader')) + '" colspan="3">' +
            (mainFormat ?
                this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-main' }, util_1.htmlEscape(dayDate.format(mainFormat)) // inner HTML
                ) :
                '') +
            (altFormat ?
                this.buildGotoAnchorHtml(dayDate, { 'class': 'fc-list-heading-alt' }, util_1.htmlEscape(dayDate.format(altFormat)) // inner HTML
                ) :
                '') +
            '</td>' +
            '</tr>';
    };
    return ListView;
}(View_1.default));
exports.default = ListView;
ListView.prototype.eventRendererClass = ListEventRenderer_1.default;
ListView.prototype.eventPointingClass = ListEventPointing_1.default;


/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var util_1 = __webpack_require__(4);
var EventRenderer_1 = __webpack_require__(44);
var ListEventRenderer = /** @class */ (function (_super) {
    tslib_1.__extends(ListEventRenderer, _super);
    function ListEventRenderer() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ListEventRenderer.prototype.renderFgSegs = function (segs) {
        if (!segs.length) {
            this.component.renderEmptyMessage();
        }
        else {
            this.component.renderSegList(segs);
        }
    };
    // generates the HTML for a single event row
    ListEventRenderer.prototype.fgSegHtml = function (seg) {
        var view = this.view;
        var calendar = view.calendar;
        var theme = calendar.theme;
        var eventFootprint = seg.footprint;
        var eventDef = eventFootprint.eventDef;
        var componentFootprint = eventFootprint.componentFootprint;
        var url = eventDef.url;
        var classes = ['fc-list-item'].concat(this.getClasses(eventDef));
        var bgColor = this.getBgColor(eventDef);
        var timeHtml;
        if (componentFootprint.isAllDay) {
            timeHtml = view.getAllDayHtml();
        }
        else if (view.isMultiDayRange(componentFootprint.unzonedRange)) {
            if (seg.isStart || seg.isEnd) { // outer segment that probably lasts part of the day
                timeHtml = util_1.htmlEscape(this._getTimeText(calendar.msToMoment(seg.startMs), calendar.msToMoment(seg.endMs), componentFootprint.isAllDay));
            }
            else { // inner segment that lasts the whole day
                timeHtml = view.getAllDayHtml();
            }
        }
        else {
            // Display the normal time text for the *event's* times
            timeHtml = util_1.htmlEscape(this.getTimeText(eventFootprint));
        }
        if (url) {
            classes.push('fc-has-url');
        }
        return '<tr class="' + classes.join(' ') + '">' +
            (this.displayEventTime ?
                '<td class="fc-list-item-time ' + theme.getClass('widgetContent') + '">' +
                    (timeHtml || '') +
                    '</td>' :
                '') +
            '<td class="fc-list-item-marker ' + theme.getClass('widgetContent') + '">' +
            '<span class="fc-event-dot"' +
            (bgColor ?
                ' style="background-color:' + bgColor + '"' :
                '') +
            '></span>' +
            '</td>' +
            '<td class="fc-list-item-title ' + theme.getClass('widgetContent') + '">' +
            '<a' + (url ? ' href="' + util_1.htmlEscape(url) + '"' : '') + '>' +
            util_1.htmlEscape(eventDef.title || '') +
            '</a>' +
            '</td>' +
            '</tr>';
    };
    // like "4:00am"
    ListEventRenderer.prototype.computeEventTimeFormat = function () {
        return this.opt('mediumTimeFormat');
    };
    return ListEventRenderer;
}(EventRenderer_1.default));
exports.default = ListEventRenderer;


/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var EventPointing_1 = __webpack_require__(64);
var ListEventPointing = /** @class */ (function (_super) {
    tslib_1.__extends(ListEventPointing, _super);
    function ListEventPointing() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // for events with a url, the whole <tr> should be clickable,
    // but it's impossible to wrap with an <a> tag. simulate this.
    ListEventPointing.prototype.handleClick = function (seg, ev) {
        var url;
        _super.prototype.handleClick.call(this, seg, ev); // might prevent the default action
        // not clicking on or within an <a> with an href
        if (!$(ev.target).closest('a[href]').length) {
            url = seg.footprint.eventDef.url;
            if (url && !ev.isDefaultPrevented()) { // jsEvent not cancelled in handler
                window.location.href = url; // simulate link click
            }
        }
    };
    return ListEventPointing;
}(EventPointing_1.default));
exports.default = ListEventPointing;


/***/ }),
/* 251 */,
/* 252 */,
/* 253 */,
/* 254 */,
/* 255 */,
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(3);
var exportHooks = __webpack_require__(18);
var util_1 = __webpack_require__(4);
var Calendar_1 = __webpack_require__(232);
// for intentional side-effects
__webpack_require__(11);
__webpack_require__(49);
__webpack_require__(260);
__webpack_require__(261);
__webpack_require__(264);
__webpack_require__(265);
__webpack_require__(266);
__webpack_require__(267);
$.fullCalendar = exportHooks;
$.fn.fullCalendar = function (options) {
    var args = Array.prototype.slice.call(arguments, 1); // for a possible method call
    var res = this; // what this function will return (this jQuery object by default)
    this.each(function (i, _element) {
        var element = $(_element);
        var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)
        var singleRes; // the returned value of this single method call
        // a method call
        if (typeof options === 'string') {
            if (options === 'getCalendar') {
                if (!i) { // first element only
                    res = calendar;
                }
            }
            else if (options === 'destroy') { // don't warn if no calendar object
                if (calendar) {
                    calendar.destroy();
                    element.removeData('fullCalendar');
                }
            }
            else if (!calendar) {
                util_1.warn('Attempting to call a FullCalendar method on an element with no calendar.');
            }
            else if ($.isFunction(calendar[options])) {
                singleRes = calendar[options].apply(calendar, args);
                if (!i) {
                    res = singleRes; // record the first method call result
                }
                if (options === 'destroy') { // for the destroy method, must remove Calendar object data
                    element.removeData('fullCalendar');
                }
            }
            else {
                util_1.warn("'" + options + "' is an unknown FullCalendar method.");
            }
        }
        else if (!calendar) { // don't initialize twice
            calendar = new Calendar_1.default(element, options);
            element.data('fullCalendar', calendar);
            calendar.render();
        }
    });
    return res;
};
module.exports = exportHooks;


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
/* Toolbar with buttons and title
----------------------------------------------------------------------------------------------------------------------*/
var Toolbar = /** @class */ (function () {
    function Toolbar(calendar, toolbarOptions) {
        this.el = null; // mirrors local `el`
        this.viewsWithButtons = [];
        this.calendar = calendar;
        this.toolbarOptions = toolbarOptions;
    }
    // method to update toolbar-specific options, not calendar-wide options
    Toolbar.prototype.setToolbarOptions = function (newToolbarOptions) {
        this.toolbarOptions = newToolbarOptions;
    };
    // can be called repeatedly and will rerender
    Toolbar.prototype.render = function () {
        var sections = this.toolbarOptions.layout;
        var el = this.el;
        if (sections) {
            if (!el) {
                el = this.el = $("<div class='fc-toolbar " + this.toolbarOptions.extraClasses + "'>");
            }
            else {
                el.empty();
            }
            el.append(this.renderSection('left'))
                .append(this.renderSection('right'))
                .append(this.renderSection('center'))
                .append('<div class="fc-clear"></div>');
        }
        else {
            this.removeElement();
        }
    };
    Toolbar.prototype.removeElement = function () {
        if (this.el) {
            this.el.remove();
            this.el = null;
        }
    };
    Toolbar.prototype.renderSection = function (position) {
        var _this = this;
        var calendar = this.calendar;
        var theme = calendar.theme;
        var optionsManager = calendar.optionsManager;
        var viewSpecManager = calendar.viewSpecManager;
        var sectionEl = $('<div class="fc-' + position + '">');
        var buttonStr = this.toolbarOptions.layout[position];
        var calendarCustomButtons = optionsManager.get('customButtons') || {};
        var calendarButtonTextOverrides = optionsManager.overrides.buttonText || {};
        var calendarButtonText = optionsManager.get('buttonText') || {};
        if (buttonStr) {
            $.each(buttonStr.split(' '), function (i, buttonGroupStr) {
                var groupChildren = $();
                var isOnlyButtons = true;
                var groupEl;
                $.each(buttonGroupStr.split(','), function (j, buttonName) {
                    var customButtonProps;
                    var viewSpec;
                    var buttonClick;
                    var buttonIcon; // only one of these will be set
                    var buttonText; // "
                    var buttonInnerHtml;
                    var buttonClasses;
                    var buttonEl;
                    var buttonAriaAttr;
                    if (buttonName === 'title') {
                        groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height
                        isOnlyButtons = false;
                    }
                    else {
                        if ((customButtonProps = calendarCustomButtons[buttonName])) {
                            buttonClick = function (ev) {
                                if (customButtonProps.click) {
                                    customButtonProps.click.call(buttonEl[0], ev);
                                }
                            };
                            (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) ||
                                (buttonIcon = theme.getIconClass(buttonName)) ||
                                (buttonText = customButtonProps.text);
                        }
                        else if ((viewSpec = viewSpecManager.getViewSpec(buttonName))) {
                            _this.viewsWithButtons.push(buttonName);
                            buttonClick = function () {
                                calendar.changeView(buttonName);
                            };
                            (buttonText = viewSpec.buttonTextOverride) ||
                                (buttonIcon = theme.getIconClass(buttonName)) ||
                                (buttonText = viewSpec.buttonTextDefault);
                        }
                        else if (calendar[buttonName]) { // a calendar method
                            buttonClick = function () {
                                calendar[buttonName]();
                            };
                            (buttonText = calendarButtonTextOverrides[buttonName]) ||
                                (buttonIcon = theme.getIconClass(buttonName)) ||
                                (buttonText = calendarButtonText[buttonName]);
                            //            ^ everything else is considered default
                        }
                        if (buttonClick) {
                            buttonClasses = [
                                'fc-' + buttonName + '-button',
                                theme.getClass('button'),
                                theme.getClass('stateDefault')
                            ];
                            if (buttonText) {
                                buttonInnerHtml = util_1.htmlEscape(buttonText);
                                buttonAriaAttr = '';
                            }
                            else if (buttonIcon) {
                                buttonInnerHtml = "<span class='" + buttonIcon + "'></span>";
                                buttonAriaAttr = ' aria-label="' + buttonName + '"';
                            }
                            buttonEl = $(// type="button" so that it doesn't submit a form
                            '<button type="button" class="' + buttonClasses.join(' ') + '"' +
                                buttonAriaAttr +
                                '>' + buttonInnerHtml + '</button>')
                                .click(function (ev) {
                                // don't process clicks for disabled buttons
                                if (!buttonEl.hasClass(theme.getClass('stateDisabled'))) {
                                    buttonClick(ev);
                                    // after the click action, if the button becomes the "active" tab, or disabled,
                                    // it should never have a hover class, so remove it now.
                                    if (buttonEl.hasClass(theme.getClass('stateActive')) ||
                                        buttonEl.hasClass(theme.getClass('stateDisabled'))) {
                                        buttonEl.removeClass(theme.getClass('stateHover'));
                                    }
                                }
                            })
                                .mousedown(function () {
                                // the *down* effect (mouse pressed in).
                                // only on buttons that are not the "active" tab, or disabled
                                buttonEl
                                    .not('.' + theme.getClass('stateActive'))
                                    .not('.' + theme.getClass('stateDisabled'))
                                    .addClass(theme.getClass('stateDown'));
                            })
                                .mouseup(function () {
                                // undo the *down* effect
                                buttonEl.removeClass(theme.getClass('stateDown'));
                            })
                                .hover(function () {
                                // the *hover* effect.
                                // only on buttons that are not the "active" tab, or disabled
                                buttonEl
                                    .not('.' + theme.getClass('stateActive'))
                                    .not('.' + theme.getClass('stateDisabled'))
                                    .addClass(theme.getClass('stateHover'));
                            }, function () {
                                // undo the *hover* effect
                                buttonEl
                                    .removeClass(theme.getClass('stateHover'))
                                    .removeClass(theme.getClass('stateDown')); // if mouseleave happens before mouseup
                            });
                            groupChildren = groupChildren.add(buttonEl);
                        }
                    }
                });
                if (isOnlyButtons) {
                    groupChildren
                        .first().addClass(theme.getClass('cornerLeft')).end()
                        .last().addClass(theme.getClass('cornerRight')).end();
                }
                if (groupChildren.length > 1) {
                    groupEl = $('<div>');
                    if (isOnlyButtons) {
                        groupEl.addClass(theme.getClass('buttonGroup'));
                    }
                    groupEl.append(groupChildren);
                    sectionEl.append(groupEl);
                }
                else {
                    sectionEl.append(groupChildren); // 1 or 0 children
                }
            });
        }
        return sectionEl;
    };
    Toolbar.prototype.updateTitle = function (text) {
        if (this.el) {
            this.el.find('h2').text(text);
        }
    };
    Toolbar.prototype.activateButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .addClass(this.calendar.theme.getClass('stateActive'));
        }
    };
    Toolbar.prototype.deactivateButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .removeClass(this.calendar.theme.getClass('stateActive'));
        }
    };
    Toolbar.prototype.disableButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .prop('disabled', true)
                .addClass(this.calendar.theme.getClass('stateDisabled'));
        }
    };
    Toolbar.prototype.enableButton = function (buttonName) {
        if (this.el) {
            this.el.find('.fc-' + buttonName + '-button')
                .prop('disabled', false)
                .removeClass(this.calendar.theme.getClass('stateDisabled'));
        }
    };
    Toolbar.prototype.getViewsWithButtons = function () {
        return this.viewsWithButtons;
    };
    return Toolbar;
}());
exports.default = Toolbar;


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var $ = __webpack_require__(3);
var util_1 = __webpack_require__(4);
var options_1 = __webpack_require__(33);
var locale_1 = __webpack_require__(32);
var Model_1 = __webpack_require__(51);
var OptionsManager = /** @class */ (function (_super) {
    tslib_1.__extends(OptionsManager, _super);
    function OptionsManager(_calendar, overrides) {
        var _this = _super.call(this) || this;
        _this._calendar = _calendar;
        _this.overrides = $.extend({}, overrides); // make a copy
        _this.dynamicOverrides = {};
        _this.compute();
        return _this;
    }
    OptionsManager.prototype.add = function (newOptionHash) {
        var optionCnt = 0;
        var optionName;
        this.recordOverrides(newOptionHash); // will trigger this model's watchers
        for (optionName in newOptionHash) {
            optionCnt++;
        }
        // special-case handling of single option change.
        // if only one option change, `optionName` will be its name.
        if (optionCnt === 1) {
            if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {
                this._calendar.updateViewSize(true); // isResize=true
                return;
            }
            else if (optionName === 'defaultDate') {
                return; // can't change date this way. use gotoDate instead
            }
            else if (optionName === 'businessHours') {
                return; // this model already reacts to this
            }
            else if (/^(event|select)(Overlap|Constraint|Allow)$/.test(optionName)) {
                return; // doesn't affect rendering. only interactions.
            }
            else if (optionName === 'timezone') {
                this._calendar.view.flash('initialEvents');
                return;
            }
        }
        // catch-all. rerender the header and footer and rebuild/rerender the current view
        this._calendar.renderHeader();
        this._calendar.renderFooter();
        // even non-current views will be affected by this option change. do before rerender
        // TODO: detangle
        this._calendar.viewsByType = {};
        this._calendar.reinitView();
    };
    // Computes the flattened options hash for the calendar and assigns to `this.options`.
    // Assumes this.overrides and this.dynamicOverrides have already been initialized.
    OptionsManager.prototype.compute = function () {
        var locale;
        var localeDefaults;
        var isRTL;
        var dirDefaults;
        var rawOptions;
        locale = util_1.firstDefined(// explicit locale option given?
        this.dynamicOverrides.locale, this.overrides.locale);
        localeDefaults = locale_1.localeOptionHash[locale];
        if (!localeDefaults) { // explicit locale option not given or invalid?
            locale = options_1.globalDefaults.locale;
            localeDefaults = locale_1.localeOptionHash[locale] || {};
        }
        isRTL = util_1.firstDefined(// based on options computed so far, is direction RTL?
        this.dynamicOverrides.isRTL, this.overrides.isRTL, localeDefaults.isRTL, options_1.globalDefaults.isRTL);
        dirDefaults = isRTL ? options_1.rtlDefaults : {};
        this.dirDefaults = dirDefaults;
        this.localeDefaults = localeDefaults;
        rawOptions = options_1.mergeOptions([
            options_1.globalDefaults,
            dirDefaults,
            localeDefaults,
            this.overrides,
            this.dynamicOverrides
        ]);
        locale_1.populateInstanceComputableOptions(rawOptions); // fill in gaps with computed options
        this.reset(rawOptions);
    };
    // stores the new options internally, but does not rerender anything.
    OptionsManager.prototype.recordOverrides = function (newOptionHash) {
        var optionName;
        for (optionName in newOptionHash) {
            this.dynamicOverrides[optionName] = newOptionHash[optionName];
        }
        this._calendar.viewSpecManager.clearCache(); // the dynamic override invalidates the options in this cache, so just clear it
        this.compute(); // this.options needs to be recomputed after the dynamic override
    };
    return OptionsManager;
}(Model_1.default));
exports.default = OptionsManager;


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var moment = __webpack_require__(0);
var $ = __webpack_require__(3);
var ViewRegistry_1 = __webpack_require__(24);
var util_1 = __webpack_require__(4);
var options_1 = __webpack_require__(33);
var locale_1 = __webpack_require__(32);
var ViewSpecManager = /** @class */ (function () {
    function ViewSpecManager(optionsManager, _calendar) {
        this.optionsManager = optionsManager;
        this._calendar = _calendar;
        this.clearCache();
    }
    ViewSpecManager.prototype.clearCache = function () {
        this.viewSpecCache = {};
    };
    // Gets information about how to create a view. Will use a cache.
    ViewSpecManager.prototype.getViewSpec = function (viewType) {
        var cache = this.viewSpecCache;
        return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
    };
    // Given a duration singular unit, like "week" or "day", finds a matching view spec.
    // Preference is given to views that have corresponding buttons.
    ViewSpecManager.prototype.getUnitViewSpec = function (unit) {
        var viewTypes;
        var i;
        var spec;
        if ($.inArray(unit, util_1.unitsDesc) !== -1) {
            // put views that have buttons first. there will be duplicates, but oh well
            viewTypes = this._calendar.header.getViewsWithButtons(); // TODO: include footer as well?
            $.each(ViewRegistry_1.viewHash, function (viewType) {
                viewTypes.push(viewType);
            });
            for (i = 0; i < viewTypes.length; i++) {
                spec = this.getViewSpec(viewTypes[i]);
                if (spec) {
                    if (spec.singleUnit === unit) {
                        return spec;
                    }
                }
            }
        }
    };
    // Builds an object with information on how to create a given view
    ViewSpecManager.prototype.buildViewSpec = function (requestedViewType) {
        var viewOverrides = this.optionsManager.overrides.views || {};
        var specChain = []; // for the view. lowest to highest priority
        var defaultsChain = []; // for the view. lowest to highest priority
        var overridesChain = []; // for the view. lowest to highest priority
        var viewType = requestedViewType;
        var spec; // for the view
        var overrides; // for the view
        var durationInput;
        var duration;
        var unit;
        // iterate from the specific view definition to a more general one until we hit an actual View class
        while (viewType) {
            spec = ViewRegistry_1.viewHash[viewType];
            overrides = viewOverrides[viewType];
            viewType = null; // clear. might repopulate for another iteration
            if (typeof spec === 'function') { // TODO: deprecate
                spec = { 'class': spec };
            }
            if (spec) {
                specChain.unshift(spec);
                defaultsChain.unshift(spec.defaults || {});
                durationInput = durationInput || spec.duration;
                viewType = viewType || spec.type;
            }
            if (overrides) {
                overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level
                durationInput = durationInput || overrides.duration;
                viewType = viewType || overrides.type;
            }
        }
        spec = util_1.mergeProps(specChain);
        spec.type = requestedViewType;
        if (!spec['class']) {
            return false;
        }
        // fall back to top-level `duration` option
        durationInput = durationInput ||
            this.optionsManager.dynamicOverrides.duration ||
            this.optionsManager.overrides.duration;
        if (durationInput) {
            duration = moment.duration(durationInput);
            if (duration.valueOf()) { // valid?
                unit = util_1.computeDurationGreatestUnit(duration, durationInput);
                spec.duration = duration;
                spec.durationUnit = unit;
                // view is a single-unit duration, like "week" or "day"
                // incorporate options for this. lowest priority
                if (duration.as(unit) === 1) {
                    spec.singleUnit = unit;
                    overridesChain.unshift(viewOverrides[unit] || {});
                }
            }
        }
        spec.defaults = options_1.mergeOptions(defaultsChain);
        spec.overrides = options_1.mergeOptions(overridesChain);
        this.buildViewSpecOptions(spec);
        this.buildViewSpecButtonText(spec, requestedViewType);
        return spec;
    };
    // Builds and assigns a view spec's options object from its already-assigned defaults and overrides
    ViewSpecManager.prototype.buildViewSpecOptions = function (spec) {
        var optionsManager = this.optionsManager;
        spec.options = options_1.mergeOptions([
            options_1.globalDefaults,
            spec.defaults,
            optionsManager.dirDefaults,
            optionsManager.localeDefaults,
            optionsManager.overrides,
            spec.overrides,
            optionsManager.dynamicOverrides // dynamically set via setter. highest precedence
        ]);
        locale_1.populateInstanceComputableOptions(spec.options);
    };
    // Computes and assigns a view spec's buttonText-related options
    ViewSpecManager.prototype.buildViewSpecButtonText = function (spec, requestedViewType) {
        var optionsManager = this.optionsManager;
        // given an options object with a possible `buttonText` hash, lookup the buttonText for the
        // requested view, falling back to a generic unit entry like "week" or "day"
        function queryButtonText(options) {
            var buttonText = options.buttonText || {};
            return buttonText[requestedViewType] ||
                // view can decide to look up a certain key
                (spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||
                // a key like "month"
                (spec.singleUnit ? buttonText[spec.singleUnit] : null);
        }
        // highest to lowest priority
        spec.buttonTextOverride =
            queryButtonText(optionsManager.dynamicOverrides) ||
                queryButtonText(optionsManager.overrides) || // constructor-specified buttonText lookup hash takes precedence
                spec.overrides.buttonText; // `buttonText` for view-specific options is a string
        // highest to lowest priority. mirrors buildViewSpecOptions
        spec.buttonTextDefault =
            queryButtonText(optionsManager.localeDefaults) ||
                queryButtonText(optionsManager.dirDefaults) ||
                spec.defaults.buttonText || // a single string. from ViewSubclass.defaults
                queryButtonText(options_1.globalDefaults) ||
                (spec.duration ? this._calendar.humanizeDuration(spec.duration) : null) || // like "3 days"
                requestedViewType; // fall back to given view name
    };
    return ViewSpecManager;
}());
exports.default = ViewSpecManager;


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var EventSourceParser_1 = __webpack_require__(38);
var ArrayEventSource_1 = __webpack_require__(56);
var FuncEventSource_1 = __webpack_require__(223);
var JsonFeedEventSource_1 = __webpack_require__(224);
EventSourceParser_1.default.registerClass(ArrayEventSource_1.default);
EventSourceParser_1.default.registerClass(FuncEventSource_1.default);
EventSourceParser_1.default.registerClass(JsonFeedEventSource_1.default);


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var ThemeRegistry_1 = __webpack_require__(57);
var StandardTheme_1 = __webpack_require__(221);
var JqueryUiTheme_1 = __webpack_require__(222);
var Bootstrap3Theme_1 = __webpack_require__(262);
var Bootstrap4Theme_1 = __webpack_require__(263);
ThemeRegistry_1.defineThemeSystem('standard', StandardTheme_1.default);
ThemeRegistry_1.defineThemeSystem('jquery-ui', JqueryUiTheme_1.default);
ThemeRegistry_1.defineThemeSystem('bootstrap3', Bootstrap3Theme_1.default);
ThemeRegistry_1.defineThemeSystem('bootstrap4', Bootstrap4Theme_1.default);


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Theme_1 = __webpack_require__(22);
var Bootstrap3Theme = /** @class */ (function (_super) {
    tslib_1.__extends(Bootstrap3Theme, _super);
    function Bootstrap3Theme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Bootstrap3Theme;
}(Theme_1.default));
exports.default = Bootstrap3Theme;
Bootstrap3Theme.prototype.classes = {
    widget: 'fc-bootstrap3',
    tableGrid: 'table-bordered',
    tableList: 'table',
    tableListHeading: 'active',
    buttonGroup: 'btn-group',
    button: 'btn btn-default',
    stateActive: 'active',
    stateDisabled: 'disabled',
    today: 'alert alert-info',
    popover: 'panel panel-default',
    popoverHeader: 'panel-heading',
    popoverContent: 'panel-body',
    // day grid
    // for left/right border color when border is inset from edges (all-day in agenda view)
    // avoid `panel` class b/c don't want margins/radius. only border color.
    headerRow: 'panel-default',
    dayRow: 'panel-default',
    // list view
    listView: 'panel panel-default'
};
Bootstrap3Theme.prototype.baseIconClass = 'glyphicon';
Bootstrap3Theme.prototype.iconClasses = {
    close: 'glyphicon-remove',
    prev: 'glyphicon-chevron-left',
    next: 'glyphicon-chevron-right',
    prevYear: 'glyphicon-backward',
    nextYear: 'glyphicon-forward'
};
Bootstrap3Theme.prototype.iconOverrideOption = 'bootstrapGlyphicons';
Bootstrap3Theme.prototype.iconOverrideCustomButtonOption = 'bootstrapGlyphicon';
Bootstrap3Theme.prototype.iconOverridePrefix = 'glyphicon-';


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(2);
var Theme_1 = __webpack_require__(22);
var Bootstrap4Theme = /** @class */ (function (_super) {
    tslib_1.__extends(Bootstrap4Theme, _super);
    function Bootstrap4Theme() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Bootstrap4Theme;
}(Theme_1.default));
exports.default = Bootstrap4Theme;
Bootstrap4Theme.prototype.classes = {
    widget: 'fc-bootstrap4',
    tableGrid: 'table-bordered',
    tableList: 'table',
    tableListHeading: 'table-active',
    buttonGroup: 'btn-group',
    button: 'btn btn-primary',
    stateActive: 'active',
    stateDisabled: 'disabled',
    today: 'alert alert-info',
    popover: 'card card-primary',
    popoverHeader: 'card-header',
    popoverContent: 'card-body',
    // day grid
    // for left/right border color when border is inset from edges (all-day in agenda view)
    // avoid `table` class b/c don't want margins/padding/structure. only border color.
    headerRow: 'table-bordered',
    dayRow: 'table-bordered',
    // list view
    listView: 'card card-primary'
};
Bootstrap4Theme.prototype.baseIconClass = 'fa';
Bootstrap4Theme.prototype.iconClasses = {
    close: 'fa-times',
    prev: 'fa-chevron-left',
    next: 'fa-chevron-right',
    prevYear: 'fa-angle-double-left',
    nextYear: 'fa-angle-double-right'
};
Bootstrap4Theme.prototype.iconOverrideOption = 'bootstrapFontAwesome';
Bootstrap4Theme.prototype.iconOverrideCustomButtonOption = 'bootstrapFontAwesome';
Bootstrap4Theme.prototype.iconOverridePrefix = 'fa-';


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var ViewRegistry_1 = __webpack_require__(24);
var BasicView_1 = __webpack_require__(67);
var MonthView_1 = __webpack_require__(246);
ViewRegistry_1.defineView('basic', {
    'class': BasicView_1.default
});
ViewRegistry_1.defineView('basicDay', {
    type: 'basic',
    duration: { days: 1 }
});
ViewRegistry_1.defineView('basicWeek', {
    type: 'basic',
    duration: { weeks: 1 }
});
ViewRegistry_1.defineView('month', {
    'class': MonthView_1.default,
    duration: { months: 1 },
    defaults: {
        fixedWeekCount: true
    }
});


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var ViewRegistry_1 = __webpack_require__(24);
var AgendaView_1 = __webpack_require__(238);
ViewRegistry_1.defineView('agenda', {
    'class': AgendaView_1.default,
    defaults: {
        allDaySlot: true,
        slotDuration: '00:30:00',
        slotEventOverlap: true // a bad name. confused with overlap/constraint system
    }
});
ViewRegistry_1.defineView('agendaDay', {
    type: 'agenda',
    duration: { days: 1 }
});
ViewRegistry_1.defineView('agendaWeek', {
    type: 'agenda',
    duration: { weeks: 1 }
});


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", { value: true });
var ViewRegistry_1 = __webpack_require__(24);
var ListView_1 = __webpack_require__(248);
ViewRegistry_1.defineView('list', {
    'class': ListView_1.default,
    buttonTextKey: 'list',
    defaults: {
        buttonText: 'list',
        listDayFormat: 'LL',
        noEventsMessage: 'No events to display'
    }
});
ViewRegistry_1.defineView('listDay', {
    type: 'list',
    duration: { days: 1 },
    defaults: {
        listDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header
    }
});
ViewRegistry_1.defineView('listWeek', {
    type: 'list',
    duration: { weeks: 1 },
    defaults: {
        listDayFormat: 'dddd',
        listDayAltFormat: 'LL'
    }
});
ViewRegistry_1.defineView('listMonth', {
    type: 'list',
    duration: { month: 1 },
    defaults: {
        listDayAltFormat: 'dddd' // day-of-week is nice-to-have
    }
});
ViewRegistry_1.defineView('listYear', {
    type: 'list',
    duration: { year: 1 },
    defaults: {
        listDayAltFormat: 'dddd' // day-of-week is nice-to-have
    }
});


/***/ }),
/* 267 */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", { value: true });


/***/ })
/******/ ]);
});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/fullcalendar.min.css":
/*!*************************************************************!*\
  !*** ./node_modules/fullcalendar/dist/fullcalendar.min.css ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "./node_modules/fullcalendar/dist/gcal.min.js":
/*!****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/gcal.min.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * FullCalendar v3.10.2
 * Docs & License: https://fullcalendar.io/
 * (c) 2019 Adam Shaw
 */
!function(e,t){ true?module.exports=t(__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js"),__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(o){if(r[o])return r[o].exports;var n=r[o]={i:o,l:!1,exports:{}};return e[o].call(n.exports,n,n.exports,t),n.l=!0,n.exports}var r={};return t.m=e,t.c=r,t.d=function(e,r,o){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:o})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=270)}({1:function(t,r){t.exports=e},2:function(e,t){var r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var r in t)t.hasOwnProperty(r)&&(e[r]=t[r])};t.__extends=function(e,t){function o(){this.constructor=e}r(e,t),e.prototype=null===t?Object.create(t):(o.prototype=t.prototype,new o)}},270:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0});var o=r(1),n=r(271);o.EventSourceParser.registerClass(n.default),o.GcalEventSource=n.default},271:function(e,t,r){function o(e){var t;return/^[^\/]+@([^\/\.]+\.)*(google|googlemail|gmail)\.com$/.test(e)?e:(t=/^https:\/\/www.googleapis.com\/calendar\/v3\/calendars\/([^\/]*)/.exec(e))||(t=/^https?:\/\/www.google.com\/calendar\/feeds\/([^\/]*)/.exec(e))?decodeURIComponent(t[1]):void 0}function n(e,t){return e.replace(/(\?.*?)?(#|$)/,function(e,r,o){return(r?r+"&":"?")+t+o})}Object.defineProperty(t,"__esModule",{value:!0});var a=r(2),l=r(3),i=r(1),u=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return a.__extends(t,e),t.parse=function(e,t){var r;return"object"==typeof e?r=e:"string"==typeof e&&(r={url:e}),!!r&&i.EventSource.parse.call(this,r,t)},t.prototype.fetch=function(e,t,r){var o=this,n=this.buildUrl(),a=this.buildRequestParams(e,t,r),u=this.ajaxSettings||{},s=u.success;return a?(this.calendar.pushLoading(),i.Promise.construct(function(e,t){l.ajax(l.extend({},i.JsonFeedEventSource.AJAX_DEFAULTS,u,{url:n,data:a,success:function(r,n,u){var c,p;o.calendar.popLoading(),r.error?(o.reportError("Google Calendar API: "+r.error.message,r.error.errors),t()):r.items&&(c=o.gcalItemsToRawEventDefs(r.items,a.timeZone),p=i.applyAll(s,o,[r,n,u]),l.isArray(p)&&(c=p),e(o.parseEventDefs(c)))},error:function(e,r,n){o.reportError("Google Calendar network failure: "+r,[e,n]),o.calendar.popLoading(),t()}}))})):i.Promise.reject()},t.prototype.gcalItemsToRawEventDefs=function(e,t){var r=this;return e.map(function(e){return r.gcalItemToRawEventDef(e,t)})},t.prototype.gcalItemToRawEventDef=function(e,t){var r=e.htmlLink||null;r&&t&&(r=n(r,"ctz="+t));var o={};return"object"==typeof e.extendedProperties&&"object"==typeof e.extendedProperties.shared&&(o=e.extendedProperties.shared),{id:e.id,title:e.summary,start:e.start.dateTime||e.start.date,end:e.end.dateTime||e.end.date,url:r,location:e.location,description:e.description,extendedProperties:o}},t.prototype.buildUrl=function(){return t.API_BASE+"/"+encodeURIComponent(this.googleCalendarId)+"/events?callback=?"},t.prototype.buildRequestParams=function(e,t,r){var o,n=this.googleCalendarApiKey||this.calendar.opt("googleCalendarApiKey");return n?(e.hasZone()||(e=e.clone().utc().add(-1,"day")),t.hasZone()||(t=t.clone().utc().add(1,"day")),o=l.extend(this.ajaxSettings.data||{},{key:n,timeMin:e.format(),timeMax:t.format(),singleEvents:!0,maxResults:9999}),r&&"local"!==r&&(o.timeZone=r.replace(" ","_")),o):(this.reportError("Specify a googleCalendarApiKey. See http://fullcalendar.io/docs/google_calendar/"),null)},t.prototype.reportError=function(e,t){var r=this.calendar,o=r.opt("googleCalendarError"),n=t||[{message:e}];this.googleCalendarError&&this.googleCalendarError.apply(r,n),o&&o.apply(r,n),i.warn.apply(null,[e].concat(t||[]))},t.prototype.getPrimitive=function(){return this.googleCalendarId},t.prototype.applyManualStandardProps=function(e){var t=i.EventSource.prototype.applyManualStandardProps.apply(this,arguments),r=e.googleCalendarId;return null==r&&e.url&&(r=o(e.url)),null!=r&&(this.googleCalendarId=r,t)},t.prototype.applyMiscProps=function(e){this.ajaxSettings||(this.ajaxSettings={}),l.extend(this.ajaxSettings,e)},t.API_BASE="https://www.googleapis.com/calendar/v3/calendars",t}(i.EventSource);t.default=u,u.defineStandardProps({url:!1,googleCalendarId:!1,googleCalendarApiKey:!0,googleCalendarError:!0})},3:function(e,r){e.exports=t}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/ar.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/ar.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(n){if(r[n])return r[n].exports;var o=r[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var r={};return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:n})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=85)}({0:function(t,r){t.exports=e},1:function(e,r){e.exports=t},85:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),r(86);var n=r(1);n.datepickerLocale("ar","ar",{closeText:"إغلاق",prevText:"&#x3C;السابق",nextText:"التالي&#x3E;",currentText:"اليوم",monthNames:["يناير","فبراير","مارس","أبريل","مايو","يونيو","يوليو","أغسطس","سبتمبر","أكتوبر","نوفمبر","ديسمبر"],monthNamesShort:["1","2","3","4","5","6","7","8","9","10","11","12"],dayNames:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"],dayNamesShort:["أحد","اثنين","ثلاثاء","أربعاء","خميس","جمعة","سبت"],dayNamesMin:["ح","ن","ث","ر","خ","ج","س"],weekHeader:"أسبوع",dateFormat:"dd/mm/yy",firstDay:0,isRTL:!0,showMonthAfterYear:!1,yearSuffix:""}),n.locale("ar",{buttonText:{month:"شهر",week:"أسبوع",day:"يوم",list:"أجندة"},allDayText:"اليوم كله",eventLimitText:"أخرى",noEventsMessage:"أي أحداث لعرض"})},86:function(e,t,r){!function(e,t){t(r(0))}(0,function(e){var t={1:"١",2:"٢",3:"٣",4:"٤",5:"٥",6:"٦",7:"٧",8:"٨",9:"٩",0:"٠"},r={"١":"1","٢":"2","٣":"3","٤":"4","٥":"5","٦":"6","٧":"7","٨":"8","٩":"9","٠":"0"},n=function(e){return 0===e?0:1===e?1:2===e?2:e%100>=3&&e%100<=10?3:e%100>=11?4:5},o={s:["أقل من ثانية","ثانية واحدة",["ثانيتان","ثانيتين"],"%d ثوان","%d ثانية","%d ثانية"],m:["أقل من دقيقة","دقيقة واحدة",["دقيقتان","دقيقتين"],"%d دقائق","%d دقيقة","%d دقيقة"],h:["أقل من ساعة","ساعة واحدة",["ساعتان","ساعتين"],"%d ساعات","%d ساعة","%d ساعة"],d:["أقل من يوم","يوم واحد",["يومان","يومين"],"%d أيام","%d يومًا","%d يوم"],M:["أقل من شهر","شهر واحد",["شهران","شهرين"],"%d أشهر","%d شهرا","%d شهر"],y:["أقل من عام","عام واحد",["عامان","عامين"],"%d أعوام","%d عامًا","%d عام"]},a=function(e){return function(t,r,a,d){var u=n(t),i=o[e][n(t)];return 2===u&&(i=i[r?0:1]),i.replace(/%d/i,t)}},d=["يناير","فبراير","مارس","أبريل","مايو","يونيو","يوليو","أغسطس","سبتمبر","أكتوبر","نوفمبر","ديسمبر"];return e.defineLocale("ar",{months:d,monthsShort:d,weekdays:"الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),weekdaysShort:"أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),weekdaysMin:"ح_ن_ث_ر_خ_ج_س".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"D/‏M/‏YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},meridiemParse:/ص|م/,isPM:function(e){return"م"===e},meridiem:function(e,t,r){return e<12?"ص":"م"},calendar:{sameDay:"[اليوم عند الساعة] LT",nextDay:"[غدًا عند الساعة] LT",nextWeek:"dddd [عند الساعة] LT",lastDay:"[أمس عند الساعة] LT",lastWeek:"dddd [عند الساعة] LT",sameElse:"L"},relativeTime:{future:"بعد %s",past:"منذ %s",s:a("s"),ss:a("s"),m:a("m"),mm:a("m"),h:a("h"),hh:a("h"),d:a("d"),dd:a("d"),M:a("M"),MM:a("M"),y:a("y"),yy:a("y")},preparse:function(e){return e.replace(/[١٢٣٤٥٦٧٨٩٠]/g,function(e){return r[e]}).replace(/،/g,",")},postformat:function(e){return e.replace(/\d/g,function(e){return t[e]}).replace(/,/g,"،")},week:{dow:6,doy:12}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/cs.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/cs.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,n){ true?module.exports=n(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,n){return function(e){function n(r){if(t[r])return t[r].exports;var s=t[r]={i:r,l:!1,exports:{}};return e[r].call(s.exports,s,s.exports,n),s.l=!0,s.exports}var t={};return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:r})},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=95)}({0:function(n,t){n.exports=e},1:function(e,t){e.exports=n},95:function(e,n,t){Object.defineProperty(n,"__esModule",{value:!0}),t(96);var r=t(1);r.datepickerLocale("cs","cs",{closeText:"Zavřít",prevText:"&#x3C;Dříve",nextText:"Později&#x3E;",currentText:"Nyní",monthNames:["leden","únor","březen","duben","květen","červen","červenec","srpen","září","říjen","listopad","prosinec"],monthNamesShort:["led","úno","bře","dub","kvě","čer","čvc","srp","zář","říj","lis","pro"],dayNames:["neděle","pondělí","úterý","středa","čtvrtek","pátek","sobota"],dayNamesShort:["ne","po","út","st","čt","pá","so"],dayNamesMin:["ne","po","út","st","čt","pá","so"],weekHeader:"Týd",dateFormat:"dd.mm.yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),r.locale("cs",{buttonText:{month:"Měsíc",week:"Týden",day:"Den",list:"Agenda"},allDayText:"Celý den",eventLimitText:function(e){return"+další: "+e},noEventsMessage:"Žádné akce k zobrazení"})},96:function(e,n,t){!function(e,n){n(t(0))}(0,function(e){function n(e){return e>1&&e<5&&1!=~~(e/10)}function t(e,t,r,s){var o=e+" ";switch(r){case"s":return t||s?"pár sekund":"pár sekundami";case"ss":return t||s?o+(n(e)?"sekundy":"sekund"):o+"sekundami";case"m":return t?"minuta":s?"minutu":"minutou";case"mm":return t||s?o+(n(e)?"minuty":"minut"):o+"minutami";case"h":return t?"hodina":s?"hodinu":"hodinou";case"hh":return t||s?o+(n(e)?"hodiny":"hodin"):o+"hodinami";case"d":return t||s?"den":"dnem";case"dd":return t||s?o+(n(e)?"dny":"dní"):o+"dny";case"M":return t||s?"měsíc":"měsícem";case"MM":return t||s?o+(n(e)?"měsíce":"měsíců"):o+"měsíci";case"y":return t||s?"rok":"rokem";case"yy":return t||s?o+(n(e)?"roky":"let"):o+"lety"}}var r="leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec".split("_"),s="led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro".split("_"),o=[/^led/i,/^úno/i,/^bře/i,/^dub/i,/^kvě/i,/^(čvn|červen$|června)/i,/^(čvc|červenec|července)/i,/^srp/i,/^zář/i,/^říj/i,/^lis/i,/^pro/i],a=/^(leden|únor|březen|duben|květen|červenec|července|červen|června|srpen|září|říjen|listopad|prosinec|led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i;return e.defineLocale("cs",{months:r,monthsShort:s,monthsRegex:a,monthsShortRegex:a,monthsStrictRegex:/^(leden|ledna|února|únor|březen|března|duben|dubna|květen|května|červenec|července|červen|června|srpen|srpna|září|říjen|října|listopadu|listopad|prosinec|prosince)/i,monthsShortStrictRegex:/^(led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i,monthsParse:o,longMonthsParse:o,shortMonthsParse:o,weekdays:"neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota".split("_"),weekdaysShort:"ne_po_út_st_čt_pá_so".split("_"),weekdaysMin:"ne_po_út_st_čt_pá_so".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd D. MMMM YYYY H:mm",l:"D. M. YYYY"},calendar:{sameDay:"[dnes v] LT",nextDay:"[zítra v] LT",nextWeek:function(){switch(this.day()){case 0:return"[v neděli v] LT";case 1:case 2:return"[v] dddd [v] LT";case 3:return"[ve středu v] LT";case 4:return"[ve čtvrtek v] LT";case 5:return"[v pátek v] LT";case 6:return"[v sobotu v] LT"}},lastDay:"[včera v] LT",lastWeek:function(){switch(this.day()){case 0:return"[minulou neděli v] LT";case 1:case 2:return"[minulé] dddd [v] LT";case 3:return"[minulou středu v] LT";case 4:case 5:return"[minulý] dddd [v] LT";case 6:return"[minulou sobotu v] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"před %s",s:t,ss:t,m:t,mm:t,h:t,hh:t,d:t,dd:t,M:t,MM:t,y:t,yy:t},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/da.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/da.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,r){ true?module.exports=r(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,r){return function(e){function r(n){if(t[n])return t[n].exports;var a=t[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,r),a.l=!0,a.exports}var t={};return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:n})},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},r.p="",r(r.s=97)}({0:function(r,t){r.exports=e},1:function(e,t){e.exports=r},97:function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0}),t(98);var n=t(1);n.datepickerLocale("da","da",{closeText:"Luk",prevText:"&#x3C;Forrige",nextText:"Næste&#x3E;",currentText:"Idag",monthNames:["Januar","Februar","Marts","April","Maj","Juni","Juli","August","September","Oktober","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","Maj","Jun","Jul","Aug","Sep","Okt","Nov","Dec"],dayNames:["Søndag","Mandag","Tirsdag","Onsdag","Torsdag","Fredag","Lørdag"],dayNamesShort:["Søn","Man","Tir","Ons","Tor","Fre","Lør"],dayNamesMin:["Sø","Ma","Ti","On","To","Fr","Lø"],weekHeader:"Uge",dateFormat:"dd-mm-yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),n.locale("da",{buttonText:{month:"Måned",week:"Uge",day:"Dag",list:"Agenda"},allDayText:"Hele dagen",eventLimitText:"flere",noEventsMessage:"Ingen arrangementer at vise"})},98:function(e,r,t){!function(e,r){r(t(0))}(0,function(e){return e.defineLocale("da",{months:"januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),monthsShort:"jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),weekdays:"søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"),weekdaysShort:"søn_man_tir_ons_tor_fre_lør".split("_"),weekdaysMin:"sø_ma_ti_on_to_fr_lø".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd [d.] D. MMMM YYYY [kl.] HH:mm"},calendar:{sameDay:"[i dag kl.] LT",nextDay:"[i morgen kl.] LT",nextWeek:"på dddd [kl.] LT",lastDay:"[i går kl.] LT",lastWeek:"[i] dddd[s kl.] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"%s siden",s:"få sekunder",ss:"%d sekunder",m:"et minut",mm:"%d minutter",h:"en time",hh:"%d timer",d:"en dag",dd:"%d dage",M:"en måned",MM:"%d måneder",y:"et år",yy:"%d år"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/de-at.js":
/*!********************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/de-at.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=99)}({0:function(t,n){t.exports=e},1:function(e,n){e.exports=t},100:function(e,t,n){!function(e,t){t(n(0))}(0,function(e){function t(e,t,n,r){var a={m:["eine Minute","einer Minute"],h:["eine Stunde","einer Stunde"],d:["ein Tag","einem Tag"],dd:[e+" Tage",e+" Tagen"],M:["ein Monat","einem Monat"],MM:[e+" Monate",e+" Monaten"],y:["ein Jahr","einem Jahr"],yy:[e+" Jahre",e+" Jahren"]};return t?a[n][0]:a[n][1]}return e.defineLocale("de-at",{months:"Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},calendar:{sameDay:"[heute um] LT [Uhr]",sameElse:"L",nextDay:"[morgen um] LT [Uhr]",nextWeek:"dddd [um] LT [Uhr]",lastDay:"[gestern um] LT [Uhr]",lastWeek:"[letzten] dddd [um] LT [Uhr]"},relativeTime:{future:"in %s",past:"vor %s",s:"ein paar Sekunden",ss:"%d Sekunden",m:t,mm:"%d Minuten",h:t,hh:"%d Stunden",d:t,dd:t,M:t,MM:t,y:t,yy:t},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}})})},99:function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),n(100);var r=n(1);r.datepickerLocale("de-at","de",{closeText:"Schließen",prevText:"&#x3C;Zurück",nextText:"Vor&#x3E;",currentText:"Heute",monthNames:["Januar","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"],monthNamesShort:["Jan","Feb","Mär","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],dayNames:["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"],dayNamesShort:["So","Mo","Di","Mi","Do","Fr","Sa"],dayNamesMin:["So","Mo","Di","Mi","Do","Fr","Sa"],weekHeader:"KW",dateFormat:"dd.mm.yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),r.locale("de-at",{buttonText:{year:"Jahr",month:"Monat",week:"Woche",day:"Tag",list:"Terminübersicht"},allDayText:"Ganztägig",eventLimitText:function(e){return"+ weitere "+e},noEventsMessage:"Keine Ereignisse anzuzeigen"})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/de-ch.js":
/*!********************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/de-ch.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=101)}({0:function(t,n){t.exports=e},1:function(e,n){e.exports=t},101:function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),n(102);var r=n(1);r.datepickerLocale("de-ch","de",{closeText:"Schließen",prevText:"&#x3C;Zurück",nextText:"Vor&#x3E;",currentText:"Heute",monthNames:["Januar","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"],monthNamesShort:["Jan","Feb","Mär","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],dayNames:["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"],dayNamesShort:["So","Mo","Di","Mi","Do","Fr","Sa"],dayNamesMin:["So","Mo","Di","Mi","Do","Fr","Sa"],weekHeader:"KW",dateFormat:"dd.mm.yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),r.locale("de-ch",{buttonText:{year:"Jahr",month:"Monat",week:"Woche",day:"Tag",list:"Terminübersicht"},allDayText:"Ganztägig",eventLimitText:function(e){return"+ weitere "+e},noEventsMessage:"Keine Ereignisse anzuzeigen"})},102:function(e,t,n){!function(e,t){t(n(0))}(0,function(e){function t(e,t,n,r){var a={m:["eine Minute","einer Minute"],h:["eine Stunde","einer Stunde"],d:["ein Tag","einem Tag"],dd:[e+" Tage",e+" Tagen"],M:["ein Monat","einem Monat"],MM:[e+" Monate",e+" Monaten"],y:["ein Jahr","einem Jahr"],yy:[e+" Jahre",e+" Jahren"]};return t?a[n][0]:a[n][1]}return e.defineLocale("de-ch",{months:"Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},calendar:{sameDay:"[heute um] LT [Uhr]",sameElse:"L",nextDay:"[morgen um] LT [Uhr]",nextWeek:"dddd [um] LT [Uhr]",lastDay:"[gestern um] LT [Uhr]",lastWeek:"[letzten] dddd [um] LT [Uhr]"},relativeTime:{future:"in %s",past:"vor %s",s:"ein paar Sekunden",ss:"%d Sekunden",m:t,mm:"%d Minuten",h:t,hh:"%d Stunden",d:t,dd:t,M:t,MM:t,y:t,yy:t},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/de.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/de.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=103)}({0:function(t,n){t.exports=e},1:function(e,n){e.exports=t},103:function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),n(104);var r=n(1);r.datepickerLocale("de","de",{closeText:"Schließen",prevText:"&#x3C;Zurück",nextText:"Vor&#x3E;",currentText:"Heute",monthNames:["Januar","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"],monthNamesShort:["Jan","Feb","Mär","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],dayNames:["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"],dayNamesShort:["So","Mo","Di","Mi","Do","Fr","Sa"],dayNamesMin:["So","Mo","Di","Mi","Do","Fr","Sa"],weekHeader:"KW",dateFormat:"dd.mm.yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),r.locale("de",{buttonText:{year:"Jahr",month:"Monat",week:"Woche",day:"Tag",list:"Terminübersicht"},allDayText:"Ganztägig",eventLimitText:function(e){return"+ weitere "+e},noEventsMessage:"Keine Ereignisse anzuzeigen",dayOfMonthFormat:"ddd DD.MM."})},104:function(e,t,n){!function(e,t){t(n(0))}(0,function(e){function t(e,t,n,r){var a={m:["eine Minute","einer Minute"],h:["eine Stunde","einer Stunde"],d:["ein Tag","einem Tag"],dd:[e+" Tage",e+" Tagen"],M:["ein Monat","einem Monat"],MM:[e+" Monate",e+" Monaten"],y:["ein Jahr","einem Jahr"],yy:[e+" Jahre",e+" Jahren"]};return t?a[n][0]:a[n][1]}return e.defineLocale("de",{months:"Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),monthsShort:"Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),monthsParseExact:!0,weekdays:"Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),weekdaysShort:"So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),weekdaysMin:"So_Mo_Di_Mi_Do_Fr_Sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY HH:mm",LLLL:"dddd, D. MMMM YYYY HH:mm"},calendar:{sameDay:"[heute um] LT [Uhr]",sameElse:"L",nextDay:"[morgen um] LT [Uhr]",nextWeek:"dddd [um] LT [Uhr]",lastDay:"[gestern um] LT [Uhr]",lastWeek:"[letzten] dddd [um] LT [Uhr]"},relativeTime:{future:"in %s",past:"vor %s",s:"ein paar Sekunden",ss:"%d Sekunden",m:t,mm:"%d Minuten",h:t,hh:"%d Stunden",d:t,dd:t,M:t,MM:t,y:t,yy:t},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/en-gb.js":
/*!********************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/en-gb.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(a){if(r[a])return r[a].exports;var n=r[a]={i:a,l:!1,exports:{}};return e[a].call(n.exports,n,n.exports,t),n.l=!0,n.exports}var r={};return t.m=e,t.c=r,t.d=function(e,r,a){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:a})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=111)}({0:function(t,r){t.exports=e},1:function(e,r){e.exports=t},111:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),r(112);var a=r(1);a.datepickerLocale("en-gb","en-GB",{closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"dd/mm/yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),a.locale("en-gb")},112:function(e,t,r){!function(e,t){t(r(0))}(0,function(e){return e.defineLocale("en-gb",{months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),monthsShort:"Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),weekdaysShort:"Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),weekdaysMin:"Su_Mo_Tu_We_Th_Fr_Sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Today at] LT",nextDay:"[Tomorrow at] LT",nextWeek:"dddd [at] LT",lastDay:"[Yesterday at] LT",lastWeek:"[Last] dddd [at] LT",sameElse:"L"},relativeTime:{future:"in %s",past:"%s ago",s:"a few seconds",ss:"%d seconds",m:"a minute",mm:"%d minutes",h:"an hour",hh:"%d hours",d:"a day",dd:"%d days",M:"a month",MM:"%d months",y:"a year",yy:"%d years"},dayOfMonthOrdinalParse:/\d{1,2}(st|nd|rd|th)/,ordinal:function(e){var t=e%10;return e+(1==~~(e%100/10)?"th":1===t?"st":2===t?"nd":3===t?"rd":"th")},week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/es.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/es.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,o){ true?module.exports=o(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,o){return function(e){function o(n){if(r[n])return r[n].exports;var t=r[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,o),t.l=!0,t.exports}var r={};return o.m=e,o.c=r,o.d=function(e,r,n){o.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:n})},o.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return o.d(r,"a",r),r},o.o=function(e,o){return Object.prototype.hasOwnProperty.call(e,o)},o.p="",o(o.s=121)}({0:function(o,r){o.exports=e},1:function(e,r){e.exports=o},121:function(e,o,r){Object.defineProperty(o,"__esModule",{value:!0}),r(122);var n=r(1);n.datepickerLocale("es","es",{closeText:"Cerrar",prevText:"&#x3C;Ant",nextText:"Sig&#x3E;",currentText:"Hoy",monthNames:["enero","febrero","marzo","abril","mayo","junio","julio","agosto","septiembre","octubre","noviembre","diciembre"],monthNamesShort:["ene","feb","mar","abr","may","jun","jul","ago","sep","oct","nov","dic"],dayNames:["domingo","lunes","martes","miércoles","jueves","viernes","sábado"],dayNamesShort:["dom","lun","mar","mié","jue","vie","sáb"],dayNamesMin:["D","L","M","X","J","V","S"],weekHeader:"Sm",dateFormat:"dd/mm/yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),n.locale("es",{buttonText:{month:"Mes",week:"Semana",day:"Día",list:"Agenda"},allDayHtml:"Todo<br/>el día",eventLimitText:"más",noEventsMessage:"No hay eventos para mostrar"})},122:function(e,o,r){!function(e,o){o(r(0))}(0,function(e){var o="ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),r="ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),n=[/^ene/i,/^feb/i,/^mar/i,/^abr/i,/^may/i,/^jun/i,/^jul/i,/^ago/i,/^sep/i,/^oct/i,/^nov/i,/^dic/i],t=/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;return e.defineLocale("es",{months:"enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),monthsShort:function(e,n){return e?/-MMM-/.test(n)?r[e.month()]:o[e.month()]:o},monthsRegex:t,monthsShortRegex:t,monthsStrictRegex:/^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,monthsShortStrictRegex:/^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,monthsParse:n,longMonthsParse:n,shortMonthsParse:n,weekdays:"domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),weekdaysShort:"dom._lun._mar._mié._jue._vie._sáb.".split("_"),weekdaysMin:"do_lu_ma_mi_ju_vi_sá".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY H:mm",LLLL:"dddd, D [de] MMMM [de] YYYY H:mm"},calendar:{sameDay:function(){return"[hoy a la"+(1!==this.hours()?"s":"")+"] LT"},nextDay:function(){return"[mañana a la"+(1!==this.hours()?"s":"")+"] LT"},nextWeek:function(){return"dddd [a la"+(1!==this.hours()?"s":"")+"] LT"},lastDay:function(){return"[ayer a la"+(1!==this.hours()?"s":"")+"] LT"},lastWeek:function(){return"[el] dddd [pasado a la"+(1!==this.hours()?"s":"")+"] LT"},sameElse:"L"},relativeTime:{future:"en %s",past:"hace %s",s:"unos segundos",ss:"%d segundos",m:"un minuto",mm:"%d minutos",h:"una hora",hh:"%d horas",d:"un día",dd:"%d días",M:"un mes",MM:"%d meses",y:"un año",yy:"%d años"},dayOfMonthOrdinalParse:/\d{1,2}º/,ordinal:"%dº",week:{dow:1,doy:4},invalidDate:"Fecha invalida"})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/eu.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/eu.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(a,e){ true?module.exports=e(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(a,e){return function(a){function e(r){if(t[r])return t[r].exports;var n=t[r]={i:r,l:!1,exports:{}};return a[r].call(n.exports,n,n.exports,e),n.l=!0,n.exports}var t={};return e.m=a,e.c=t,e.d=function(a,t,r){e.o(a,t)||Object.defineProperty(a,t,{configurable:!1,enumerable:!0,get:r})},e.n=function(a){var t=a&&a.__esModule?function(){return a.default}:function(){return a};return e.d(t,"a",t),t},e.o=function(a,e){return Object.prototype.hasOwnProperty.call(a,e)},e.p="",e(e.s=125)}({0:function(e,t){e.exports=a},1:function(a,t){a.exports=e},125:function(a,e,t){Object.defineProperty(e,"__esModule",{value:!0}),t(126);var r=t(1);r.datepickerLocale("eu","eu",{closeText:"Egina",prevText:"&#x3C;Aur",nextText:"Hur&#x3E;",currentText:"Gaur",monthNames:["urtarrila","otsaila","martxoa","apirila","maiatza","ekaina","uztaila","abuztua","iraila","urria","azaroa","abendua"],monthNamesShort:["urt.","ots.","mar.","api.","mai.","eka.","uzt.","abu.","ira.","urr.","aza.","abe."],dayNames:["igandea","astelehena","asteartea","asteazkena","osteguna","ostirala","larunbata"],dayNamesShort:["ig.","al.","ar.","az.","og.","ol.","lr."],dayNamesMin:["ig","al","ar","az","og","ol","lr"],weekHeader:"As",dateFormat:"yy-mm-dd",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),r.locale("eu",{buttonText:{month:"Hilabetea",week:"Astea",day:"Eguna",list:"Agenda"},allDayHtml:"Egun<br/>osoa",eventLimitText:"gehiago",noEventsMessage:"Ez dago ekitaldirik erakusteko"})},126:function(a,e,t){!function(a,e){e(t(0))}(0,function(a){return a.defineLocale("eu",{months:"urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),monthsShort:"urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),monthsParseExact:!0,weekdays:"igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),weekdaysShort:"ig._al._ar._az._og._ol._lr.".split("_"),weekdaysMin:"ig_al_ar_az_og_ol_lr".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"YYYY[ko] MMMM[ren] D[a]",LLL:"YYYY[ko] MMMM[ren] D[a] HH:mm",LLLL:"dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",l:"YYYY-M-D",ll:"YYYY[ko] MMM D[a]",lll:"YYYY[ko] MMM D[a] HH:mm",llll:"ddd, YYYY[ko] MMM D[a] HH:mm"},calendar:{sameDay:"[gaur] LT[etan]",nextDay:"[bihar] LT[etan]",nextWeek:"dddd LT[etan]",lastDay:"[atzo] LT[etan]",lastWeek:"[aurreko] dddd LT[etan]",sameElse:"L"},relativeTime:{future:"%s barru",past:"duela %s",s:"segundo batzuk",ss:"%d segundo",m:"minutu bat",mm:"%d minutu",h:"ordu bat",hh:"%d ordu",d:"egun bat",dd:"%d egun",M:"hilabete bat",MM:"%d hilabete",y:"urte bat",yy:"%d urte"},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:7}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/fi.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/fi.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,u){ true?module.exports=u(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,u){return function(e){function u(a){if(t[a])return t[a].exports;var n=t[a]={i:a,l:!1,exports:{}};return e[a].call(n.exports,n,n.exports,u),n.l=!0,n.exports}var t={};return u.m=e,u.c=t,u.d=function(e,t,a){u.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:a})},u.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return u.d(t,"a",t),t},u.o=function(e,u){return Object.prototype.hasOwnProperty.call(e,u)},u.p="",u(u.s=129)}({0:function(u,t){u.exports=e},1:function(e,t){e.exports=u},129:function(e,u,t){Object.defineProperty(u,"__esModule",{value:!0}),t(130);var a=t(1);a.datepickerLocale("fi","fi",{closeText:"Sulje",prevText:"&#xAB;Edellinen",nextText:"Seuraava&#xBB;",currentText:"Tänään",monthNames:["Tammikuu","Helmikuu","Maaliskuu","Huhtikuu","Toukokuu","Kesäkuu","Heinäkuu","Elokuu","Syyskuu","Lokakuu","Marraskuu","Joulukuu"],monthNamesShort:["Tammi","Helmi","Maalis","Huhti","Touko","Kesä","Heinä","Elo","Syys","Loka","Marras","Joulu"],dayNamesShort:["Su","Ma","Ti","Ke","To","Pe","La"],dayNames:["Sunnuntai","Maanantai","Tiistai","Keskiviikko","Torstai","Perjantai","Lauantai"],dayNamesMin:["Su","Ma","Ti","Ke","To","Pe","La"],weekHeader:"Vk",dateFormat:"d.m.yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),a.locale("fi",{buttonText:{month:"Kuukausi",week:"Viikko",day:"Päivä",list:"Tapahtumat"},allDayText:"Koko päivä",eventLimitText:"lisää",noEventsMessage:"Ei näytettäviä tapahtumia"})},130:function(e,u,t){!function(e,u){u(t(0))}(0,function(e){function u(e,u,a,n){var i="";switch(a){case"s":return n?"muutaman sekunnin":"muutama sekunti";case"ss":return n?"sekunnin":"sekuntia";case"m":return n?"minuutin":"minuutti";case"mm":i=n?"minuutin":"minuuttia";break;case"h":return n?"tunnin":"tunti";case"hh":i=n?"tunnin":"tuntia";break;case"d":return n?"päivän":"päivä";case"dd":i=n?"päivän":"päivää";break;case"M":return n?"kuukauden":"kuukausi";case"MM":i=n?"kuukauden":"kuukautta";break;case"y":return n?"vuoden":"vuosi";case"yy":i=n?"vuoden":"vuotta"}return i=t(e,n)+" "+i}function t(e,u){return e<10?u?n[e]:a[e]:e}var a="nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän".split(" "),n=["nolla","yhden","kahden","kolmen","neljän","viiden","kuuden",a[7],a[8],a[9]];return e.defineLocale("fi",{months:"tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),monthsShort:"tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu".split("_"),weekdays:"sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),weekdaysShort:"su_ma_ti_ke_to_pe_la".split("_"),weekdaysMin:"su_ma_ti_ke_to_pe_la".split("_"),longDateFormat:{LT:"HH.mm",LTS:"HH.mm.ss",L:"DD.MM.YYYY",LL:"Do MMMM[ta] YYYY",LLL:"Do MMMM[ta] YYYY, [klo] HH.mm",LLLL:"dddd, Do MMMM[ta] YYYY, [klo] HH.mm",l:"D.M.YYYY",ll:"Do MMM YYYY",lll:"Do MMM YYYY, [klo] HH.mm",llll:"ddd, Do MMM YYYY, [klo] HH.mm"},calendar:{sameDay:"[tänään] [klo] LT",nextDay:"[huomenna] [klo] LT",nextWeek:"dddd [klo] LT",lastDay:"[eilen] [klo] LT",lastWeek:"[viime] dddd[na] [klo] LT",sameElse:"L"},relativeTime:{future:"%s päästä",past:"%s sitten",s:u,ss:u,m:u,mm:u,h:u,hh:u,d:u,dd:u,M:u,MM:u,y:u,yy:u},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/fr.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/fr.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,r){ true?module.exports=r(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,r){return function(e){function r(t){if(n[t])return n[t].exports;var a=n[t]={i:t,l:!1,exports:{}};return e[t].call(a.exports,a,a.exports,r),a.l=!0,a.exports}var n={};return r.m=e,r.c=n,r.d=function(e,n,t){r.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:t})},r.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(n,"a",n),n},r.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},r.p="",r(r.s=135)}({0:function(r,n){r.exports=e},1:function(e,n){e.exports=r},135:function(e,r,n){Object.defineProperty(r,"__esModule",{value:!0}),n(136);var t=n(1);t.datepickerLocale("fr","fr",{closeText:"Fermer",prevText:"Précédent",nextText:"Suivant",currentText:"Aujourd'hui",monthNames:["janvier","février","mars","avril","mai","juin","juillet","août","septembre","octobre","novembre","décembre"],monthNamesShort:["janv.","févr.","mars","avr.","mai","juin","juil.","août","sept.","oct.","nov.","déc."],dayNames:["dimanche","lundi","mardi","mercredi","jeudi","vendredi","samedi"],dayNamesShort:["dim.","lun.","mar.","mer.","jeu.","ven.","sam."],dayNamesMin:["D","L","M","M","J","V","S"],weekHeader:"Sem.",dateFormat:"dd/mm/yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),t.locale("fr",{buttonText:{year:"Année",month:"Mois",week:"Semaine",day:"Jour",list:"Mon planning"},allDayHtml:"Toute la<br/>journée",eventLimitText:"en plus",noEventsMessage:"Aucun événement à afficher"})},136:function(e,r,n){!function(e,r){r(n(0))}(0,function(e){return e.defineLocale("fr",{months:"janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),monthsShort:"janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),monthsParseExact:!0,weekdays:"dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),weekdaysShort:"dim._lun._mar._mer._jeu._ven._sam.".split("_"),weekdaysMin:"di_lu_ma_me_je_ve_sa".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[Aujourd’hui à] LT",nextDay:"[Demain à] LT",nextWeek:"dddd [à] LT",lastDay:"[Hier à] LT",lastWeek:"dddd [dernier à] LT",sameElse:"L"},relativeTime:{future:"dans %s",past:"il y a %s",s:"quelques secondes",ss:"%d secondes",m:"une minute",mm:"%d minutes",h:"une heure",hh:"%d heures",d:"un jour",dd:"%d jours",M:"un mois",MM:"%d mois",y:"un an",yy:"%d ans"},dayOfMonthOrdinalParse:/\d{1,2}(er|)/,ordinal:function(e,r){switch(r){case"D":return e+(1===e?"er":"");default:case"M":case"Q":case"DDD":case"d":return e+(1===e?"er":"e");case"w":case"W":return e+(1===e?"re":"e")}},week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/he.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/he.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=139)}({0:function(t,n){t.exports=e},1:function(e,n){e.exports=t},139:function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),n(140);var r=n(1);r.datepickerLocale("he","he",{closeText:"סגור",prevText:"&#x3C;הקודם",nextText:"הבא&#x3E;",currentText:"היום",monthNames:["ינואר","פברואר","מרץ","אפריל","מאי","יוני","יולי","אוגוסט","ספטמבר","אוקטובר","נובמבר","דצמבר"],monthNamesShort:["ינו","פבר","מרץ","אפר","מאי","יוני","יולי","אוג","ספט","אוק","נוב","דצמ"],dayNames:["ראשון","שני","שלישי","רביעי","חמישי","שישי","שבת"],dayNamesShort:["א'","ב'","ג'","ד'","ה'","ו'","שבת"],dayNamesMin:["א'","ב'","ג'","ד'","ה'","ו'","שבת"],weekHeader:"Wk",dateFormat:"dd/mm/yy",firstDay:0,isRTL:!0,showMonthAfterYear:!1,yearSuffix:""}),r.locale("he",{buttonText:{month:"חודש",week:"שבוע",day:"יום",list:"סדר יום"},allDayText:"כל היום",eventLimitText:"אחר",noEventsMessage:"אין אירועים להצגה",weekNumberTitle:"שבוע"})},140:function(e,t,n){!function(e,t){t(n(0))}(0,function(e){return e.defineLocale("he",{months:"ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר".split("_"),monthsShort:"ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳".split("_"),weekdays:"ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת".split("_"),weekdaysShort:"א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳".split("_"),weekdaysMin:"א_ב_ג_ד_ה_ו_ש".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [ב]MMMM YYYY",LLL:"D [ב]MMMM YYYY HH:mm",LLLL:"dddd, D [ב]MMMM YYYY HH:mm",l:"D/M/YYYY",ll:"D MMM YYYY",lll:"D MMM YYYY HH:mm",llll:"ddd, D MMM YYYY HH:mm"},calendar:{sameDay:"[היום ב־]LT",nextDay:"[מחר ב־]LT",nextWeek:"dddd [בשעה] LT",lastDay:"[אתמול ב־]LT",lastWeek:"[ביום] dddd [האחרון בשעה] LT",sameElse:"L"},relativeTime:{future:"בעוד %s",past:"לפני %s",s:"מספר שניות",ss:"%d שניות",m:"דקה",mm:"%d דקות",h:"שעה",hh:function(e){return 2===e?"שעתיים":e+" שעות"},d:"יום",dd:function(e){return 2===e?"יומיים":e+" ימים"},M:"חודש",MM:function(e){return 2===e?"חודשיים":e+" חודשים"},y:"שנה",yy:function(e){return 2===e?"שנתיים":e%10==0&&10!==e?e+" שנה":e+" שנים"}},meridiemParse:/אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,isPM:function(e){return/^(אחה"צ|אחרי הצהריים|בערב)$/.test(e)},meridiem:function(e,t,n){return e<5?"לפנות בוקר":e<10?"בבוקר":e<12?n?'לפנה"צ':"לפני הצהריים":e<18?n?'אחה"צ':"אחרי הצהריים":"בערב"}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/hu.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/hu.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(n){if(r[n])return r[n].exports;var a=r[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,t),a.l=!0,a.exports}var r={};return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:n})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=145)}({0:function(t,r){t.exports=e},1:function(e,r){e.exports=t},145:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),r(146);var n=r(1);n.datepickerLocale("hu","hu",{closeText:"bezár",prevText:"vissza",nextText:"előre",currentText:"ma",monthNames:["Január","Február","Március","Április","Május","Június","Július","Augusztus","Szeptember","Október","November","December"],monthNamesShort:["Jan","Feb","Már","Ápr","Máj","Jún","Júl","Aug","Szep","Okt","Nov","Dec"],dayNames:["Vasárnap","Hétfő","Kedd","Szerda","Csütörtök","Péntek","Szombat"],dayNamesShort:["Vas","Hét","Ked","Sze","Csü","Pén","Szo"],dayNamesMin:["V","H","K","Sze","Cs","P","Szo"],weekHeader:"Hét",dateFormat:"yy.mm.dd.",firstDay:1,isRTL:!1,showMonthAfterYear:!0,yearSuffix:""}),n.locale("hu",{buttonText:{month:"Hónap",week:"Hét",day:"Nap",list:"Napló"},allDayText:"Egész nap",eventLimitText:"további",noEventsMessage:"Nincs megjeleníthető esemény"})},146:function(e,t,r){!function(e,t){t(r(0))}(0,function(e){function t(e,t,r,n){var a=e;switch(r){case"s":return n||t?"néhány másodperc":"néhány másodperce";case"ss":return a+(n||t)?" másodperc":" másodperce";case"m":return"egy"+(n||t?" perc":" perce");case"mm":return a+(n||t?" perc":" perce");case"h":return"egy"+(n||t?" óra":" órája");case"hh":return a+(n||t?" óra":" órája");case"d":return"egy"+(n||t?" nap":" napja");case"dd":return a+(n||t?" nap":" napja");case"M":return"egy"+(n||t?" hónap":" hónapja");case"MM":return a+(n||t?" hónap":" hónapja");case"y":return"egy"+(n||t?" év":" éve");case"yy":return a+(n||t?" év":" éve")}return""}function r(e){return(e?"":"[múlt] ")+"["+n[this.day()]+"] LT[-kor]"}var n="vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton".split(" ");return e.defineLocale("hu",{months:"január_február_március_április_május_június_július_augusztus_szeptember_október_november_december".split("_"),monthsShort:"jan_feb_márc_ápr_máj_jún_júl_aug_szept_okt_nov_dec".split("_"),weekdays:"vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat".split("_"),weekdaysShort:"vas_hét_kedd_sze_csüt_pén_szo".split("_"),weekdaysMin:"v_h_k_sze_cs_p_szo".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"YYYY.MM.DD.",LL:"YYYY. MMMM D.",LLL:"YYYY. MMMM D. H:mm",LLLL:"YYYY. MMMM D., dddd H:mm"},meridiemParse:/de|du/i,isPM:function(e){return"u"===e.charAt(1).toLowerCase()},meridiem:function(e,t,r){return e<12?!0===r?"de":"DE":!0===r?"du":"DU"},calendar:{sameDay:"[ma] LT[-kor]",nextDay:"[holnap] LT[-kor]",nextWeek:function(){return r.call(this,!0)},lastDay:"[tegnap] LT[-kor]",lastWeek:function(){return r.call(this,!1)},sameElse:"L"},relativeTime:{future:"%s múlva",past:"%s",s:t,ss:t,m:t,mm:t,h:t,hh:t,d:t,dd:t,M:t,MM:t,y:t,yy:t},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/it.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/it.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(n){if(o[n])return o[n].exports;var r=o[n]={i:n,l:!1,exports:{}};return e[n].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var o={};return t.m=e,t.c=o,t.d=function(e,o,n){t.o(e,o)||Object.defineProperty(e,o,{configurable:!1,enumerable:!0,get:n})},t.n=function(e){var o=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(o,"a",o),o},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=151)}({0:function(t,o){t.exports=e},1:function(e,o){e.exports=t},151:function(e,t,o){Object.defineProperty(t,"__esModule",{value:!0}),o(152);var n=o(1);n.datepickerLocale("it","it",{closeText:"Chiudi",prevText:"&#x3C;Prec",nextText:"Succ&#x3E;",currentText:"Oggi",monthNames:["Gennaio","Febbraio","Marzo","Aprile","Maggio","Giugno","Luglio","Agosto","Settembre","Ottobre","Novembre","Dicembre"],monthNamesShort:["Gen","Feb","Mar","Apr","Mag","Giu","Lug","Ago","Set","Ott","Nov","Dic"],dayNames:["Domenica","Lunedì","Martedì","Mercoledì","Giovedì","Venerdì","Sabato"],dayNamesShort:["Dom","Lun","Mar","Mer","Gio","Ven","Sab"],dayNamesMin:["Do","Lu","Ma","Me","Gi","Ve","Sa"],weekHeader:"Sm",dateFormat:"dd/mm/yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),n.locale("it",{buttonText:{month:"Mese",week:"Settimana",day:"Giorno",list:"Agenda"},allDayHtml:"Tutto il<br/>giorno",eventLimitText:function(e){return"+altri "+e},noEventsMessage:"Non ci sono eventi da visualizzare"})},152:function(e,t,o){!function(e,t){t(o(0))}(0,function(e){return e.defineLocale("it",{months:"gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),monthsShort:"gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),weekdays:"domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"),weekdaysShort:"dom_lun_mar_mer_gio_ven_sab".split("_"),weekdaysMin:"do_lu_ma_me_gi_ve_sa".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:function(){return"[Oggi a"+(this.hours()>1?"lle ":0===this.hours()?" ":"ll'")+"]LT"},nextDay:function(){return"[Domani a"+(this.hours()>1?"lle ":0===this.hours()?" ":"ll'")+"]LT"},nextWeek:function(){return"dddd [a"+(this.hours()>1?"lle ":0===this.hours()?" ":"ll'")+"]LT"},lastDay:function(){return"[Ieri a"+(this.hours()>1?"lle ":0===this.hours()?" ":"ll'")+"]LT"},lastWeek:function(){switch(this.day()){case 0:return"[La scorsa] dddd [a"+(this.hours()>1?"lle ":0===this.hours()?" ":"ll'")+"]LT";default:return"[Lo scorso] dddd [a"+(this.hours()>1?"lle ":0===this.hours()?" ":"ll'")+"]LT"}},sameElse:"L"},relativeTime:{future:function(e){return(/^[0-9].+$/.test(e)?"tra":"in")+" "+e},past:"%s fa",s:"alcuni secondi",ss:"%d secondi",m:"un minuto",mm:"%d minuti",h:"un'ora",hh:"%d ore",d:"un giorno",dd:"%d giorni",M:"un mese",MM:"%d mesi",y:"un anno",yy:"%d anni"},dayOfMonthOrdinalParse:/\d{1,2}º/,ordinal:"%dº",week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/ja.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/ja.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=153)}({0:function(t,n){t.exports=e},1:function(e,n){e.exports=t},153:function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),n(154);var r=n(1);r.datepickerLocale("ja","ja",{closeText:"閉じる",prevText:"&#x3C;前",nextText:"次&#x3E;",currentText:"今日",monthNames:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],monthNamesShort:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],dayNames:["日曜日","月曜日","火曜日","水曜日","木曜日","金曜日","土曜日"],dayNamesShort:["日","月","火","水","木","金","土"],dayNamesMin:["日","月","火","水","木","金","土"],weekHeader:"週",dateFormat:"yy/mm/dd",firstDay:0,isRTL:!1,showMonthAfterYear:!0,yearSuffix:"年"}),r.locale("ja",{buttonText:{month:"月",week:"週",day:"日",list:"予定リスト"},allDayText:"終日",eventLimitText:function(e){return"他 "+e+" 件"},noEventsMessage:"表示する予定はありません"})},154:function(e,t,n){!function(e,t){t(n(0))}(0,function(e){return e.defineLocale("ja",{eras:[{since:"2019-05-01",offset:1,name:"令和",narrow:"㋿",abbr:"R"},{since:"1989-01-08",until:"2019-04-30",offset:1,name:"平成",narrow:"㍻",abbr:"H"},{since:"1926-12-25",until:"1989-01-07",offset:1,name:"昭和",narrow:"㍼",abbr:"S"},{since:"1912-07-30",until:"1926-12-24",offset:1,name:"大正",narrow:"㍽",abbr:"T"},{since:"1873-01-01",until:"1912-07-29",offset:6,name:"明治",narrow:"㍾",abbr:"M"},{since:"0001-01-01",until:"1873-12-31",offset:1,name:"西暦",narrow:"AD",abbr:"AD"},{since:"0000-12-31",until:-1/0,offset:1,name:"紀元前",narrow:"BC",abbr:"BC"}],eraYearOrdinalRegex:/(元|\d+)年/,eraYearOrdinalParse:function(e,t){return"元"===t[1]?1:parseInt(t[1]||e,10)},months:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),monthsShort:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),weekdays:"日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日".split("_"),weekdaysShort:"日_月_火_水_木_金_土".split("_"),weekdaysMin:"日_月_火_水_木_金_土".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY年M月D日",LLL:"YYYY年M月D日 HH:mm",LLLL:"YYYY年M月D日 dddd HH:mm",l:"YYYY/MM/DD",ll:"YYYY年M月D日",lll:"YYYY年M月D日 HH:mm",llll:"YYYY年M月D日(ddd) HH:mm"},meridiemParse:/午前|午後/i,isPM:function(e){return"午後"===e},meridiem:function(e,t,n){return e<12?"午前":"午後"},calendar:{sameDay:"[今日] LT",nextDay:"[明日] LT",nextWeek:function(e){return e.week()!==this.week()?"[来週]dddd LT":"dddd LT"},lastDay:"[昨日] LT",lastWeek:function(e){return this.week()!==e.week()?"[先週]dddd LT":"dddd LT"},sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}日/,ordinal:function(e,t){switch(t){case"y":return 1===e?"元年":e+"年";case"d":case"D":case"DDD":return e+"日";default:return e}},relativeTime:{future:"%s後",past:"%s前",s:"数秒",ss:"%d秒",m:"1分",mm:"%d分",h:"1時間",hh:"%d時間",d:"1日",dd:"%d日",M:"1ヶ月",MM:"%dヶ月",y:"1年",yy:"%d年"}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/ko.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/ko.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=159)}({0:function(t,n){t.exports=e},1:function(e,n){e.exports=t},159:function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),n(160);var r=n(1);r.datepickerLocale("ko","ko",{closeText:"닫기",prevText:"이전달",nextText:"다음달",currentText:"오늘",monthNames:["1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월"],monthNamesShort:["1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월"],dayNames:["일요일","월요일","화요일","수요일","목요일","금요일","토요일"],dayNamesShort:["일","월","화","수","목","금","토"],dayNamesMin:["일","월","화","수","목","금","토"],weekHeader:"주",dateFormat:"yy. m. d.",firstDay:0,isRTL:!1,showMonthAfterYear:!0,yearSuffix:"년"}),r.locale("ko",{buttonText:{month:"월",week:"주",day:"일",list:"일정목록"},allDayText:"종일",eventLimitText:"개",noEventsMessage:"일정이 없습니다"})},160:function(e,t,n){!function(e,t){t(n(0))}(0,function(e){return e.defineLocale("ko",{months:"1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"),monthsShort:"1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"),weekdays:"일요일_월요일_화요일_수요일_목요일_금요일_토요일".split("_"),weekdaysShort:"일_월_화_수_목_금_토".split("_"),weekdaysMin:"일_월_화_수_목_금_토".split("_"),longDateFormat:{LT:"A h:mm",LTS:"A h:mm:ss",L:"YYYY.MM.DD.",LL:"YYYY년 MMMM D일",LLL:"YYYY년 MMMM D일 A h:mm",LLLL:"YYYY년 MMMM D일 dddd A h:mm",l:"YYYY.MM.DD.",ll:"YYYY년 MMMM D일",lll:"YYYY년 MMMM D일 A h:mm",llll:"YYYY년 MMMM D일 dddd A h:mm"},calendar:{sameDay:"오늘 LT",nextDay:"내일 LT",nextWeek:"dddd LT",lastDay:"어제 LT",lastWeek:"지난주 dddd LT",sameElse:"L"},relativeTime:{future:"%s 후",past:"%s 전",s:"몇 초",ss:"%d초",m:"1분",mm:"%d분",h:"한 시간",hh:"%d시간",d:"하루",dd:"%d일",M:"한 달",MM:"%d달",y:"일 년",yy:"%d년"},dayOfMonthOrdinalParse:/\d{1,2}(일|월|주)/,ordinal:function(e,t){switch(t){case"d":case"D":case"DDD":return e+"일";case"M":return e+"월";case"w":case"W":return e+"주";default:return e}},meridiemParse:/오전|오후/,isPM:function(e){return"오후"===e},meridiem:function(e,t,n){return e<12?"오전":"오후"}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/nl.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/nl.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,n){ true?module.exports=n(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,n){return function(e){function n(t){if(a[t])return a[t].exports;var r=a[t]={i:t,l:!1,exports:{}};return e[t].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var a={};return n.m=e,n.c=a,n.d=function(e,a,t){n.o(e,a)||Object.defineProperty(e,a,{configurable:!1,enumerable:!0,get:t})},n.n=function(e){var a=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(a,"a",a),a},n.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},n.p="",n(n.s=177)}({0:function(n,a){n.exports=e},1:function(e,a){e.exports=n},177:function(e,n,a){Object.defineProperty(n,"__esModule",{value:!0}),a(178);var t=a(1);t.datepickerLocale("nl","nl",{closeText:"Sluiten",prevText:"←",nextText:"→",currentText:"Vandaag",monthNames:["januari","februari","maart","april","mei","juni","juli","augustus","september","oktober","november","december"],monthNamesShort:["jan","feb","mrt","apr","mei","jun","jul","aug","sep","okt","nov","dec"],dayNames:["zondag","maandag","dinsdag","woensdag","donderdag","vrijdag","zaterdag"],dayNamesShort:["zon","maa","din","woe","don","vri","zat"],dayNamesMin:["zo","ma","di","wo","do","vr","za"],weekHeader:"Wk",dateFormat:"dd-mm-yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),t.locale("nl",{buttonText:{year:"Jaar",month:"Maand",week:"Week",day:"Dag",list:"Agenda"},allDayText:"Hele dag",eventLimitText:"extra",noEventsMessage:"Geen evenementen om te laten zien"})},178:function(e,n,a){!function(e,n){n(a(0))}(0,function(e){var n="jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"),a="jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),t=[/^jan/i,/^feb/i,/^maart|mrt.?$/i,/^apr/i,/^mei$/i,/^jun[i.]?$/i,/^jul[i.]?$/i,/^aug/i,/^sep/i,/^okt/i,/^nov/i,/^dec/i],r=/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;return e.defineLocale("nl",{months:"januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),monthsShort:function(e,t){return e?/-MMM-/.test(t)?a[e.month()]:n[e.month()]:n},monthsRegex:r,monthsShortRegex:r,monthsStrictRegex:/^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,monthsShortStrictRegex:/^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,monthsParse:t,longMonthsParse:t,shortMonthsParse:t,weekdays:"zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),weekdaysShort:"zo._ma._di._wo._do._vr._za.".split("_"),weekdaysMin:"zo_ma_di_wo_do_vr_za".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD-MM-YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd D MMMM YYYY HH:mm"},calendar:{sameDay:"[vandaag om] LT",nextDay:"[morgen om] LT",nextWeek:"dddd [om] LT",lastDay:"[gisteren om] LT",lastWeek:"[afgelopen] dddd [om] LT",sameElse:"L"},relativeTime:{future:"over %s",past:"%s geleden",s:"een paar seconden",ss:"%d seconden",m:"één minuut",mm:"%d minuten",h:"één uur",hh:"%d uur",d:"één dag",dd:"%d dagen",M:"één maand",MM:"%d maanden",y:"één jaar",yy:"%d jaar"},dayOfMonthOrdinalParse:/\d{1,2}(ste|de)/,ordinal:function(e){return e+(1===e||8===e||e>=20?"ste":"de")},week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/pl.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/pl.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(n){if(r[n])return r[n].exports;var i=r[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var r={};return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:n})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=181)}({0:function(t,r){t.exports=e},1:function(e,r){e.exports=t},181:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),r(182);var n=r(1);n.datepickerLocale("pl","pl",{closeText:"Zamknij",prevText:"&#x3C;Poprzedni",nextText:"Następny&#x3E;",currentText:"Dziś",monthNames:["Styczeń","Luty","Marzec","Kwiecień","Maj","Czerwiec","Lipiec","Sierpień","Wrzesień","Październik","Listopad","Grudzień"],monthNamesShort:["Sty","Lu","Mar","Kw","Maj","Cze","Lip","Sie","Wrz","Pa","Lis","Gru"],dayNames:["Niedziela","Poniedziałek","Wtorek","Środa","Czwartek","Piątek","Sobota"],dayNamesShort:["Nie","Pn","Wt","Śr","Czw","Pt","So"],dayNamesMin:["N","Pn","Wt","Śr","Cz","Pt","So"],weekHeader:"Tydz",dateFormat:"dd.mm.yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),n.locale("pl",{buttonText:{month:"Miesiąc",week:"Tydzień",day:"Dzień",list:"Plan dnia"},allDayText:"Cały dzień",eventLimitText:"więcej",noEventsMessage:"Brak wydarzeń do wyświetlenia"})},182:function(e,t,r){!function(e,t){t(r(0))}(0,function(e){function t(e){return e%10<5&&e%10>1&&~~(e/10)%10!=1}function r(e,r,n){var i=e+" ";switch(n){case"ss":return i+(t(e)?"sekundy":"sekund");case"m":return r?"minuta":"minutę";case"mm":return i+(t(e)?"minuty":"minut");case"h":return r?"godzina":"godzinę";case"hh":return i+(t(e)?"godziny":"godzin");case"MM":return i+(t(e)?"miesiące":"miesięcy");case"yy":return i+(t(e)?"lata":"lat")}}var n="styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień".split("_"),i="stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia".split("_");return e.defineLocale("pl",{months:function(e,t){return e?""===t?"("+i[e.month()]+"|"+n[e.month()]+")":/D MMMM/.test(t)?i[e.month()]:n[e.month()]:n},monthsShort:"sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru".split("_"),weekdays:"niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota".split("_"),weekdaysShort:"ndz_pon_wt_śr_czw_pt_sob".split("_"),weekdaysMin:"Nd_Pn_Wt_Śr_Cz_Pt_So".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[Dziś o] LT",nextDay:"[Jutro o] LT",nextWeek:function(){switch(this.day()){case 0:return"[W niedzielę o] LT";case 2:return"[We wtorek o] LT";case 3:return"[W środę o] LT";case 6:return"[W sobotę o] LT";default:return"[W] dddd [o] LT"}},lastDay:"[Wczoraj o] LT",lastWeek:function(){switch(this.day()){case 0:return"[W zeszłą niedzielę o] LT";case 3:return"[W zeszłą środę o] LT";case 6:return"[W zeszłą sobotę o] LT";default:return"[W zeszły] dddd [o] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"%s temu",s:"kilka sekund",ss:r,m:r,mm:r,h:r,hh:r,d:"1 dzień",dd:"%d dni",M:"miesiąc",MM:r,y:"rok",yy:r},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/pt-br.js":
/*!********************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/pt-br.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(r){if(o[r])return o[r].exports;var a=o[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}var o={};return t.m=e,t.c=o,t.d=function(e,o,r){t.o(e,o)||Object.defineProperty(e,o,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var o=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(o,"a",o),o},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=183)}({0:function(t,o){t.exports=e},1:function(e,o){e.exports=t},183:function(e,t,o){Object.defineProperty(t,"__esModule",{value:!0}),o(184);var r=o(1);r.datepickerLocale("pt-br","pt-BR",{closeText:"Fechar",prevText:"&#x3C;Anterior",nextText:"Próximo&#x3E;",currentText:"Hoje",monthNames:["Janeiro","Fevereiro","Março","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"],monthNamesShort:["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"],dayNames:["Domingo","Segunda-feira","Terça-feira","Quarta-feira","Quinta-feira","Sexta-feira","Sábado"],dayNamesShort:["Dom","Seg","Ter","Qua","Qui","Sex","Sáb"],dayNamesMin:["Dom","Seg","Ter","Qua","Qui","Sex","Sáb"],weekHeader:"Sm",dateFormat:"dd/mm/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),r.locale("pt-br",{buttonText:{month:"Mês",week:"Semana",day:"Dia",list:"Compromissos"},allDayText:"dia inteiro",eventLimitText:function(e){return"mais +"+e},noEventsMessage:"Não há eventos para mostrar"})},184:function(e,t,o){!function(e,t){t(o(0))}(0,function(e){return e.defineLocale("pt-br",{months:"janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),monthsShort:"jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),weekdays:"domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado".split("_"),weekdaysShort:"dom_seg_ter_qua_qui_sex_sáb".split("_"),weekdaysMin:"do_2ª_3ª_4ª_5ª_6ª_sá".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY [às] HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY [às] HH:mm"},calendar:{sameDay:"[Hoje às] LT",nextDay:"[Amanhã às] LT",nextWeek:"dddd [às] LT",lastDay:"[Ontem às] LT",lastWeek:function(){return 0===this.day()||6===this.day()?"[Último] dddd [às] LT":"[Última] dddd [às] LT"},sameElse:"L"},relativeTime:{future:"em %s",past:"há %s",s:"poucos segundos",ss:"%d segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",M:"um mês",MM:"%d meses",y:"um ano",yy:"%d anos"},dayOfMonthOrdinalParse:/\d{1,2}º/,ordinal:"%dº"})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/pt.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/pt.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(a){if(o[a])return o[a].exports;var r=o[a]={i:a,l:!1,exports:{}};return e[a].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var o={};return t.m=e,t.c=o,t.d=function(e,o,a){t.o(e,o)||Object.defineProperty(e,o,{configurable:!1,enumerable:!0,get:a})},t.n=function(e){var o=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(o,"a",o),o},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=185)}({0:function(t,o){t.exports=e},1:function(e,o){e.exports=t},185:function(e,t,o){Object.defineProperty(t,"__esModule",{value:!0}),o(186);var a=o(1);a.datepickerLocale("pt","pt",{closeText:"Fechar",prevText:"Anterior",nextText:"Seguinte",currentText:"Hoje",monthNames:["Janeiro","Fevereiro","Março","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"],monthNamesShort:["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"],dayNames:["Domingo","Segunda-feira","Terça-feira","Quarta-feira","Quinta-feira","Sexta-feira","Sábado"],dayNamesShort:["Dom","Seg","Ter","Qua","Qui","Sex","Sáb"],dayNamesMin:["Dom","Seg","Ter","Qua","Qui","Sex","Sáb"],weekHeader:"Sem",dateFormat:"dd/mm/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),a.locale("pt",{buttonText:{month:"Mês",week:"Semana",day:"Dia",list:"Agenda"},allDayText:"Todo o dia",eventLimitText:"mais",noEventsMessage:"Não há eventos para mostrar"})},186:function(e,t,o){!function(e,t){t(o(0))}(0,function(e){return e.defineLocale("pt",{months:"janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),monthsShort:"jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),weekdays:"Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"),weekdaysShort:"Dom_Seg_Ter_Qua_Qui_Sex_Sáb".split("_"),weekdaysMin:"Do_2ª_3ª_4ª_5ª_6ª_Sá".split("_"),weekdaysParseExact:!0,longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D [de] MMMM [de] YYYY",LLL:"D [de] MMMM [de] YYYY HH:mm",LLLL:"dddd, D [de] MMMM [de] YYYY HH:mm"},calendar:{sameDay:"[Hoje às] LT",nextDay:"[Amanhã às] LT",nextWeek:"dddd [às] LT",lastDay:"[Ontem às] LT",lastWeek:function(){return 0===this.day()||6===this.day()?"[Último] dddd [às] LT":"[Última] dddd [às] LT"},sameElse:"L"},relativeTime:{future:"em %s",past:"há %s",s:"segundos",ss:"%d segundos",m:"um minuto",mm:"%d minutos",h:"uma hora",hh:"%d horas",d:"um dia",dd:"%d dias",M:"um mês",MM:"%d meses",y:"um ano",yy:"%d anos"},dayOfMonthOrdinalParse:/\d{1,2}º/,ordinal:"%dº",week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/ro.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/ro.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(i){if(n[i])return n[i].exports;var r=n[i]={i:i,l:!1,exports:{}};return e[i].call(r.exports,r,r.exports,t),r.l=!0,r.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,i){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:i})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=187)}({0:function(t,n){t.exports=e},1:function(e,n){e.exports=t},187:function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),n(188);var i=n(1);i.datepickerLocale("ro","ro",{closeText:"Închide",prevText:"&#xAB; Luna precedentă",nextText:"Luna următoare &#xBB;",currentText:"Azi",monthNames:["Ianuarie","Februarie","Martie","Aprilie","Mai","Iunie","Iulie","August","Septembrie","Octombrie","Noiembrie","Decembrie"],monthNamesShort:["Ian","Feb","Mar","Apr","Mai","Iun","Iul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Duminică","Luni","Marţi","Miercuri","Joi","Vineri","Sâmbătă"],dayNamesShort:["Dum","Lun","Mar","Mie","Joi","Vin","Sâm"],dayNamesMin:["Du","Lu","Ma","Mi","Jo","Vi","Sâ"],weekHeader:"Săpt",dateFormat:"dd.mm.yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),i.locale("ro",{buttonText:{prev:"precedentă",next:"următoare",month:"Lună",week:"Săptămână",day:"Zi",list:"Agendă"},allDayText:"Toată ziua",eventLimitText:function(e){return"+alte "+e},noEventsMessage:"Nu există evenimente de afișat"})},188:function(e,t,n){!function(e,t){t(n(0))}(0,function(e){function t(e,t,n){var i={ss:"secunde",mm:"minute",hh:"ore",dd:"zile",MM:"luni",yy:"ani"},r=" ";return(e%100>=20||e>=100&&e%100==0)&&(r=" de "),e+r+i[n]}return e.defineLocale("ro",{months:"ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"),monthsShort:"ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"),monthsParseExact:!0,weekdays:"duminică_luni_marți_miercuri_joi_vineri_sâmbătă".split("_"),weekdaysShort:"Dum_Lun_Mar_Mie_Joi_Vin_Sâm".split("_"),weekdaysMin:"Du_Lu_Ma_Mi_Jo_Vi_Sâ".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY H:mm",LLLL:"dddd, D MMMM YYYY H:mm"},calendar:{sameDay:"[azi la] LT",nextDay:"[mâine la] LT",nextWeek:"dddd [la] LT",lastDay:"[ieri la] LT",lastWeek:"[fosta] dddd [la] LT",sameElse:"L"},relativeTime:{future:"peste %s",past:"%s în urmă",s:"câteva secunde",ss:t,m:"un minut",mm:t,h:"o oră",hh:t,d:"o zi",dd:t,M:"o lună",MM:t,y:"un an",yy:t},week:{dow:1,doy:7}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/ru.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/ru.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(n){if(r[n])return r[n].exports;var s=r[n]={i:n,l:!1,exports:{}};return e[n].call(s.exports,s,s.exports,t),s.l=!0,s.exports}var r={};return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:n})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=189)}({0:function(t,r){t.exports=e},1:function(e,r){e.exports=t},189:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),r(190);var n=r(1);n.datepickerLocale("ru","ru",{closeText:"Закрыть",prevText:"&#x3C;Пред",nextText:"След&#x3E;",currentText:"Сегодня",monthNames:["Январь","Февраль","Март","Апрель","Май","Июнь","Июль","Август","Сентябрь","Октябрь","Ноябрь","Декабрь"],monthNamesShort:["Янв","Фев","Мар","Апр","Май","Июн","Июл","Авг","Сен","Окт","Ноя","Дек"],dayNames:["воскресенье","понедельник","вторник","среда","четверг","пятница","суббота"],dayNamesShort:["вск","пнд","втр","срд","чтв","птн","сбт"],dayNamesMin:["Вс","Пн","Вт","Ср","Чт","Пт","Сб"],weekHeader:"Нед",dateFormat:"dd.mm.yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),n.locale("ru",{buttonText:{month:"Месяц",week:"Неделя",day:"День",list:"Повестка дня"},allDayText:"Весь день",eventLimitText:function(e){return"+ ещё "+e},noEventsMessage:"Нет событий для отображения"})},190:function(e,t,r){!function(e,t){t(r(0))}(0,function(e){function t(e,t){var r=e.split("_");return t%10==1&&t%100!=11?r[0]:t%10>=2&&t%10<=4&&(t%100<10||t%100>=20)?r[1]:r[2]}function r(e,r,n){var s={ss:r?"секунда_секунды_секунд":"секунду_секунды_секунд",mm:r?"минута_минуты_минут":"минуту_минуты_минут",hh:"час_часа_часов",dd:"день_дня_дней",MM:"месяц_месяца_месяцев",yy:"год_года_лет"};return"m"===n?r?"минута":"минуту":e+" "+t(s[n],+e)}var n=[/^янв/i,/^фев/i,/^мар/i,/^апр/i,/^ма[йя]/i,/^июн/i,/^июл/i,/^авг/i,/^сен/i,/^окт/i,/^ноя/i,/^дек/i];return e.defineLocale("ru",{months:{format:"января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря".split("_"),standalone:"январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_")},monthsShort:{format:"янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.".split("_"),standalone:"янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.".split("_")},weekdays:{standalone:"воскресенье_понедельник_вторник_среда_четверг_пятница_суббота".split("_"),format:"воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу".split("_"),isFormat:/\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?\] ?dddd/},weekdaysShort:"вс_пн_вт_ср_чт_пт_сб".split("_"),weekdaysMin:"вс_пн_вт_ср_чт_пт_сб".split("_"),monthsParse:n,longMonthsParse:n,shortMonthsParse:n,monthsRegex:/^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,monthsShortRegex:/^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,monthsStrictRegex:/^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,monthsShortStrictRegex:/^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY г.",LLL:"D MMMM YYYY г., H:mm",LLLL:"dddd, D MMMM YYYY г., H:mm"},calendar:{sameDay:"[Сегодня, в] LT",nextDay:"[Завтра, в] LT",lastDay:"[Вчера, в] LT",nextWeek:function(e){if(e.week()===this.week())return 2===this.day()?"[Во] dddd, [в] LT":"[В] dddd, [в] LT";switch(this.day()){case 0:return"[В следующее] dddd, [в] LT";case 1:case 2:case 4:return"[В следующий] dddd, [в] LT";case 3:case 5:case 6:return"[В следующую] dddd, [в] LT"}},lastWeek:function(e){if(e.week()===this.week())return 2===this.day()?"[Во] dddd, [в] LT":"[В] dddd, [в] LT";switch(this.day()){case 0:return"[В прошлое] dddd, [в] LT";case 1:case 2:case 4:return"[В прошлый] dddd, [в] LT";case 3:case 5:case 6:return"[В прошлую] dddd, [в] LT"}},sameElse:"L"},relativeTime:{future:"через %s",past:"%s назад",s:"несколько секунд",ss:r,m:r,mm:r,h:"час",hh:r,d:"день",dd:r,M:"месяц",MM:r,y:"год",yy:r},meridiemParse:/ночи|утра|дня|вечера/i,isPM:function(e){return/^(дня|вечера)$/.test(e)},meridiem:function(e,t,r){return e<4?"ночи":e<12?"утра":e<17?"дня":"вечера"},dayOfMonthOrdinalParse:/\d{1,2}-(й|го|я)/,ordinal:function(e,t){switch(t){case"M":case"d":case"DDD":return e+"-й";case"D":return e+"-го";case"w":case"W":return e+"-я";default:return e}},week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/sk.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/sk.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(n){if(r[n])return r[n].exports;var o=r[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var r={};return t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:n})},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=191)}({0:function(t,r){t.exports=e},1:function(e,r){e.exports=t},191:function(e,t,r){Object.defineProperty(t,"__esModule",{value:!0}),r(192);var n=r(1);n.datepickerLocale("sk","sk",{closeText:"Zavrieť",prevText:"&#x3C;Predchádzajúci",nextText:"Nasledujúci&#x3E;",currentText:"Dnes",monthNames:["január","február","marec","apríl","máj","jún","júl","august","september","október","november","december"],monthNamesShort:["Jan","Feb","Mar","Apr","Máj","Jún","Júl","Aug","Sep","Okt","Nov","Dec"],dayNames:["nedeľa","pondelok","utorok","streda","štvrtok","piatok","sobota"],dayNamesShort:["Ned","Pon","Uto","Str","Štv","Pia","Sob"],dayNamesMin:["Ne","Po","Ut","St","Št","Pia","So"],weekHeader:"Ty",dateFormat:"dd.mm.yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),n.locale("sk",{buttonText:{month:"Mesiac",week:"Týždeň",day:"Deň",list:"Rozvrh"},allDayText:"Celý deň",eventLimitText:function(e){return"+ďalšie: "+e},noEventsMessage:"Žiadne akcie na zobrazenie"})},192:function(e,t,r){!function(e,t){t(r(0))}(0,function(e){function t(e){return e>1&&e<5}function r(e,r,n,o){var a=e+" ";switch(n){case"s":return r||o?"pár sekúnd":"pár sekundami";case"ss":return r||o?a+(t(e)?"sekundy":"sekúnd"):a+"sekundami";case"m":return r?"minúta":o?"minútu":"minútou";case"mm":return r||o?a+(t(e)?"minúty":"minút"):a+"minútami";case"h":return r?"hodina":o?"hodinu":"hodinou";case"hh":return r||o?a+(t(e)?"hodiny":"hodín"):a+"hodinami";case"d":return r||o?"deň":"dňom";case"dd":return r||o?a+(t(e)?"dni":"dní"):a+"dňami";case"M":return r||o?"mesiac":"mesiacom";case"MM":return r||o?a+(t(e)?"mesiace":"mesiacov"):a+"mesiacmi";case"y":return r||o?"rok":"rokom";case"yy":return r||o?a+(t(e)?"roky":"rokov"):a+"rokmi"}}var n="január_február_marec_apríl_máj_jún_júl_august_september_október_november_december".split("_"),o="jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec".split("_");return e.defineLocale("sk",{months:n,monthsShort:o,weekdays:"nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota".split("_"),weekdaysShort:"ne_po_ut_st_št_pi_so".split("_"),weekdaysMin:"ne_po_ut_st_št_pi_so".split("_"),longDateFormat:{LT:"H:mm",LTS:"H:mm:ss",L:"DD.MM.YYYY",LL:"D. MMMM YYYY",LLL:"D. MMMM YYYY H:mm",LLLL:"dddd D. MMMM YYYY H:mm"},calendar:{sameDay:"[dnes o] LT",nextDay:"[zajtra o] LT",nextWeek:function(){switch(this.day()){case 0:return"[v nedeľu o] LT";case 1:case 2:return"[v] dddd [o] LT";case 3:return"[v stredu o] LT";case 4:return"[vo štvrtok o] LT";case 5:return"[v piatok o] LT";case 6:return"[v sobotu o] LT"}},lastDay:"[včera o] LT",lastWeek:function(){switch(this.day()){case 0:return"[minulú nedeľu o] LT";case 1:case 2:return"[minulý] dddd [o] LT";case 3:return"[minulú stredu o] LT";case 4:case 5:return"[minulý] dddd [o] LT";case 6:return"[minulú sobotu o] LT"}},sameElse:"L"},relativeTime:{future:"za %s",past:"pred %s",s:r,ss:r,m:r,mm:r,h:r,hh:r,d:r,dd:r,M:r,MM:r,y:r,yy:r},dayOfMonthOrdinalParse:/\d{1,2}\./,ordinal:"%d.",week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/sv.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/sv.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,r){ true?module.exports=r(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,r){return function(e){function r(n){if(t[n])return t[n].exports;var a=t[n]={i:n,l:!1,exports:{}};return e[n].call(a.exports,a,a.exports,r),a.l=!0,a.exports}var t={};return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:n})},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},r.p="",r(r.s=201)}({0:function(r,t){r.exports=e},1:function(e,t){e.exports=r},201:function(e,r,t){Object.defineProperty(r,"__esModule",{value:!0}),t(202);var n=t(1);n.datepickerLocale("sv","sv",{closeText:"Stäng",prevText:"&#xAB;Förra",nextText:"Nästa&#xBB;",currentText:"Idag",monthNames:["Januari","Februari","Mars","April","Maj","Juni","Juli","Augusti","September","Oktober","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","Maj","Jun","Jul","Aug","Sep","Okt","Nov","Dec"],dayNamesShort:["Sön","Mån","Tis","Ons","Tor","Fre","Lör"],dayNames:["Söndag","Måndag","Tisdag","Onsdag","Torsdag","Fredag","Lördag"],dayNamesMin:["Sö","Må","Ti","On","To","Fr","Lö"],weekHeader:"v. ",dateFormat:"yy-mm-dd",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),n.locale("sv",{buttonText:{month:"Månad",week:"Vecka",day:"Dag",list:"Program"},allDayText:"Heldag",eventLimitText:"till",noEventsMessage:"Inga händelser att visa"})},202:function(e,r,t){!function(e,r){r(t(0))}(0,function(e){return e.defineLocale("sv",{months:"januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),monthsShort:"jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),weekdays:"söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag".split("_"),weekdaysShort:"sön_mån_tis_ons_tor_fre_lör".split("_"),weekdaysMin:"sö_må_ti_on_to_fr_lö".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY-MM-DD",LL:"D MMMM YYYY",LLL:"D MMMM YYYY [kl.] HH:mm",LLLL:"dddd D MMMM YYYY [kl.] HH:mm",lll:"D MMM YYYY HH:mm",llll:"ddd D MMM YYYY HH:mm"},calendar:{sameDay:"[Idag] LT",nextDay:"[Imorgon] LT",lastDay:"[Igår] LT",nextWeek:"[På] dddd LT",lastWeek:"[I] dddd[s] LT",sameElse:"L"},relativeTime:{future:"om %s",past:"för %s sedan",s:"några sekunder",ss:"%d sekunder",m:"en minut",mm:"%d minuter",h:"en timme",hh:"%d timmar",d:"en dag",dd:"%d dagar",M:"en månad",MM:"%d månader",y:"ett år",yy:"%d år"},dayOfMonthOrdinalParse:/\d{1,2}(\:e|\:a)/,ordinal:function(e){var r=e%10;return e+(1==~~(e%100/10)?":e":1===r?":a":2===r?":a":":e")},week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/tr.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/tr.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,a){ true?module.exports=a(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,a){return function(e){function a(n){if(t[n])return t[n].exports;var r=t[n]={i:n,l:!1,exports:{}};return e[n].call(r.exports,r,r.exports,a),r.l=!0,r.exports}var t={};return a.m=e,a.c=t,a.d=function(e,t,n){a.o(e,t)||Object.defineProperty(e,t,{configurable:!1,enumerable:!0,get:n})},a.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return a.d(t,"a",t),t},a.o=function(e,a){return Object.prototype.hasOwnProperty.call(e,a)},a.p="",a(a.s=205)}({0:function(a,t){a.exports=e},1:function(e,t){e.exports=a},205:function(e,a,t){Object.defineProperty(a,"__esModule",{value:!0}),t(206);var n=t(1);n.datepickerLocale("tr","tr",{closeText:"kapat",prevText:"&#x3C;geri",nextText:"ileri&#x3e",currentText:"bugün",monthNames:["Ocak","Şubat","Mart","Nisan","Mayıs","Haziran","Temmuz","Ağustos","Eylül","Ekim","Kasım","Aralık"],monthNamesShort:["Oca","Şub","Mar","Nis","May","Haz","Tem","Ağu","Eyl","Eki","Kas","Ara"],dayNames:["Pazar","Pazartesi","Salı","Çarşamba","Perşembe","Cuma","Cumartesi"],dayNamesShort:["Pz","Pt","Sa","Ça","Pe","Cu","Ct"],dayNamesMin:["Pz","Pt","Sa","Ça","Pe","Cu","Ct"],weekHeader:"Hf",dateFormat:"dd.mm.yy",firstDay:1,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),n.locale("tr",{buttonText:{next:"ileri",month:"Ay",week:"Hafta",day:"Gün",list:"Ajanda"},allDayText:"Tüm gün",eventLimitText:"daha fazla",noEventsMessage:"Gösterilecek etkinlik yok"})},206:function(e,a,t){!function(e,a){a(t(0))}(0,function(e){var a={1:"'inci",5:"'inci",8:"'inci",70:"'inci",80:"'inci",2:"'nci",7:"'nci",20:"'nci",50:"'nci",3:"'üncü",4:"'üncü",100:"'üncü",6:"'ncı",9:"'uncu",10:"'uncu",30:"'uncu",60:"'ıncı",90:"'ıncı"};return e.defineLocale("tr",{months:"Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık".split("_"),monthsShort:"Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara".split("_"),weekdays:"Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi".split("_"),weekdaysShort:"Paz_Pts_Sal_Çar_Per_Cum_Cts".split("_"),weekdaysMin:"Pz_Pt_Sa_Ça_Pe_Cu_Ct".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD.MM.YYYY",LL:"D MMMM YYYY",LLL:"D MMMM YYYY HH:mm",LLLL:"dddd, D MMMM YYYY HH:mm"},calendar:{sameDay:"[bugün saat] LT",nextDay:"[yarın saat] LT",nextWeek:"[gelecek] dddd [saat] LT",lastDay:"[dün] LT",lastWeek:"[geçen] dddd [saat] LT",sameElse:"L"},relativeTime:{future:"%s sonra",past:"%s önce",s:"birkaç saniye",ss:"%d saniye",m:"bir dakika",mm:"%d dakika",h:"bir saat",hh:"%d saat",d:"bir gün",dd:"%d gün",M:"bir ay",MM:"%d ay",y:"bir yıl",yy:"%d yıl"},ordinal:function(e,t){switch(t){case"d":case"D":case"Do":case"DD":return e;default:if(0===e)return e+"'ıncı";var n=e%10,r=e%100-n,i=e>=100?100:null;return e+(a[n]||a[r]||a[i])}},week:{dow:1,doy:7}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/vi.js":
/*!*****************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/vi.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(t,n){ true?module.exports=n(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(t,n){return function(t){function n(h){if(e[h])return e[h].exports;var r=e[h]={i:h,l:!1,exports:{}};return t[h].call(r.exports,r,r.exports,n),r.l=!0,r.exports}var e={};return n.m=t,n.c=e,n.d=function(t,e,h){n.o(t,e)||Object.defineProperty(t,e,{configurable:!1,enumerable:!0,get:h})},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},n.p="",n(n.s=209)}({0:function(n,e){n.exports=t},1:function(t,e){t.exports=n},209:function(t,n,e){Object.defineProperty(n,"__esModule",{value:!0}),e(210);var h=e(1);h.datepickerLocale("vi","vi",{closeText:"Đóng",prevText:"&#x3C;Trước",nextText:"Tiếp&#x3E;",currentText:"Hôm nay",monthNames:["Tháng Một","Tháng Hai","Tháng Ba","Tháng Tư","Tháng Năm","Tháng Sáu","Tháng Bảy","Tháng Tám","Tháng Chín","Tháng Mười","Tháng Mười Một","Tháng Mười Hai"],monthNamesShort:["Tháng 1","Tháng 2","Tháng 3","Tháng 4","Tháng 5","Tháng 6","Tháng 7","Tháng 8","Tháng 9","Tháng 10","Tháng 11","Tháng 12"],dayNames:["Chủ Nhật","Thứ Hai","Thứ Ba","Thứ Tư","Thứ Năm","Thứ Sáu","Thứ Bảy"],dayNamesShort:["CN","T2","T3","T4","T5","T6","T7"],dayNamesMin:["CN","T2","T3","T4","T5","T6","T7"],weekHeader:"Tu",dateFormat:"dd/mm/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""}),h.locale("vi",{buttonText:{month:"Tháng",week:"Tuần",day:"Ngày",list:"Lịch biểu"},allDayText:"Cả ngày",eventLimitText:function(t){return"+ thêm "+t},noEventsMessage:"Không có sự kiện để hiển thị"})},210:function(t,n,e){!function(t,n){n(e(0))}(0,function(t){return t.defineLocale("vi",{months:"tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12".split("_"),monthsShort:"Th01_Th02_Th03_Th04_Th05_Th06_Th07_Th08_Th09_Th10_Th11_Th12".split("_"),monthsParseExact:!0,weekdays:"chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy".split("_"),weekdaysShort:"CN_T2_T3_T4_T5_T6_T7".split("_"),weekdaysMin:"CN_T2_T3_T4_T5_T6_T7".split("_"),weekdaysParseExact:!0,meridiemParse:/sa|ch/i,isPM:function(t){return/^ch$/i.test(t)},meridiem:function(t,n,e){return t<12?e?"sa":"SA":e?"ch":"CH"},longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"DD/MM/YYYY",LL:"D MMMM [năm] YYYY",LLL:"D MMMM [năm] YYYY HH:mm",LLLL:"dddd, D MMMM [năm] YYYY HH:mm",l:"DD/M/YYYY",ll:"D MMM YYYY",lll:"D MMM YYYY HH:mm",llll:"ddd, D MMM YYYY HH:mm"},calendar:{sameDay:"[Hôm nay lúc] LT",nextDay:"[Ngày mai lúc] LT",nextWeek:"dddd [tuần tới lúc] LT",lastDay:"[Hôm qua lúc] LT",lastWeek:"dddd [tuần trước lúc] LT",sameElse:"L"},relativeTime:{future:"%s tới",past:"%s trước",s:"vài giây",ss:"%d giây",m:"một phút",mm:"%d phút",h:"một giờ",hh:"%d giờ",d:"một ngày",dd:"%d ngày",M:"một tháng",MM:"%d tháng",y:"một năm",yy:"%d năm"},dayOfMonthOrdinalParse:/\d{1,2}/,ordinal:function(t){return t},week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/fullcalendar/dist/locale/zh-cn.js":
/*!********************************************************!*\
  !*** ./node_modules/fullcalendar/dist/locale/zh-cn.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?module.exports=t(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"),__webpack_require__(/*! fullcalendar */ "./node_modules/fullcalendar/dist/fullcalendar.js")):undefined}("undefined"!=typeof self?self:this,function(e,t){return function(e){function t(r){if(n[r])return n[r].exports;var o=n[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,t),o.l=!0,o.exports}var n={};return t.m=e,t.c=n,t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=211)}({0:function(t,n){t.exports=e},1:function(e,n){e.exports=t},211:function(e,t,n){Object.defineProperty(t,"__esModule",{value:!0}),n(212);var r=n(1);r.datepickerLocale("zh-cn","zh-CN",{closeText:"关闭",prevText:"&#x3C;上月",nextText:"下月&#x3E;",currentText:"今天",monthNames:["一月","二月","三月","四月","五月","六月","七月","八月","九月","十月","十一月","十二月"],monthNamesShort:["一月","二月","三月","四月","五月","六月","七月","八月","九月","十月","十一月","十二月"],dayNames:["星期日","星期一","星期二","星期三","星期四","星期五","星期六"],dayNamesShort:["周日","周一","周二","周三","周四","周五","周六"],dayNamesMin:["日","一","二","三","四","五","六"],weekHeader:"周",dateFormat:"yy-mm-dd",firstDay:1,isRTL:!1,showMonthAfterYear:!0,yearSuffix:"年"}),r.locale("zh-cn",{buttonText:{month:"月",week:"周",day:"日",list:"日程"},allDayText:"全天",eventLimitText:function(e){return"另外 "+e+" 个"},noEventsMessage:"没有事件显示"})},212:function(e,t,n){!function(e,t){t(n(0))}(0,function(e){return e.defineLocale("zh-cn",{months:"一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),monthsShort:"1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),weekdays:"星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),weekdaysShort:"周日_周一_周二_周三_周四_周五_周六".split("_"),weekdaysMin:"日_一_二_三_四_五_六".split("_"),longDateFormat:{LT:"HH:mm",LTS:"HH:mm:ss",L:"YYYY/MM/DD",LL:"YYYY年M月D日",LLL:"YYYY年M月D日Ah点mm分",LLLL:"YYYY年M月D日ddddAh点mm分",l:"YYYY/M/D",ll:"YYYY年M月D日",lll:"YYYY年M月D日 HH:mm",llll:"YYYY年M月D日dddd HH:mm"},meridiemParse:/凌晨|早上|上午|中午|下午|晚上/,meridiemHour:function(e,t){return 12===e&&(e=0),"凌晨"===t||"早上"===t||"上午"===t?e:"下午"===t||"晚上"===t?e+12:e>=11?e:e+12},meridiem:function(e,t,n){var r=100*e+t;return r<600?"凌晨":r<900?"早上":r<1130?"上午":r<1230?"中午":r<1800?"下午":"晚上"},calendar:{sameDay:"[今天]LT",nextDay:"[明天]LT",nextWeek:"[下]ddddLT",lastDay:"[昨天]LT",lastWeek:"[上]ddddLT",sameElse:"L"},dayOfMonthOrdinalParse:/\d{1,2}(日|月|周)/,ordinal:function(e,t){switch(t){case"d":case"D":case"DDD":return e+"日";case"M":return e+"月";case"w":case"W":return e+"周";default:return e}},relativeTime:{future:"%s后",past:"%s前",s:"几秒",ss:"%d 秒",m:"1 分钟",mm:"%d 分钟",h:"1 小时",hh:"%d 小时",d:"1 天",dd:"%d 天",M:"1 个月",MM:"%d 个月",y:"1 年",yy:"%d 年"},week:{dow:1,doy:4}})})}})});

/***/ }),

/***/ "./node_modules/jquery-ui/ui/data.js":
/*!*******************************************!*\
  !*** ./node_modules/jquery-ui/ui/data.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI :data 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :data Selector
//>>group: Core
//>>description: Selects elements which have data stored under the specified key.
//>>docs: http://api.jqueryui.com/data-selector/

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
} ( function( $ ) {
return $.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo( function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		} ) :

		// Support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		}
} );
} ) );


/***/ }),

/***/ "./node_modules/jquery-ui/ui/ie.js":
/*!*****************************************!*\
  !*** ./node_modules/jquery-ui/ui/ie.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
} ( function( $ ) {

// This file is deprecated
return $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );
} ) );


/***/ }),

/***/ "./node_modules/jquery-ui/ui/plugin.js":
/*!*********************************************!*\
  !*** ./node_modules/jquery-ui/ui/plugin.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
} ( function( $ ) {

// $.ui.plugin is deprecated. Use $.widget() extensions instead.
return $.ui.plugin = {
	add: function( module, option, set ) {
		var i,
			proto = $.ui[ module ].prototype;
		for ( i in set ) {
			proto.plugins[ i ] = proto.plugins[ i ] || [];
			proto.plugins[ i ].push( [ option, set[ i ] ] );
		}
	},
	call: function( instance, name, args, allowDisconnected ) {
		var i,
			set = instance.plugins[ name ];

		if ( !set ) {
			return;
		}

		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode ||
				instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
			return;
		}

		for ( i = 0; i < set.length; i++ ) {
			if ( instance.options[ set[ i ][ 0 ] ] ) {
				set[ i ][ 1 ].apply( instance.element, args );
			}
		}
	}
};

} ) );


/***/ }),

/***/ "./node_modules/jquery-ui/ui/safe-blur.js":
/*!************************************************!*\
  !*** ./node_modules/jquery-ui/ui/safe-blur.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
} ( function( $ ) {
return $.ui.safeBlur = function( element ) {

	// Support: IE9 - 10 only
	// If the <body> is blurred, IE will switch windows, see #9420
	if ( element && element.nodeName.toLowerCase() !== "body" ) {
		$( element ).trigger( "blur" );
	}
};

} ) );


/***/ }),

/***/ "./node_modules/jquery-ui/ui/scroll-parent.js":
/*!****************************************************!*\
  !*** ./node_modules/jquery-ui/ui/scroll-parent.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Scroll Parent 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: scrollParent
//>>group: Core
//>>description: Get the closest ancestor element that is scrollable.
//>>docs: http://api.jqueryui.com/scrollParent/

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"), __webpack_require__(/*! ./version */ "./node_modules/jquery-ui/ui/version.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
} ( function( $ ) {

return $.fn.scrollParent = function( includeHidden ) {
	var position = this.css( "position" ),
		excludeStaticParent = position === "absolute",
		overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
		scrollParent = this.parents().filter( function() {
			var parent = $( this );
			if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
				return false;
			}
			return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
				parent.css( "overflow-x" ) );
		} ).eq( 0 );

	return position === "fixed" || !scrollParent.length ?
		$( this[ 0 ].ownerDocument || document ) :
		scrollParent;
};

} ) );


/***/ }),

/***/ "./node_modules/jquery-ui/ui/widgets/draggable.js":
/*!********************************************************!*\
  !*** ./node_modules/jquery-ui/ui/widgets/draggable.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Draggable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Draggable
//>>group: Interactions
//>>description: Enables dragging functionality for any element.
//>>docs: http://api.jqueryui.com/draggable/
//>>demos: http://jqueryui.com/draggable/
//>>css.structure: ../../themes/base/draggable.css

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
			__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"),
			__webpack_require__(/*! ./mouse */ "./node_modules/jquery-ui/ui/widgets/mouse.js"),
			__webpack_require__(/*! ../data */ "./node_modules/jquery-ui/ui/data.js"),
			__webpack_require__(/*! ../plugin */ "./node_modules/jquery-ui/ui/plugin.js"),
			__webpack_require__(/*! ../safe-active-element */ "./node_modules/jquery-ui/ui/safe-active-element.js"),
			__webpack_require__(/*! ../safe-blur */ "./node_modules/jquery-ui/ui/safe-blur.js"),
			__webpack_require__(/*! ../scroll-parent */ "./node_modules/jquery-ui/ui/scroll-parent.js"),
			__webpack_require__(/*! ../version */ "./node_modules/jquery-ui/ui/version.js"),
			__webpack_require__(/*! ../widget */ "./node_modules/jquery-ui/ui/widget.js")
		], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}( function( $ ) {

$.widget( "ui.draggable", $.ui.mouse, {
	version: "1.12.1",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// Callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if ( this.options.helper === "original" ) {
			this._setPositionRelative();
		}
		if ( this.options.addClasses ) {
			this._addClass( "ui-draggable" );
		}
		this._setHandleClassName();

		this._mouseInit();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "handle" ) {
			this._removeHandleClassName();
			this._setHandleClassName();
		}
	},

	_destroy: function() {
		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
			this.destroyOnClear = true;
			return;
		}
		this._removeHandleClassName();
		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var o = this.options;

		// Among others, prevent a drag on a resizable-handle
		if ( this.helper || o.disabled ||
				$( event.target ).closest( ".ui-resizable-handle" ).length > 0 ) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle( event );
		if ( !this.handle ) {
			return false;
		}

		this._blurActiveElement( event );

		this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );

		return true;

	},

	_blockFrames: function( selector ) {
		this.iframeBlocks = this.document.find( selector ).map( function() {
			var iframe = $( this );

			return $( "<div>" )
				.css( "position", "absolute" )
				.appendTo( iframe.parent() )
				.outerWidth( iframe.outerWidth() )
				.outerHeight( iframe.outerHeight() )
				.offset( iframe.offset() )[ 0 ];
		} );
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_blurActiveElement: function( event ) {
		var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),
			target = $( event.target );

		// Don't blur if the event occurred on an element that is within
		// the currently focused element
		// See #10527, #12472
		if ( target.closest( activeElement ).length ) {
			return;
		}

		// Blur any element that currently has focus, see #4261
		$.ui.safeBlur( activeElement );
	},

	_mouseStart: function( event ) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper( event );

		this._addClass( this.helper, "ui-draggable-dragging" );

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent( true );
		this.offsetParent = this.helper.offsetParent();
		this.hasFixedAncestor = this.helper.parents().filter( function() {
				return $( this ).css( "position" ) === "fixed";
			} ).length > 0;

		//The element's absolute position on the page minus margins
		this.positionAbs = this.element.offset();
		this._refreshOffsets( event );

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition( event, false );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		( o.cursorAt && this._adjustOffsetFromHelper( o.cursorAt ) );

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if ( this._trigger( "start", event ) === false ) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ( $.ui.ddmanager && !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( this, event );
		}

		// Execute the drag once - this causes the helper not to be visible before getting its
		// correct position
		this._mouseDrag( event, true );

		// If the ddmanager is used for droppables, inform the manager that dragging has started
		// (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart( this, event );
		}

		return true;
	},

	_refreshOffsets: function( event ) {
		this.offset = {
			top: this.positionAbs.top - this.margins.top,
			left: this.positionAbs.left - this.margins.left,
			scroll: false,
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset()
		};

		this.offset.click = {
			left: event.pageX - this.offset.left,
			top: event.pageY - this.offset.top
		};
	},

	_mouseDrag: function( event, noPropagation ) {

		// reset any necessary cached properties (see #5009)
		if ( this.hasFixedAncestor ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition( event, true );
		this.positionAbs = this._convertPositionTo( "absolute" );

		//Call plugins and callbacks and use the resulting position if something is returned
		if ( !noPropagation ) {
			var ui = this._uiHash();
			if ( this._trigger( "drag", event, ui ) === false ) {
				this._mouseUp( new $.Event( "mouseup", event ) );
				return false;
			}
			this.position = ui.position;
		}

		this.helper[ 0 ].style.left = this.position.left + "px";
		this.helper[ 0 ].style.top = this.position.top + "px";

		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.drag( this, event );
		}

		return false;
	},

	_mouseStop: function( event ) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ( $.ui.ddmanager && !this.options.dropBehaviour ) {
			dropped = $.ui.ddmanager.drop( this, event );
		}

		//if a drop comes from outside (a sortable)
		if ( this.dropped ) {
			dropped = this.dropped;
			this.dropped = false;
		}

		if ( ( this.options.revert === "invalid" && !dropped ) ||
				( this.options.revert === "valid" && dropped ) ||
				this.options.revert === true || ( $.isFunction( this.options.revert ) &&
				this.options.revert.call( this.element, dropped ) )
		) {
			$( this.helper ).animate(
				this.originalPosition,
				parseInt( this.options.revertDuration, 10 ),
				function() {
					if ( that._trigger( "stop", event ) !== false ) {
						that._clear();
					}
				}
			);
		} else {
			if ( this._trigger( "stop", event ) !== false ) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function( event ) {
		this._unblockFrames();

		// If the ddmanager is used for droppables, inform the manager that dragging has stopped
		// (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop( this, event );
		}

		// Only need to focus if the event occurred on the draggable itself, see #10527
		if ( this.handleElement.is( event.target ) ) {

			// The interaction is over; whether or not the click resulted in a drag,
			// focus the element
			this.element.trigger( "focus" );
		}

		return $.ui.mouse.prototype._mouseUp.call( this, event );
	},

	cancel: function() {

		if ( this.helper.is( ".ui-draggable-dragging" ) ) {
			this._mouseUp( new $.Event( "mouseup", { target: this.element[ 0 ] } ) );
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function( event ) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_setHandleClassName: function() {
		this.handleElement = this.options.handle ?
			this.element.find( this.options.handle ) : this.element;
		this._addClass( this.handleElement, "ui-draggable-handle" );
	},

	_removeHandleClassName: function() {
		this._removeClass( this.handleElement, "ui-draggable-handle" );
	},

	_createHelper: function( event ) {

		var o = this.options,
			helperIsFunction = $.isFunction( o.helper ),
			helper = helperIsFunction ?
				$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
				( o.helper === "clone" ?
					this.element.clone().removeAttr( "id" ) :
					this.element );

		if ( !helper.parents( "body" ).length ) {
			helper.appendTo( ( o.appendTo === "parent" ?
				this.element[ 0 ].parentNode :
				o.appendTo ) );
		}

		// Http://bugs.jqueryui.com/ticket/9446
		// a helper function can return the original element
		// which wouldn't have been set to relative in _create
		if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
			this._setPositionRelative();
		}

		if ( helper[ 0 ] !== this.element[ 0 ] &&
				!( /(fixed|absolute)/ ).test( helper.css( "position" ) ) ) {
			helper.css( "position", "absolute" );
		}

		return helper;

	},

	_setPositionRelative: function() {
		if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
			this.element[ 0 ].style.position = "relative";
		}
	},

	_adjustOffsetFromHelper: function( obj ) {
		if ( typeof obj === "string" ) {
			obj = obj.split( " " );
		}
		if ( $.isArray( obj ) ) {
			obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
		}
		if ( "left" in obj ) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ( "right" in obj ) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ( "top" in obj ) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ( "bottom" in obj ) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_isRootNode: function( element ) {
		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset(),
			document = this.document[ 0 ];

		// This is a special case where we need to modify a offset calculated on start, since the
		// following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the
		// next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
		// the document, which means that the scroll is included in the initial calculation of the
		// offset of the parent, and never recalculated upon drag
		if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== document &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),
			left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )
		};

	},

	_getRelativeOffset: function() {
		if ( this.cssPosition !== "relative" ) {
			return { top: 0, left: 0 };
		}

		var p = this.element.position(),
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +
				( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
			left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +
				( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
		};

	},

	_cacheMargins: function() {
		this.margins = {
			left: ( parseInt( this.element.css( "marginLeft" ), 10 ) || 0 ),
			top: ( parseInt( this.element.css( "marginTop" ), 10 ) || 0 ),
			right: ( parseInt( this.element.css( "marginRight" ), 10 ) || 0 ),
			bottom: ( parseInt( this.element.css( "marginBottom" ), 10 ) || 0 )
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var isUserScrollable, c, ce,
			o = this.options,
			document = this.document[ 0 ];

		this.relativeContainer = null;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() -
					this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() +
					( $( window ).height() || document.body.parentNode.scrollHeight ) -
					this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document" ) {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) -
					this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if ( !ce ) {
			return;
		}

		isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) +
				( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) +
				( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
			( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
				( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
				this.helperProportions.width -
				this.margins.left -
				this.margins.right,
			( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
				( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
				this.helperProportions.height -
				this.margins.top -
				this.margins.bottom
		];
		this.relativeContainer = c;
	},

	_convertPositionTo: function( d, pos ) {

		if ( !pos ) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: (

				// The absolute mouse position
				pos.top	+

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top * mod -
				( ( this.cssPosition === "fixed" ?
					-this.offset.scroll.top :
					( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod )
			),
			left: (

				// The absolute mouse position
				pos.left +

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left * mod	-
				( ( this.cssPosition === "fixed" ?
					-this.offset.scroll.left :
					( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod )
			)
		};

	},

	_generatePosition: function( event, constrainPosition ) {

		var containment, co, top, left,
			o = this.options,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
			pageX = event.pageX,
			pageY = event.pageY;

		// Cache the scroll
		if ( !scrollIsRootNode || !this.offset.scroll ) {
			this.offset.scroll = {
				top: this.scrollParent.scrollTop(),
				left: this.scrollParent.scrollLeft()
			};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( constrainPosition ) {
			if ( this.containment ) {
				if ( this.relativeContainer ) {
					co = this.relativeContainer.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				} else {
					containment = this.containment;
				}

				if ( event.pageX - this.offset.click.left < containment[ 0 ] ) {
					pageX = containment[ 0 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top < containment[ 1 ] ) {
					pageY = containment[ 1 ] + this.offset.click.top;
				}
				if ( event.pageX - this.offset.click.left > containment[ 2 ] ) {
					pageX = containment[ 2 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top > containment[ 3 ] ) {
					pageY = containment[ 3 ] + this.offset.click.top;
				}
			}

			if ( o.grid ) {

				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid
				// argument errors in IE (see ticket #6950)
				top = o.grid[ 1 ] ? this.originalPageY + Math.round( ( pageY -
					this.originalPageY ) / o.grid[ 1 ] ) * o.grid[ 1 ] : this.originalPageY;
				pageY = containment ? ( ( top - this.offset.click.top >= containment[ 1 ] ||
					top - this.offset.click.top > containment[ 3 ] ) ?
						top :
						( ( top - this.offset.click.top >= containment[ 1 ] ) ?
							top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) : top;

				left = o.grid[ 0 ] ? this.originalPageX +
					Math.round( ( pageX - this.originalPageX ) / o.grid[ 0 ] ) * o.grid[ 0 ] :
					this.originalPageX;
				pageX = containment ? ( ( left - this.offset.click.left >= containment[ 0 ] ||
					left - this.offset.click.left > containment[ 2 ] ) ?
						left :
						( ( left - this.offset.click.left >= containment[ 0 ] ) ?
							left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) : left;
			}

			if ( o.axis === "y" ) {
				pageX = this.originalPageX;
			}

			if ( o.axis === "x" ) {
				pageY = this.originalPageY;
			}
		}

		return {
			top: (

				// The absolute mouse position
				pageY -

				// Click offset (relative to the element)
				this.offset.click.top -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top +
				( this.cssPosition === "fixed" ?
					-this.offset.scroll.top :
					( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
			),
			left: (

				// The absolute mouse position
				pageX -

				// Click offset (relative to the element)
				this.offset.click.left -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left +
				( this.cssPosition === "fixed" ?
					-this.offset.scroll.left :
					( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
			)
		};

	},

	_clear: function() {
		this._removeClass( this.helper, "ui-draggable-dragging" );
		if ( this.helper[ 0 ] !== this.element[ 0 ] && !this.cancelHelperRemoval ) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
		if ( this.destroyOnClear ) {
			this.destroy();
		}
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function( type, event, ui ) {
		ui = ui || this._uiHash();
		$.ui.plugin.call( this, type, [ event, ui, this ], true );

		// Absolute position and offset (see #6884 ) have to be recalculated after plugins
		if ( /^(drag|start|stop)/.test( type ) ) {
			this.positionAbs = this._convertPositionTo( "absolute" );
			ui.offset = this.positionAbs;
		}
		return $.Widget.prototype._trigger.call( this, type, event, ui );
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

} );

$.ui.plugin.add( "draggable", "connectToSortable", {
	start: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		} );

		draggable.sortables = [];
		$( draggable.options.connectToSortable ).each( function() {
			var sortable = $( this ).sortable( "instance" );

			if ( sortable && !sortable.options.disabled ) {
				draggable.sortables.push( sortable );

				// RefreshPositions is called at drag start to refresh the containerCache
				// which is used in drag. This ensures it's initialized and synchronized
				// with any changes that might have happened on the page since initialization.
				sortable.refreshPositions();
				sortable._trigger( "activate", event, uiSortable );
			}
		} );
	},
	stop: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		} );

		draggable.cancelHelperRemoval = false;

		$.each( draggable.sortables, function() {
			var sortable = this;

			if ( sortable.isOver ) {
				sortable.isOver = 0;

				// Allow this sortable to handle removing the helper
				draggable.cancelHelperRemoval = true;
				sortable.cancelHelperRemoval = false;

				// Use _storedCSS To restore properties in the sortable,
				// as this also handles revert (#9675) since the draggable
				// may have modified them in unexpected ways (#8809)
				sortable._storedCSS = {
					position: sortable.placeholder.css( "position" ),
					top: sortable.placeholder.css( "top" ),
					left: sortable.placeholder.css( "left" )
				};

				sortable._mouseStop( event );

				// Once drag has ended, the sortable should return to using
				// its original helper, not the shared helper from draggable
				sortable.options.helper = sortable.options._helper;
			} else {

				// Prevent this Sortable from removing the helper.
				// However, don't set the draggable to remove the helper
				// either as another connected Sortable may yet handle the removal.
				sortable.cancelHelperRemoval = true;

				sortable._trigger( "deactivate", event, uiSortable );
			}
		} );
	},
	drag: function( event, ui, draggable ) {
		$.each( draggable.sortables, function() {
			var innermostIntersecting = false,
				sortable = this;

			// Copy over variables that sortable's _intersectsWith uses
			sortable.positionAbs = draggable.positionAbs;
			sortable.helperProportions = draggable.helperProportions;
			sortable.offset.click = draggable.offset.click;

			if ( sortable._intersectsWith( sortable.containerCache ) ) {
				innermostIntersecting = true;

				$.each( draggable.sortables, function() {

					// Copy over variables that sortable's _intersectsWith uses
					this.positionAbs = draggable.positionAbs;
					this.helperProportions = draggable.helperProportions;
					this.offset.click = draggable.offset.click;

					if ( this !== sortable &&
							this._intersectsWith( this.containerCache ) &&
							$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
						innermostIntersecting = false;
					}

					return innermostIntersecting;
				} );
			}

			if ( innermostIntersecting ) {

				// If it intersects, we use a little isOver variable and set it once,
				// so that the move-in stuff gets fired only once.
				if ( !sortable.isOver ) {
					sortable.isOver = 1;

					// Store draggable's parent in case we need to reappend to it later.
					draggable._parent = ui.helper.parent();

					sortable.currentItem = ui.helper
						.appendTo( sortable.element )
						.data( "ui-sortable-item", true );

					// Store helper option to later restore it
					sortable.options._helper = sortable.options.helper;

					sortable.options.helper = function() {
						return ui.helper[ 0 ];
					};

					// Fire the start events of the sortable with our passed browser event,
					// and our own helper (so it doesn't create a new one)
					event.target = sortable.currentItem[ 0 ];
					sortable._mouseCapture( event, true );
					sortable._mouseStart( event, true, true );

					// Because the browser event is way off the new appended portlet,
					// modify necessary variables to reflect the changes
					sortable.offset.click.top = draggable.offset.click.top;
					sortable.offset.click.left = draggable.offset.click.left;
					sortable.offset.parent.left -= draggable.offset.parent.left -
						sortable.offset.parent.left;
					sortable.offset.parent.top -= draggable.offset.parent.top -
						sortable.offset.parent.top;

					draggable._trigger( "toSortable", event );

					// Inform draggable that the helper is in a valid drop zone,
					// used solely in the revert option to handle "valid/invalid".
					draggable.dropped = sortable.element;

					// Need to refreshPositions of all sortables in the case that
					// adding to one sortable changes the location of the other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					} );

					// Hack so receive/update callbacks work (mostly)
					draggable.currentItem = draggable.element;
					sortable.fromOutside = draggable;
				}

				if ( sortable.currentItem ) {
					sortable._mouseDrag( event );

					// Copy the sortable's position because the draggable's can potentially reflect
					// a relative position, while sortable is always absolute, which the dragged
					// element has now become. (#8809)
					ui.position = sortable.position;
				}
			} else {

				// If it doesn't intersect with the sortable, and it intersected before,
				// we fake the drag stop of the sortable, but make sure it doesn't remove
				// the helper by using cancelHelperRemoval.
				if ( sortable.isOver ) {

					sortable.isOver = 0;
					sortable.cancelHelperRemoval = true;

					// Calling sortable's mouseStop would trigger a revert,
					// so revert must be temporarily false until after mouseStop is called.
					sortable.options._revert = sortable.options.revert;
					sortable.options.revert = false;

					sortable._trigger( "out", event, sortable._uiHash( sortable ) );
					sortable._mouseStop( event, true );

					// Restore sortable behaviors that were modfied
					// when the draggable entered the sortable area (#9481)
					sortable.options.revert = sortable.options._revert;
					sortable.options.helper = sortable.options._helper;

					if ( sortable.placeholder ) {
						sortable.placeholder.remove();
					}

					// Restore and recalculate the draggable's offset considering the sortable
					// may have modified them in unexpected ways. (#8809, #10669)
					ui.helper.appendTo( draggable._parent );
					draggable._refreshOffsets( event );
					ui.position = draggable._generatePosition( event, true );

					draggable._trigger( "fromSortable", event );

					// Inform draggable that the helper is no longer in a valid drop zone
					draggable.dropped = false;

					// Need to refreshPositions of all sortables just in case removing
					// from one sortable changes the location of other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					} );
				}
			}
		} );
	}
} );

$.ui.plugin.add( "draggable", "cursor", {
	start: function( event, ui, instance ) {
		var t = $( "body" ),
			o = instance.options;

		if ( t.css( "cursor" ) ) {
			o._cursor = t.css( "cursor" );
		}
		t.css( "cursor", o.cursor );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if ( o._cursor ) {
			$( "body" ).css( "cursor", o._cursor );
		}
	}
} );

$.ui.plugin.add( "draggable", "opacity", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;
		if ( t.css( "opacity" ) ) {
			o._opacity = t.css( "opacity" );
		}
		t.css( "opacity", o.opacity );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if ( o._opacity ) {
			$( ui.helper ).css( "opacity", o._opacity );
		}
	}
} );

$.ui.plugin.add( "draggable", "scroll", {
	start: function( event, ui, i ) {
		if ( !i.scrollParentNotHidden ) {
			i.scrollParentNotHidden = i.helper.scrollParent( false );
		}

		if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] &&
				i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
			i.overflowOffset = i.scrollParentNotHidden.offset();
		}
	},
	drag: function( event, ui, i  ) {

		var o = i.options,
			scrolled = false,
			scrollParent = i.scrollParentNotHidden[ 0 ],
			document = i.document[ 0 ];

		if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
			if ( !o.axis || o.axis !== "x" ) {
				if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY <
						o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
				} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX <
						o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
				} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if ( !o.axis || o.axis !== "x" ) {
				if ( event.pageY - $( document ).scrollTop() < o.scrollSensitivity ) {
					scrolled = $( document ).scrollTop( $( document ).scrollTop() - o.scrollSpeed );
				} else if ( $( window ).height() - ( event.pageY - $( document ).scrollTop() ) <
						o.scrollSensitivity ) {
					scrolled = $( document ).scrollTop( $( document ).scrollTop() + o.scrollSpeed );
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( event.pageX - $( document ).scrollLeft() < o.scrollSensitivity ) {
					scrolled = $( document ).scrollLeft(
						$( document ).scrollLeft() - o.scrollSpeed
					);
				} else if ( $( window ).width() - ( event.pageX - $( document ).scrollLeft() ) <
						o.scrollSensitivity ) {
					scrolled = $( document ).scrollLeft(
						$( document ).scrollLeft() + o.scrollSpeed
					);
				}
			}

		}

		if ( scrolled !== false && $.ui.ddmanager && !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( i, event );
		}

	}
} );

$.ui.plugin.add( "draggable", "snap", {
	start: function( event, ui, i ) {

		var o = i.options;

		i.snapElements = [];

		$( o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap )
			.each( function() {
				var $t = $( this ),
					$o = $t.offset();
				if ( this !== i.element[ 0 ] ) {
					i.snapElements.push( {
						item: this,
						width: $t.outerWidth(), height: $t.outerHeight(),
						top: $o.top, left: $o.left
					} );
				}
			} );

	},
	drag: function( event, ui, inst ) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for ( i = inst.snapElements.length - 1; i >= 0; i-- ) {

			l = inst.snapElements[ i ].left - inst.margins.left;
			r = l + inst.snapElements[ i ].width;
			t = inst.snapElements[ i ].top - inst.margins.top;
			b = t + inst.snapElements[ i ].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d ||
					!$.contains( inst.snapElements[ i ].item.ownerDocument,
					inst.snapElements[ i ].item ) ) {
				if ( inst.snapElements[ i ].snapping ) {
					( inst.options.snap.release &&
						inst.options.snap.release.call(
							inst.element,
							event,
							$.extend( inst._uiHash(), { snapItem: inst.snapElements[ i ].item } )
						) );
				}
				inst.snapElements[ i ].snapping = false;
				continue;
			}

			if ( o.snapMode !== "inner" ) {
				ts = Math.abs( t - y2 ) <= d;
				bs = Math.abs( b - y1 ) <= d;
				ls = Math.abs( l - x2 ) <= d;
				rs = Math.abs( r - x1 ) <= d;
				if ( ts ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: t - inst.helperProportions.height,
						left: 0
					} ).top;
				}
				if ( bs ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: b,
						left: 0
					} ).top;
				}
				if ( ls ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: l - inst.helperProportions.width
					} ).left;
				}
				if ( rs ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: r
					} ).left;
				}
			}

			first = ( ts || bs || ls || rs );

			if ( o.snapMode !== "outer" ) {
				ts = Math.abs( t - y1 ) <= d;
				bs = Math.abs( b - y2 ) <= d;
				ls = Math.abs( l - x1 ) <= d;
				rs = Math.abs( r - x2 ) <= d;
				if ( ts ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: t,
						left: 0
					} ).top;
				}
				if ( bs ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: b - inst.helperProportions.height,
						left: 0
					} ).top;
				}
				if ( ls ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: l
					} ).left;
				}
				if ( rs ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: r - inst.helperProportions.width
					} ).left;
				}
			}

			if ( !inst.snapElements[ i ].snapping && ( ts || bs || ls || rs || first ) ) {
				( inst.options.snap.snap &&
					inst.options.snap.snap.call(
						inst.element,
						event,
						$.extend( inst._uiHash(), {
							snapItem: inst.snapElements[ i ].item
						} ) ) );
			}
			inst.snapElements[ i ].snapping = ( ts || bs || ls || rs || first );

		}

	}
} );

$.ui.plugin.add( "draggable", "stack", {
	start: function( event, ui, instance ) {
		var min,
			o = instance.options,
			group = $.makeArray( $( o.stack ) ).sort( function( a, b ) {
				return ( parseInt( $( a ).css( "zIndex" ), 10 ) || 0 ) -
					( parseInt( $( b ).css( "zIndex" ), 10 ) || 0 );
			} );

		if ( !group.length ) { return; }

		min = parseInt( $( group[ 0 ] ).css( "zIndex" ), 10 ) || 0;
		$( group ).each( function( i ) {
			$( this ).css( "zIndex", min + i );
		} );
		this.css( "zIndex", ( min + group.length ) );
	}
} );

$.ui.plugin.add( "draggable", "zIndex", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;

		if ( t.css( "zIndex" ) ) {
			o._zIndex = t.css( "zIndex" );
		}
		t.css( "zIndex", o.zIndex );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;

		if ( o._zIndex ) {
			$( ui.helper ).css( "zIndex", o._zIndex );
		}
	}
} );

return $.ui.draggable;

} ) );


/***/ }),

/***/ "./node_modules/jquery-ui/ui/widgets/mouse.js":
/*!****************************************************!*\
  !*** ./node_modules/jquery-ui/ui/widgets/mouse.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery UI Mouse 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Mouse
//>>group: Widgets
//>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
//>>docs: http://api.jqueryui.com/mouse/

( function( factory ) {
	if ( true ) {

		// AMD. Register as an anonymous module.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [
			__webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js"),
			__webpack_require__(/*! ../ie */ "./node_modules/jquery-ui/ui/ie.js"),
			__webpack_require__(/*! ../version */ "./node_modules/jquery-ui/ui/version.js"),
			__webpack_require__(/*! ../widget */ "./node_modules/jquery-ui/ui/widget.js")
		], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}( function( $ ) {

var mouseHandled = false;
$( document ).on( "mouseup", function() {
	mouseHandled = false;
} );

return $.widget( "ui.mouse", {
	version: "1.12.1",
	options: {
		cancel: "input, textarea, button, select, option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.on( "mousedown." + this.widgetName, function( event ) {
				return that._mouseDown( event );
			} )
			.on( "click." + this.widgetName, function( event ) {
				if ( true === $.data( event.target, that.widgetName + ".preventClickEvent" ) ) {
					$.removeData( event.target, that.widgetName + ".preventClickEvent" );
					event.stopImmediatePropagation();
					return false;
				}
			} );

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.off( "." + this.widgetName );
		if ( this._mouseMoveDelegate ) {
			this.document
				.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
				.off( "mouseup." + this.widgetName, this._mouseUpDelegate );
		}
	},

	_mouseDown: function( event ) {

		// don't let more than one widget handle mouseStart
		if ( mouseHandled ) {
			return;
		}

		this._mouseMoved = false;

		// We may have missed mouseup (out of window)
		( this._mouseStarted && this._mouseUp( event ) );

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = ( event.which === 1 ),

			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = ( typeof this.options.cancel === "string" && event.target.nodeName ?
				$( event.target ).closest( this.options.cancel ).length : false );
		if ( !btnIsLeft || elIsCancel || !this._mouseCapture( event ) ) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if ( !this.mouseDelayMet ) {
			this._mouseDelayTimer = setTimeout( function() {
				that.mouseDelayMet = true;
			}, this.options.delay );
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted = ( this._mouseStart( event ) !== false );
			if ( !this._mouseStarted ) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if ( true === $.data( event.target, this.widgetName + ".preventClickEvent" ) ) {
			$.removeData( event.target, this.widgetName + ".preventClickEvent" );
		}

		// These delegates are required to keep context
		this._mouseMoveDelegate = function( event ) {
			return that._mouseMove( event );
		};
		this._mouseUpDelegate = function( event ) {
			return that._mouseUp( event );
		};

		this.document
			.on( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.on( "mouseup." + this.widgetName, this._mouseUpDelegate );

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function( event ) {

		// Only check for mouseups outside the document if you've moved inside the document
		// at least once. This prevents the firing of mouseup in the case of IE<9, which will
		// fire a mousemove event if content is placed under the cursor. See #7778
		// Support: IE <9
		if ( this._mouseMoved ) {

			// IE mouseup check - mouseup happened when mouse was out of window
			if ( $.ui.ie && ( !document.documentMode || document.documentMode < 9 ) &&
					!event.button ) {
				return this._mouseUp( event );

			// Iframe mouseup check - mouseup occurred in another document
			} else if ( !event.which ) {

				// Support: Safari <=8 - 9
				// Safari sets which to 0 if you press any of the following keys
				// during a drag (#14461)
				if ( event.originalEvent.altKey || event.originalEvent.ctrlKey ||
						event.originalEvent.metaKey || event.originalEvent.shiftKey ) {
					this.ignoreMissingWhich = true;
				} else if ( !this.ignoreMissingWhich ) {
					return this._mouseUp( event );
				}
			}
		}

		if ( event.which || event.button ) {
			this._mouseMoved = true;
		}

		if ( this._mouseStarted ) {
			this._mouseDrag( event );
			return event.preventDefault();
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted =
				( this._mouseStart( this._mouseDownEvent, event ) !== false );
			( this._mouseStarted ? this._mouseDrag( event ) : this._mouseUp( event ) );
		}

		return !this._mouseStarted;
	},

	_mouseUp: function( event ) {
		this.document
			.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.off( "mouseup." + this.widgetName, this._mouseUpDelegate );

		if ( this._mouseStarted ) {
			this._mouseStarted = false;

			if ( event.target === this._mouseDownEvent.target ) {
				$.data( event.target, this.widgetName + ".preventClickEvent", true );
			}

			this._mouseStop( event );
		}

		if ( this._mouseDelayTimer ) {
			clearTimeout( this._mouseDelayTimer );
			delete this._mouseDelayTimer;
		}

		this.ignoreMissingWhich = false;
		mouseHandled = false;
		event.preventDefault();
	},

	_mouseDistanceMet: function( event ) {
		return ( Math.max(
				Math.abs( this._mouseDownEvent.pageX - event.pageX ),
				Math.abs( this._mouseDownEvent.pageY - event.pageY )
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function( /* event */ ) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function( /* event */ ) {},
	_mouseDrag: function( /* event */ ) {},
	_mouseStop: function( /* event */ ) {},
	_mouseCapture: function( /* event */ ) { return true; }
} );

} ) );


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvZnVsbGNhbGVuZGFyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdWxsY2FsZW5kYXIvZGlzdC9mdWxsY2FsZW5kYXIubWluLmNzcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvZ2NhbC5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9hci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2NzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9kZS1hdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2RlLWNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9lbi1nYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvZXUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9maS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2ZyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvaGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9odS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL2l0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvamEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9rby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL25sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvcGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9wdC1ici5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3B0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvcm8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS9ydS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3NrLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvc3YuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Z1bGxjYWxlbmRhci9kaXN0L2xvY2FsZS90ci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZnVsbGNhbGVuZGFyL2Rpc3QvbG9jYWxlL3ZpLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mdWxsY2FsZW5kYXIvZGlzdC9sb2NhbGUvemgtY24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS9kYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvaWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS9wbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS9zYWZlLWJsdXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS9zY3JvbGwtcGFyZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qcXVlcnktdWkvdWkvd2lkZ2V0cy9kcmFnZ2FibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2pxdWVyeS11aS91aS93aWRnZXRzL21vdXNlLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBeUQ7QUFDN0QsMkJBQTJCLG1CQUFPLENBQUMsK0NBQVEsR0FBRyxtQkFBTyxDQUFDLG9EQUFRO0FBQzlELE1BQU0sRUFLMkQ7QUFDakUsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywwQkFBMEIsRUFBRTtBQUMvRCx5Q0FBeUMsZUFBZTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELCtEQUEr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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQzs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFF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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNCQUFzQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJB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QUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsbURBQW1EO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QyxxQ0FBcUMscUJBQXFCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQSw4REFBOEQ7QUFDOUQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7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Q0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxVQUFVO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNEOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBLG9DQUFvQztBQUNwQyw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyQkFBMkI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esa0JBQWtCO0FBQ2xCLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzQ0FBc0M7QUFDdEMsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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cUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxjQUFjO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJEQUEyRDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDRCQUE0QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUEsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssV0FBVztBQUNoQixLQUFLLGNBQWM7QUFDbkIsS0FBSyxjQUFjO0FBQ25CLEtBQUssY0FBYztBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsUUFBUTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBLDJDQUEyQyw0QkFBNEI7QUFDdkUsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJOztBQUVKLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxRQUFROztBQUVqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdDQUF3QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSix3QkFBd0IsUUFBUTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLENBQUM7Ozs7Ozs7Ozs7OztBQ2p1Q0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sSUFBMEM7O0FBRWhEO0FBQ0EsRUFBRSxpQ0FBUTtBQUNWLEdBQUcseUVBQVE7QUFDWCxHQUFHLHFFQUFPO0FBQ1YsR0FBRywrRUFBWTtBQUNmLEdBQUcsNkVBQVc7QUFDZCxHQUFHLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsb0dBQUU7QUFDZCxFQUFFLE1BQU0sRUFJTjtBQUNGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQSx3Q0FBd0M7QUFDeEMsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2Qyx5Q0FBeUMsYUFBYTtBQUN0RCxDQUFDOztBQUVELENBQUMiLCJmaWxlIjoidmVuZG9yc35jYWxlbmRhci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogRnVsbENhbGVuZGFyIHYzLjEwLjJcbiAqIERvY3MgJiBMaWNlbnNlOiBodHRwczovL2Z1bGxjYWxlbmRhci5pby9cbiAqIChjKSAyMDE5IEFkYW0gU2hhd1xuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJtb21lbnRcIiksIHJlcXVpcmUoXCJqcXVlcnlcIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wibW9tZW50XCIsIFwianF1ZXJ5XCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkZ1bGxDYWxlbmRhclwiXSA9IGZhY3RvcnkocmVxdWlyZShcIm1vbWVudFwiKSwgcmVxdWlyZShcImpxdWVyeVwiKSk7XG5cdGVsc2Vcblx0XHRyb290W1wiRnVsbENhbGVuZGFyXCJdID0gZmFjdG9yeShyb290W1wibW9tZW50XCJdLCByb290W1wialF1ZXJ5XCJdKTtcbn0pKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV8zX18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjU2KTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzBfXztcblxuLyoqKi8gfSksXG4vKiAxICovLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKlxyXG5kZXJpdmVkIGZyb206XHJcbmh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvdHNsaWIvYmxvYi92MS42LjAvdHNsaWIuanNcclxuXG5vbmx5IGluY2x1ZGUgdGhlIGhlbHBlcnMgd2UgbmVlZCwgdG8ga2VlcCBkb3duIGZpbGVzaXplXHJcbiovXHJcbnZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpXHJcbiAgICAgICAgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpXHJcbiAgICAgICAgICAgIGRbcF0gPSBiW3BdOyB9O1xyXG5leHBvcnRzLl9fZXh0ZW5kcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn07XHJcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzNfXztcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuLyogRnVsbENhbGVuZGFyLXNwZWNpZmljIERPTSBVdGlsaXRpZXNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIEdpdmVuIHRoZSBzY3JvbGxiYXIgd2lkdGhzIG9mIHNvbWUgb3RoZXIgY29udGFpbmVyLCBjcmVhdGUgYm9yZGVycy9tYXJnaW5zIG9uIHJvd0VscyBpbiBvcmRlciB0byBtYXRjaCB0aGUgbGVmdFxyXG4vLyBhbmQgcmlnaHQgc3BhY2UgdGhhdCB3YXMgb2Zmc2V0IGJ5IHRoZSBzY3JvbGxiYXJzLiBBIDEtcGl4ZWwgYm9yZGVyIGZpcnN0LCB0aGVuIG1hcmdpbiBiZXlvbmQgdGhhdC5cclxuZnVuY3Rpb24gY29tcGVuc2F0ZVNjcm9sbChyb3dFbHMsIHNjcm9sbGJhcldpZHRocykge1xyXG4gICAgaWYgKHNjcm9sbGJhcldpZHRocy5sZWZ0KSB7XHJcbiAgICAgICAgcm93RWxzLmNzcyh7XHJcbiAgICAgICAgICAgICdib3JkZXItbGVmdC13aWR0aCc6IDEsXHJcbiAgICAgICAgICAgICdtYXJnaW4tbGVmdCc6IHNjcm9sbGJhcldpZHRocy5sZWZ0IC0gMVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKHNjcm9sbGJhcldpZHRocy5yaWdodCkge1xyXG4gICAgICAgIHJvd0Vscy5jc3Moe1xyXG4gICAgICAgICAgICAnYm9yZGVyLXJpZ2h0LXdpZHRoJzogMSxcclxuICAgICAgICAgICAgJ21hcmdpbi1yaWdodCc6IHNjcm9sbGJhcldpZHRocy5yaWdodCAtIDFcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmNvbXBlbnNhdGVTY3JvbGwgPSBjb21wZW5zYXRlU2Nyb2xsO1xyXG4vLyBVbmRvZXMgY29tcGVuc2F0ZVNjcm9sbCBhbmQgcmVzdG9yZXMgYWxsIGJvcmRlcnMvbWFyZ2luc1xyXG5mdW5jdGlvbiB1bmNvbXBlbnNhdGVTY3JvbGwocm93RWxzKSB7XHJcbiAgICByb3dFbHMuY3NzKHtcclxuICAgICAgICAnbWFyZ2luLWxlZnQnOiAnJyxcclxuICAgICAgICAnbWFyZ2luLXJpZ2h0JzogJycsXHJcbiAgICAgICAgJ2JvcmRlci1sZWZ0LXdpZHRoJzogJycsXHJcbiAgICAgICAgJ2JvcmRlci1yaWdodC13aWR0aCc6ICcnXHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLnVuY29tcGVuc2F0ZVNjcm9sbCA9IHVuY29tcGVuc2F0ZVNjcm9sbDtcclxuLy8gTWFrZSB0aGUgbW91c2UgY3Vyc29yIGV4cHJlc3MgdGhhdCBhbiBldmVudCBpcyBub3QgYWxsb3dlZCBpbiB0aGUgY3VycmVudCBhcmVhXHJcbmZ1bmN0aW9uIGRpc2FibGVDdXJzb3IoKSB7XHJcbiAgICAkKCdib2R5JykuYWRkQ2xhc3MoJ2ZjLW5vdC1hbGxvd2VkJyk7XHJcbn1cclxuZXhwb3J0cy5kaXNhYmxlQ3Vyc29yID0gZGlzYWJsZUN1cnNvcjtcclxuLy8gUmV0dXJucyB0aGUgbW91c2UgY3Vyc29yIHRvIGl0cyBvcmlnaW5hbCBsb29rXHJcbmZ1bmN0aW9uIGVuYWJsZUN1cnNvcigpIHtcclxuICAgICQoJ2JvZHknKS5yZW1vdmVDbGFzcygnZmMtbm90LWFsbG93ZWQnKTtcclxufVxyXG5leHBvcnRzLmVuYWJsZUN1cnNvciA9IGVuYWJsZUN1cnNvcjtcclxuLy8gR2l2ZW4gYSB0b3RhbCBhdmFpbGFibGUgaGVpZ2h0IHRvIGZpbGwsIGhhdmUgYGVsc2AgKGVzc2VudGlhbGx5IGNoaWxkIHJvd3MpIGV4cGFuZCB0byBhY2NvbW9kYXRlLlxyXG4vLyBCeSBkZWZhdWx0LCBhbGwgZWxlbWVudHMgdGhhdCBhcmUgc2hvcnRlciB0aGFuIHRoZSByZWNvbW1lbmRlZCBoZWlnaHQgYXJlIGV4cGFuZGVkIHVuaWZvcm1seSwgbm90IGNvbnNpZGVyaW5nXHJcbi8vIGFueSBvdGhlciBlbHMgdGhhdCBhcmUgYWxyZWFkeSB0b28gdGFsbC4gaWYgYHNob3VsZFJlZGlzdHJpYnV0ZWAgaXMgb24sIGl0IGNvbnNpZGVycyB0aGVzZSB0YWxsIHJvd3MgYW5kXHJcbi8vIHJlZHVjZXMgdGhlIGF2YWlsYWJsZSBoZWlnaHQuXHJcbmZ1bmN0aW9uIGRpc3RyaWJ1dGVIZWlnaHQoZWxzLCBhdmFpbGFibGVIZWlnaHQsIHNob3VsZFJlZGlzdHJpYnV0ZSkge1xyXG4gICAgLy8gKkZMT09SSU5HIE5PVEUqOiB3ZSBmbG9vciBpbiBjZXJ0YWluIHBsYWNlcyBiZWNhdXNlIHpvb20gY2FuIGdpdmUgaW5hY2N1cmF0ZSBmbG9hdGluZy1wb2ludCBkaW1lbnNpb25zLFxyXG4gICAgLy8gYW5kIGl0IGlzIGJldHRlciB0byBiZSBzaG9ydGVyIHRoYW4gdGFsbGVyLCB0byBhdm9pZCBjcmVhdGluZyB1bm5lY2Vzc2FyeSBzY3JvbGxiYXJzLlxyXG4gICAgdmFyIG1pbk9mZnNldDEgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAvIGVscy5sZW5ndGgpOyAvLyBmb3Igbm9uLWxhc3QgZWxlbWVudFxyXG4gICAgdmFyIG1pbk9mZnNldDIgPSBNYXRoLmZsb29yKGF2YWlsYWJsZUhlaWdodCAtIG1pbk9mZnNldDEgKiAoZWxzLmxlbmd0aCAtIDEpKTsgLy8gZm9yIGxhc3QgZWxlbWVudCAqRkxPT1JJTkcgTk9URSpcclxuICAgIHZhciBmbGV4RWxzID0gW107IC8vIGVsZW1lbnRzIHRoYXQgYXJlIGFsbG93ZWQgdG8gZXhwYW5kLiBhcnJheSBvZiBET00gbm9kZXNcclxuICAgIHZhciBmbGV4T2Zmc2V0cyA9IFtdOyAvLyBhbW91bnQgb2YgdmVydGljYWwgc3BhY2UgaXQgdGFrZXMgdXBcclxuICAgIHZhciBmbGV4SGVpZ2h0cyA9IFtdOyAvLyBhY3R1YWwgY3NzIGhlaWdodFxyXG4gICAgdmFyIHVzZWRIZWlnaHQgPSAwO1xyXG4gICAgdW5kaXN0cmlidXRlSGVpZ2h0KGVscyk7IC8vIGdpdmUgYWxsIGVsZW1lbnRzIHRoZWlyIG5hdHVyYWwgaGVpZ2h0XHJcbiAgICAvLyBmaW5kIGVsZW1lbnRzIHRoYXQgYXJlIGJlbG93IHRoZSByZWNvbW1lbmRlZCBoZWlnaHQgKGV4cGFuZGFibGUpLlxyXG4gICAgLy8gaW1wb3J0YW50IHRvIHF1ZXJ5IGZvciBoZWlnaHRzIGluIGEgc2luZ2xlIGZpcnN0IHBhc3MgKHRvIGF2b2lkIHJlZmxvdyBvc2NpbGxhdGlvbikuXHJcbiAgICBlbHMuZWFjaChmdW5jdGlvbiAoaSwgZWwpIHtcclxuICAgICAgICB2YXIgbWluT2Zmc2V0ID0gaSA9PT0gZWxzLmxlbmd0aCAtIDEgPyBtaW5PZmZzZXQyIDogbWluT2Zmc2V0MTtcclxuICAgICAgICB2YXIgbmF0dXJhbE9mZnNldCA9ICQoZWwpLm91dGVySGVpZ2h0KHRydWUpO1xyXG4gICAgICAgIGlmIChuYXR1cmFsT2Zmc2V0IDwgbWluT2Zmc2V0KSB7XHJcbiAgICAgICAgICAgIGZsZXhFbHMucHVzaChlbCk7XHJcbiAgICAgICAgICAgIGZsZXhPZmZzZXRzLnB1c2gobmF0dXJhbE9mZnNldCk7XHJcbiAgICAgICAgICAgIGZsZXhIZWlnaHRzLnB1c2goJChlbCkuaGVpZ2h0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBlbGVtZW50IHN0cmV0Y2hlcyBwYXN0IHJlY29tbWVuZGVkIGhlaWdodCAobm9uLWV4cGFuZGFibGUpLiBtYXJrIHRoZSBzcGFjZSBhcyBvY2N1cGllZC5cclxuICAgICAgICAgICAgdXNlZEhlaWdodCArPSBuYXR1cmFsT2Zmc2V0O1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgLy8gcmVhZGp1c3QgdGhlIHJlY29tbWVuZGVkIGhlaWdodCB0byBvbmx5IGNvbnNpZGVyIHRoZSBoZWlnaHQgYXZhaWxhYmxlIHRvIG5vbi1tYXhlZC1vdXQgcm93cy5cclxuICAgIGlmIChzaG91bGRSZWRpc3RyaWJ1dGUpIHtcclxuICAgICAgICBhdmFpbGFibGVIZWlnaHQgLT0gdXNlZEhlaWdodDtcclxuICAgICAgICBtaW5PZmZzZXQxID0gTWF0aC5mbG9vcihhdmFpbGFibGVIZWlnaHQgLyBmbGV4RWxzLmxlbmd0aCk7XHJcbiAgICAgICAgbWluT2Zmc2V0MiA9IE1hdGguZmxvb3IoYXZhaWxhYmxlSGVpZ2h0IC0gbWluT2Zmc2V0MSAqIChmbGV4RWxzLmxlbmd0aCAtIDEpKTsgLy8gKkZMT09SSU5HIE5PVEUqXHJcbiAgICB9XHJcbiAgICAvLyBhc3NpZ24gaGVpZ2h0cyB0byBhbGwgZXhwYW5kYWJsZSBlbGVtZW50c1xyXG4gICAgJChmbGV4RWxzKS5lYWNoKGZ1bmN0aW9uIChpLCBlbCkge1xyXG4gICAgICAgIHZhciBtaW5PZmZzZXQgPSBpID09PSBmbGV4RWxzLmxlbmd0aCAtIDEgPyBtaW5PZmZzZXQyIDogbWluT2Zmc2V0MTtcclxuICAgICAgICB2YXIgbmF0dXJhbE9mZnNldCA9IGZsZXhPZmZzZXRzW2ldO1xyXG4gICAgICAgIHZhciBuYXR1cmFsSGVpZ2h0ID0gZmxleEhlaWdodHNbaV07XHJcbiAgICAgICAgdmFyIG5ld0hlaWdodCA9IG1pbk9mZnNldCAtIChuYXR1cmFsT2Zmc2V0IC0gbmF0dXJhbEhlaWdodCk7IC8vIHN1YnRyYWN0IHRoZSBtYXJnaW4vcGFkZGluZ1xyXG4gICAgICAgIGlmIChuYXR1cmFsT2Zmc2V0IDwgbWluT2Zmc2V0KSB7IC8vIHdlIGNoZWNrIHRoaXMgYWdhaW4gYmVjYXVzZSByZWRpc3RyaWJ1dGlvbiBtaWdodCBoYXZlIGNoYW5nZWQgdGhpbmdzXHJcbiAgICAgICAgICAgICQoZWwpLmhlaWdodChuZXdIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuZGlzdHJpYnV0ZUhlaWdodCA9IGRpc3RyaWJ1dGVIZWlnaHQ7XHJcbi8vIFVuZG9lcyBkaXN0cnVidXRlSGVpZ2h0LCByZXN0b3JpbmcgYWxsIGVscyB0byB0aGVpciBuYXR1cmFsIGhlaWdodFxyXG5mdW5jdGlvbiB1bmRpc3RyaWJ1dGVIZWlnaHQoZWxzKSB7XHJcbiAgICBlbHMuaGVpZ2h0KCcnKTtcclxufVxyXG5leHBvcnRzLnVuZGlzdHJpYnV0ZUhlaWdodCA9IHVuZGlzdHJpYnV0ZUhlaWdodDtcclxuLy8gR2l2ZW4gYGVsc2AsIGEgalF1ZXJ5IHNldCBvZiA8dGQ+IGNlbGxzLCBmaW5kIHRoZSBjZWxsIHdpdGggdGhlIGxhcmdlc3QgbmF0dXJhbCB3aWR0aCBhbmQgc2V0IHRoZSB3aWR0aHMgb2YgYWxsIHRoZVxyXG4vLyBjZWxscyB0byBiZSB0aGF0IHdpZHRoLlxyXG4vLyBQUkVSRVFVSVNJVEU6IGlmIHlvdSB3YW50IGEgY2VsbCB0byB0YWtlIHVwIHdpZHRoLCBpdCBuZWVkcyB0byBoYXZlIGEgc2luZ2xlIGlubmVyIGVsZW1lbnQgdy8gZGlzcGxheTppbmxpbmVcclxuZnVuY3Rpb24gbWF0Y2hDZWxsV2lkdGhzKGVscykge1xyXG4gICAgdmFyIG1heElubmVyV2lkdGggPSAwO1xyXG4gICAgZWxzLmZpbmQoJz4gKicpLmVhY2goZnVuY3Rpb24gKGksIGlubmVyRWwpIHtcclxuICAgICAgICB2YXIgaW5uZXJXaWR0aCA9ICQoaW5uZXJFbCkub3V0ZXJXaWR0aCgpO1xyXG4gICAgICAgIGlmIChpbm5lcldpZHRoID4gbWF4SW5uZXJXaWR0aCkge1xyXG4gICAgICAgICAgICBtYXhJbm5lcldpZHRoID0gaW5uZXJXaWR0aDtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuICAgIG1heElubmVyV2lkdGgrKzsgLy8gc29tZXRpbWVzIG5vdCBhY2N1cmF0ZSBvZiB3aWR0aCB0aGUgdGV4dCBuZWVkcyB0byBzdGF5IG9uIG9uZSBsaW5lLiBpbnN1cmFuY2VcclxuICAgIGVscy53aWR0aChtYXhJbm5lcldpZHRoKTtcclxuICAgIHJldHVybiBtYXhJbm5lcldpZHRoO1xyXG59XHJcbmV4cG9ydHMubWF0Y2hDZWxsV2lkdGhzID0gbWF0Y2hDZWxsV2lkdGhzO1xyXG4vLyBHaXZlbiBvbmUgZWxlbWVudCB0aGF0IHJlc2lkZXMgaW5zaWRlIGFub3RoZXIsXHJcbi8vIFN1YnRyYWN0cyB0aGUgaGVpZ2h0IG9mIHRoZSBpbm5lciBlbGVtZW50IGZyb20gdGhlIG91dGVyIGVsZW1lbnQuXHJcbmZ1bmN0aW9uIHN1YnRyYWN0SW5uZXJFbEhlaWdodChvdXRlckVsLCBpbm5lckVsKSB7XHJcbiAgICB2YXIgYm90aCA9IG91dGVyRWwuYWRkKGlubmVyRWwpO1xyXG4gICAgdmFyIGRpZmY7XHJcbiAgICAvLyBlZmZpbicgSUU4LzkvMTAvMTEgc29tZXRpbWVzIHJldHVybnMgMCBmb3IgZGltZW5zaW9ucy4gdGhpcyB3ZWlyZCBoYWNrIHdhcyB0aGUgb25seSB0aGluZyB0aGF0IHdvcmtlZFxyXG4gICAgYm90aC5jc3Moe1xyXG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgIGxlZnQ6IC0xIC8vIGVuc3VyZSByZWZsb3cgaW4gY2FzZSB0aGUgZWwgd2FzIGFscmVhZHkgcmVsYXRpdmUuIG5lZ2F0aXZlIGlzIGxlc3MgbGlrZWx5IHRvIGNhdXNlIG5ldyBzY3JvbGxcclxuICAgIH0pO1xyXG4gICAgZGlmZiA9IG91dGVyRWwub3V0ZXJIZWlnaHQoKSAtIGlubmVyRWwub3V0ZXJIZWlnaHQoKTsgLy8gZ3JhYiB0aGUgZGltZW5zaW9uc1xyXG4gICAgYm90aC5jc3MoeyBwb3NpdGlvbjogJycsIGxlZnQ6ICcnIH0pOyAvLyB1bmRvIGhhY2tcclxuICAgIHJldHVybiBkaWZmO1xyXG59XHJcbmV4cG9ydHMuc3VidHJhY3RJbm5lckVsSGVpZ2h0ID0gc3VidHJhY3RJbm5lckVsSGVpZ2h0O1xyXG4vKiBFbGVtZW50IEdlb20gVXRpbGl0aWVzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBib3Jyb3dlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5LXVpL2Jsb2IvMS4xMS4wL3VpL2NvcmUuanMjTDUxXHJcbmZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbCkge1xyXG4gICAgdmFyIHBvc2l0aW9uID0gZWwuY3NzKCdwb3NpdGlvbicpO1xyXG4gICAgdmFyIHNjcm9sbFBhcmVudCA9IGVsLnBhcmVudHMoKS5maWx0ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSAkKHRoaXMpO1xyXG4gICAgICAgIHJldHVybiAoLyhhdXRvfHNjcm9sbCkvKS50ZXN0KHBhcmVudC5jc3MoJ292ZXJmbG93JykgKyBwYXJlbnQuY3NzKCdvdmVyZmxvdy15JykgKyBwYXJlbnQuY3NzKCdvdmVyZmxvdy14JykpO1xyXG4gICAgfSkuZXEoMCk7XHJcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICdmaXhlZCcgfHwgIXNjcm9sbFBhcmVudC5sZW5ndGggPyAkKGVsWzBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQpIDogc2Nyb2xsUGFyZW50O1xyXG59XHJcbmV4cG9ydHMuZ2V0U2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50O1xyXG4vLyBRdWVyaWVzIHRoZSBvdXRlciBib3VuZGluZyBhcmVhIG9mIGEgalF1ZXJ5IGVsZW1lbnQuXHJcbi8vIFJldHVybnMgYSByZWN0YW5nbGUgd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlczogbGVmdCwgcmlnaHQgKGV4Y2x1c2l2ZSksIHRvcCwgYm90dG9tIChleGNsdXNpdmUpLlxyXG4vLyBPcmlnaW4gaXMgb3B0aW9uYWwuXHJcbmZ1bmN0aW9uIGdldE91dGVyUmVjdChlbCwgb3JpZ2luKSB7XHJcbiAgICB2YXIgb2Zmc2V0ID0gZWwub2Zmc2V0KCk7XHJcbiAgICB2YXIgbGVmdCA9IG9mZnNldC5sZWZ0IC0gKG9yaWdpbiA/IG9yaWdpbi5sZWZ0IDogMCk7XHJcbiAgICB2YXIgdG9wID0gb2Zmc2V0LnRvcCAtIChvcmlnaW4gPyBvcmlnaW4udG9wIDogMCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgcmlnaHQ6IGxlZnQgKyBlbC5vdXRlcldpZHRoKCksXHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgYm90dG9tOiB0b3AgKyBlbC5vdXRlckhlaWdodCgpXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0T3V0ZXJSZWN0ID0gZ2V0T3V0ZXJSZWN0O1xyXG4vLyBRdWVyaWVzIHRoZSBhcmVhIHdpdGhpbiB0aGUgbWFyZ2luL2JvcmRlci9zY3JvbGxiYXJzIG9mIGEgalF1ZXJ5IGVsZW1lbnQuIERvZXMgbm90IGdvIHdpdGhpbiB0aGUgcGFkZGluZy5cclxuLy8gUmV0dXJucyBhIHJlY3RhbmdsZSB3aXRoIGFic29sdXRlIGNvb3JkaW5hdGVzOiBsZWZ0LCByaWdodCAoZXhjbHVzaXZlKSwgdG9wLCBib3R0b20gKGV4Y2x1c2l2ZSkuXHJcbi8vIE9yaWdpbiBpcyBvcHRpb25hbC5cclxuLy8gV0FSTklORzogZ2l2ZW4gZWxlbWVudCBjYW4ndCBoYXZlIGJvcmRlcnNcclxuLy8gTk9URTogc2hvdWxkIHVzZSBjbGllbnRMZWZ0L2NsaWVudFRvcCwgYnV0IHZlcnkgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyLlxyXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0KGVsLCBvcmlnaW4pIHtcclxuICAgIHZhciBvZmZzZXQgPSBlbC5vZmZzZXQoKTtcclxuICAgIHZhciBzY3JvbGxiYXJXaWR0aHMgPSBnZXRTY3JvbGxiYXJXaWR0aHMoZWwpO1xyXG4gICAgdmFyIGxlZnQgPSBvZmZzZXQubGVmdCArIGdldENzc0Zsb2F0KGVsLCAnYm9yZGVyLWxlZnQtd2lkdGgnKSArIHNjcm9sbGJhcldpZHRocy5sZWZ0IC0gKG9yaWdpbiA/IG9yaWdpbi5sZWZ0IDogMCk7XHJcbiAgICB2YXIgdG9wID0gb2Zmc2V0LnRvcCArIGdldENzc0Zsb2F0KGVsLCAnYm9yZGVyLXRvcC13aWR0aCcpICsgc2Nyb2xsYmFyV2lkdGhzLnRvcCAtIChvcmlnaW4gPyBvcmlnaW4udG9wIDogMCk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IGxlZnQsXHJcbiAgICAgICAgcmlnaHQ6IGxlZnQgKyBlbFswXS5jbGllbnRXaWR0aCxcclxuICAgICAgICB0b3A6IHRvcCxcclxuICAgICAgICBib3R0b206IHRvcCArIGVsWzBdLmNsaWVudEhlaWdodCAvLyBjbGllbnRIZWlnaHQgaW5jbHVkZXMgcGFkZGluZyBidXQgTk9UIHNjcm9sbGJhcnNcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5nZXRDbGllbnRSZWN0ID0gZ2V0Q2xpZW50UmVjdDtcclxuLy8gUXVlcmllcyB0aGUgYXJlYSB3aXRoaW4gdGhlIG1hcmdpbi9ib3JkZXIvcGFkZGluZyBvZiBhIGpRdWVyeSBlbGVtZW50LiBBc3N1bWVkIG5vdCB0byBoYXZlIHNjcm9sbGJhcnMuXHJcbi8vIFJldHVybnMgYSByZWN0YW5nbGUgd2l0aCBhYnNvbHV0ZSBjb29yZGluYXRlczogbGVmdCwgcmlnaHQgKGV4Y2x1c2l2ZSksIHRvcCwgYm90dG9tIChleGNsdXNpdmUpLlxyXG4vLyBPcmlnaW4gaXMgb3B0aW9uYWwuXHJcbmZ1bmN0aW9uIGdldENvbnRlbnRSZWN0KGVsLCBvcmlnaW4pIHtcclxuICAgIHZhciBvZmZzZXQgPSBlbC5vZmZzZXQoKTsgLy8ganVzdCBvdXRzaWRlIG9mIGJvcmRlciwgbWFyZ2luIG5vdCBpbmNsdWRlZFxyXG4gICAgdmFyIGxlZnQgPSBvZmZzZXQubGVmdCArIGdldENzc0Zsb2F0KGVsLCAnYm9yZGVyLWxlZnQtd2lkdGgnKSArIGdldENzc0Zsb2F0KGVsLCAncGFkZGluZy1sZWZ0JykgLVxyXG4gICAgICAgIChvcmlnaW4gPyBvcmlnaW4ubGVmdCA6IDApO1xyXG4gICAgdmFyIHRvcCA9IG9mZnNldC50b3AgKyBnZXRDc3NGbG9hdChlbCwgJ2JvcmRlci10b3Atd2lkdGgnKSArIGdldENzc0Zsb2F0KGVsLCAncGFkZGluZy10b3AnKSAtXHJcbiAgICAgICAgKG9yaWdpbiA/IG9yaWdpbi50b3AgOiAwKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogbGVmdCxcclxuICAgICAgICByaWdodDogbGVmdCArIGVsLndpZHRoKCksXHJcbiAgICAgICAgdG9wOiB0b3AsXHJcbiAgICAgICAgYm90dG9tOiB0b3AgKyBlbC5oZWlnaHQoKVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmdldENvbnRlbnRSZWN0ID0gZ2V0Q29udGVudFJlY3Q7XHJcbi8vIFJldHVybnMgdGhlIGNvbXB1dGVkIGxlZnQvcmlnaHQvdG9wL2JvdHRvbSBzY3JvbGxiYXIgd2lkdGhzIGZvciB0aGUgZ2l2ZW4galF1ZXJ5IGVsZW1lbnQuXHJcbi8vIFdBUk5JTkc6IGdpdmVuIGVsZW1lbnQgY2FuJ3QgaGF2ZSBib3JkZXJzICh3aGljaCB3aWxsIGNhdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB0byBiZSBsYXJnZXIpLlxyXG4vLyBOT1RFOiBzaG91bGQgdXNlIGNsaWVudExlZnQvY2xpZW50VG9wLCBidXQgdmVyeSB1bnJlbGlhYmxlIGNyb3NzLWJyb3dzZXIuXHJcbmZ1bmN0aW9uIGdldFNjcm9sbGJhcldpZHRocyhlbCkge1xyXG4gICAgdmFyIGxlZnRSaWdodFdpZHRoID0gZWxbMF0ub2Zmc2V0V2lkdGggLSBlbFswXS5jbGllbnRXaWR0aDtcclxuICAgIHZhciBib3R0b21XaWR0aCA9IGVsWzBdLm9mZnNldEhlaWdodCAtIGVsWzBdLmNsaWVudEhlaWdodDtcclxuICAgIHZhciB3aWR0aHM7XHJcbiAgICBsZWZ0UmlnaHRXaWR0aCA9IHNhbml0aXplU2Nyb2xsYmFyV2lkdGgobGVmdFJpZ2h0V2lkdGgpO1xyXG4gICAgYm90dG9tV2lkdGggPSBzYW5pdGl6ZVNjcm9sbGJhcldpZHRoKGJvdHRvbVdpZHRoKTtcclxuICAgIHdpZHRocyA9IHsgbGVmdDogMCwgcmlnaHQ6IDAsIHRvcDogMCwgYm90dG9tOiBib3R0b21XaWR0aCB9O1xyXG4gICAgaWYgKGdldElzTGVmdFJ0bFNjcm9sbGJhcnMoKSAmJiBlbC5jc3MoJ2RpcmVjdGlvbicpID09PSAncnRsJykgeyAvLyBpcyB0aGUgc2Nyb2xsYmFyIG9uIHRoZSBsZWZ0IHNpZGU/XHJcbiAgICAgICAgd2lkdGhzLmxlZnQgPSBsZWZ0UmlnaHRXaWR0aDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHdpZHRocy5yaWdodCA9IGxlZnRSaWdodFdpZHRoO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHdpZHRocztcclxufVxyXG5leHBvcnRzLmdldFNjcm9sbGJhcldpZHRocyA9IGdldFNjcm9sbGJhcldpZHRocztcclxuLy8gVGhlIHNjcm9sbGJhciB3aWR0aCBjb21wdXRhdGlvbnMgaW4gZ2V0U2Nyb2xsYmFyV2lkdGhzIGFyZSBzb21ldGltZXMgZmxhd2VkIHdoZW4gaXQgY29tZXMgdG9cclxuLy8gcmV0aW5hIGRpc3BsYXlzLCByb3VuZGluZywgYW5kIElFMTEuIE1hc3NhZ2UgdGhlbSBpbnRvIGEgdXNhYmxlIHZhbHVlLlxyXG5mdW5jdGlvbiBzYW5pdGl6ZVNjcm9sbGJhcldpZHRoKHdpZHRoKSB7XHJcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHdpZHRoKTsgLy8gbm8gbmVnYXRpdmVzXHJcbiAgICB3aWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xyXG4gICAgcmV0dXJuIHdpZHRoO1xyXG59XHJcbi8vIExvZ2ljIGZvciBkZXRlcm1pbmluZyBpZiwgd2hlbiB0aGUgZWxlbWVudCBpcyByaWdodC10by1sZWZ0LCB0aGUgc2Nyb2xsYmFyIGFwcGVhcnMgb24gdGhlIGxlZnQgc2lkZVxyXG52YXIgX2lzTGVmdFJ0bFNjcm9sbGJhcnMgPSBudWxsO1xyXG5mdW5jdGlvbiBnZXRJc0xlZnRSdGxTY3JvbGxiYXJzKCkge1xyXG4gICAgaWYgKF9pc0xlZnRSdGxTY3JvbGxiYXJzID09PSBudWxsKSB7XHJcbiAgICAgICAgX2lzTGVmdFJ0bFNjcm9sbGJhcnMgPSBjb21wdXRlSXNMZWZ0UnRsU2Nyb2xsYmFycygpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9pc0xlZnRSdGxTY3JvbGxiYXJzO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVJc0xlZnRSdGxTY3JvbGxiYXJzKCkge1xyXG4gICAgdmFyIGVsID0gJCgnPGRpdj48ZGl2PjwvZGl2PjwvZGl2PicpXHJcbiAgICAgICAgLmNzcyh7XHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgdG9wOiAtMTAwMCxcclxuICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgIGJvcmRlcjogMCxcclxuICAgICAgICBwYWRkaW5nOiAwLFxyXG4gICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJyxcclxuICAgICAgICBkaXJlY3Rpb246ICdydGwnXHJcbiAgICB9KVxyXG4gICAgICAgIC5hcHBlbmRUbygnYm9keScpO1xyXG4gICAgdmFyIGlubmVyRWwgPSBlbC5jaGlsZHJlbigpO1xyXG4gICAgdmFyIHJlcyA9IGlubmVyRWwub2Zmc2V0KCkubGVmdCA+IGVsLm9mZnNldCgpLmxlZnQ7IC8vIGlzIHRoZSBpbm5lciBkaXYgc2hpZnRlZCB0byBhY2NvbW1vZGF0ZSBhIGxlZnQgc2Nyb2xsYmFyP1xyXG4gICAgZWwucmVtb3ZlKCk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59XHJcbi8vIFJldHJpZXZlcyBhIGpRdWVyeSBlbGVtZW50J3MgY29tcHV0ZWQgQ1NTIHZhbHVlIGFzIGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyLlxyXG4vLyBJZiB0aGUgcXVlcmllZCB2YWx1ZSBpcyBub24tbnVtZXJpYyAoZXg6IElFIGNhbiByZXR1cm4gXCJtZWRpdW1cIiBmb3IgYm9yZGVyIHdpZHRoKSwgd2lsbCBqdXN0IHJldHVybiB6ZXJvLlxyXG5mdW5jdGlvbiBnZXRDc3NGbG9hdChlbCwgcHJvcCkge1xyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQoZWwuY3NzKHByb3ApKSB8fCAwO1xyXG59XHJcbi8qIE1vdXNlIC8gVG91Y2ggVXRpbGl0aWVzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBSZXR1cm5zIGEgYm9vbGVhbiB3aGV0aGVyIHRoaXMgd2FzIGEgbGVmdCBtb3VzZSBjbGljayBhbmQgbm8gY3RybCBrZXkgKHdoaWNoIG1lYW5zIHJpZ2h0IGNsaWNrIG9uIE1hYylcclxuZnVuY3Rpb24gaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpIHtcclxuICAgIHJldHVybiBldi53aGljaCA9PT0gMSAmJiAhZXYuY3RybEtleTtcclxufVxyXG5leHBvcnRzLmlzUHJpbWFyeU1vdXNlQnV0dG9uID0gaXNQcmltYXJ5TW91c2VCdXR0b247XHJcbmZ1bmN0aW9uIGdldEV2WChldikge1xyXG4gICAgdmFyIHRvdWNoZXMgPSBldi5vcmlnaW5hbEV2ZW50LnRvdWNoZXM7XHJcbiAgICAvLyBvbiBtb2JpbGUgRkYsIHBhZ2VYIGZvciB0b3VjaCBldmVudHMgaXMgcHJlc2VudCwgYnV0IGluY29ycmVjdCxcclxuICAgIC8vIHNvLCBsb29rIGF0IHRvdWNoIGNvb3JkaW5hdGVzIGZpcnN0LlxyXG4gICAgaWYgKHRvdWNoZXMgJiYgdG91Y2hlcy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdG91Y2hlc1swXS5wYWdlWDtcclxuICAgIH1cclxuICAgIHJldHVybiBldi5wYWdlWDtcclxufVxyXG5leHBvcnRzLmdldEV2WCA9IGdldEV2WDtcclxuZnVuY3Rpb24gZ2V0RXZZKGV2KSB7XHJcbiAgICB2YXIgdG91Y2hlcyA9IGV2Lm9yaWdpbmFsRXZlbnQudG91Y2hlcztcclxuICAgIC8vIG9uIG1vYmlsZSBGRiwgcGFnZVggZm9yIHRvdWNoIGV2ZW50cyBpcyBwcmVzZW50LCBidXQgaW5jb3JyZWN0LFxyXG4gICAgLy8gc28sIGxvb2sgYXQgdG91Y2ggY29vcmRpbmF0ZXMgZmlyc3QuXHJcbiAgICBpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB0b3VjaGVzWzBdLnBhZ2VZO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2LnBhZ2VZO1xyXG59XHJcbmV4cG9ydHMuZ2V0RXZZID0gZ2V0RXZZO1xyXG5mdW5jdGlvbiBnZXRFdklzVG91Y2goZXYpIHtcclxuICAgIHJldHVybiAvXnRvdWNoLy50ZXN0KGV2LnR5cGUpO1xyXG59XHJcbmV4cG9ydHMuZ2V0RXZJc1RvdWNoID0gZ2V0RXZJc1RvdWNoO1xyXG5mdW5jdGlvbiBwcmV2ZW50U2VsZWN0aW9uKGVsKSB7XHJcbiAgICBlbC5hZGRDbGFzcygnZmMtdW5zZWxlY3RhYmxlJylcclxuICAgICAgICAub24oJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xyXG59XHJcbmV4cG9ydHMucHJldmVudFNlbGVjdGlvbiA9IHByZXZlbnRTZWxlY3Rpb247XHJcbmZ1bmN0aW9uIGFsbG93U2VsZWN0aW9uKGVsKSB7XHJcbiAgICBlbC5yZW1vdmVDbGFzcygnZmMtdW5zZWxlY3RhYmxlJylcclxuICAgICAgICAub2ZmKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcclxufVxyXG5leHBvcnRzLmFsbG93U2VsZWN0aW9uID0gYWxsb3dTZWxlY3Rpb247XHJcbi8vIFN0b3BzIGEgbW91c2UvdG91Y2ggZXZlbnQgZnJvbSBkb2luZyBpdCdzIG5hdGl2ZSBicm93c2VyIGFjdGlvblxyXG5mdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldikge1xyXG4gICAgZXYucHJldmVudERlZmF1bHQoKTtcclxufVxyXG5leHBvcnRzLnByZXZlbnREZWZhdWx0ID0gcHJldmVudERlZmF1bHQ7XHJcbi8qIEdlbmVyYWwgR2VvbWV0cnkgVXRpbHNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIFJldHVybnMgYSBuZXcgcmVjdGFuZ2xlIHRoYXQgaXMgdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgdHdvIHJlY3RhbmdsZXMuIElmIHRoZXkgZG9uJ3QgaW50ZXJzZWN0LCByZXR1cm5zIGZhbHNlXHJcbmZ1bmN0aW9uIGludGVyc2VjdFJlY3RzKHJlY3QxLCByZWN0Mikge1xyXG4gICAgdmFyIHJlcyA9IHtcclxuICAgICAgICBsZWZ0OiBNYXRoLm1heChyZWN0MS5sZWZ0LCByZWN0Mi5sZWZ0KSxcclxuICAgICAgICByaWdodDogTWF0aC5taW4ocmVjdDEucmlnaHQsIHJlY3QyLnJpZ2h0KSxcclxuICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcclxuICAgICAgICBib3R0b206IE1hdGgubWluKHJlY3QxLmJvdHRvbSwgcmVjdDIuYm90dG9tKVxyXG4gICAgfTtcclxuICAgIGlmIChyZXMubGVmdCA8IHJlcy5yaWdodCAmJiByZXMudG9wIDwgcmVzLmJvdHRvbSkge1xyXG4gICAgICAgIHJldHVybiByZXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuZXhwb3J0cy5pbnRlcnNlY3RSZWN0cyA9IGludGVyc2VjdFJlY3RzO1xyXG4vLyBSZXR1cm5zIGEgbmV3IHBvaW50IHRoYXQgd2lsbCBoYXZlIGJlZW4gbW92ZWQgdG8gcmVzaWRlIHdpdGhpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXHJcbmZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxlZnQ6IE1hdGgubWluKE1hdGgubWF4KHBvaW50LmxlZnQsIHJlY3QubGVmdCksIHJlY3QucmlnaHQpLFxyXG4gICAgICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmNvbnN0cmFpblBvaW50ID0gY29uc3RyYWluUG9pbnQ7XHJcbi8vIFJldHVybnMgYSBwb2ludCB0aGF0IGlzIHRoZSBjZW50ZXIgb2YgdGhlIGdpdmVuIHJlY3RhbmdsZVxyXG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3QpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMixcclxuICAgICAgICB0b3A6IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDJcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5nZXRSZWN0Q2VudGVyID0gZ2V0UmVjdENlbnRlcjtcclxuLy8gU3VidHJhY3RzIHBvaW50MidzIGNvb3JkaW5hdGVzIGZyb20gcG9pbnQxJ3MgY29vcmRpbmF0ZXMsIHJldHVybmluZyBhIGRlbHRhXHJcbmZ1bmN0aW9uIGRpZmZQb2ludHMocG9pbnQxLCBwb2ludDIpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGVmdDogcG9pbnQxLmxlZnQgLSBwb2ludDIubGVmdCxcclxuICAgICAgICB0b3A6IHBvaW50MS50b3AgLSBwb2ludDIudG9wXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZGlmZlBvaW50cyA9IGRpZmZQb2ludHM7XHJcbi8qIE9iamVjdCBPcmRlcmluZyBieSBGaWVsZFxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZnVuY3Rpb24gcGFyc2VGaWVsZFNwZWNzKGlucHV0KSB7XHJcbiAgICB2YXIgc3BlY3MgPSBbXTtcclxuICAgIHZhciB0b2tlbnMgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIHRva2VuO1xyXG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICB0b2tlbnMgPSBpbnB1dC5zcGxpdCgvXFxzKixcXHMqLyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICB0b2tlbnMgPSBbaW5wdXRdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJC5pc0FycmF5KGlucHV0KSkge1xyXG4gICAgICAgIHRva2VucyA9IGlucHV0O1xyXG4gICAgfVxyXG4gICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHNwZWNzLnB1c2godG9rZW4uY2hhckF0KDApID09PSAnLScgP1xyXG4gICAgICAgICAgICAgICAgeyBmaWVsZDogdG9rZW4uc3Vic3RyaW5nKDEpLCBvcmRlcjogLTEgfSA6XHJcbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbiwgb3JkZXI6IDEgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBzcGVjcy5wdXNoKHsgZnVuYzogdG9rZW4gfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNwZWNzO1xyXG59XHJcbmV4cG9ydHMucGFyc2VGaWVsZFNwZWNzID0gcGFyc2VGaWVsZFNwZWNzO1xyXG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajEsIG9iajIsIGZpZWxkU3BlY3MsIG9iajFmYWxsYmFjaywgb2JqMmZhbGxiYWNrKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBjbXA7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRTcGVjcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNtcCA9IGNvbXBhcmVCeUZpZWxkU3BlYyhvYmoxLCBvYmoyLCBmaWVsZFNwZWNzW2ldLCBvYmoxZmFsbGJhY2ssIG9iajJmYWxsYmFjayk7XHJcbiAgICAgICAgaWYgKGNtcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAwO1xyXG59XHJcbmV4cG9ydHMuY29tcGFyZUJ5RmllbGRTcGVjcyA9IGNvbXBhcmVCeUZpZWxkU3BlY3M7XHJcbmZ1bmN0aW9uIGNvbXBhcmVCeUZpZWxkU3BlYyhvYmoxLCBvYmoyLCBmaWVsZFNwZWMsIG9iajFmYWxsYmFjaywgb2JqMmZhbGxiYWNrKSB7XHJcbiAgICBpZiAoZmllbGRTcGVjLmZ1bmMpIHtcclxuICAgICAgICByZXR1cm4gZmllbGRTcGVjLmZ1bmMob2JqMSwgb2JqMik7XHJcbiAgICB9XHJcbiAgICB2YXIgdmFsMSA9IG9iajFbZmllbGRTcGVjLmZpZWxkXTtcclxuICAgIHZhciB2YWwyID0gb2JqMltmaWVsZFNwZWMuZmllbGRdO1xyXG4gICAgaWYgKHZhbDEgPT0gbnVsbCAmJiBvYmoxZmFsbGJhY2spIHtcclxuICAgICAgICB2YWwxID0gb2JqMWZhbGxiYWNrW2ZpZWxkU3BlYy5maWVsZF07XHJcbiAgICB9XHJcbiAgICBpZiAodmFsMiA9PSBudWxsICYmIG9iajJmYWxsYmFjaykge1xyXG4gICAgICAgIHZhbDIgPSBvYmoyZmFsbGJhY2tbZmllbGRTcGVjLmZpZWxkXTtcclxuICAgIH1cclxuICAgIHJldHVybiBmbGV4aWJsZUNvbXBhcmUodmFsMSwgdmFsMikgKiAoZmllbGRTcGVjLm9yZGVyIHx8IDEpO1xyXG59XHJcbmV4cG9ydHMuY29tcGFyZUJ5RmllbGRTcGVjID0gY29tcGFyZUJ5RmllbGRTcGVjO1xyXG5mdW5jdGlvbiBmbGV4aWJsZUNvbXBhcmUoYSwgYikge1xyXG4gICAgaWYgKCFhICYmICFiKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKGEgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgaWYgKCQudHlwZShhKSA9PT0gJ3N0cmluZycgfHwgJC50eXBlKGIpID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiBTdHJpbmcoYSkubG9jYWxlQ29tcGFyZShTdHJpbmcoYikpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGEgLSBiO1xyXG59XHJcbmV4cG9ydHMuZmxleGlibGVDb21wYXJlID0gZmxleGlibGVDb21wYXJlO1xyXG4vKiBEYXRlIFV0aWxpdGllc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZXhwb3J0cy5kYXlJRHMgPSBbJ3N1bicsICdtb24nLCAndHVlJywgJ3dlZCcsICd0aHUnLCAnZnJpJywgJ3NhdCddO1xyXG5leHBvcnRzLnVuaXRzRGVzYyA9IFsneWVhcicsICdtb250aCcsICd3ZWVrJywgJ2RheScsICdob3VyJywgJ21pbnV0ZScsICdzZWNvbmQnLCAnbWlsbGlzZWNvbmQnXTsgLy8gZGVzY2VuZGluZ1xyXG4vLyBEaWZmcyB0aGUgdHdvIG1vbWVudHMgaW50byBhIER1cmF0aW9uIHdoZXJlIGZ1bGwtZGF5cyBhcmUgcmVjb3JkZWQgZmlyc3QsIHRoZW4gdGhlIHJlbWFpbmluZyB0aW1lLlxyXG4vLyBNb21lbnRzIHdpbGwgaGF2ZSB0aGVpciB0aW1lem9uZXMgbm9ybWFsaXplZC5cclxuZnVuY3Rpb24gZGlmZkRheVRpbWUoYSwgYikge1xyXG4gICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih7XHJcbiAgICAgICAgZGF5czogYS5jbG9uZSgpLnN0cmlwVGltZSgpLmRpZmYoYi5jbG9uZSgpLnN0cmlwVGltZSgpLCAnZGF5cycpLFxyXG4gICAgICAgIG1zOiBhLnRpbWUoKSAtIGIudGltZSgpIC8vIHRpbWUtb2YtZGF5IGZyb20gZGF5IHN0YXJ0LiBkaXNyZWdhcmRzIHRpbWV6b25lXHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmRpZmZEYXlUaW1lID0gZGlmZkRheVRpbWU7XHJcbi8vIERpZmZzIHRoZSB0d28gbW9tZW50cyB2aWEgdGhlaXIgc3RhcnQtb2YtZGF5IChyZWdhcmRsZXNzIG9mIHRpbWV6b25lKS4gUHJvZHVjZXMgd2hvbGUtZGF5IGR1cmF0aW9ucy5cclxuZnVuY3Rpb24gZGlmZkRheShhLCBiKSB7XHJcbiAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHtcclxuICAgICAgICBkYXlzOiBhLmNsb25lKCkuc3RyaXBUaW1lKCkuZGlmZihiLmNsb25lKCkuc3RyaXBUaW1lKCksICdkYXlzJylcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuZGlmZkRheSA9IGRpZmZEYXk7XHJcbi8vIERpZmZzIHR3byBtb21lbnRzLCBwcm9kdWNpbmcgYSBkdXJhdGlvbiwgbWFkZSBvZiBhIHdob2xlLXVuaXQtaW5jcmVtZW50IG9mIHRoZSBnaXZlbiB1bml0LiBVc2VzIHJvdW5kaW5nLlxyXG5mdW5jdGlvbiBkaWZmQnlVbml0KGEsIGIsIHVuaXQpIHtcclxuICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oTWF0aC5yb3VuZChhLmRpZmYoYiwgdW5pdCwgdHJ1ZSkpLCAvLyByZXR1cm5GbG9hdD10cnVlXHJcbiAgICB1bml0KTtcclxufVxyXG5leHBvcnRzLmRpZmZCeVVuaXQgPSBkaWZmQnlVbml0O1xyXG4vLyBDb21wdXRlcyB0aGUgdW5pdCBuYW1lIG9mIHRoZSBsYXJnZXN0IHdob2xlLXVuaXQgcGVyaW9kIG9mIHRpbWUuXHJcbi8vIEZvciBleGFtcGxlLCA0OCBob3VycyB3aWxsIGJlIFwiZGF5c1wiIHdoZXJlYXMgNDkgaG91cnMgd2lsbCBiZSBcImhvdXJzXCIuXHJcbi8vIEFjY2VwdHMgc3RhcnQvZW5kLCBhIHJhbmdlIG9iamVjdCwgb3IgYW4gb3JpZ2luYWwgZHVyYXRpb24gb2JqZWN0LlxyXG5mdW5jdGlvbiBjb21wdXRlR3JlYXRlc3RVbml0KHN0YXJ0LCBlbmQpIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIHVuaXQ7XHJcbiAgICB2YXIgdmFsO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGV4cG9ydHMudW5pdHNEZXNjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdW5pdCA9IGV4cG9ydHMudW5pdHNEZXNjW2ldO1xyXG4gICAgICAgIHZhbCA9IGNvbXB1dGVSYW5nZUFzKHVuaXQsIHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIGlmICh2YWwgPj0gMSAmJiBpc0ludCh2YWwpKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1bml0OyAvLyB3aWxsIGJlIFwibWlsbGlzZWNvbmRzXCIgaWYgbm90aGluZyBlbHNlIG1hdGNoZXNcclxufVxyXG5leHBvcnRzLmNvbXB1dGVHcmVhdGVzdFVuaXQgPSBjb21wdXRlR3JlYXRlc3RVbml0O1xyXG4vLyBsaWtlIGNvbXB1dGVHcmVhdGVzdFVuaXQsIGJ1dCBoYXMgc3BlY2lhbCBhYmlsaXRpZXMgdG8gaW50ZXJwcmV0IHRoZSBzb3VyY2UgaW5wdXQgZm9yIGNsdWVzXHJcbmZ1bmN0aW9uIGNvbXB1dGVEdXJhdGlvbkdyZWF0ZXN0VW5pdChkdXJhdGlvbiwgZHVyYXRpb25JbnB1dCkge1xyXG4gICAgdmFyIHVuaXQgPSBjb21wdXRlR3JlYXRlc3RVbml0KGR1cmF0aW9uKTtcclxuICAgIC8vIHByZXZlbnQgZGF5czo3IGZyb20gYmVpbmcgaW50ZXJwcmV0ZWQgYXMgYSB3ZWVrXHJcbiAgICBpZiAodW5pdCA9PT0gJ3dlZWsnICYmIHR5cGVvZiBkdXJhdGlvbklucHV0ID09PSAnb2JqZWN0JyAmJiBkdXJhdGlvbklucHV0LmRheXMpIHtcclxuICAgICAgICB1bml0ID0gJ2RheSc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5pdDtcclxufVxyXG5leHBvcnRzLmNvbXB1dGVEdXJhdGlvbkdyZWF0ZXN0VW5pdCA9IGNvbXB1dGVEdXJhdGlvbkdyZWF0ZXN0VW5pdDtcclxuLy8gQ29tcHV0ZXMgdGhlIG51bWJlciBvZiB1bml0cyAobGlrZSBcImhvdXJzXCIpIGluIHRoZSBnaXZlbiByYW5nZS5cclxuLy8gUmFuZ2UgY2FuIGJlIGEge3N0YXJ0LGVuZH0gb2JqZWN0LCBzZXBhcmF0ZSBzdGFydC9lbmQgYXJncywgb3IgYSBEdXJhdGlvbi5cclxuLy8gUmVzdWx0cyBhcmUgYmFzZWQgb24gTW9tZW50J3MgLmFzKCkgYW5kIC5kaWZmKCkgbWV0aG9kcywgc28gcmVzdWx0cyBjYW4gZGVwZW5kIG9uIGludGVybmFsIGhhbmRsaW5nXHJcbi8vIG9mIG1vbnRoLWRpZmZpbmcgbG9naWMgKHdoaWNoIHRlbmRzIHRvIHZhcnkgZnJvbSB2ZXJzaW9uIHRvIHZlcnNpb24pLlxyXG5mdW5jdGlvbiBjb21wdXRlUmFuZ2VBcyh1bml0LCBzdGFydCwgZW5kKSB7XHJcbiAgICBpZiAoZW5kICE9IG51bGwpIHsgLy8gZ2l2ZW4gc3RhcnQsIGVuZFxyXG4gICAgICAgIHJldHVybiBlbmQuZGlmZihzdGFydCwgdW5pdCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChtb21lbnQuaXNEdXJhdGlvbihzdGFydCkpIHsgLy8gZ2l2ZW4gZHVyYXRpb25cclxuICAgICAgICByZXR1cm4gc3RhcnQuYXModW5pdCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHsgLy8gZ2l2ZW4geyBzdGFydCwgZW5kIH0gcmFuZ2Ugb2JqZWN0XHJcbiAgICAgICAgcmV0dXJuIHN0YXJ0LmVuZC5kaWZmKHN0YXJ0LnN0YXJ0LCB1bml0LCB0cnVlKTtcclxuICAgIH1cclxufVxyXG4vLyBJbnRlbGxpZ2VudGx5IGRpdmlkZXMgYSByYW5nZSAoc3BlY2lmaWVkIGJ5IGEgc3RhcnQvZW5kIHBhcmFtcykgYnkgYSBkdXJhdGlvblxyXG5mdW5jdGlvbiBkaXZpZGVSYW5nZUJ5RHVyYXRpb24oc3RhcnQsIGVuZCwgZHVyKSB7XHJcbiAgICB2YXIgbW9udGhzO1xyXG4gICAgaWYgKGR1cmF0aW9uSGFzVGltZShkdXIpKSB7XHJcbiAgICAgICAgcmV0dXJuIChlbmQgLSBzdGFydCkgLyBkdXI7XHJcbiAgICB9XHJcbiAgICBtb250aHMgPSBkdXIuYXNNb250aHMoKTtcclxuICAgIGlmIChNYXRoLmFicyhtb250aHMpID49IDEgJiYgaXNJbnQobW9udGhzKSkge1xyXG4gICAgICAgIHJldHVybiBlbmQuZGlmZihzdGFydCwgJ21vbnRocycsIHRydWUpIC8gbW9udGhzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVuZC5kaWZmKHN0YXJ0LCAnZGF5cycsIHRydWUpIC8gZHVyLmFzRGF5cygpO1xyXG59XHJcbmV4cG9ydHMuZGl2aWRlUmFuZ2VCeUR1cmF0aW9uID0gZGl2aWRlUmFuZ2VCeUR1cmF0aW9uO1xyXG4vLyBJbnRlbGxpZ2VudGx5IGRpdmlkZXMgb25lIGR1cmF0aW9uIGJ5IGFub3RoZXJcclxuZnVuY3Rpb24gZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uKGR1cjEsIGR1cjIpIHtcclxuICAgIHZhciBtb250aHMxO1xyXG4gICAgdmFyIG1vbnRoczI7XHJcbiAgICBpZiAoZHVyYXRpb25IYXNUaW1lKGR1cjEpIHx8IGR1cmF0aW9uSGFzVGltZShkdXIyKSkge1xyXG4gICAgICAgIHJldHVybiBkdXIxIC8gZHVyMjtcclxuICAgIH1cclxuICAgIG1vbnRoczEgPSBkdXIxLmFzTW9udGhzKCk7XHJcbiAgICBtb250aHMyID0gZHVyMi5hc01vbnRocygpO1xyXG4gICAgaWYgKE1hdGguYWJzKG1vbnRoczEpID49IDEgJiYgaXNJbnQobW9udGhzMSkgJiZcclxuICAgICAgICBNYXRoLmFicyhtb250aHMyKSA+PSAxICYmIGlzSW50KG1vbnRoczIpKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbnRoczEgLyBtb250aHMyO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGR1cjEuYXNEYXlzKCkgLyBkdXIyLmFzRGF5cygpO1xyXG59XHJcbmV4cG9ydHMuZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uID0gZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uO1xyXG4vLyBJbnRlbGxpZ2VudGx5IG11bHRpcGxpZXMgYSBkdXJhdGlvbiBieSBhIG51bWJlclxyXG5mdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGR1ciwgbikge1xyXG4gICAgdmFyIG1vbnRocztcclxuICAgIGlmIChkdXJhdGlvbkhhc1RpbWUoZHVyKSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oZHVyICogbik7XHJcbiAgICB9XHJcbiAgICBtb250aHMgPSBkdXIuYXNNb250aHMoKTtcclxuICAgIGlmIChNYXRoLmFicyhtb250aHMpID49IDEgJiYgaXNJbnQobW9udGhzKSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oeyBtb250aHM6IG1vbnRocyAqIG4gfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHsgZGF5czogZHVyLmFzRGF5cygpICogbiB9KTtcclxufVxyXG5leHBvcnRzLm11bHRpcGx5RHVyYXRpb24gPSBtdWx0aXBseUR1cmF0aW9uO1xyXG4vLyBSZXR1cm5zIGEgYm9vbGVhbiBhYm91dCB3aGV0aGVyIHRoZSBnaXZlbiBkdXJhdGlvbiBoYXMgYW55IHRpbWUgcGFydHMgKGhvdXJzL21pbnV0ZXMvc2Vjb25kcy9tcylcclxuZnVuY3Rpb24gZHVyYXRpb25IYXNUaW1lKGR1cikge1xyXG4gICAgcmV0dXJuIEJvb2xlYW4oZHVyLmhvdXJzKCkgfHwgZHVyLm1pbnV0ZXMoKSB8fCBkdXIuc2Vjb25kcygpIHx8IGR1ci5taWxsaXNlY29uZHMoKSk7XHJcbn1cclxuZXhwb3J0cy5kdXJhdGlvbkhhc1RpbWUgPSBkdXJhdGlvbkhhc1RpbWU7XHJcbmZ1bmN0aW9uIGlzTmF0aXZlRGF0ZShpbnB1dCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IERhdGVdJyB8fCBpbnB1dCBpbnN0YW5jZW9mIERhdGU7XHJcbn1cclxuZXhwb3J0cy5pc05hdGl2ZURhdGUgPSBpc05hdGl2ZURhdGU7XHJcbi8vIFJldHVybnMgYSBib29sZWFuIGFib3V0IHdoZXRoZXIgdGhlIGdpdmVuIGlucHV0IGlzIGEgdGltZSBzdHJpbmcsIGxpa2UgXCIwNjo0MDowMFwiIG9yIFwiMDY6MDBcIlxyXG5mdW5jdGlvbiBpc1RpbWVTdHJpbmcoc3RyKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiZcclxuICAgICAgICAvXlxcZCtcXDpcXGQrKD86XFw6XFxkK1xcLj8oPzpcXGR7M30pPyk/JC8udGVzdChzdHIpO1xyXG59XHJcbmV4cG9ydHMuaXNUaW1lU3RyaW5nID0gaXNUaW1lU3RyaW5nO1xyXG4vKiBMb2dnaW5nIGFuZCBEZWJ1Z1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuZnVuY3Rpb24gbG9nKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcclxuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUubG9nKSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMubG9nID0gbG9nO1xyXG5mdW5jdGlvbiB3YXJuKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbnNvbGUgPSB3aW5kb3cuY29uc29sZTtcclxuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xyXG4gICAgICAgIHJldHVybiBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbG9nLmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMud2FybiA9IHdhcm47XHJcbi8qIEdlbmVyYWwgVXRpbGl0aWVzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgaGFzT3duUHJvcE1ldGhvZCA9IHt9Lmhhc093blByb3BlcnR5O1xyXG4vLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdC5cclxuLy8gVGhlIHNlY29uZCBhcmd1bWVudCBhbGxvd3MgZm9yIGFuIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIHdobydzIG9iamVjdCB2YWx1ZXMgd2lsbCBiZSBtZXJnZWQgdG9nZXRoZXIuXHJcbmZ1bmN0aW9uIG1lcmdlUHJvcHMocHJvcE9ianMsIGNvbXBsZXhQcm9wcykge1xyXG4gICAgdmFyIGRlc3QgPSB7fTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIG5hbWU7XHJcbiAgICB2YXIgY29tcGxleE9ianM7XHJcbiAgICB2YXIgajtcclxuICAgIHZhciB2YWw7XHJcbiAgICB2YXIgcHJvcHM7XHJcbiAgICBpZiAoY29tcGxleFByb3BzKSB7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbXBsZXhQcm9wcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBuYW1lID0gY29tcGxleFByb3BzW2ldO1xyXG4gICAgICAgICAgICBjb21wbGV4T2JqcyA9IFtdO1xyXG4gICAgICAgICAgICAvLyBjb2xsZWN0IHRoZSB0cmFpbGluZyBvYmplY3QgdmFsdWVzLCBzdG9wcGluZyB3aGVuIGEgbm9uLW9iamVjdCBpcyBkaXNjb3ZlcmVkXHJcbiAgICAgICAgICAgIGZvciAoaiA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBwcm9wT2Jqc1tqXVtuYW1lXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXhPYmpzLnVuc2hpZnQodmFsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHZhbDsgLy8gaWYgdGhlcmUgd2VyZSBubyBvYmplY3RzLCB0aGlzIHZhbHVlIHdpbGwgYmUgdXNlZFxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSB0cmFpbGluZyB2YWx1ZXMgd2VyZSBvYmplY3RzLCB1c2UgdGhlIG1lcmdlZCB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0W25hbWVdID0gbWVyZ2VQcm9wcyhjb21wbGV4T2Jqcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHRoZSBkZXN0aW5hdGlvbiwgZ29pbmcgZnJvbSBsYXN0IHRvIGZpcnN0XHJcbiAgICBmb3IgKGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG4gICAgICAgIHByb3BzID0gcHJvcE9ianNbaV07XHJcbiAgICAgICAgZm9yIChuYW1lIGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgIGlmICghKG5hbWUgaW4gZGVzdCkpIHsgLy8gaWYgYWxyZWFkeSBhc3NpZ25lZCBieSBwcmV2aW91cyBwcm9wcyBvciBjb21wbGV4IHByb3BzLCBkb24ndCByZWFzc2lnblxyXG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXSA9IHByb3BzW25hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlc3Q7XHJcbn1cclxuZXhwb3J0cy5tZXJnZVByb3BzID0gbWVyZ2VQcm9wcztcclxuZnVuY3Rpb24gY29weU93blByb3BzKHNyYywgZGVzdCkge1xyXG4gICAgZm9yICh2YXIgbmFtZV8xIGluIHNyYykge1xyXG4gICAgICAgIGlmIChoYXNPd25Qcm9wKHNyYywgbmFtZV8xKSkge1xyXG4gICAgICAgICAgICBkZXN0W25hbWVfMV0gPSBzcmNbbmFtZV8xXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5jb3B5T3duUHJvcHMgPSBjb3B5T3duUHJvcHM7XHJcbmZ1bmN0aW9uIGhhc093blByb3Aob2JqLCBuYW1lKSB7XHJcbiAgICByZXR1cm4gaGFzT3duUHJvcE1ldGhvZC5jYWxsKG9iaiwgbmFtZSk7XHJcbn1cclxuZXhwb3J0cy5oYXNPd25Qcm9wID0gaGFzT3duUHJvcDtcclxuZnVuY3Rpb24gYXBwbHlBbGwoZnVuY3Rpb25zLCB0aGlzT2JqLCBhcmdzKSB7XHJcbiAgICBpZiAoJC5pc0Z1bmN0aW9uKGZ1bmN0aW9ucykpIHtcclxuICAgICAgICBmdW5jdGlvbnMgPSBbZnVuY3Rpb25zXTtcclxuICAgIH1cclxuICAgIGlmIChmdW5jdGlvbnMpIHtcclxuICAgICAgICB2YXIgaSA9IHZvaWQgMDtcclxuICAgICAgICB2YXIgcmV0ID0gdm9pZCAwO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmdW5jdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmV0ID0gZnVuY3Rpb25zW2ldLmFwcGx5KHRoaXNPYmosIGFyZ3MpIHx8IHJldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmFwcGx5QWxsID0gYXBwbHlBbGw7XHJcbmZ1bmN0aW9uIHJlbW92ZU1hdGNoaW5nKGFycmF5LCB0ZXN0RnVuYykge1xyXG4gICAgdmFyIHJlbW92ZUNudCA9IDA7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIGlmICh0ZXN0RnVuYyhhcnJheVtpXSkpIHsgLy8gdHJ1dGh5IHZhbHVlIG1lYW5zICpyZW1vdmUqXHJcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgcmVtb3ZlQ250Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlbW92ZUNudDtcclxufVxyXG5leHBvcnRzLnJlbW92ZU1hdGNoaW5nID0gcmVtb3ZlTWF0Y2hpbmc7XHJcbmZ1bmN0aW9uIHJlbW92ZUV4YWN0KGFycmF5LCBleGFjdFZhbCkge1xyXG4gICAgdmFyIHJlbW92ZUNudCA9IDA7XHJcbiAgICB2YXIgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZXhhY3RWYWwpIHtcclxuICAgICAgICAgICAgYXJyYXkuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgICByZW1vdmVDbnQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGkrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVtb3ZlQ250O1xyXG59XHJcbmV4cG9ydHMucmVtb3ZlRXhhY3QgPSByZW1vdmVFeGFjdDtcclxuZnVuY3Rpb24gaXNBcnJheXNFcXVhbChhMCwgYTEpIHtcclxuICAgIHZhciBsZW4gPSBhMC5sZW5ndGg7XHJcbiAgICB2YXIgaTtcclxuICAgIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gIT09IGExLmxlbmd0aCkgeyAvLyBub3QgYXJyYXk/IG9yIG5vdCBzYW1lIGxlbmd0aD9cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBpZiAoYTBbaV0gIT09IGExW2ldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5leHBvcnRzLmlzQXJyYXlzRXF1YWwgPSBpc0FycmF5c0VxdWFsO1xyXG5mdW5jdGlvbiBmaXJzdERlZmluZWQoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYXJnc1tpXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcmdzW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLmZpcnN0RGVmaW5lZCA9IGZpcnN0RGVmaW5lZDtcclxuZnVuY3Rpb24gaHRtbEVzY2FwZShzKSB7XHJcbiAgICByZXR1cm4gKHMgKyAnJykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxyXG4gICAgICAgIC5yZXBsYWNlKC88L2csICcmbHQ7JylcclxuICAgICAgICAucmVwbGFjZSgvPi9nLCAnJmd0OycpXHJcbiAgICAgICAgLnJlcGxhY2UoLycvZywgJyYjMDM5OycpXHJcbiAgICAgICAgLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKVxyXG4gICAgICAgIC5yZXBsYWNlKC9cXG4vZywgJzxicj4nKTtcclxufVxyXG5leHBvcnRzLmh0bWxFc2NhcGUgPSBodG1sRXNjYXBlO1xyXG5mdW5jdGlvbiBzdHJpcEh0bWxFbnRpdGllcyh0ZXh0KSB7XHJcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC8mLio/Oy9nLCAnJyk7XHJcbn1cclxuZXhwb3J0cy5zdHJpcEh0bWxFbnRpdGllcyA9IHN0cmlwSHRtbEVudGl0aWVzO1xyXG4vLyBHaXZlbiBhIGhhc2ggb2YgQ1NTIHByb3BlcnRpZXMsIHJldHVybnMgYSBzdHJpbmcgb2YgQ1NTLlxyXG4vLyBVc2VzIHByb3BlcnR5IG5hbWVzIGFzLWlzIChubyBjYW1lbC1jYXNlIGNvbnZlcnNpb24pLiBXaWxsIG5vdCBtYWtlIHN0YXRlbWVudHMgZm9yIG51bGwvdW5kZWZpbmVkIHZhbHVlcy5cclxuZnVuY3Rpb24gY3NzVG9TdHIoY3NzUHJvcHMpIHtcclxuICAgIHZhciBzdGF0ZW1lbnRzID0gW107XHJcbiAgICAkLmVhY2goY3NzUHJvcHMsIGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcclxuICAgICAgICBpZiAodmFsICE9IG51bGwpIHtcclxuICAgICAgICAgICAgc3RhdGVtZW50cy5wdXNoKG5hbWUgKyAnOicgKyB2YWwpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHN0YXRlbWVudHMuam9pbignOycpO1xyXG59XHJcbmV4cG9ydHMuY3NzVG9TdHIgPSBjc3NUb1N0cjtcclxuLy8gR2l2ZW4gYW4gb2JqZWN0IGhhc2ggb2YgSFRNTCBhdHRyaWJ1dGUgbmFtZXMgdG8gdmFsdWVzLFxyXG4vLyBnZW5lcmF0ZXMgYSBzdHJpbmcgdGhhdCBjYW4gYmUgaW5qZWN0ZWQgYmV0d2VlbiA8ID4gaW4gSFRNTFxyXG5mdW5jdGlvbiBhdHRyc1RvU3RyKGF0dHJzKSB7XHJcbiAgICB2YXIgcGFydHMgPSBbXTtcclxuICAgICQuZWFjaChhdHRycywgZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xyXG4gICAgICAgIGlmICh2YWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKG5hbWUgKyAnPVwiJyArIGh0bWxFc2NhcGUodmFsKSArICdcIicpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJyAnKTtcclxufVxyXG5leHBvcnRzLmF0dHJzVG9TdHIgPSBhdHRyc1RvU3RyO1xyXG5mdW5jdGlvbiBjYXBpdGFsaXNlRmlyc3RMZXR0ZXIoc3RyKSB7XHJcbiAgICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpO1xyXG59XHJcbmV4cG9ydHMuY2FwaXRhbGlzZUZpcnN0TGV0dGVyID0gY2FwaXRhbGlzZUZpcnN0TGV0dGVyO1xyXG5mdW5jdGlvbiBjb21wYXJlTnVtYmVycyhhLCBiKSB7XHJcbiAgICByZXR1cm4gYSAtIGI7XHJcbn1cclxuZXhwb3J0cy5jb21wYXJlTnVtYmVycyA9IGNvbXBhcmVOdW1iZXJzO1xyXG5mdW5jdGlvbiBpc0ludChuKSB7XHJcbiAgICByZXR1cm4gbiAlIDEgPT09IDA7XHJcbn1cclxuZXhwb3J0cy5pc0ludCA9IGlzSW50O1xyXG4vLyBSZXR1cm5zIGEgbWV0aG9kIGJvdW5kIHRvIHRoZSBnaXZlbiBvYmplY3QgY29udGV4dC5cclxuLy8gSnVzdCBsaWtlIG9uZSBvZiB0aGUgalF1ZXJ5LnByb3h5IHNpZ25hdHVyZXMsIGJ1dCB3aXRob3V0IHRoZSB1bmRlc2lyZWQgYmVoYXZpb3Igb2YgdHJlYXRpbmcgdGhlIHNhbWUgbWV0aG9kIHdpdGhcclxuLy8gZGlmZmVyZW50IGNvbnRleHRzIGFzIGlkZW50aWNhbCB3aGVuIGJpbmRpbmcvdW5iaW5kaW5nIGV2ZW50cy5cclxuZnVuY3Rpb24gcHJveHkob2JqLCBtZXRob2ROYW1lKSB7XHJcbiAgICB2YXIgbWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5wcm94eSA9IHByb3h5O1xyXG4vLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIGFzIGxvbmcgYXMgaXQgY29udGludWVzIHRvIGJlIGludm9rZWQsIHdpbGwgbm90XHJcbi8vIGJlIHRyaWdnZXJlZC4gVGhlIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGl0IHN0b3BzIGJlaW5nIGNhbGxlZCBmb3JcclxuLy8gTiBtaWxsaXNlY29uZHMuIElmIGBpbW1lZGlhdGVgIGlzIHBhc3NlZCwgdHJpZ2dlciB0aGUgZnVuY3Rpb24gb24gdGhlXHJcbi8vIGxlYWRpbmcgZWRnZSwgaW5zdGVhZCBvZiB0aGUgdHJhaWxpbmcuXHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNoa2VuYXMvdW5kZXJzY29yZS9ibG9iLzEuNi4wL3VuZGVyc2NvcmUuanMjTDcxNFxyXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBpbW1lZGlhdGUpIHtcclxuICAgIGlmIChpbW1lZGlhdGUgPT09IHZvaWQgMCkgeyBpbW1lZGlhdGUgPSBmYWxzZTsgfVxyXG4gICAgdmFyIHRpbWVvdXQ7XHJcbiAgICB2YXIgYXJncztcclxuICAgIHZhciBjb250ZXh0O1xyXG4gICAgdmFyIHRpbWVzdGFtcDtcclxuICAgIHZhciByZXN1bHQ7XHJcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxhc3QgPSArbmV3IERhdGUoKSAtIHRpbWVzdGFtcDtcclxuICAgICAgICBpZiAobGFzdCA8IHdhaXQpIHtcclxuICAgICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnRleHQgPSB0aGlzO1xyXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XHJcbiAgICAgICAgdGltZXN0YW1wID0gK25ldyBEYXRlKCk7XHJcbiAgICAgICAgdmFyIGNhbGxOb3cgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXQ7XHJcbiAgICAgICAgaWYgKCF0aW1lb3V0KSB7XHJcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNhbGxOb3cpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcclxuICAgICAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmRlYm91bmNlID0gZGVib3VuY2U7XHJcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG52YXIgVW56b25lZFJhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVW56b25lZFJhbmdlKHN0YXJ0SW5wdXQsIGVuZElucHV0KSB7XHJcbiAgICAgICAgLy8gVE9ETzogbW92ZSB0aGVzZSBpbnRvIGZvb3RwcmludC5cclxuICAgICAgICAvLyBFc3BlY2lhbGx5LCBkb2Vzbid0IG1ha2Ugc2Vuc2UgZm9yIG51bGwgc3RhcnRNcy9lbmRNcy5cclxuICAgICAgICB0aGlzLmlzU3RhcnQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuaXNFbmQgPSB0cnVlO1xyXG4gICAgICAgIGlmIChtb21lbnQuaXNNb21lbnQoc3RhcnRJbnB1dCkpIHtcclxuICAgICAgICAgICAgc3RhcnRJbnB1dCA9IHN0YXJ0SW5wdXQuY2xvbmUoKS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1vbWVudC5pc01vbWVudChlbmRJbnB1dCkpIHtcclxuICAgICAgICAgICAgZW5kSW5wdXQgPSBlbmRJbnB1dC5jbG9uZSgpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhcnRJbnB1dCkge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0TXMgPSBzdGFydElucHV0LnZhbHVlT2YoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZElucHV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kTXMgPSBlbmRJbnB1dC52YWx1ZU9mKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLypcclxuICAgIFNJREVFRkZFQ1Q6IHdpbGwgbXV0YXRlIGV2ZW50UmFuZ2VzLlxyXG4gICAgV2lsbCByZXR1cm4gYSBuZXcgYXJyYXkgcmVzdWx0LlxyXG4gICAgT25seSB3b3JrcyBmb3Igbm9uLW9wZW4tZW5kZWQgcmFuZ2VzLlxyXG4gICAgKi9cclxuICAgIFVuem9uZWRSYW5nZS5pbnZlcnRSYW5nZXMgPSBmdW5jdGlvbiAocmFuZ2VzLCBjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICB2YXIgaW52ZXJ0ZWRSYW5nZXMgPSBbXTtcclxuICAgICAgICB2YXIgc3RhcnRNcyA9IGNvbnN0cmFpbnRSYW5nZS5zdGFydE1zOyAvLyB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyByYW5nZS4gdGhlIHN0YXJ0IG9mIHRoZSBuZXcgcmFuZ2VcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgZGF0ZVJhbmdlO1xyXG4gICAgICAgIC8vIHJhbmdlcyBuZWVkIHRvIGJlIGluIG9yZGVyLiByZXF1aXJlZCBmb3Igb3VyIGRhdGUtd2Fsa2luZyBhbGdvcml0aG1cclxuICAgICAgICByYW5nZXMuc29ydChjb21wYXJlVW56b25lZFJhbmdlcyk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBkYXRlUmFuZ2UgPSByYW5nZXNbaV07XHJcbiAgICAgICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGJlZm9yZSB0aGUgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcclxuICAgICAgICAgICAgaWYgKGRhdGVSYW5nZS5zdGFydE1zID4gc3RhcnRNcykgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxyXG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWRSYW5nZXMucHVzaChuZXcgVW56b25lZFJhbmdlKHN0YXJ0TXMsIGRhdGVSYW5nZS5zdGFydE1zKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRhdGVSYW5nZS5lbmRNcyA+IHN0YXJ0TXMpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0TXMgPSBkYXRlUmFuZ2UuZW5kTXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYWZ0ZXIgdGhlIGxhc3QgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcclxuICAgICAgICBpZiAoc3RhcnRNcyA8IGNvbnN0cmFpbnRSYW5nZS5lbmRNcykgeyAvLyBjb21wYXJlIG1pbGxpc2Vjb25kIHRpbWUgKHNraXAgYW55IGFtYmlnIGxvZ2ljKVxyXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKG5ldyBVbnpvbmVkUmFuZ2Uoc3RhcnRNcywgY29uc3RyYWludFJhbmdlLmVuZE1zKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnZlcnRlZFJhbmdlcztcclxuICAgIH07XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmludGVyc2VjdCA9IGZ1bmN0aW9uIChvdGhlclJhbmdlKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0TXMgPSB0aGlzLnN0YXJ0TXM7XHJcbiAgICAgICAgdmFyIGVuZE1zID0gdGhpcy5lbmRNcztcclxuICAgICAgICB2YXIgbmV3UmFuZ2UgPSBudWxsO1xyXG4gICAgICAgIGlmIChvdGhlclJhbmdlLnN0YXJ0TXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoc3RhcnRNcyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydE1zID0gb3RoZXJSYW5nZS5zdGFydE1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc3RhcnRNcyA9IE1hdGgubWF4KHN0YXJ0TXMsIG90aGVyUmFuZ2Uuc3RhcnRNcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG90aGVyUmFuZ2UuZW5kTXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpZiAoZW5kTXMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgZW5kTXMgPSBvdGhlclJhbmdlLmVuZE1zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZW5kTXMgPSBNYXRoLm1pbihlbmRNcywgb3RoZXJSYW5nZS5lbmRNcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0TXMgPT0gbnVsbCB8fCBlbmRNcyA9PSBudWxsIHx8IHN0YXJ0TXMgPCBlbmRNcykge1xyXG4gICAgICAgICAgICBuZXdSYW5nZSA9IG5ldyBVbnpvbmVkUmFuZ2Uoc3RhcnRNcywgZW5kTXMpO1xyXG4gICAgICAgICAgICBuZXdSYW5nZS5pc1N0YXJ0ID0gdGhpcy5pc1N0YXJ0ICYmIHN0YXJ0TXMgPT09IHRoaXMuc3RhcnRNcztcclxuICAgICAgICAgICAgbmV3UmFuZ2UuaXNFbmQgPSB0aGlzLmlzRW5kICYmIGVuZE1zID09PSB0aGlzLmVuZE1zO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3UmFuZ2U7XHJcbiAgICB9O1xyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5pbnRlcnNlY3RzV2l0aCA9IGZ1bmN0aW9uIChvdGhlclJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmVuZE1zID09IG51bGwgfHwgb3RoZXJSYW5nZS5zdGFydE1zID09IG51bGwgfHwgdGhpcy5lbmRNcyA+IG90aGVyUmFuZ2Uuc3RhcnRNcykgJiZcclxuICAgICAgICAgICAgKHRoaXMuc3RhcnRNcyA9PSBudWxsIHx8IG90aGVyUmFuZ2UuZW5kTXMgPT0gbnVsbCB8fCB0aGlzLnN0YXJ0TXMgPCBvdGhlclJhbmdlLmVuZE1zKTtcclxuICAgIH07XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zUmFuZ2UgPSBmdW5jdGlvbiAoaW5uZXJSYW5nZSkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zdGFydE1zID09IG51bGwgfHwgKGlubmVyUmFuZ2Uuc3RhcnRNcyAhPSBudWxsICYmIGlubmVyUmFuZ2Uuc3RhcnRNcyA+PSB0aGlzLnN0YXJ0TXMpKSAmJlxyXG4gICAgICAgICAgICAodGhpcy5lbmRNcyA9PSBudWxsIHx8IChpbm5lclJhbmdlLmVuZE1zICE9IG51bGwgJiYgaW5uZXJSYW5nZS5lbmRNcyA8PSB0aGlzLmVuZE1zKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gYGRhdGVgIGNhbiBiZSBhIG1vbWVudCwgYSBEYXRlLCBvciBhIG1pbGxpc2Vjb25kIHRpbWUuXHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmNvbnRhaW5zRGF0ZSA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgdmFyIG1zID0gZGF0ZS52YWx1ZU9mKCk7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXJ0TXMgPT0gbnVsbCB8fCBtcyA+PSB0aGlzLnN0YXJ0TXMpICYmXHJcbiAgICAgICAgICAgICh0aGlzLmVuZE1zID09IG51bGwgfHwgbXMgPCB0aGlzLmVuZE1zKTtcclxuICAgIH07XHJcbiAgICAvLyBJZiB0aGUgZ2l2ZW4gZGF0ZSBpcyBub3Qgd2l0aGluIHRoZSBnaXZlbiByYW5nZSwgbW92ZSBpdCBpbnNpZGUuXHJcbiAgICAvLyAoSWYgaXQncyBwYXN0IHRoZSBlbmQsIG1ha2UgaXQgb25lIG1pbGxpc2Vjb25kIGJlZm9yZSB0aGUgZW5kKS5cclxuICAgIC8vIGBkYXRlYCBjYW4gYmUgYSBtb21lbnQsIGEgRGF0ZSwgb3IgYSBtaWxsaXNlY29uZCB0aW1lLlxyXG4gICAgLy8gUmV0dXJucyBhIE1TLXRpbWUuXHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmNvbnN0cmFpbkRhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHZhciBtcyA9IGRhdGUudmFsdWVPZigpO1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0TXMgIT0gbnVsbCAmJiBtcyA8IHRoaXMuc3RhcnRNcykge1xyXG4gICAgICAgICAgICBtcyA9IHRoaXMuc3RhcnRNcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kTXMgIT0gbnVsbCAmJiBtcyA+PSB0aGlzLmVuZE1zKSB7XHJcbiAgICAgICAgICAgIG1zID0gdGhpcy5lbmRNcyAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtcztcclxuICAgIH07XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlclJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRNcyA9PT0gb3RoZXJSYW5nZS5zdGFydE1zICYmIHRoaXMuZW5kTXMgPT09IG90aGVyUmFuZ2UuZW5kTXM7XHJcbiAgICB9O1xyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmFuZ2UgPSBuZXcgVW56b25lZFJhbmdlKHRoaXMuc3RhcnRNcywgdGhpcy5lbmRNcyk7XHJcbiAgICAgICAgcmFuZ2UuaXNTdGFydCA9IHRoaXMuaXNTdGFydDtcclxuICAgICAgICByYW5nZS5pc0VuZCA9IHRoaXMuaXNFbmQ7XHJcbiAgICAgICAgcmV0dXJuIHJhbmdlO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgYW4gYW1iaWctem9uZWQgbW9tZW50IGZyb20gc3RhcnRNcy5cclxuICAgIC8vIEJFV0FSRTogcmV0dXJuZWQgbW9tZW50IGlzIG5vdCBsb2NhbGl6ZWQuXHJcbiAgICAvLyBGb3JtYXR0aW5nIGFuZCBzdGFydC1vZi13ZWVrIHdpbGwgYmUgZGVmYXVsdC5cclxuICAgIFVuem9uZWRSYW5nZS5wcm90b3R5cGUuZ2V0U3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRNcyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGModGhpcy5zdGFydE1zKS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhbiBhbWJpZy16b25lZCBtb21lbnQgZnJvbSBzdGFydE1zLlxyXG4gICAgLy8gQkVXQVJFOiByZXR1cm5lZCBtb21lbnQgaXMgbm90IGxvY2FsaXplZC5cclxuICAgIC8vIEZvcm1hdHRpbmcgYW5kIHN0YXJ0LW9mLXdlZWsgd2lsbCBiZSBkZWZhdWx0LlxyXG4gICAgVW56b25lZFJhbmdlLnByb3RvdHlwZS5nZXRFbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kTXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKHRoaXMuZW5kTXMpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBVbnpvbmVkUmFuZ2UucHJvdG90eXBlLmFzID0gZnVuY3Rpb24gKHVuaXQpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50LnV0Yyh0aGlzLmVuZE1zKS5kaWZmKG1vbWVudC51dGModGhpcy5zdGFydE1zKSwgdW5pdCwgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFVuem9uZWRSYW5nZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVW56b25lZFJhbmdlO1xyXG4vKlxyXG5Pbmx5IHdvcmtzIGZvciBub24tb3Blbi1lbmRlZCByYW5nZXMuXHJcbiovXHJcbmZ1bmN0aW9uIGNvbXBhcmVVbnpvbmVkUmFuZ2VzKHJhbmdlMSwgcmFuZ2UyKSB7XHJcbiAgICByZXR1cm4gcmFuZ2UxLnN0YXJ0TXMgLSByYW5nZTIuc3RhcnRNczsgLy8gZWFybGllciByYW5nZXMgZ28gZmlyc3RcclxufVxyXG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBQYXJzYWJsZU1vZGVsTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xyXG52YXIgQ2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG52YXIgRXZlbnREZWZQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG52YXIgRXZlbnRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFdmVudFNvdXJjZSwgX3N1cGVyKTtcclxuICAgIC8vIGNhbiB3ZSBkbyBhd2F5IHdpdGggY2FsZW5kYXI/IGF0IGxlYXN0IGZvciB0aGUgYWJzdHJhY3Q/XHJcbiAgICAvLyB1c2VmdWwgZm9yIGJ1aWxkRXZlbnREZWZcclxuICAgIGZ1bmN0aW9uIEV2ZW50U291cmNlKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIF90aGlzLmNsYXNzTmFtZSA9IFtdO1xyXG4gICAgICAgIF90aGlzLnVpZCA9IFN0cmluZyhFdmVudFNvdXJjZS51dWlkKyspO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICByYXdJbnB1dCBjYW4gYmUgYW55IGRhdGEgdHlwZSFcclxuICAgICovXHJcbiAgICBFdmVudFNvdXJjZS5wYXJzZSA9IGZ1bmN0aW9uIChyYXdJbnB1dCwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgc291cmNlID0gbmV3IHRoaXMoY2FsZW5kYXIpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmF3SW5wdXQgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UuYXBwbHlQcm9wcyhyYXdJbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLm5vcm1hbGl6ZUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgaWYgKGlkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcoaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIG11c3QgaW1wbGVtZW50LiBtdXN0IHJldHVybiBhIHByb21pc2UuXHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIC8vIG9wdGlvbmFsIGZvciBzdWJjbGFzc2VzIHRvIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5yZW1vdmVBbGxFdmVudERlZnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gb3B0aW9uYWwgZm9yIHN1YmNsYXNzZXMgdG8gaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIEZvciBjb21wYWlyaW5nL21hdGNoaW5nXHJcbiAgICAqL1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLmdldFByaW1pdGl2ZSA9IGZ1bmN0aW9uIChvdGhlclNvdXJjZSkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS5wcm90b3R5cGUucGFyc2VFdmVudERlZnMgPSBmdW5jdGlvbiAocmF3RXZlbnREZWZzKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBldmVudERlZnMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmF3RXZlbnREZWZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmID0gdGhpcy5wYXJzZUV2ZW50RGVmKHJhd0V2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChldmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWZzLnB1c2goZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudERlZnM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRTb3VyY2UucHJvdG90eXBlLnBhcnNlRXZlbnREZWYgPSBmdW5jdGlvbiAocmF3SW5wdXQpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXJUcmFuc2Zvcm0gPSB0aGlzLmNhbGVuZGFyLm9wdCgnZXZlbnREYXRhVHJhbnNmb3JtJyk7XHJcbiAgICAgICAgdmFyIHNvdXJjZVRyYW5zZm9ybSA9IHRoaXMuZXZlbnREYXRhVHJhbnNmb3JtO1xyXG4gICAgICAgIGlmIChjYWxlbmRhclRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByYXdJbnB1dCA9IGNhbGVuZGFyVHJhbnNmb3JtKHJhd0lucHV0LCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNvdXJjZVRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICByYXdJbnB1dCA9IHNvdXJjZVRyYW5zZm9ybShyYXdJbnB1dCwgdGhpcy5jYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBFdmVudERlZlBhcnNlcl8xLmRlZmF1bHQucGFyc2UocmF3SW5wdXQsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50U291cmNlLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICBpZiAocmF3UHJvcHMuaWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gRXZlbnRTb3VyY2Uubm9ybWFsaXplSWQocmF3UHJvcHMuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPOiBjb252ZXJnZSB3aXRoIEV2ZW50RGVmXHJcbiAgICAgICAgaWYgKCQuaXNBcnJheShyYXdQcm9wcy5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2xhc3NOYW1lID0gcmF3UHJvcHMuY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcmF3UHJvcHMuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHJhd1Byb3BzLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBFdmVudFNvdXJjZS51dWlkID0gMDtcclxuICAgIEV2ZW50U291cmNlLmRlZmluZVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0LmRlZmluZVN0YW5kYXJkUHJvcHM7XHJcbiAgICBFdmVudFNvdXJjZS5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzID0gUGFyc2FibGVNb2RlbE1peGluXzEuZGVmYXVsdC5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzO1xyXG4gICAgcmV0dXJuIEV2ZW50U291cmNlO1xyXG59KENsYXNzXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFNvdXJjZTtcclxuUGFyc2FibGVNb2RlbE1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50U291cmNlKTtcclxuLy8gUGFyc2luZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuRXZlbnRTb3VyY2UuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICAvLyBtYW51YWxseSBwcm9jZXNzLi4uXHJcbiAgICBpZDogZmFsc2UsXHJcbiAgICBjbGFzc05hbWU6IGZhbHNlLFxyXG4gICAgLy8gYXV0b21hdGljYWxseSB0cmFuc2Zlci4uLlxyXG4gICAgY29sb3I6IHRydWUsXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IHRydWUsXHJcbiAgICBib3JkZXJDb2xvcjogdHJ1ZSxcclxuICAgIHRleHRDb2xvcjogdHJ1ZSxcclxuICAgIGVkaXRhYmxlOiB0cnVlLFxyXG4gICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcclxuICAgIGR1cmF0aW9uRWRpdGFibGU6IHRydWUsXHJcbiAgICByZW5kZXJpbmc6IHRydWUsXHJcbiAgICBvdmVybGFwOiB0cnVlLFxyXG4gICAgY29uc3RyYWludDogdHJ1ZSxcclxuICAgIGFsbERheURlZmF1bHQ6IHRydWUsXHJcbiAgICBldmVudERhdGFUcmFuc2Zvcm06IHRydWVcclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLypcclxuVXRpbGl0eSBtZXRob2RzIGZvciBlYXNpbHkgbGlzdGVuaW5nIHRvIGV2ZW50cyBvbiBhbm90aGVyIG9iamVjdCxcclxuYW5kIG1vcmUgaW1wb3J0YW50bHksIGVhc2lseSB1bmxpc3RlbmluZyBmcm9tIHRoZW0uXHJcblxuVVNBR0U6XHJcbiAgaW1wb3J0IHsgZGVmYXVsdCBhcyBMaXN0ZW5lck1peGluLCBMaXN0ZW5lckludGVyZmFjZSB9IGZyb20gJy4vTGlzdGVuZXJNaXhpbidcclxuaW4gY2xhc3M6XHJcbiAgbGlzdGVuVG86IExpc3RlbmVySW50ZXJmYWNlWydsaXN0ZW5UbyddXHJcbiAgc3RvcExpc3RlbmluZ1RvOiBMaXN0ZW5lckludGVyZmFjZVsnc3RvcExpc3RlbmluZ1RvJ11cclxuYWZ0ZXIgY2xhc3M6XHJcbiAgTGlzdGVuZXJNaXhpbi5taXhJbnRvKFRoZUNsYXNzKVxyXG4qL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG52YXIgZ3VpZCA9IDA7XHJcbnZhciBMaXN0ZW5lck1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGlzdGVuZXJNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExpc3RlbmVyTWl4aW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIEdpdmVuIGFuIGBvdGhlcmAgb2JqZWN0IHRoYXQgaGFzIG9uL29mZiBtZXRob2RzLCBiaW5kIHRoZSBnaXZlbiBgY2FsbGJhY2tgIHRvIGFuIGV2ZW50IGJ5IHRoZSBnaXZlbiBuYW1lLlxyXG4gICAgVGhlIGBjYWxsYmFja2Agd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgYHRoaXNgIGNvbnRleHQgb2YgdGhlIG9iamVjdCB0aGF0IC5saXN0ZW5UbyBpcyBiZWluZyBjYWxsZWQgb24uXHJcbiAgICBDYW4gYmUgY2FsbGVkOlxyXG4gICAgICAubGlzdGVuVG8ob3RoZXIsIGV2ZW50TmFtZSwgY2FsbGJhY2spXHJcbiAgICBPUlxyXG4gICAgICAubGlzdGVuVG8ob3RoZXIsIHtcclxuICAgICAgICBldmVudE5hbWUxOiBjYWxsYmFjazEsXHJcbiAgICAgICAgZXZlbnROYW1lMjogY2FsbGJhY2syXHJcbiAgICAgIH0pXHJcbiAgICAqL1xyXG4gICAgTGlzdGVuZXJNaXhpbi5wcm90b3R5cGUubGlzdGVuVG8gPSBmdW5jdGlvbiAob3RoZXIsIGFyZywgY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gJ29iamVjdCcpIHsgLy8gZ2l2ZW4gZGljdGlvbmFyeSBvZiBjYWxsYmFja3NcclxuICAgICAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGFyZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGFyZy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyhvdGhlciwgZXZlbnROYW1lLCBhcmdbZXZlbnROYW1lXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgb3RoZXIub24oYXJnICsgJy4nICsgdGhpcy5nZXRMaXN0ZW5lck5hbWVzcGFjZSgpLCAvLyB1c2UgZXZlbnQgbmFtZXNwYWNpbmcgdG8gaWRlbnRpZnkgdGhpcyBvYmplY3RcclxuICAgICAgICAgICAgJC5wcm94eShjYWxsYmFjaywgdGhpcykgLy8gYWx3YXlzIHVzZSBgdGhpc2AgY29udGV4dFxyXG4gICAgICAgICAgICAvLyB0aGUgdXN1YWxseS11bmRlc2lyZWQgalF1ZXJ5IGd1aWQgYmVoYXZpb3IgZG9lc24ndCBtYXR0ZXIsXHJcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgYWx3YXlzIHVuYmluZCB2aWEgbmFtZXNwYWNlXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBDYXVzZXMgdGhlIGN1cnJlbnQgb2JqZWN0IHRvIHN0b3AgbGlzdGVuaW5nIHRvIGV2ZW50cyBvbiB0aGUgYG90aGVyYCBvYmplY3QuXHJcbiAgICBgZXZlbnROYW1lYCBpcyBvcHRpb25hbC4gSWYgb21pdHRlZCwgd2lsbCBzdG9wIGxpc3RlbmluZyB0byBBTEwgZXZlbnRzIG9uIGBvdGhlcmAuXHJcbiAgICAqL1xyXG4gICAgTGlzdGVuZXJNaXhpbi5wcm90b3R5cGUuc3RvcExpc3RlbmluZ1RvID0gZnVuY3Rpb24gKG90aGVyLCBldmVudE5hbWUpIHtcclxuICAgICAgICBvdGhlci5vZmYoKGV2ZW50TmFtZSB8fCAnJykgKyAnLicgKyB0aGlzLmdldExpc3RlbmVyTmFtZXNwYWNlKCkpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBSZXR1cm5zIGEgc3RyaW5nLCB1bmlxdWUgdG8gdGhpcyBvYmplY3QsIHRvIGJlIHVzZWQgZm9yIGV2ZW50IG5hbWVzcGFjaW5nXHJcbiAgICAqL1xyXG4gICAgTGlzdGVuZXJNaXhpbi5wcm90b3R5cGUuZ2V0TGlzdGVuZXJOYW1lc3BhY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJJZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJJZCA9IGd1aWQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdfbGlzdGVuZXInICsgdGhpcy5saXN0ZW5lcklkO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMaXN0ZW5lck1peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMaXN0ZW5lck1peGluO1xyXG5cblxuLyoqKi8gfSksXG4vKiA4ICovLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcclxudmFyIEV2ZW50SW5zdGFuY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTMpO1xyXG52YXIgRXZlbnREYXRlUHJvZmlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcbnZhciBTaW5nbGVFdmVudERlZiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFNpbmdsZUV2ZW50RGVmLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gU2luZ2xlRXZlbnREZWYoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIFdpbGwgcmVjZWl2ZSBzdGFydC9lbmQgcGFyYW1zLCBidXQgd2lsbCBiZSBpZ25vcmVkLlxyXG4gICAgKi9cclxuICAgIFNpbmdsZUV2ZW50RGVmLnByb3RvdHlwZS5idWlsZEluc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMuYnVpbGRJbnN0YW5jZSgpXTtcclxuICAgIH07XHJcbiAgICBTaW5nbGVFdmVudERlZi5wcm90b3R5cGUuYnVpbGRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50SW5zdGFuY2VfMS5kZWZhdWx0KHRoaXMsIC8vIGRlZmluaXRpb25cclxuICAgICAgICB0aGlzLmRhdGVQcm9maWxlKTtcclxuICAgIH07XHJcbiAgICBTaW5nbGVFdmVudERlZi5wcm90b3R5cGUuaXNBbGxEYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0ZVByb2ZpbGUuaXNBbGxEYXkoKTtcclxuICAgIH07XHJcbiAgICBTaW5nbGVFdmVudERlZi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRlZiA9IF9zdXBlci5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcclxuICAgICAgICBkZWYuZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHJldHVybiBkZWY7XHJcbiAgICB9O1xyXG4gICAgU2luZ2xlRXZlbnREZWYucHJvdG90eXBlLnJlem9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLnNvdXJjZS5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHRoaXMuZGF0ZVByb2ZpbGUgPSBuZXcgRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQoY2FsZW5kYXIubW9tZW50KGRhdGVQcm9maWxlLnN0YXJ0KSwgZGF0ZVByb2ZpbGUuZW5kID8gY2FsZW5kYXIubW9tZW50KGRhdGVQcm9maWxlLmVuZCkgOiBudWxsLCBjYWxlbmRhcik7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE5PVEU6IGlmIHN1cGVyLW1ldGhvZCBmYWlscywgc2hvdWxkIHN0aWxsIGF0dGVtcHQgdG8gYXBwbHlcclxuICAgICovXHJcbiAgICBTaW5nbGVFdmVudERlZi5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgdmFyIHN1cGVyU3VjY2VzcyA9IF9zdXBlci5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzLmNhbGwodGhpcywgcmF3UHJvcHMpO1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0LnBhcnNlKHJhd1Byb3BzLCB0aGlzLnNvdXJjZSk7IC8vIHJldHVybnMgbnVsbCBvbiBmYWlsdXJlXHJcbiAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZVByb2ZpbGUgPSBkYXRlUHJvZmlsZTtcclxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIGBkYXRlYCBzaG93cyB1cCBpbiB0aGUgbGVnYWN5IGV2ZW50IG9iamVjdHMgYXMtaXNcclxuICAgICAgICAgICAgaWYgKHJhd1Byb3BzLmRhdGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5taXNjUHJvcHMuZGF0ZSA9IHJhd1Byb3BzLmRhdGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHN1cGVyU3VjY2VzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNpbmdsZUV2ZW50RGVmO1xyXG59KEV2ZW50RGVmXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTaW5nbGVFdmVudERlZjtcclxuLy8gUGFyc2luZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuU2luZ2xlRXZlbnREZWYuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICBzdGFydDogZmFsc2UsXHJcbiAgICBkYXRlOiBmYWxzZSxcclxuICAgIGVuZDogZmFsc2UsXHJcbiAgICBhbGxEYXk6IGZhbHNlXHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiAxMCAqLyxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBhbWJpZ0RhdGVPZk1vbnRoUmVnZXggPSAvXlxccypcXGR7NH0tXFxkXFxkJC87XHJcbnZhciBhbWJpZ1RpbWVPclpvbmVSZWdleCA9IC9eXFxzKlxcZHs0fS0oPzooXFxkXFxkLVxcZFxcZCl8KFdcXGRcXGQkKXwoV1xcZFxcZC1cXGQpfChcXGRcXGRcXGQpKSgoVHwgKShcXGRcXGQoOlxcZFxcZCg6XFxkXFxkKFxcLlxcZCspPyk/KT8pPyk/JC87XHJcbnZhciBuZXdNb21lbnRQcm90byA9IG1vbWVudC5mbjsgLy8gd2hlcmUgd2Ugd2lsbCBhdHRhY2ggb3VyIG5ldyBtZXRob2RzXHJcbmV4cG9ydHMubmV3TW9tZW50UHJvdG8gPSBuZXdNb21lbnRQcm90bztcclxudmFyIG9sZE1vbWVudFByb3RvID0gJC5leHRlbmQoe30sIG5ld01vbWVudFByb3RvKTsgLy8gY29weSBvZiBvcmlnaW5hbCBtb21lbnQgbWV0aG9kc1xyXG5leHBvcnRzLm9sZE1vbWVudFByb3RvID0gb2xkTW9tZW50UHJvdG87XHJcbi8vIHRlbGwgbW9tZW50anMgdG8gdHJhbnNmZXIgdGhlc2UgcHJvcGVydGllcyB1cG9uIGNsb25lXHJcbnZhciBtb21lbnRQcm9wZXJ0aWVzID0gbW9tZW50Lm1vbWVudFByb3BlcnRpZXM7XHJcbm1vbWVudFByb3BlcnRpZXMucHVzaCgnX2Z1bGxDYWxlbmRhcicpO1xyXG5tb21lbnRQcm9wZXJ0aWVzLnB1c2goJ19hbWJpZ1RpbWUnKTtcclxubW9tZW50UHJvcGVydGllcy5wdXNoKCdfYW1iaWdab25lJyk7XHJcbi8qXHJcbkNhbGwgdGhpcyBpZiB5b3Ugd2FudCBNb21lbnQncyBvcmlnaW5hbCBmb3JtYXQgbWV0aG9kIHRvIGJlIHVzZWRcclxuKi9cclxuZnVuY3Rpb24gb2xkTW9tZW50Rm9ybWF0KG1vbSwgZm9ybWF0U3RyKSB7XHJcbiAgICByZXR1cm4gb2xkTW9tZW50UHJvdG8uZm9ybWF0LmNhbGwobW9tLCBmb3JtYXRTdHIpOyAvLyBvbGRNb21lbnRQcm90byBkZWZpbmVkIGluIG1vbWVudC1leHQuanNcclxufVxyXG5leHBvcnRzLm9sZE1vbWVudEZvcm1hdCA9IG9sZE1vbWVudEZvcm1hdDtcclxuLy8gQ3JlYXRpbmdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDcmVhdGVzIGEgbmV3IG1vbWVudCwgc2ltaWxhciB0byB0aGUgdmFuaWxsYSBtb21lbnQoLi4uKSBjb25zdHJ1Y3RvciwgYnV0IHdpdGhcclxuLy8gZXh0cmEgZmVhdHVyZXMgKGFtYmlndW91cyB0aW1lLCBlbmhhbmNlZCBmb3JtYXR0aW5nKS4gV2hlbiBnaXZlbiBhbiBleGlzdGluZyBtb21lbnQsXHJcbi8vIGl0IHdpbGwgZnVuY3Rpb24gYXMgYSBjbG9uZSAoYW5kIHJldGFpbiB0aGUgem9uZSBvZiB0aGUgbW9tZW50KS4gQW55dGhpbmcgZWxzZSB3aWxsXHJcbi8vIHJlc3VsdCBpbiBhIG1vbWVudCBpbiB0aGUgbG9jYWwgem9uZS5cclxudmFyIG1vbWVudEV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBtYWtlTW9tZW50KGFyZ3VtZW50cyk7XHJcbn07XHJcbmV4cG9ydHMuZGVmYXVsdCA9IG1vbWVudEV4dDtcclxuLy8gU2FtZXMgYXMgbW9tZW50RXh0LCBidXQgZm9yY2VzIHRoZSByZXN1bHRpbmcgbW9tZW50IHRvIGJlIGluIHRoZSBVVEMgdGltZXpvbmUuXHJcbm1vbWVudEV4dC51dGMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgbW9tID0gbWFrZU1vbWVudChhcmd1bWVudHMsIHRydWUpO1xyXG4gICAgLy8gRm9yY2UgaXQgaW50byBVVEMgYmVjYXVzZSBtYWtlTW9tZW50IGRvZXNuJ3QgZ3VhcmFudGVlIGl0XHJcbiAgICAvLyAoaWYgZ2l2ZW4gYSBwcmUtZXhpc3RpbmcgbW9tZW50IGZvciBleGFtcGxlKVxyXG4gICAgaWYgKG1vbS5oYXNUaW1lKCkpIHsgLy8gZG9uJ3QgZ2l2ZSBhbWJpZ3VvdXNseS10aW1lZCBtb21lbnRzIGEgVVRDIHpvbmVcclxuICAgICAgICBtb20udXRjKCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tO1xyXG59O1xyXG4vLyBTYW1lIGFzIG1vbWVudEV4dCwgYnV0IHdoZW4gZ2l2ZW4gYW4gSVNPODYwMSBzdHJpbmcsIHRoZSB0aW1lem9uZSBvZmZzZXQgaXMgcHJlc2VydmVkLlxyXG4vLyBJU084NjAxIHN0cmluZ3Mgd2l0aCBubyB0aW1lem9uZSBvZmZzZXQgd2lsbCBiZWNvbWUgYW1iaWd1b3VzbHkgem9uZWQuXHJcbm1vbWVudEV4dC5wYXJzZVpvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gbWFrZU1vbWVudChhcmd1bWVudHMsIHRydWUsIHRydWUpO1xyXG59O1xyXG4vLyBCdWlsZHMgYW4gZW5oYW5jZWQgbW9tZW50IGZyb20gYXJncy4gV2hlbiBnaXZlbiBhbiBleGlzdGluZyBtb21lbnQsIGl0IGNsb25lcy4gV2hlbiBnaXZlbiBhXHJcbi8vIG5hdGl2ZSBEYXRlLCBvciBjYWxsZWQgd2l0aCBubyBhcmd1bWVudHMgKHRoZSBjdXJyZW50IHRpbWUpLCB0aGUgcmVzdWx0aW5nIG1vbWVudCB3aWxsIGJlIGxvY2FsLlxyXG4vLyBBbnl0aGluZyBlbHNlIG5lZWRzIHRvIGJlIFwicGFyc2VkXCIgKGEgc3RyaW5nIG9yIGFuIGFycmF5KSwgYW5kIHdpbGwgYmUgYWZmZWN0ZWQgYnk6XHJcbi8vICAgIHBhcnNlQXNVVEMgLSBpZiB0aGVyZSBpcyBubyB6b25lIGluZm9ybWF0aW9uLCBzaG91bGQgd2UgcGFyc2UgdGhlIGlucHV0IGluIFVUQz9cclxuLy8gICAgcGFyc2Vab25lIC0gaWYgdGhlcmUgaXMgem9uZSBpbmZvcm1hdGlvbiwgc2hvdWxkIHdlIGZvcmNlIHRoZSB6b25lIG9mIHRoZSBtb21lbnQ/XHJcbmZ1bmN0aW9uIG1ha2VNb21lbnQoYXJncywgcGFyc2VBc1VUQywgcGFyc2Vab25lKSB7XHJcbiAgICBpZiAocGFyc2VBc1VUQyA9PT0gdm9pZCAwKSB7IHBhcnNlQXNVVEMgPSBmYWxzZTsgfVxyXG4gICAgaWYgKHBhcnNlWm9uZSA9PT0gdm9pZCAwKSB7IHBhcnNlWm9uZSA9IGZhbHNlOyB9XHJcbiAgICB2YXIgaW5wdXQgPSBhcmdzWzBdO1xyXG4gICAgdmFyIGlzU2luZ2xlU3RyaW5nID0gYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJztcclxuICAgIHZhciBpc0FtYmlnVGltZTtcclxuICAgIHZhciBpc0FtYmlnWm9uZTtcclxuICAgIHZhciBhbWJpZ01hdGNoO1xyXG4gICAgdmFyIG1vbTtcclxuICAgIGlmIChtb21lbnQuaXNNb21lbnQoaW5wdXQpIHx8IHV0aWxfMS5pc05hdGl2ZURhdGUoaW5wdXQpIHx8IGlucHV0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBtb20gPSBtb21lbnQuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHsgLy8gXCJwYXJzaW5nXCIgaXMgcmVxdWlyZWRcclxuICAgICAgICBpc0FtYmlnVGltZSA9IGZhbHNlO1xyXG4gICAgICAgIGlzQW1iaWdab25lID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGlzU2luZ2xlU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChhbWJpZ0RhdGVPZk1vbnRoUmVnZXgudGVzdChpbnB1dCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIGFjY2VwdCBzdHJpbmdzIGxpa2UgJzIwMTQtMDUnLCBidXQgY29udmVydCB0byB0aGUgZmlyc3Qgb2YgdGhlIG1vbnRoXHJcbiAgICAgICAgICAgICAgICBpbnB1dCArPSAnLTAxJztcclxuICAgICAgICAgICAgICAgIGFyZ3MgPSBbaW5wdXRdOyAvLyBmb3Igd2hlbiB3ZSBwYXNzIGl0IG9uIHRvIG1vbWVudCdzIGNvbnN0cnVjdG9yXHJcbiAgICAgICAgICAgICAgICBpc0FtYmlnVGltZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBpc0FtYmlnWm9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKGFtYmlnTWF0Y2ggPSBhbWJpZ1RpbWVPclpvbmVSZWdleC5leGVjKGlucHV0KSkpIHtcclxuICAgICAgICAgICAgICAgIGlzQW1iaWdUaW1lID0gIWFtYmlnTWF0Y2hbNV07IC8vIG5vIHRpbWUgcGFydD9cclxuICAgICAgICAgICAgICAgIGlzQW1iaWdab25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgkLmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIC8vIGFycmF5cyBoYXZlIG5vIHRpbWV6b25lIGluZm9ybWF0aW9uLCBzbyBhc3N1bWUgYW1iaWd1b3VzIHpvbmVcclxuICAgICAgICAgICAgaXNBbWJpZ1pvbmUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvdGhlcndpc2UsIHByb2JhYmx5IGEgc3RyaW5nIHdpdGggYSBmb3JtYXRcclxuICAgICAgICBpZiAocGFyc2VBc1VUQyB8fCBpc0FtYmlnVGltZSkge1xyXG4gICAgICAgICAgICBtb20gPSBtb21lbnQudXRjLmFwcGx5KG1vbWVudCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtb20gPSBtb21lbnQuYXBwbHkobnVsbCwgYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FtYmlnVGltZSkge1xyXG4gICAgICAgICAgICBtb20uX2FtYmlnVGltZSA9IHRydWU7XHJcbiAgICAgICAgICAgIG1vbS5fYW1iaWdab25lID0gdHJ1ZTsgLy8gYW1iaWd1b3VzIHRpbWUgYWx3YXlzIG1lYW5zIGFtYmlndW91cyB6b25lXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcnNlWm9uZSkgeyAvLyBsZXQncyByZWNvcmQgdGhlIGlucHV0dGVkIHpvbmUgc29tZWhvd1xyXG4gICAgICAgICAgICBpZiAoaXNBbWJpZ1pvbmUpIHtcclxuICAgICAgICAgICAgICAgIG1vbS5fYW1iaWdab25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc1NpbmdsZVN0cmluZykge1xyXG4gICAgICAgICAgICAgICAgbW9tLnV0Y09mZnNldChpbnB1dCk7IC8vIGlmIG5vdCBhIHZhbGlkIHpvbmUsIHdpbGwgYXNzaWduIFVUQ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbW9tLl9mdWxsQ2FsZW5kYXIgPSB0cnVlOyAvLyBmbGFnIGZvciBleHRlbmRlZCBmdW5jdGlvbmFsaXR5XHJcbiAgICByZXR1cm4gbW9tO1xyXG59XHJcbi8vIFdlZWsgTnVtYmVyXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gUmV0dXJucyB0aGUgd2VlayBudW1iZXIsIGNvbnNpZGVyaW5nIHRoZSBsb2NhbGUncyBjdXN0b20gd2VlayBudW1iZXIgY2FsY3VhdGlvblxyXG4vLyBgd2Vla3NgIGlzIGFuIGFsaWFzIGZvciBgd2Vla2BcclxubmV3TW9tZW50UHJvdG8ud2VlayA9IG5ld01vbWVudFByb3RvLndlZWtzID0gZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICB2YXIgd2Vla0NhbGMgPSB0aGlzLl9sb2NhbGUuX2Z1bGxDYWxlbmRhcl93ZWVrQ2FsYztcclxuICAgIGlmIChpbnB1dCA9PSBudWxsICYmIHR5cGVvZiB3ZWVrQ2FsYyA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBjdXN0b20gZnVuY3Rpb24gb25seSB3b3JrcyBmb3IgZ2V0dGVyXHJcbiAgICAgICAgcmV0dXJuIHdlZWtDYWxjKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAod2Vla0NhbGMgPT09ICdJU08nKSB7XHJcbiAgICAgICAgcmV0dXJuIG9sZE1vbWVudFByb3RvLmlzb1dlZWsuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgLy8gSVNPIGdldHRlci9zZXR0ZXJcclxuICAgIH1cclxuICAgIHJldHVybiBvbGRNb21lbnRQcm90by53ZWVrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGxvY2FsIGdldHRlci9zZXR0ZXJcclxufTtcclxuLy8gVGltZS1vZi1kYXlcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBHRVRURVJcclxuLy8gUmV0dXJucyBhIER1cmF0aW9uIHdpdGggdGhlIGhvdXJzL21pbnV0ZXMvc2Vjb25kcy9tcyB2YWx1ZXMgb2YgdGhlIG1vbWVudC5cclxuLy8gSWYgdGhlIG1vbWVudCBoYXMgYW4gYW1iaWd1b3VzIHRpbWUsIGEgZHVyYXRpb24gb2YgMDA6MDAgd2lsbCBiZSByZXR1cm5lZC5cclxuLy9cclxuLy8gU0VUVEVSXHJcbi8vIFlvdSBjYW4gc3VwcGx5IGEgRHVyYXRpb24sIGEgTW9tZW50LCBvciBhIER1cmF0aW9uLWxpa2UgYXJndW1lbnQuXHJcbi8vIFdoZW4gc2V0dGluZyB0aGUgdGltZSwgYW5kIHRoZSBtb21lbnQgaGFzIGFuIGFtYmlndW91cyB0aW1lLCBpdCB0aGVuIGJlY29tZXMgdW5hbWJpZ3VvdXMuXHJcbm5ld01vbWVudFByb3RvLnRpbWUgPSBmdW5jdGlvbiAodGltZSkge1xyXG4gICAgLy8gRmFsbGJhY2sgdG8gdGhlIG9yaWdpbmFsIG1ldGhvZCAoaWYgdGhlcmUgaXMgb25lKSBpZiB0aGlzIG1vbWVudCB3YXNuJ3QgY3JlYXRlZCB2aWEgRnVsbENhbGVuZGFyLlxyXG4gICAgLy8gYHRpbWVgIGlzIGEgZ2VuZXJpYyBlbm91Z2ggbWV0aG9kIG5hbWUgd2hlcmUgdGhpcyBwcmVjYXV0aW9uIGlzIG5lY2Vzc2FyeSB0byBhdm9pZCBjb2xsaXNpb25zIHcvIG90aGVyIHBsdWdpbnMuXHJcbiAgICBpZiAoIXRoaXMuX2Z1bGxDYWxlbmRhcikge1xyXG4gICAgICAgIHJldHVybiBvbGRNb21lbnRQcm90by50aW1lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGltZSA9PSBudWxsKSB7IC8vIGdldHRlclxyXG4gICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oe1xyXG4gICAgICAgICAgICBob3VyczogdGhpcy5ob3VycygpLFxyXG4gICAgICAgICAgICBtaW51dGVzOiB0aGlzLm1pbnV0ZXMoKSxcclxuICAgICAgICAgICAgc2Vjb25kczogdGhpcy5zZWNvbmRzKCksXHJcbiAgICAgICAgICAgIG1pbGxpc2Vjb25kczogdGhpcy5taWxsaXNlY29uZHMoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7IC8vIHNldHRlclxyXG4gICAgICAgIHRoaXMuX2FtYmlnVGltZSA9IGZhbHNlOyAvLyBtYXJrIHRoYXQgdGhlIG1vbWVudCBub3cgaGFzIGEgdGltZVxyXG4gICAgICAgIGlmICghbW9tZW50LmlzRHVyYXRpb24odGltZSkgJiYgIW1vbWVudC5pc01vbWVudCh0aW1lKSkge1xyXG4gICAgICAgICAgICB0aW1lID0gbW9tZW50LmR1cmF0aW9uKHRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUaGUgZGF5IHZhbHVlIHNob3VsZCBjYXVzZSBvdmVyZmxvdyAoc28gMjQgaG91cnMgYmVjb21lcyAwMDowMDowMCBvZiBuZXh0IGRheSkuXHJcbiAgICAgICAgLy8gT25seSBmb3IgRHVyYXRpb24gdGltZXMsIG5vdCBNb21lbnQgdGltZXMuXHJcbiAgICAgICAgdmFyIGRheUhvdXJzID0gMDtcclxuICAgICAgICBpZiAobW9tZW50LmlzRHVyYXRpb24odGltZSkpIHtcclxuICAgICAgICAgICAgZGF5SG91cnMgPSBNYXRoLmZsb29yKHRpbWUuYXNEYXlzKCkpICogMjQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gc2V0IHRoZSBpbmRpdmlkdWFsIGZpZWxkcy5cclxuICAgICAgICAvLyBDYW4ndCB1c2Ugc3RhcnRPZignZGF5JykgdGhlbiBhZGQgZHVyYXRpb24uIEluIGNhc2Ugb2YgRFNUIGF0IHN0YXJ0IG9mIGRheS5cclxuICAgICAgICByZXR1cm4gdGhpcy5ob3VycyhkYXlIb3VycyArIHRpbWUuaG91cnMoKSlcclxuICAgICAgICAgICAgLm1pbnV0ZXModGltZS5taW51dGVzKCkpXHJcbiAgICAgICAgICAgIC5zZWNvbmRzKHRpbWUuc2Vjb25kcygpKVxyXG4gICAgICAgICAgICAubWlsbGlzZWNvbmRzKHRpbWUubWlsbGlzZWNvbmRzKCkpO1xyXG4gICAgfVxyXG59O1xyXG4vLyBDb252ZXJ0cyB0aGUgbW9tZW50IHRvIFVUQywgc3RyaXBwaW5nIG91dCBpdHMgdGltZS1vZi1kYXkgYW5kIHRpbWV6b25lIG9mZnNldCxcclxuLy8gYnV0IHByZXNlcnZpbmcgaXRzIFlNRC4gQSBtb21lbnQgd2l0aCBhIHN0cmlwcGVkIHRpbWUgd2lsbCBkaXNwbGF5IG5vIHRpbWVcclxuLy8gbm9yIHRpbWV6b25lIG9mZnNldCB3aGVuIC5mb3JtYXQoKSBpcyBjYWxsZWQuXHJcbm5ld01vbWVudFByb3RvLnN0cmlwVGltZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghdGhpcy5fYW1iaWdUaW1lKSB7XHJcbiAgICAgICAgdGhpcy51dGModHJ1ZSk7IC8vIGtlZXBMb2NhbFRpbWU9dHJ1ZSAoZm9yIGtlZXBpbmcgKmRhdGUqIHZhbHVlKVxyXG4gICAgICAgIC8vIHNldCB0aW1lIHRvIHplcm9cclxuICAgICAgICB0aGlzLnNldCh7XHJcbiAgICAgICAgICAgIGhvdXJzOiAwLFxyXG4gICAgICAgICAgICBtaW51dGVzOiAwLFxyXG4gICAgICAgICAgICBzZWNvbmRzOiAwLFxyXG4gICAgICAgICAgICBtczogMFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIE1hcmsgdGhlIHRpbWUgYXMgYW1iaWd1b3VzLiBUaGlzIG5lZWRzIHRvIGhhcHBlbiBhZnRlciB0aGUgLnV0YygpIGNhbGwsIHdoaWNoIG1pZ2h0IGNhbGwgLnV0Y09mZnNldCgpLFxyXG4gICAgICAgIC8vIHdoaWNoIGNsZWFycyBhbGwgYW1iaWcgZmxhZ3MuXHJcbiAgICAgICAgdGhpcy5fYW1iaWdUaW1lID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9hbWJpZ1pvbmUgPSB0cnVlOyAvLyBpZiBhbWJpZ3VvdXMgdGltZSwgYWxzbyBhbWJpZ3VvdXMgdGltZXpvbmUgb2Zmc2V0XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbn07XHJcbi8vIFJldHVybnMgaWYgdGhlIG1vbWVudCBoYXMgYSBub24tYW1iaWd1b3VzIHRpbWUgKGJvb2xlYW4pXHJcbm5ld01vbWVudFByb3RvLmhhc1RpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuX2FtYmlnVGltZTtcclxufTtcclxuLy8gVGltZXpvbmVcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vLyBDb252ZXJ0cyB0aGUgbW9tZW50IHRvIFVUQywgc3RyaXBwaW5nIG91dCBpdHMgdGltZXpvbmUgb2Zmc2V0LCBidXQgcHJlc2VydmluZyBpdHNcclxuLy8gWU1EIGFuZCB0aW1lLW9mLWRheS4gQSBtb21lbnQgd2l0aCBhIHN0cmlwcGVkIHRpbWV6b25lIG9mZnNldCB3aWxsIGRpc3BsYXkgbm9cclxuLy8gdGltZXpvbmUgb2Zmc2V0IHdoZW4gLmZvcm1hdCgpIGlzIGNhbGxlZC5cclxubmV3TW9tZW50UHJvdG8uc3RyaXBab25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHdhc0FtYmlnVGltZTtcclxuICAgIGlmICghdGhpcy5fYW1iaWdab25lKSB7XHJcbiAgICAgICAgd2FzQW1iaWdUaW1lID0gdGhpcy5fYW1iaWdUaW1lO1xyXG4gICAgICAgIHRoaXMudXRjKHRydWUpOyAvLyBrZWVwTG9jYWxUaW1lPXRydWUgKGZvciBrZWVwaW5nIGRhdGUgYW5kIHRpbWUgdmFsdWVzKVxyXG4gICAgICAgIC8vIHRoZSBhYm92ZSBjYWxsIHRvIC51dGMoKS8udXRjT2Zmc2V0KCkgdW5mb3J0dW5hdGVseSBtaWdodCBjbGVhciB0aGUgYW1iaWcgZmxhZ3MsIHNvIHJlc3RvcmVcclxuICAgICAgICB0aGlzLl9hbWJpZ1RpbWUgPSB3YXNBbWJpZ1RpbWUgfHwgZmFsc2U7XHJcbiAgICAgICAgLy8gTWFyayB0aGUgem9uZSBhcyBhbWJpZ3VvdXMuIFRoaXMgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHRoZSAudXRjKCkgY2FsbCwgd2hpY2ggbWlnaHQgY2FsbCAudXRjT2Zmc2V0KCksXHJcbiAgICAgICAgLy8gd2hpY2ggY2xlYXJzIHRoZSBhbWJpZyBmbGFncy5cclxuICAgICAgICB0aGlzLl9hbWJpZ1pvbmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG59O1xyXG4vLyBSZXR1cm5zIG9mIHRoZSBtb21lbnQgaGFzIGEgbm9uLWFtYmlndW91cyB0aW1lem9uZSBvZmZzZXQgKGJvb2xlYW4pXHJcbm5ld01vbWVudFByb3RvLmhhc1pvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMuX2FtYmlnWm9uZTtcclxufTtcclxuLy8gaW1wbGljaXRseSBtYXJrcyBhIHpvbmVcclxubmV3TW9tZW50UHJvdG8ubG9jYWwgPSBmdW5jdGlvbiAoa2VlcExvY2FsVGltZSkge1xyXG4gICAgLy8gZm9yIHdoZW4gY29udmVydGluZyBmcm9tIGFtYmlndW91c2x5LXpvbmVkIHRvIGxvY2FsLFxyXG4gICAgLy8ga2VlcCB0aGUgdGltZSB2YWx1ZXMgd2hlbiBjb252ZXJ0aW5nIGZyb20gVVRDIC0+IGxvY2FsXHJcbiAgICBvbGRNb21lbnRQcm90by5sb2NhbC5jYWxsKHRoaXMsIHRoaXMuX2FtYmlnWm9uZSB8fCBrZWVwTG9jYWxUaW1lKTtcclxuICAgIC8vIGVuc3VyZSBub24tYW1iaWd1b3VzXHJcbiAgICAvLyB0aGlzIHByb2JhYmx5IGFscmVhZHkgaGFwcGVuZWQgdmlhIGxvY2FsKCkgLT4gdXRjT2Zmc2V0KCksIGJ1dCBkb24ndCByZWx5IG9uIE1vbWVudCdzIGludGVybmFsc1xyXG4gICAgdGhpcy5fYW1iaWdUaW1lID0gZmFsc2U7XHJcbiAgICB0aGlzLl9hbWJpZ1pvbmUgPSBmYWxzZTtcclxuICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxufTtcclxuLy8gaW1wbGljaXRseSBtYXJrcyBhIHpvbmVcclxubmV3TW9tZW50UHJvdG8udXRjID0gZnVuY3Rpb24gKGtlZXBMb2NhbFRpbWUpIHtcclxuICAgIG9sZE1vbWVudFByb3RvLnV0Yy5jYWxsKHRoaXMsIGtlZXBMb2NhbFRpbWUpO1xyXG4gICAgLy8gZW5zdXJlIG5vbi1hbWJpZ3VvdXNcclxuICAgIC8vIHRoaXMgcHJvYmFibHkgYWxyZWFkeSBoYXBwZW5lZCB2aWEgdXRjKCkgLT4gdXRjT2Zmc2V0KCksIGJ1dCBkb24ndCByZWx5IG9uIE1vbWVudCdzIGludGVybmFsc1xyXG4gICAgdGhpcy5fYW1iaWdUaW1lID0gZmFsc2U7XHJcbiAgICB0aGlzLl9hbWJpZ1pvbmUgPSBmYWxzZTtcclxuICAgIHJldHVybiB0aGlzO1xyXG59O1xyXG4vLyBpbXBsaWNpdGx5IG1hcmtzIGEgem9uZSAod2lsbCBwcm9iYWJseSBnZXQgY2FsbGVkIHVwb24gLnV0YygpIGFuZCAubG9jYWwoKSlcclxubmV3TW9tZW50UHJvdG8udXRjT2Zmc2V0ID0gZnVuY3Rpb24gKHR6bykge1xyXG4gICAgaWYgKHR6byAhPSBudWxsKSB7IC8vIHNldHRlclxyXG4gICAgICAgIC8vIHRoZXNlIGFzc2lnbm1lbnRzIG5lZWRzIHRvIGhhcHBlbiBiZWZvcmUgdGhlIG9yaWdpbmFsIHpvbmUgbWV0aG9kIGlzIGNhbGxlZC5cclxuICAgICAgICAvLyBJIGZvcmdldCB3aHksIHNvbWV0aGluZyB0byBkbyB3aXRoIGEgYnJvd3NlciBjcmFzaC5cclxuICAgICAgICB0aGlzLl9hbWJpZ1RpbWUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9hbWJpZ1pvbmUgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiBvbGRNb21lbnRQcm90by51dGNPZmZzZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKlxyXG5NZWFudCB0byBiZSBpbW11dGFibGVcclxuKi9cclxudmFyIENvbXBvbmVudEZvb3RwcmludCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbXBvbmVudEZvb3RwcmludCh1bnpvbmVkUmFuZ2UsIGlzQWxsRGF5KSB7XHJcbiAgICAgICAgdGhpcy5pc0FsbERheSA9IGZhbHNlOyAvLyBjb21wb25lbnQgY2FuIGNob29zZSB0byBpZ25vcmUgdGhpc1xyXG4gICAgICAgIHRoaXMudW56b25lZFJhbmdlID0gdW56b25lZFJhbmdlO1xyXG4gICAgICAgIHRoaXMuaXNBbGxEYXkgPSBpc0FsbERheTtcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBPbmx5IHdvcmtzIGZvciBub24tb3Blbi1lbmRlZCByYW5nZXMuXHJcbiAgICAqL1xyXG4gICAgQ29tcG9uZW50Rm9vdHByaW50LnByb3RvdHlwZS50b0xlZ2FjeSA9IGZ1bmN0aW9uIChjYWxlbmRhcikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBjYWxlbmRhci5tc1RvTW9tZW50KHRoaXMudW56b25lZFJhbmdlLnN0YXJ0TXMsIHRoaXMuaXNBbGxEYXkpLFxyXG4gICAgICAgICAgICBlbmQ6IGNhbGVuZGFyLm1zVG9Nb21lbnQodGhpcy51bnpvbmVkUmFuZ2UuZW5kTXMsIHRoaXMuaXNBbGxEYXkpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29tcG9uZW50Rm9vdHByaW50O1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb21wb25lbnRGb290cHJpbnQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qXHJcblVTQUdFOlxyXG4gIGltcG9ydCB7IGRlZmF1bHQgYXMgRW1pdHRlck1peGluLCBFbWl0dGVySW50ZXJmYWNlIH0gZnJvbSAnLi9FbWl0dGVyTWl4aW4nXHJcbmluIGNsYXNzOlxyXG4gIG9uOiBFbWl0dGVySW50ZXJmYWNlWydvbiddXHJcbiAgb25lOiBFbWl0dGVySW50ZXJmYWNlWydvbmUnXVxyXG4gIG9mZjogRW1pdHRlckludGVyZmFjZVsnb2ZmJ11cclxuICB0cmlnZ2VyOiBFbWl0dGVySW50ZXJmYWNlWyd0cmlnZ2VyJ11cclxuICB0cmlnZ2VyV2l0aDogRW1pdHRlckludGVyZmFjZVsndHJpZ2dlcldpdGgnXVxyXG4gIGhhc0hhbmRsZXJzOiBFbWl0dGVySW50ZXJmYWNlWydoYXNIYW5kbGVycyddXHJcbmFmdGVyIGNsYXNzOlxyXG4gIEVtaXR0ZXJNaXhpbi5taXhJbnRvKFRoZUNsYXNzKVxyXG4qL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG52YXIgRW1pdHRlck1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRW1pdHRlck1peGluLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRW1pdHRlck1peGluKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIGpRdWVyeS1pZmljYXRpb24gdmlhICQodGhpcykgYWxsb3dzIGEgbm9uLURPTSBvYmplY3QgdG8gaGF2ZVxyXG4gICAgLy8gdGhlIHNhbWUgZXZlbnQgaGFuZGxpbmcgY2FwYWJpbGl0aWVzIChpbmNsdWRpbmcgbmFtZXNwYWNlcykuXHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgJCh0aGlzKS5vbih0eXBlcywgdGhpcy5fcHJlcGFyZUludGVyY2VwdChoYW5kbGVyKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUub25lID0gZnVuY3Rpb24gKHR5cGVzLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgJCh0aGlzKS5vbmUodHlwZXMsIHRoaXMuX3ByZXBhcmVJbnRlcmNlcHQoaGFuZGxlcikpO1xyXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLl9wcmVwYXJlSW50ZXJjZXB0ID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcclxuICAgICAgICAvLyBoYW5kbGVycyBhcmUgYWx3YXlzIGNhbGxlZCB3aXRoIGFuIFwiZXZlbnRcIiBvYmplY3QgYXMgdGhlaXIgZmlyc3QgcGFyYW0uXHJcbiAgICAgICAgLy8gc25lYWsgdGhlIGB0aGlzYCBjb250ZXh0IGFuZCBhcmd1bWVudHMgaW50byB0aGUgZXh0cmEgcGFyYW1ldGVyIG9iamVjdFxyXG4gICAgICAgIC8vIGFuZCBmb3J3YXJkIHRoZW0gb24gdG8gdGhlIG9yaWdpbmFsIGhhbmRsZXIuXHJcbiAgICAgICAgdmFyIGludGVyY2VwdCA9IGZ1bmN0aW9uIChldiwgZXh0cmEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXIuYXBwbHkoZXh0cmEuY29udGV4dCB8fCB0aGlzLCBleHRyYS5hcmdzIHx8IFtdKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIG1pbWljayBqUXVlcnkncyBpbnRlcm5hbCBcInByb3h5XCIgc3lzdGVtIChyaXNreSwgSSBrbm93KVxyXG4gICAgICAgIC8vIGNhdXNpbmcgYWxsIGZ1bmN0aW9ucyB3aXRoIHRoZSBzYW1lIC5ndWlkIHRvIGFwcGVhciB0byBiZSB0aGUgc2FtZS5cclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9ibG9iLzIuMi40L3NyYy9jb3JlLmpzI0w0NDhcclxuICAgICAgICAvLyB0aGlzIGlzIG5lZWRlZCBmb3IgY2FsbGluZyAub2ZmIHdpdGggdGhlIG9yaWdpbmFsIG5vbi1pbnRlcmNlcHQgaGFuZGxlci5cclxuICAgICAgICBpZiAoIWhhbmRsZXIuZ3VpZCkge1xyXG4gICAgICAgICAgICBoYW5kbGVyLmd1aWQgPSAkLmd1aWQrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgaW50ZXJjZXB0Lmd1aWQgPSBoYW5kbGVyLmd1aWQ7XHJcbiAgICAgICAgcmV0dXJuIGludGVyY2VwdDtcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICh0eXBlcywgaGFuZGxlcikge1xyXG4gICAgICAgICQodGhpcykub2ZmKHR5cGVzLCBoYW5kbGVyKTtcclxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXHJcbiAgICB9O1xyXG4gICAgRW1pdHRlck1peGluLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKHR5cGVzKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwYXNzIGluIFwiZXh0cmFcIiBpbmZvIHRvIHRoZSBpbnRlcmNlcHRcclxuICAgICAgICAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKHR5cGVzLCB7IGFyZ3M6IGFyZ3MgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7IC8vIGZvciBjaGFpbmluZ1xyXG4gICAgfTtcclxuICAgIEVtaXR0ZXJNaXhpbi5wcm90b3R5cGUudHJpZ2dlcldpdGggPSBmdW5jdGlvbiAodHlwZXMsIGNvbnRleHQsIGFyZ3MpIHtcclxuICAgICAgICAvLyBgdHJpZ2dlckhhbmRsZXJgIGlzIGxlc3MgcmVsaWFudCBvbiB0aGUgRE9NIGNvbXBhcmVkIHRvIGB0cmlnZ2VyYC5cclxuICAgICAgICAvLyBwYXNzIGluIFwiZXh0cmFcIiBpbmZvIHRvIHRoZSBpbnRlcmNlcHQuXHJcbiAgICAgICAgJCh0aGlzKS50cmlnZ2VySGFuZGxlcih0eXBlcywgeyBjb250ZXh0OiBjb250ZXh0LCBhcmdzOiBhcmdzIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzOyAvLyBmb3IgY2hhaW5pbmdcclxuICAgIH07XHJcbiAgICBFbWl0dGVyTWl4aW4ucHJvdG90eXBlLmhhc0hhbmRsZXJzID0gZnVuY3Rpb24gKHR5cGUpIHtcclxuICAgICAgICB2YXIgaGFzaCA9ICQuX2RhdGEodGhpcywgJ2V2ZW50cycpOyAvLyBodHRwOi8vYmxvZy5qcXVlcnkuY29tLzIwMTIvMDgvMDkvanF1ZXJ5LTEtOC1yZWxlYXNlZC9cclxuICAgICAgICByZXR1cm4gaGFzaCAmJiBoYXNoW3R5cGVdICYmIGhhc2hbdHlwZV0ubGVuZ3RoID4gMDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRW1pdHRlck1peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFbWl0dGVyTWl4aW47XHJcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEludGVyYWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSW50ZXJhY3Rpb24oY29tcG9uZW50KSB7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gY29tcG9uZW50Ll9nZXRWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICB9XHJcbiAgICBJbnRlcmFjdGlvbi5wcm90b3R5cGUub3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3Lm9wdChuYW1lKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGlvbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgY2FuIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIHJldHVybiBJbnRlcmFjdGlvbjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSW50ZXJhY3Rpb247XHJcblxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIE1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gTWl4aW4oKSB7XHJcbiAgICB9XHJcbiAgICBNaXhpbi5taXhJbnRvID0gZnVuY3Rpb24gKGRlc3RDbGFzcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgaWYgKCFkZXN0Q2xhc3MucHJvdG90eXBlW25hbWVdKSB7IC8vIGlmIGRlc3RpbmF0aW9uIGNsYXNzIGRvZXNuJ3QgYWxyZWFkeSBkZWZpbmUgaXRcclxuICAgICAgICAgICAgICAgIGRlc3RDbGFzcy5wcm90b3R5cGVbbmFtZV0gPSBfdGhpcy5wcm90b3R5cGVbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgd2lsbCBvdmVycmlkZSBleGlzdGluZyBtZXRob2RzXHJcbiAgICBUT0RPOiByZW1vdmUhIG5vdCB1c2VkIGFueW1vcmVcclxuICAgICovXHJcbiAgICBNaXhpbi5taXhPdmVyID0gZnVuY3Rpb24gKGRlc3RDbGFzcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcy5wcm90b3R5cGUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgZGVzdENsYXNzLnByb3RvdHlwZVtuYW1lXSA9IF90aGlzLnByb3RvdHlwZVtuYW1lXTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gTWl4aW47XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1peGluO1xyXG5cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbi8qXHJcbk1lYW50IHRvIGJlIGltbXV0YWJsZVxyXG4qL1xyXG52YXIgRXZlbnREYXRlUHJvZmlsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50RGF0ZVByb2ZpbGUoc3RhcnQsIGVuZCwgY2FsZW5kYXIpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLnVuem9uZWRSYW5nZSA9IHRoaXMuYnVpbGRVbnpvbmVkUmFuZ2UoY2FsZW5kYXIpO1xyXG4gICAgfVxyXG4gICAgLypcclxuICAgIE5lZWRzIGFuIEV2ZW50U291cmNlIG9iamVjdFxyXG4gICAgKi9cclxuICAgIEV2ZW50RGF0ZVByb2ZpbGUucGFyc2UgPSBmdW5jdGlvbiAocmF3UHJvcHMsIHNvdXJjZSkge1xyXG4gICAgICAgIHZhciBzdGFydElucHV0ID0gcmF3UHJvcHMuc3RhcnQgfHwgcmF3UHJvcHMuZGF0ZTtcclxuICAgICAgICB2YXIgZW5kSW5wdXQgPSByYXdQcm9wcy5lbmQ7XHJcbiAgICAgICAgaWYgKCFzdGFydElucHV0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gc291cmNlLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBzdGFydCA9IGNhbGVuZGFyLm1vbWVudChzdGFydElucHV0KTtcclxuICAgICAgICB2YXIgZW5kID0gZW5kSW5wdXQgPyBjYWxlbmRhci5tb21lbnQoZW5kSW5wdXQpIDogbnVsbDtcclxuICAgICAgICB2YXIgZm9yY2VkQWxsRGF5ID0gcmF3UHJvcHMuYWxsRGF5O1xyXG4gICAgICAgIHZhciBmb3JjZUV2ZW50RHVyYXRpb24gPSBjYWxlbmRhci5vcHQoJ2ZvcmNlRXZlbnREdXJhdGlvbicpO1xyXG4gICAgICAgIGlmICghc3RhcnQuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvcmNlZEFsbERheSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvcmNlZEFsbERheSA9IHNvdXJjZS5hbGxEYXlEZWZhdWx0O1xyXG4gICAgICAgICAgICBpZiAoZm9yY2VkQWxsRGF5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlZEFsbERheSA9IGNhbGVuZGFyLm9wdCgnYWxsRGF5RGVmYXVsdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmb3JjZWRBbGxEYXkgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgc3RhcnQuc3RyaXBUaW1lKCk7XHJcbiAgICAgICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVuZC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChmb3JjZWRBbGxEYXkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmICghc3RhcnQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC50aW1lKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgJiYgIWVuZC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIGVuZC50aW1lKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmQgJiYgKCFlbmQuaXNWYWxpZCgpIHx8ICFlbmQuaXNBZnRlcihzdGFydCkpKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghZW5kICYmIGZvcmNlRXZlbnREdXJhdGlvbikge1xyXG4gICAgICAgICAgICBlbmQgPSBjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQoIXN0YXJ0Lmhhc1RpbWUoKSwgc3RhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RGF0ZVByb2ZpbGUoc3RhcnQsIGVuZCwgY2FsZW5kYXIpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGF0ZVByb2ZpbGUuaXNTdGFuZGFyZFByb3AgPSBmdW5jdGlvbiAocHJvcE5hbWUpIHtcclxuICAgICAgICByZXR1cm4gcHJvcE5hbWUgPT09ICdzdGFydCcgfHwgcHJvcE5hbWUgPT09ICdkYXRlJyB8fCBwcm9wTmFtZSA9PT0gJ2VuZCcgfHwgcHJvcE5hbWUgPT09ICdhbGxEYXknO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGF0ZVByb2ZpbGUucHJvdG90eXBlLmlzQWxsRGF5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhKHRoaXMuc3RhcnQuaGFzVGltZSgpIHx8ICh0aGlzLmVuZCAmJiB0aGlzLmVuZC5oYXNUaW1lKCkpKTtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgTmVlZHMgYSBDYWxlbmRhciBvYmplY3RcclxuICAgICovXHJcbiAgICBFdmVudERhdGVQcm9maWxlLnByb3RvdHlwZS5idWlsZFVuem9uZWRSYW5nZSA9IGZ1bmN0aW9uIChjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBzdGFydE1zID0gdGhpcy5zdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpLnZhbHVlT2YoKTtcclxuICAgICAgICB2YXIgZW5kTXMgPSB0aGlzLmdldEVuZChjYWxlbmRhcikuc3RyaXBab25lKCkudmFsdWVPZigpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydE1zLCBlbmRNcyk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE5lZWRzIGEgQ2FsZW5kYXIgb2JqZWN0XHJcbiAgICAqL1xyXG4gICAgRXZlbnREYXRlUHJvZmlsZS5wcm90b3R5cGUuZ2V0RW5kID0gZnVuY3Rpb24gKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kID9cclxuICAgICAgICAgICAgdGhpcy5lbmQuY2xvbmUoKSA6XHJcbiAgICAgICAgICAgIC8vIGRlcml2ZSB0aGUgZW5kIGZyb20gdGhlIHN0YXJ0IGFuZCBhbGxEYXkuIGNvbXB1dGUgYWxsRGF5IGlmIG5lY2Vzc2FyeVxyXG4gICAgICAgICAgICBjYWxlbmRhci5nZXREZWZhdWx0RXZlbnRFbmQodGhpcy5pc0FsbERheSgpLCB0aGlzLnN0YXJ0KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnREYXRlUHJvZmlsZTtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnREYXRlUHJvZmlsZTtcclxuXG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcclxuLyogVHJhY2tzIG1vdXNlIG1vdmVtZW50cyBvdmVyIGEgY29tcG9uZW50IGFuZCByYWlzZXMgZXZlbnRzIGFib3V0IHdoaWNoIGhpdCB0aGUgbW91c2UgaXMgb3Zlci5cclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbm9wdGlvbnM6XHJcbi0gc3ViamVjdEVsXHJcbi0gc3ViamVjdENlbnRlclxyXG4qL1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSGl0RHJhZ0xpc3RlbmVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSGl0RHJhZ0xpc3RlbmVyKGNvbXBvbmVudCwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIENhbGxlZCB3aGVuIGRyYWcgbGlzdGVuaW5nIHN0YXJ0cyAoYnV0IGEgcmVhbCBkcmFnIGhhcyBub3QgbmVjZXNzYXJpbHkgYmVnYW4pLlxyXG4gICAgLy8gZXYgbWlnaHQgYmUgdW5kZWZpbmVkIGlmIGRyYWdnaW5nIHdhcyBzdGFydGVkIG1hbnVhbGx5LlxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvblN0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIHN1YmplY3RFbCA9IHRoaXMuc3ViamVjdEVsO1xyXG4gICAgICAgIHZhciBzdWJqZWN0UmVjdDtcclxuICAgICAgICB2YXIgb3JpZ1BvaW50O1xyXG4gICAgICAgIHZhciBwb2ludDtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5oaXRzTmVlZGVkKCk7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlU2Nyb2xsQm91bmRzKCk7IC8vIGZvciBhdXRvc2Nyb2xsXHJcbiAgICAgICAgaWYgKGV2KSB7XHJcbiAgICAgICAgICAgIG9yaWdQb2ludCA9IHsgbGVmdDogdXRpbF8xLmdldEV2WChldiksIHRvcDogdXRpbF8xLmdldEV2WShldikgfTtcclxuICAgICAgICAgICAgcG9pbnQgPSBvcmlnUG9pbnQ7XHJcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpbiB0aGUgcG9pbnQgdG8gYm91bmRzIG9mIHRoZSBlbGVtZW50IGJlaW5nIGRyYWdnZWRcclxuICAgICAgICAgICAgaWYgKHN1YmplY3RFbCkge1xyXG4gICAgICAgICAgICAgICAgc3ViamVjdFJlY3QgPSB1dGlsXzEuZ2V0T3V0ZXJSZWN0KHN1YmplY3RFbCk7IC8vIHVzZWQgZm9yIGNlbnRlcmluZyBhcyB3ZWxsXHJcbiAgICAgICAgICAgICAgICBwb2ludCA9IHV0aWxfMS5jb25zdHJhaW5Qb2ludChwb2ludCwgc3ViamVjdFJlY3QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub3JpZ0hpdCA9IHRoaXMucXVlcnlIaXQocG9pbnQubGVmdCwgcG9pbnQudG9wKTtcclxuICAgICAgICAgICAgLy8gdHJlYXQgdGhlIGNlbnRlciBvZiB0aGUgc3ViamVjdCBhcyB0aGUgY29sbGlzaW9uIHBvaW50P1xyXG4gICAgICAgICAgICBpZiAoc3ViamVjdEVsICYmIHRoaXMub3B0aW9ucy5zdWJqZWN0Q2VudGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBvbmx5IGNvbnNpZGVyIHRoZSBhcmVhIHRoZSBzdWJqZWN0IG92ZXJsYXBzIHRoZSBoaXQuIGJlc3QgZm9yIGxhcmdlIHN1YmplY3RzLlxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc2tpcCB0aGlzIGlmIGhpdCBkaWRuJ3Qgc3VwcGx5IGxlZnQvcmlnaHQvdG9wL2JvdHRvbVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN1YmplY3RSZWN0ID0gdXRpbF8xLmludGVyc2VjdFJlY3RzKHRoaXMub3JpZ0hpdCwgc3ViamVjdFJlY3QpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YmplY3RSZWN0OyAvLyBpbiBjYXNlIHRoZXJlIGlzIG5vIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcG9pbnQgPSB1dGlsXzEuZ2V0UmVjdENlbnRlcihzdWJqZWN0UmVjdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IHV0aWxfMS5kaWZmUG9pbnRzKHBvaW50LCBvcmlnUG9pbnQpOyAvLyBwb2ludCAtIG9yaWdQb2ludFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vcmlnSGl0ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jb29yZEFkanVzdCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbGwgdGhlIHN1cGVyLW1ldGhvZC4gZG8gaXQgYWZ0ZXIgb3JpZ0hpdCBoYXMgYmVlbiBjb21wdXRlZFxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25TdGFydC5jYWxsKHRoaXMsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgYWN0dWFsIGRyYWcgaGFzIHN0YXJ0ZWRcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIGhpdDtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmhhbmRsZURyYWdTdGFydC5jYWxsKHRoaXMsIGV2KTtcclxuICAgICAgICAvLyBtaWdodCBiZSBkaWZmZXJlbnQgZnJvbSB0aGlzLm9yaWdIaXQgaWYgdGhlIG1pbi1kaXN0YW5jZSBpcyBsYXJnZVxyXG4gICAgICAgIGhpdCA9IHRoaXMucXVlcnlIaXQodXRpbF8xLmdldEV2WChldiksIHV0aWxfMS5nZXRFdlkoZXYpKTtcclxuICAgICAgICAvLyByZXBvcnQgdGhlIGluaXRpYWwgaGl0IHRoZSBtb3VzZSBpcyBvdmVyXHJcbiAgICAgICAgLy8gZXNwZWNpYWxseSBpbXBvcnRhbnQgaWYgbm8gbWluLWRpc3RhbmNlIGFuZCBkcmFnIHN0YXJ0cyBpbW1lZGlhdGVseVxyXG4gICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVIaXRPdmVyKGhpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBkcmFnIG1vdmVzXHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWcgPSBmdW5jdGlvbiAoZHgsIGR5LCBldikge1xyXG4gICAgICAgIHZhciBoaXQ7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVEcmFnLmNhbGwodGhpcywgZHgsIGR5LCBldik7XHJcbiAgICAgICAgaGl0ID0gdGhpcy5xdWVyeUhpdCh1dGlsXzEuZ2V0RXZYKGV2KSwgdXRpbF8xLmdldEV2WShldikpO1xyXG4gICAgICAgIGlmICghaXNIaXRzRXF1YWwoaGl0LCB0aGlzLmhpdCkpIHsgLy8gYSBkaWZmZXJlbnQgaGl0IHRoYW4gYmVmb3JlP1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oaXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlSGl0T3V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGhpdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVIaXRPdmVyKGhpdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gZHJhZ2dpbmcgaGFzIGJlZW4gc3RvcHBlZFxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVIaXREb25lKCk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVEcmFnRW5kLmNhbGwodGhpcywgZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIGEgdGhlIG1vdXNlIGhhcyBqdXN0IG1vdmVkIG92ZXIgYSBuZXcgaGl0XHJcbiAgICBIaXREcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUhpdE92ZXIgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgdmFyIGlzT3JpZyA9IGlzSGl0c0VxdWFsKGhpdCwgdGhpcy5vcmlnSGl0KTtcclxuICAgICAgICB0aGlzLmhpdCA9IGhpdDtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2hpdE92ZXInLCB0aGlzLmhpdCwgaXNPcmlnLCB0aGlzLm9yaWdIaXQpO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBtb3VzZSBoYXMganVzdCBtb3ZlZCBvdXQgb2YgYSBoaXRcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSGl0T3V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhpdCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2hpdE91dCcsIHRoaXMuaGl0KTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVIaXREb25lKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaGl0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIGFmdGVyIGEgaGl0T3V0LiBBbHNvIGNhbGxlZCBiZWZvcmUgYSBkcmFnU3RvcFxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVIaXREb25lID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmhpdCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2hpdERvbmUnLCB0aGlzLmhpdCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHRoZSBpbnRlcmFjdGlvbiBlbmRzLCB3aGV0aGVyIHRoZXJlIHdhcyBhIHJlYWwgZHJhZyBvciBub3RcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25FbmQgPSBmdW5jdGlvbiAoZXYsIGlzQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVJbnRlcmFjdGlvbkVuZC5jYWxsKHRoaXMsIGV2LCBpc0NhbmNlbGxlZCk7XHJcbiAgICAgICAgdGhpcy5vcmlnSGl0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhpdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQuaGl0c05vdE5lZWRlZCgpO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIHNjcm9sbGluZyBoYXMgc3RvcHBlZCwgd2hldGhlciB0aHJvdWdoIGF1dG8gc2Nyb2xsLCBvciB0aGUgdXNlciBzY3JvbGxpbmdcclxuICAgIEhpdERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsRW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsRW5kLmNhbGwodGhpcyk7XHJcbiAgICAgICAgLy8gaGl0cycgYWJzb2x1dGUgcG9zaXRpb25zIHdpbGwgYmUgaW4gbmV3IHBsYWNlcyBhZnRlciBhIHVzZXIncyBzY3JvbGwuXHJcbiAgICAgICAgLy8gSEFDSyBmb3IgcmVjb21wdXRpbmcuXHJcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5yZWxlYXNlSGl0cygpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbXBvbmVudC5wcmVwYXJlSGl0cygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSBoaXQgdW5kZXJuZWF0aCB0aGUgY29vcmRpbmF0ZXMgZm9yIHRoZSBnaXZlbiBtb3VzZSBldmVudFxyXG4gICAgSGl0RHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChsZWZ0LCB0b3ApIHtcclxuICAgICAgICBpZiAodGhpcy5jb29yZEFkanVzdCkge1xyXG4gICAgICAgICAgICBsZWZ0ICs9IHRoaXMuY29vcmRBZGp1c3QubGVmdDtcclxuICAgICAgICAgICAgdG9wICs9IHRoaXMuY29vcmRBZGp1c3QudG9wO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5jb21wb25lbnQucXVlcnlIaXQobGVmdCwgdG9wKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSGl0RHJhZ0xpc3RlbmVyO1xyXG59KERyYWdMaXN0ZW5lcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSGl0RHJhZ0xpc3RlbmVyO1xyXG4vLyBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgaGl0cyBhcmUgaWRlbnRpY2FsbHkgZXF1YWwuIGBmYWxzZWAgb3RoZXJ3aXNlLiBNdXN0IGJlIGZyb20gdGhlIHNhbWUgY29tcG9uZW50LlxyXG4vLyBUd28gbnVsbCB2YWx1ZXMgd2lsbCBiZSBjb25zaWRlcmVkIGVxdWFsLCBhcyB0d28gXCJvdXQgb2YgdGhlIGNvbXBvbmVudFwiIHN0YXRlcyBhcmUgdGhlIHNhbWUuXHJcbmZ1bmN0aW9uIGlzSGl0c0VxdWFsKGhpdDAsIGhpdDEpIHtcclxuICAgIGlmICghaGl0MCAmJiAhaGl0MSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKGhpdDAgJiYgaGl0MSkge1xyXG4gICAgICAgIHJldHVybiBoaXQwLmNvbXBvbmVudCA9PT0gaGl0MS5jb21wb25lbnQgJiZcclxuICAgICAgICAgICAgaXNIaXRQcm9wc1dpdGhpbihoaXQwLCBoaXQxKSAmJlxyXG4gICAgICAgICAgICBpc0hpdFByb3BzV2l0aGluKGhpdDEsIGhpdDApOyAvLyBlbnN1cmVzIGFsbCBwcm9wcyBhcmUgaWRlbnRpY2FsXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLy8gUmV0dXJucyB0cnVlIGlmIGFsbCBvZiBzdWJIaXQncyBub24tc3RhbmRhcmQgcHJvcGVydGllcyBhcmUgd2l0aGluIHN1cGVySGl0XHJcbmZ1bmN0aW9uIGlzSGl0UHJvcHNXaXRoaW4oc3ViSGl0LCBzdXBlckhpdCkge1xyXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gc3ViSGl0KSB7XHJcbiAgICAgICAgaWYgKCEvXihjb21wb25lbnR8bGVmdHxyaWdodHx0b3B8Ym90dG9tKSQvLnRlc3QocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgICAgIGlmIChzdWJIaXRbcHJvcE5hbWVdICE9PSBzdXBlckhpdFtwcm9wTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy52ZXJzaW9uID0gJzMuMTAuMic7XHJcbi8vIFdoZW4gaW50cm9kdWNpbmcgaW50ZXJuYWwgQVBJIGluY29tcGF0aWJpbGl0aWVzICh3aGVyZSBmdWxsY2FsZW5kYXIgcGx1Z2lucyB3b3VsZCBicmVhayksXHJcbi8vIHRoZSBtaW5vciB2ZXJzaW9uIG9mIHRoZSBjYWxlbmRhciBzaG91bGQgYmUgdXBwZWQgKGV4OiAyLjcuMiAtPiAyLjguMClcclxuLy8gYW5kIHRoZSBiZWxvdyBpbnRlZ2VyIHNob3VsZCBiZSBpbmNyZW1lbnRlZC5cclxuZXhwb3J0cy5pbnRlcm5hbEFwaVZlcnNpb24gPSAxMjtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbmV4cG9ydHMuYXBwbHlBbGwgPSB1dGlsXzEuYXBwbHlBbGw7XHJcbmV4cG9ydHMuZGVib3VuY2UgPSB1dGlsXzEuZGVib3VuY2U7XHJcbmV4cG9ydHMuaXNJbnQgPSB1dGlsXzEuaXNJbnQ7XHJcbmV4cG9ydHMuaHRtbEVzY2FwZSA9IHV0aWxfMS5odG1sRXNjYXBlO1xyXG5leHBvcnRzLmNzc1RvU3RyID0gdXRpbF8xLmNzc1RvU3RyO1xyXG5leHBvcnRzLnByb3h5ID0gdXRpbF8xLnByb3h5O1xyXG5leHBvcnRzLmNhcGl0YWxpc2VGaXJzdExldHRlciA9IHV0aWxfMS5jYXBpdGFsaXNlRmlyc3RMZXR0ZXI7XHJcbmV4cG9ydHMuZ2V0T3V0ZXJSZWN0ID0gdXRpbF8xLmdldE91dGVyUmVjdDtcclxuZXhwb3J0cy5nZXRDbGllbnRSZWN0ID0gdXRpbF8xLmdldENsaWVudFJlY3Q7XHJcbmV4cG9ydHMuZ2V0Q29udGVudFJlY3QgPSB1dGlsXzEuZ2V0Q29udGVudFJlY3Q7XHJcbmV4cG9ydHMuZ2V0U2Nyb2xsYmFyV2lkdGhzID0gdXRpbF8xLmdldFNjcm9sbGJhcldpZHRocztcclxuZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IHV0aWxfMS5wcmV2ZW50RGVmYXVsdDtcclxuZXhwb3J0cy5wYXJzZUZpZWxkU3BlY3MgPSB1dGlsXzEucGFyc2VGaWVsZFNwZWNzO1xyXG5leHBvcnRzLmNvbXBhcmVCeUZpZWxkU3BlY3MgPSB1dGlsXzEuY29tcGFyZUJ5RmllbGRTcGVjcztcclxuZXhwb3J0cy5jb21wYXJlQnlGaWVsZFNwZWMgPSB1dGlsXzEuY29tcGFyZUJ5RmllbGRTcGVjO1xyXG5leHBvcnRzLmZsZXhpYmxlQ29tcGFyZSA9IHV0aWxfMS5mbGV4aWJsZUNvbXBhcmU7XHJcbmV4cG9ydHMuY29tcHV0ZUdyZWF0ZXN0VW5pdCA9IHV0aWxfMS5jb21wdXRlR3JlYXRlc3RVbml0O1xyXG5leHBvcnRzLmRpdmlkZVJhbmdlQnlEdXJhdGlvbiA9IHV0aWxfMS5kaXZpZGVSYW5nZUJ5RHVyYXRpb247XHJcbmV4cG9ydHMuZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uID0gdXRpbF8xLmRpdmlkZUR1cmF0aW9uQnlEdXJhdGlvbjtcclxuZXhwb3J0cy5tdWx0aXBseUR1cmF0aW9uID0gdXRpbF8xLm11bHRpcGx5RHVyYXRpb247XHJcbmV4cG9ydHMuZHVyYXRpb25IYXNUaW1lID0gdXRpbF8xLmR1cmF0aW9uSGFzVGltZTtcclxuZXhwb3J0cy5sb2cgPSB1dGlsXzEubG9nO1xyXG5leHBvcnRzLndhcm4gPSB1dGlsXzEud2FybjtcclxuZXhwb3J0cy5yZW1vdmVFeGFjdCA9IHV0aWxfMS5yZW1vdmVFeGFjdDtcclxuZXhwb3J0cy5pbnRlcnNlY3RSZWN0cyA9IHV0aWxfMS5pbnRlcnNlY3RSZWN0cztcclxuZXhwb3J0cy5hbGxvd1NlbGVjdGlvbiA9IHV0aWxfMS5hbGxvd1NlbGVjdGlvbjtcclxuZXhwb3J0cy5hdHRyc1RvU3RyID0gdXRpbF8xLmF0dHJzVG9TdHI7XHJcbmV4cG9ydHMuY29tcGFyZU51bWJlcnMgPSB1dGlsXzEuY29tcGFyZU51bWJlcnM7XHJcbmV4cG9ydHMuY29tcGVuc2F0ZVNjcm9sbCA9IHV0aWxfMS5jb21wZW5zYXRlU2Nyb2xsO1xyXG5leHBvcnRzLmNvbXB1dGVEdXJhdGlvbkdyZWF0ZXN0VW5pdCA9IHV0aWxfMS5jb21wdXRlRHVyYXRpb25HcmVhdGVzdFVuaXQ7XHJcbmV4cG9ydHMuY29uc3RyYWluUG9pbnQgPSB1dGlsXzEuY29uc3RyYWluUG9pbnQ7XHJcbmV4cG9ydHMuY29weU93blByb3BzID0gdXRpbF8xLmNvcHlPd25Qcm9wcztcclxuZXhwb3J0cy5kaWZmQnlVbml0ID0gdXRpbF8xLmRpZmZCeVVuaXQ7XHJcbmV4cG9ydHMuZGlmZkRheSA9IHV0aWxfMS5kaWZmRGF5O1xyXG5leHBvcnRzLmRpZmZEYXlUaW1lID0gdXRpbF8xLmRpZmZEYXlUaW1lO1xyXG5leHBvcnRzLmRpZmZQb2ludHMgPSB1dGlsXzEuZGlmZlBvaW50cztcclxuZXhwb3J0cy5kaXNhYmxlQ3Vyc29yID0gdXRpbF8xLmRpc2FibGVDdXJzb3I7XHJcbmV4cG9ydHMuZGlzdHJpYnV0ZUhlaWdodCA9IHV0aWxfMS5kaXN0cmlidXRlSGVpZ2h0O1xyXG5leHBvcnRzLmVuYWJsZUN1cnNvciA9IHV0aWxfMS5lbmFibGVDdXJzb3I7XHJcbmV4cG9ydHMuZmlyc3REZWZpbmVkID0gdXRpbF8xLmZpcnN0RGVmaW5lZDtcclxuZXhwb3J0cy5nZXRFdklzVG91Y2ggPSB1dGlsXzEuZ2V0RXZJc1RvdWNoO1xyXG5leHBvcnRzLmdldEV2WCA9IHV0aWxfMS5nZXRFdlg7XHJcbmV4cG9ydHMuZ2V0RXZZID0gdXRpbF8xLmdldEV2WTtcclxuZXhwb3J0cy5nZXRSZWN0Q2VudGVyID0gdXRpbF8xLmdldFJlY3RDZW50ZXI7XHJcbmV4cG9ydHMuZ2V0U2Nyb2xsUGFyZW50ID0gdXRpbF8xLmdldFNjcm9sbFBhcmVudDtcclxuZXhwb3J0cy5oYXNPd25Qcm9wID0gdXRpbF8xLmhhc093blByb3A7XHJcbmV4cG9ydHMuaXNBcnJheXNFcXVhbCA9IHV0aWxfMS5pc0FycmF5c0VxdWFsO1xyXG5leHBvcnRzLmlzTmF0aXZlRGF0ZSA9IHV0aWxfMS5pc05hdGl2ZURhdGU7XHJcbmV4cG9ydHMuaXNQcmltYXJ5TW91c2VCdXR0b24gPSB1dGlsXzEuaXNQcmltYXJ5TW91c2VCdXR0b247XHJcbmV4cG9ydHMuaXNUaW1lU3RyaW5nID0gdXRpbF8xLmlzVGltZVN0cmluZztcclxuZXhwb3J0cy5tYXRjaENlbGxXaWR0aHMgPSB1dGlsXzEubWF0Y2hDZWxsV2lkdGhzO1xyXG5leHBvcnRzLm1lcmdlUHJvcHMgPSB1dGlsXzEubWVyZ2VQcm9wcztcclxuZXhwb3J0cy5wcmV2ZW50U2VsZWN0aW9uID0gdXRpbF8xLnByZXZlbnRTZWxlY3Rpb247XHJcbmV4cG9ydHMucmVtb3ZlTWF0Y2hpbmcgPSB1dGlsXzEucmVtb3ZlTWF0Y2hpbmc7XHJcbmV4cG9ydHMuc3RyaXBIdG1sRW50aXRpZXMgPSB1dGlsXzEuc3RyaXBIdG1sRW50aXRpZXM7XHJcbmV4cG9ydHMuc3VidHJhY3RJbm5lckVsSGVpZ2h0ID0gdXRpbF8xLnN1YnRyYWN0SW5uZXJFbEhlaWdodDtcclxuZXhwb3J0cy51bmNvbXBlbnNhdGVTY3JvbGwgPSB1dGlsXzEudW5jb21wZW5zYXRlU2Nyb2xsO1xyXG5leHBvcnRzLnVuZGlzdHJpYnV0ZUhlaWdodCA9IHV0aWxfMS51bmRpc3RyaWJ1dGVIZWlnaHQ7XHJcbmV4cG9ydHMuZGF5SURzID0gdXRpbF8xLmRheUlEcztcclxuZXhwb3J0cy51bml0c0Rlc2MgPSB1dGlsXzEudW5pdHNEZXNjO1xyXG52YXIgZGF0ZV9mb3JtYXR0aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KTtcclxuZXhwb3J0cy5mb3JtYXREYXRlID0gZGF0ZV9mb3JtYXR0aW5nXzEuZm9ybWF0RGF0ZTtcclxuZXhwb3J0cy5mb3JtYXRSYW5nZSA9IGRhdGVfZm9ybWF0dGluZ18xLmZvcm1hdFJhbmdlO1xyXG5leHBvcnRzLnF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdCA9IGRhdGVfZm9ybWF0dGluZ18xLnF1ZXJ5TW9zdEdyYW51bGFyRm9ybWF0VW5pdDtcclxudmFyIGxvY2FsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XHJcbmV4cG9ydHMuZGF0ZXBpY2tlckxvY2FsZSA9IGxvY2FsZV8xLmRhdGVwaWNrZXJMb2NhbGU7XHJcbmV4cG9ydHMubG9jYWxlID0gbG9jYWxlXzEubG9jYWxlO1xyXG5leHBvcnRzLmdldE1vbWVudExvY2FsZURhdGEgPSBsb2NhbGVfMS5nZXRNb21lbnRMb2NhbGVEYXRhO1xyXG5leHBvcnRzLnBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyA9IGxvY2FsZV8xLnBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucztcclxudmFyIHV0aWxfMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG5leHBvcnRzLmV2ZW50RGVmc1RvRXZlbnRJbnN0YW5jZXMgPSB1dGlsXzIuZXZlbnREZWZzVG9FdmVudEluc3RhbmNlcztcclxuZXhwb3J0cy5ldmVudEZvb3RwcmludFRvQ29tcG9uZW50Rm9vdHByaW50ID0gdXRpbF8yLmV2ZW50Rm9vdHByaW50VG9Db21wb25lbnRGb290cHJpbnQ7XHJcbmV4cG9ydHMuZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZSA9IHV0aWxfMi5ldmVudEluc3RhbmNlVG9FdmVudFJhbmdlO1xyXG5leHBvcnRzLmV2ZW50SW5zdGFuY2VUb1Vuem9uZWRSYW5nZSA9IHV0aWxfMi5ldmVudEluc3RhbmNlVG9VbnpvbmVkUmFuZ2U7XHJcbmV4cG9ydHMuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQgPSB1dGlsXzIuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQ7XHJcbnZhciBtb21lbnRfZXh0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuZXhwb3J0cy5tb21lbnQgPSBtb21lbnRfZXh0XzEuZGVmYXVsdDtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbmV4cG9ydHMuRW1pdHRlck1peGluID0gRW1pdHRlck1peGluXzEuZGVmYXVsdDtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbmV4cG9ydHMuTGlzdGVuZXJNaXhpbiA9IExpc3RlbmVyTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgTW9kZWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTEpO1xyXG5leHBvcnRzLk1vZGVsID0gTW9kZWxfMS5kZWZhdWx0O1xyXG52YXIgQ29uc3RyYWludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjE3KTtcclxuZXhwb3J0cy5Db25zdHJhaW50cyA9IENvbnN0cmFpbnRzXzEuZGVmYXVsdDtcclxudmFyIERhdGVQcm9maWxlR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KTtcclxuZXhwb3J0cy5EYXRlUHJvZmlsZUdlbmVyYXRvciA9IERhdGVQcm9maWxlR2VuZXJhdG9yXzEuZGVmYXVsdDtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuZXhwb3J0cy5VbnpvbmVkUmFuZ2UgPSBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0O1xyXG52YXIgQ29tcG9uZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxuZXhwb3J0cy5Db21wb25lbnRGb290cHJpbnQgPSBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0O1xyXG52YXIgQnVzaW5lc3NIb3VyR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOCk7XHJcbmV4cG9ydHMuQnVzaW5lc3NIb3VyR2VuZXJhdG9yID0gQnVzaW5lc3NIb3VyR2VuZXJhdG9yXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50UGVyaW9kXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOSk7XHJcbmV4cG9ydHMuRXZlbnRQZXJpb2QgPSBFdmVudFBlcmlvZF8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudE1hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIwKTtcclxuZXhwb3J0cy5FdmVudE1hbmFnZXIgPSBFdmVudE1hbmFnZXJfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xyXG5leHBvcnRzLkV2ZW50RGVmID0gRXZlbnREZWZfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnREZWZNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XHJcbmV4cG9ydHMuRXZlbnREZWZNdXRhdGlvbiA9IEV2ZW50RGVmTXV0YXRpb25fMS5kZWZhdWx0O1xyXG52YXIgRXZlbnREZWZQYXJzZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzYpO1xyXG5leHBvcnRzLkV2ZW50RGVmUGFyc2VyID0gRXZlbnREZWZQYXJzZXJfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRJbnN0YW5jZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XHJcbmV4cG9ydHMuRXZlbnRJbnN0YW5jZSA9IEV2ZW50SW5zdGFuY2VfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MCk7XHJcbmV4cG9ydHMuRXZlbnRSYW5nZSA9IEV2ZW50UmFuZ2VfMS5kZWZhdWx0O1xyXG52YXIgUmVjdXJyaW5nRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xyXG5leHBvcnRzLlJlY3VycmluZ0V2ZW50RGVmID0gUmVjdXJyaW5nRXZlbnREZWZfMS5kZWZhdWx0O1xyXG52YXIgU2luZ2xlRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcbmV4cG9ydHMuU2luZ2xlRXZlbnREZWYgPSBTaW5nbGVFdmVudERlZl8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudERlZkRhdGVNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XHJcbmV4cG9ydHMuRXZlbnREZWZEYXRlTXV0YXRpb24gPSBFdmVudERlZkRhdGVNdXRhdGlvbl8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudERhdGVQcm9maWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuZXhwb3J0cy5FdmVudERhdGVQcm9maWxlID0gRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudFNvdXJjZVBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcbmV4cG9ydHMuRXZlbnRTb3VyY2VQYXJzZXIgPSBFdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQ7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuZXhwb3J0cy5FdmVudFNvdXJjZSA9IEV2ZW50U291cmNlXzEuZGVmYXVsdDtcclxudmFyIFRoZW1lUmVnaXN0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xyXG5leHBvcnRzLmRlZmluZVRoZW1lU3lzdGVtID0gVGhlbWVSZWdpc3RyeV8xLmRlZmluZVRoZW1lU3lzdGVtO1xyXG5leHBvcnRzLmdldFRoZW1lU3lzdGVtQ2xhc3MgPSBUaGVtZVJlZ2lzdHJ5XzEuZ2V0VGhlbWVTeXN0ZW1DbGFzcztcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbmV4cG9ydHMuRXZlbnRJbnN0YW5jZUdyb3VwID0gRXZlbnRJbnN0YW5jZUdyb3VwXzEuZGVmYXVsdDtcclxudmFyIEFycmF5RXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTYpO1xyXG5leHBvcnRzLkFycmF5RXZlbnRTb3VyY2UgPSBBcnJheUV2ZW50U291cmNlXzEuZGVmYXVsdDtcclxudmFyIEZ1bmNFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjMpO1xyXG5leHBvcnRzLkZ1bmNFdmVudFNvdXJjZSA9IEZ1bmNFdmVudFNvdXJjZV8xLmRlZmF1bHQ7XHJcbnZhciBKc29uRmVlZEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNCk7XHJcbmV4cG9ydHMuSnNvbkZlZWRFdmVudFNvdXJjZSA9IEpzb25GZWVkRXZlbnRTb3VyY2VfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRGb290cHJpbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG5leHBvcnRzLkV2ZW50Rm9vdHByaW50ID0gRXZlbnRGb290cHJpbnRfMS5kZWZhdWx0O1xyXG52YXIgQ2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG5leHBvcnRzLkNsYXNzID0gQ2xhc3NfMS5kZWZhdWx0O1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG5leHBvcnRzLk1peGluID0gTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgQ29vcmRDYWNoZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XHJcbmV4cG9ydHMuQ29vcmRDYWNoZSA9IENvb3JkQ2FjaGVfMS5kZWZhdWx0O1xyXG52YXIgSXRlcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI1KTtcclxuZXhwb3J0cy5JdGVyYXRvciA9IEl0ZXJhdG9yXzEuZGVmYXVsdDtcclxudmFyIERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSk7XHJcbmV4cG9ydHMuRHJhZ0xpc3RlbmVyID0gRHJhZ0xpc3RlbmVyXzEuZGVmYXVsdDtcclxudmFyIEhpdERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbmV4cG9ydHMuSGl0RHJhZ0xpc3RlbmVyID0gSGl0RHJhZ0xpc3RlbmVyXzEuZGVmYXVsdDtcclxudmFyIE1vdXNlRm9sbG93ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjI2KTtcclxuZXhwb3J0cy5Nb3VzZUZvbGxvd2VyID0gTW91c2VGb2xsb3dlcl8xLmRlZmF1bHQ7XHJcbnZhciBQYXJzYWJsZU1vZGVsTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xyXG5leHBvcnRzLlBhcnNhYmxlTW9kZWxNaXhpbiA9IFBhcnNhYmxlTW9kZWxNaXhpbl8xLmRlZmF1bHQ7XHJcbnZhciBQb3BvdmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNyk7XHJcbmV4cG9ydHMuUG9wb3ZlciA9IFBvcG92ZXJfMS5kZWZhdWx0O1xyXG52YXIgUHJvbWlzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcbmV4cG9ydHMuUHJvbWlzZSA9IFByb21pc2VfMS5kZWZhdWx0O1xyXG52YXIgVGFza1F1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyOCk7XHJcbmV4cG9ydHMuVGFza1F1ZXVlID0gVGFza1F1ZXVlXzEuZGVmYXVsdDtcclxudmFyIFJlbmRlclF1ZXVlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyOSk7XHJcbmV4cG9ydHMuUmVuZGVyUXVldWUgPSBSZW5kZXJRdWV1ZV8xLmRlZmF1bHQ7XHJcbnZhciBTY3JvbGxlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MSk7XHJcbmV4cG9ydHMuU2Nyb2xsZXIgPSBTY3JvbGxlcl8xLmRlZmF1bHQ7XHJcbnZhciBUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcbmV4cG9ydHMuVGhlbWUgPSBUaGVtZV8xLmRlZmF1bHQ7XHJcbnZhciBDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMwKTtcclxuZXhwb3J0cy5Db21wb25lbnQgPSBDb21wb25lbnRfMS5kZWZhdWx0O1xyXG52YXIgRGF0ZUNvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzEpO1xyXG5leHBvcnRzLkRhdGVDb21wb25lbnQgPSBEYXRlQ29tcG9uZW50XzEuZGVmYXVsdDtcclxudmFyIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XHJcbmV4cG9ydHMuSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50ID0gSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEuZGVmYXVsdDtcclxudmFyIENhbGVuZGFyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzMik7XHJcbmV4cG9ydHMuQ2FsZW5kYXIgPSBDYWxlbmRhcl8xLmRlZmF1bHQ7XHJcbnZhciBWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcclxuZXhwb3J0cy5WaWV3ID0gVmlld18xLmRlZmF1bHQ7XHJcbnZhciBWaWV3UmVnaXN0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xyXG5leHBvcnRzLmRlZmluZVZpZXcgPSBWaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3O1xyXG5leHBvcnRzLmdldFZpZXdDb25maWcgPSBWaWV3UmVnaXN0cnlfMS5nZXRWaWV3Q29uZmlnO1xyXG52YXIgRGF5VGFibGVNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MCk7XHJcbmV4cG9ydHMuRGF5VGFibGVNaXhpbiA9IERheVRhYmxlTWl4aW5fMS5kZWZhdWx0O1xyXG52YXIgQnVzaW5lc3NIb3VyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG5leHBvcnRzLkJ1c2luZXNzSG91clJlbmRlcmVyID0gQnVzaW5lc3NIb3VyUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG52YXIgRXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XHJcbmV4cG9ydHMuRXZlbnRSZW5kZXJlciA9IEV2ZW50UmVuZGVyZXJfMS5kZWZhdWx0O1xyXG52YXIgRmlsbFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYyKTtcclxuZXhwb3J0cy5GaWxsUmVuZGVyZXIgPSBGaWxsUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG52YXIgSGVscGVyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjMpO1xyXG5leHBvcnRzLkhlbHBlclJlbmRlcmVyID0gSGVscGVyUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG52YXIgRXh0ZXJuYWxEcm9wcGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzMpO1xyXG5leHBvcnRzLkV4dGVybmFsRHJvcHBpbmcgPSBFeHRlcm5hbERyb3BwaW5nXzEuZGVmYXVsdDtcclxudmFyIEV2ZW50UmVzaXppbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjM0KTtcclxuZXhwb3J0cy5FdmVudFJlc2l6aW5nID0gRXZlbnRSZXNpemluZ18xLmRlZmF1bHQ7XHJcbnZhciBFdmVudFBvaW50aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcclxuZXhwb3J0cy5FdmVudFBvaW50aW5nID0gRXZlbnRQb2ludGluZ18xLmRlZmF1bHQ7XHJcbnZhciBFdmVudERyYWdnaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNSk7XHJcbmV4cG9ydHMuRXZlbnREcmFnZ2luZyA9IEV2ZW50RHJhZ2dpbmdfMS5kZWZhdWx0O1xyXG52YXIgRGF0ZVNlbGVjdGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzYpO1xyXG5leHBvcnRzLkRhdGVTZWxlY3RpbmcgPSBEYXRlU2VsZWN0aW5nXzEuZGVmYXVsdDtcclxudmFyIERhdGVDbGlja2luZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzcpO1xyXG5leHBvcnRzLkRhdGVDbGlja2luZyA9IERhdGVDbGlja2luZ18xLmRlZmF1bHQ7XHJcbnZhciBJbnRlcmFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcbmV4cG9ydHMuSW50ZXJhY3Rpb24gPSBJbnRlcmFjdGlvbl8xLmRlZmF1bHQ7XHJcbnZhciBTdGFuZGFyZEludGVyYWN0aW9uc01peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcclxuZXhwb3J0cy5TdGFuZGFyZEludGVyYWN0aW9uc01peGluID0gU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbl8xLmRlZmF1bHQ7XHJcbnZhciBBZ2VuZGFWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzOCk7XHJcbmV4cG9ydHMuQWdlbmRhVmlldyA9IEFnZW5kYVZpZXdfMS5kZWZhdWx0O1xyXG52YXIgVGltZUdyaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjM5KTtcclxuZXhwb3J0cy5UaW1lR3JpZCA9IFRpbWVHcmlkXzEuZGVmYXVsdDtcclxudmFyIFRpbWVHcmlkRXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDApO1xyXG5leHBvcnRzLlRpbWVHcmlkRXZlbnRSZW5kZXJlciA9IFRpbWVHcmlkRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbnZhciBUaW1lR3JpZEZpbGxSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDIpO1xyXG5leHBvcnRzLlRpbWVHcmlkRmlsbFJlbmRlcmVyID0gVGltZUdyaWRGaWxsUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG52YXIgVGltZUdyaWRIZWxwZXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDEpO1xyXG5leHBvcnRzLlRpbWVHcmlkSGVscGVyUmVuZGVyZXIgPSBUaW1lR3JpZEhlbHBlclJlbmRlcmVyXzEuZGVmYXVsdDtcclxudmFyIERheUdyaWRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjYpO1xyXG5leHBvcnRzLkRheUdyaWQgPSBEYXlHcmlkXzEuZGVmYXVsdDtcclxudmFyIERheUdyaWRFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0Myk7XHJcbmV4cG9ydHMuRGF5R3JpZEV2ZW50UmVuZGVyZXIgPSBEYXlHcmlkRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbnZhciBEYXlHcmlkRmlsbFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NSk7XHJcbmV4cG9ydHMuRGF5R3JpZEZpbGxSZW5kZXJlciA9IERheUdyaWRGaWxsUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG52YXIgRGF5R3JpZEhlbHBlclJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0NCk7XHJcbmV4cG9ydHMuRGF5R3JpZEhlbHBlclJlbmRlcmVyID0gRGF5R3JpZEhlbHBlclJlbmRlcmVyXzEuZGVmYXVsdDtcclxudmFyIEJhc2ljVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XHJcbmV4cG9ydHMuQmFzaWNWaWV3ID0gQmFzaWNWaWV3XzEuZGVmYXVsdDtcclxudmFyIEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcclxuZXhwb3J0cy5CYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvciA9IEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yXzEuZGVmYXVsdDtcclxudmFyIE1vbnRoVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDYpO1xyXG5leHBvcnRzLk1vbnRoVmlldyA9IE1vbnRoVmlld18xLmRlZmF1bHQ7XHJcbnZhciBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDcpO1xyXG5leHBvcnRzLk1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yID0gTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3JfMS5kZWZhdWx0O1xyXG52YXIgTGlzdFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ4KTtcclxuZXhwb3J0cy5MaXN0VmlldyA9IExpc3RWaWV3XzEuZGVmYXVsdDtcclxudmFyIExpc3RFdmVudFBvaW50aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1MCk7XHJcbmV4cG9ydHMuTGlzdEV2ZW50UG9pbnRpbmcgPSBMaXN0RXZlbnRQb2ludGluZ18xLmRlZmF1bHQ7XHJcbnZhciBMaXN0RXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDkpO1xyXG5leHBvcnRzLkxpc3RFdmVudFJlbmRlcmVyID0gTGlzdEV2ZW50UmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5cblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFdmVudFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcclxudmFyIEV2ZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbmZ1bmN0aW9uIGV2ZW50RGVmc1RvRXZlbnRJbnN0YW5jZXMoZXZlbnREZWZzLCB1bnpvbmVkUmFuZ2UpIHtcclxuICAgIHZhciBldmVudEluc3RhbmNlcyA9IFtdO1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnREZWZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgZXZlbnRJbnN0YW5jZXMucHVzaC5hcHBseShldmVudEluc3RhbmNlcywgLy8gYXBwZW5kXHJcbiAgICAgICAgZXZlbnREZWZzW2ldLmJ1aWxkSW5zdGFuY2VzKHVuem9uZWRSYW5nZSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGV2ZW50SW5zdGFuY2VzO1xyXG59XHJcbmV4cG9ydHMuZXZlbnREZWZzVG9FdmVudEluc3RhbmNlcyA9IGV2ZW50RGVmc1RvRXZlbnRJbnN0YW5jZXM7XHJcbmZ1bmN0aW9uIGV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgcmV0dXJuIG5ldyBFdmVudFJhbmdlXzEuZGVmYXVsdChldmVudEluc3RhbmNlLmRhdGVQcm9maWxlLnVuem9uZWRSYW5nZSwgZXZlbnRJbnN0YW5jZS5kZWYsIGV2ZW50SW5zdGFuY2UpO1xyXG59XHJcbmV4cG9ydHMuZXZlbnRJbnN0YW5jZVRvRXZlbnRSYW5nZSA9IGV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2U7XHJcbmZ1bmN0aW9uIGV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50KGV2ZW50UmFuZ2UpIHtcclxuICAgIHJldHVybiBuZXcgRXZlbnRGb290cHJpbnRfMS5kZWZhdWx0KG5ldyBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0KGV2ZW50UmFuZ2UudW56b25lZFJhbmdlLCBldmVudFJhbmdlLmV2ZW50RGVmLmlzQWxsRGF5KCkpLCBldmVudFJhbmdlLmV2ZW50RGVmLCBldmVudFJhbmdlLmV2ZW50SW5zdGFuY2UgLy8gbWlnaHQgbm90IGV4aXN0XHJcbiAgICApO1xyXG59XHJcbmV4cG9ydHMuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQgPSBldmVudFJhbmdlVG9FdmVudEZvb3RwcmludDtcclxuZnVuY3Rpb24gZXZlbnRJbnN0YW5jZVRvVW56b25lZFJhbmdlKGV2ZW50SW5zdGFuY2UpIHtcclxuICAgIHJldHVybiBldmVudEluc3RhbmNlLmRhdGVQcm9maWxlLnVuem9uZWRSYW5nZTtcclxufVxyXG5leHBvcnRzLmV2ZW50SW5zdGFuY2VUb1Vuem9uZWRSYW5nZSA9IGV2ZW50SW5zdGFuY2VUb1Vuem9uZWRSYW5nZTtcclxuZnVuY3Rpb24gZXZlbnRGb290cHJpbnRUb0NvbXBvbmVudEZvb3RwcmludChldmVudEZvb3RwcmludCkge1xyXG4gICAgcmV0dXJuIGV2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludDtcclxufVxyXG5leHBvcnRzLmV2ZW50Rm9vdHByaW50VG9Db21wb25lbnRGb290cHJpbnQgPSBldmVudEZvb3RwcmludFRvQ29tcG9uZW50Rm9vdHByaW50O1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxudmFyIEV2ZW50UmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTApO1xyXG4vKlxyXG5JdCdzIGV4cGVjdGVkIHRoYXQgdGhlcmUgd2lsbCBiZSBhdCBsZWFzdCBvbmUgRXZlbnRJbnN0YW5jZSxcclxuT1IgdGhhdCBhbiBleHBsaWNpdEV2ZW50RGVmIGlzIGFzc2lnbmVkLlxyXG4qL1xyXG52YXIgRXZlbnRJbnN0YW5jZUdyb3VwID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRJbnN0YW5jZUdyb3VwKGV2ZW50SW5zdGFuY2VzKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudEluc3RhbmNlcyA9IGV2ZW50SW5zdGFuY2VzIHx8IFtdO1xyXG4gICAgfVxyXG4gICAgRXZlbnRJbnN0YW5jZUdyb3VwLnByb3RvdHlwZS5nZXRBbGxFdmVudFJhbmdlcyA9IGZ1bmN0aW9uIChjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICBpZiAoY29uc3RyYWludFJhbmdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNsaWNlTm9ybWFsUmVuZGVyUmFuZ2VzKGNvbnN0cmFpbnRSYW5nZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEluc3RhbmNlcy5tYXAodXRpbF8xLmV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLnNsaWNlUmVuZGVyUmFuZ2VzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRSYW5nZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmlzSW52ZXJzZSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNsaWNlSW52ZXJzZVJlbmRlclJhbmdlcyhjb25zdHJhaW50UmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2xpY2VOb3JtYWxSZW5kZXJSYW5nZXMoY29uc3RyYWludFJhbmdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRJbnN0YW5jZUdyb3VwLnByb3RvdHlwZS5zbGljZU5vcm1hbFJlbmRlclJhbmdlcyA9IGZ1bmN0aW9uIChjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZXMgPSB0aGlzLmV2ZW50SW5zdGFuY2VzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlO1xyXG4gICAgICAgIHZhciBzbGljZWRSYW5nZTtcclxuICAgICAgICB2YXIgc2xpY2VkRXZlbnRSYW5nZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZSA9IGV2ZW50SW5zdGFuY2VzW2ldO1xyXG4gICAgICAgICAgICBzbGljZWRSYW5nZSA9IGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUudW56b25lZFJhbmdlLmludGVyc2VjdChjb25zdHJhaW50UmFuZ2UpO1xyXG4gICAgICAgICAgICBpZiAoc2xpY2VkUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHNsaWNlZEV2ZW50UmFuZ2VzLnB1c2gobmV3IEV2ZW50UmFuZ2VfMS5kZWZhdWx0KHNsaWNlZFJhbmdlLCBldmVudEluc3RhbmNlLmRlZiwgZXZlbnRJbnN0YW5jZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzbGljZWRFdmVudFJhbmdlcztcclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLnNsaWNlSW52ZXJzZVJlbmRlclJhbmdlcyA9IGZ1bmN0aW9uIChjb25zdHJhaW50UmFuZ2UpIHtcclxuICAgICAgICB2YXIgdW56b25lZFJhbmdlcyA9IHRoaXMuZXZlbnRJbnN0YW5jZXMubWFwKHV0aWxfMS5ldmVudEluc3RhbmNlVG9VbnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHZhciBvd25lckRlZiA9IHRoaXMuZ2V0RXZlbnREZWYoKTtcclxuICAgICAgICB1bnpvbmVkUmFuZ2VzID0gVW56b25lZFJhbmdlXzEuZGVmYXVsdC5pbnZlcnRSYW5nZXModW56b25lZFJhbmdlcywgY29uc3RyYWludFJhbmdlKTtcclxuICAgICAgICByZXR1cm4gdW56b25lZFJhbmdlcy5tYXAoZnVuY3Rpb24gKHVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50UmFuZ2VfMS5kZWZhdWx0KHVuem9uZWRSYW5nZSwgb3duZXJEZWYpOyAvLyBkb24ndCBnaXZlIGFuIEV2ZW50SW5zdGFuY2VcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLmlzSW52ZXJzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRFdmVudERlZigpLmhhc0ludmVyc2VSZW5kZXJpbmcoKTtcclxuICAgIH07XHJcbiAgICBFdmVudEluc3RhbmNlR3JvdXAucHJvdG90eXBlLmdldEV2ZW50RGVmID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV4cGxpY2l0RXZlbnREZWYgfHwgdGhpcy5ldmVudEluc3RhbmNlc1swXS5kZWY7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50SW5zdGFuY2VHcm91cDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRJbnN0YW5jZUdyb3VwO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIFByb21pc2VTdHViID0ge1xyXG4gICAgY29uc3RydWN0OiBmdW5jdGlvbiAoZXhlY3V0b3IpIHtcclxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCk7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBleGVjdXRvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBleGVjdXRvcihmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHZhbCk7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlc29sdmluZ1RoZW4ocHJvbWlzZSwgdmFsKTtcclxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KCk7XHJcbiAgICAgICAgICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlamVjdGluZ1RoZW4ocHJvbWlzZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH0sXHJcbiAgICByZXNvbHZlOiBmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgdmFyIGRlZmVycmVkID0gJC5EZWZlcnJlZCgpLnJlc29sdmUodmFsKTtcclxuICAgICAgICB2YXIgcHJvbWlzZSA9IGRlZmVycmVkLnByb21pc2UoKTtcclxuICAgICAgICBhdHRhY2hJbW1lZGlhdGVseVJlc29sdmluZ1RoZW4ocHJvbWlzZSwgdmFsKTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH0sXHJcbiAgICByZWplY3Q6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVmZXJyZWQgPSAkLkRlZmVycmVkKCkucmVqZWN0KCk7XHJcbiAgICAgICAgdmFyIHByb21pc2UgPSBkZWZlcnJlZC5wcm9taXNlKCk7XHJcbiAgICAgICAgYXR0YWNoSW1tZWRpYXRlbHlSZWplY3RpbmdUaGVuKHByb21pc2UpO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG59O1xyXG5leHBvcnRzLmRlZmF1bHQgPSBQcm9taXNlU3R1YjtcclxuZnVuY3Rpb24gYXR0YWNoSW1tZWRpYXRlbHlSZXNvbHZpbmdUaGVuKHByb21pc2UsIHZhbCkge1xyXG4gICAgcHJvbWlzZS50aGVuID0gZnVuY3Rpb24gKG9uUmVzb2x2ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb25SZXNvbHZlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlU3R1Yi5yZXNvbHZlKG9uUmVzb2x2ZSh2YWwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIGF0dGFjaEltbWVkaWF0ZWx5UmVqZWN0aW5nVGhlbihwcm9taXNlKSB7XHJcbiAgICBwcm9taXNlLnRoZW4gPSBmdW5jdGlvbiAob25SZXNvbHZlLCBvblJlamVjdCkge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgb25SZWplY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9O1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgVGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBUaGVtZShvcHRpb25zTWFuYWdlcikge1xyXG4gICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIgPSBvcHRpb25zTWFuYWdlcjtcclxuICAgICAgICB0aGlzLnByb2Nlc3NJY29uT3ZlcnJpZGUoKTtcclxuICAgIH1cclxuICAgIFRoZW1lLnByb3RvdHlwZS5wcm9jZXNzSWNvbk92ZXJyaWRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZU9wdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnNldEljb25PdmVycmlkZSh0aGlzLm9wdGlvbnNNYW5hZ2VyLmdldCh0aGlzLmljb25PdmVycmlkZU9wdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUaGVtZS5wcm90b3R5cGUuc2V0SWNvbk92ZXJyaWRlID0gZnVuY3Rpb24gKGljb25PdmVycmlkZUhhc2gpIHtcclxuICAgICAgICB2YXIgaWNvbkNsYXNzZXNDb3B5O1xyXG4gICAgICAgIHZhciBidXR0b25OYW1lO1xyXG4gICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QoaWNvbk92ZXJyaWRlSGFzaCkpIHtcclxuICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5ID0gJC5leHRlbmQoe30sIHRoaXMuaWNvbkNsYXNzZXMpO1xyXG4gICAgICAgICAgICBmb3IgKGJ1dHRvbk5hbWUgaW4gaWNvbk92ZXJyaWRlSGFzaCkge1xyXG4gICAgICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5W2J1dHRvbk5hbWVdID0gdGhpcy5hcHBseUljb25PdmVycmlkZVByZWZpeChpY29uT3ZlcnJpZGVIYXNoW2J1dHRvbk5hbWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0gaWNvbkNsYXNzZXNDb3B5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpY29uT3ZlcnJpZGVIYXNoID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICB0aGlzLmljb25DbGFzc2VzID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRoZW1lLnByb3RvdHlwZS5hcHBseUljb25PdmVycmlkZVByZWZpeCA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5pY29uT3ZlcnJpZGVQcmVmaXg7XHJcbiAgICAgICAgaWYgKHByZWZpeCAmJiBjbGFzc05hbWUuaW5kZXhPZihwcmVmaXgpICE9PSAwKSB7IC8vIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcclxuICAgICAgICAgICAgY2xhc3NOYW1lID0gcHJlZml4ICsgY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xyXG4gICAgfTtcclxuICAgIFRoZW1lLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzW2tleV0gfHwgJyc7XHJcbiAgICB9O1xyXG4gICAgVGhlbWUucHJvdG90eXBlLmdldEljb25DbGFzcyA9IGZ1bmN0aW9uIChidXR0b25OYW1lKSB7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuaWNvbkNsYXNzZXNbYnV0dG9uTmFtZV07XHJcbiAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iYXNlSWNvbkNsYXNzICsgJyAnICsgY2xhc3NOYW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9O1xyXG4gICAgVGhlbWUucHJvdG90eXBlLmdldEN1c3RvbUJ1dHRvbkljb25DbGFzcyA9IGZ1bmN0aW9uIChjdXN0b21CdXR0b25Qcm9wcykge1xyXG4gICAgICAgIHZhciBjbGFzc05hbWU7XHJcbiAgICAgICAgaWYgKHRoaXMuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGN1c3RvbUJ1dHRvblByb3BzW3RoaXMuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uXTtcclxuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUljb25DbGFzcyArICcgJyArIHRoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoY2xhc3NOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJyc7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRoZW1lO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUaGVtZTtcclxuVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7fTtcclxuVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge307XHJcblRoZW1lLnByb3RvdHlwZS5iYXNlSWNvbkNsYXNzID0gJyc7XHJcblRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnJztcclxuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBleHBvcnRIb29rcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbmV4cG9ydEhvb2tzLnRvdWNoTW91c2VJZ25vcmVXYWl0ID0gNTAwO1xyXG52YXIgZ2xvYmFsRW1pdHRlciA9IG51bGw7XHJcbnZhciBuZWVkZWRDb3VudCA9IDA7XHJcbi8qXHJcbkxpc3RlbnMgdG8gZG9jdW1lbnQgYW5kIHdpbmRvdy1sZXZlbCB1c2VyLWludGVyYWN0aW9uIGV2ZW50cywgbGlrZSB0b3VjaCBldmVudHMgYW5kIG1vdXNlIGV2ZW50cyxcclxuYW5kIGZpcmVzIHRoZXNlIGV2ZW50cyBhcy1pcyB0byB3aG9ldmVyIGlzIG9ic2VydmluZyBhIEdsb2JhbEVtaXR0ZXIuXHJcbkJlc3Qgd2hlbiB1c2VkIGFzIGEgc2luZ2xldG9uIHZpYSBHbG9iYWxFbWl0dGVyLmdldCgpXHJcblxuTm9ybWFsaXplcyBtb3VzZS90b3VjaCBldmVudHMuIEZvciBleGFtcGxlczpcclxuLSBpZ25vcmVzIHRoZSB0aGUgc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyB0aGF0IGhhcHBlbiBhZnRlciBhIHF1aWNrIHRhcDogbW91c2Vtb3ZlK21vdXNlZG93bittb3VzZXVwK2NsaWNrXHJcbi0gY29tcGVuc2F0ZXMgZm9yIHZhcmlvdXMgYnVnZ3kgc2NlbmFyaW9zIHdoZXJlIGEgdG91Y2hlbmQgZG9lcyBub3QgZmlyZVxyXG4qL1xyXG52YXIgR2xvYmFsRW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEdsb2JhbEVtaXR0ZXIoKSB7XHJcbiAgICAgICAgdGhpcy5pc1RvdWNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tb3VzZUlnbm9yZURlcHRoID0gMDtcclxuICAgIH1cclxuICAgIC8vIGdldHMgdGhlIHNpbmdsZXRvblxyXG4gICAgR2xvYmFsRW1pdHRlci5nZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFnbG9iYWxFbWl0dGVyKSB7XHJcbiAgICAgICAgICAgIGdsb2JhbEVtaXR0ZXIgPSBuZXcgR2xvYmFsRW1pdHRlcigpO1xyXG4gICAgICAgICAgICBnbG9iYWxFbWl0dGVyLmJpbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbEVtaXR0ZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gY2FsbGVkIHdoZW4gYW4gb2JqZWN0IGtub3dzIGl0IHdpbGwgbmVlZCBhIEdsb2JhbEVtaXR0ZXIgaW4gdGhlIG5lYXIgZnV0dXJlLlxyXG4gICAgR2xvYmFsRW1pdHRlci5uZWVkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgR2xvYmFsRW1pdHRlci5nZXQoKTsgLy8gZW5zdXJlcyBnbG9iYWxFbWl0dGVyXHJcbiAgICAgICAgbmVlZGVkQ291bnQrKztcclxuICAgIH07XHJcbiAgICAvLyBjYWxsZWQgd2hlbiB0aGUgb2JqZWN0IHRoYXQgb3JpZ2luYWxseSBjYWxsZWQgbmVlZGVkKCkgZG9lc24ndCBuZWVkIGEgR2xvYmFsRW1pdHRlciBhbnltb3JlLlxyXG4gICAgR2xvYmFsRW1pdHRlci51bm5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBuZWVkZWRDb3VudC0tO1xyXG4gICAgICAgIGlmICghbmVlZGVkQ291bnQpIHsgLy8gbm9ib2R5IGVsc2UgbmVlZHMgaXRcclxuICAgICAgICAgICAgZ2xvYmFsRW1pdHRlci51bmJpbmQoKTtcclxuICAgICAgICAgICAgZ2xvYmFsRW1pdHRlciA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCB7XHJcbiAgICAgICAgICAgIHRvdWNoc3RhcnQ6IHRoaXMuaGFuZGxlVG91Y2hTdGFydCxcclxuICAgICAgICAgICAgdG91Y2hjYW5jZWw6IHRoaXMuaGFuZGxlVG91Y2hDYW5jZWwsXHJcbiAgICAgICAgICAgIHRvdWNoZW5kOiB0aGlzLmhhbmRsZVRvdWNoRW5kLFxyXG4gICAgICAgICAgICBtb3VzZWRvd246IHRoaXMuaGFuZGxlTW91c2VEb3duLFxyXG4gICAgICAgICAgICBtb3VzZW1vdmU6IHRoaXMuaGFuZGxlTW91c2VNb3ZlLFxyXG4gICAgICAgICAgICBtb3VzZXVwOiB0aGlzLmhhbmRsZU1vdXNlVXAsXHJcbiAgICAgICAgICAgIGNsaWNrOiB0aGlzLmhhbmRsZUNsaWNrLFxyXG4gICAgICAgICAgICBzZWxlY3RzdGFydDogdGhpcy5oYW5kbGVTZWxlY3RTdGFydCxcclxuICAgICAgICAgICAgY29udGV4dG1lbnU6IHRoaXMuaGFuZGxlQ29udGV4dE1lbnVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBiZWNhdXNlIHdlIG5lZWQgdG8gY2FsbCBwcmV2ZW50RGVmYXVsdFxyXG4gICAgICAgIC8vIGJlY2F1c2UgaHR0cHM6Ly93d3cuY2hyb21lc3RhdHVzLmNvbS9mZWF0dXJlcy81MDkzNTY2MDA3MjE0MDgwXHJcbiAgICAgICAgLy8gVE9ETzogaW52ZXN0aWdhdGUgcGVyZm9ybWFuY2UgYmVjYXVzZSB0aGlzIGlzIGEgZ2xvYmFsIGhhbmRsZXJcclxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5oYW5kbGVUb3VjaE1vdmVQcm94eSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBfdGhpcy5oYW5kbGVUb3VjaE1vdmUoJC5FdmVudChldikpO1xyXG4gICAgICAgIH0sIHsgcGFzc2l2ZTogZmFsc2UgfSAvLyBhbGxvd3MgcHJldmVudERlZmF1bHQoKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgLy8gYXR0YWNoIGEgaGFuZGxlciB0byBnZXQgY2FsbGVkIHdoZW4gQU5ZIHNjcm9sbCBhY3Rpb24gaGFwcGVucyBvbiB0aGUgcGFnZS5cclxuICAgICAgICAvLyB0aGlzIHdhcyBpbXBvc3NpYmxlIHRvIGRvIHdpdGggbm9ybWFsIG9uL29mZiBiZWNhdXNlICdzY3JvbGwnIGRvZXNuJ3QgYnViYmxlLlxyXG4gICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMyOTU0NTY1Lzk2MzQyXHJcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuaGFuZGxlU2Nyb2xsUHJveHkgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlU2Nyb2xsKCQuRXZlbnQoZXYpKTtcclxuICAgICAgICB9LCB0cnVlIC8vIHVzZUNhcHR1cmVcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLnVuYmluZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7XHJcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuaGFuZGxlVG91Y2hNb3ZlUHJveHksIHsgcGFzc2l2ZTogZmFsc2UgfSAvLyB1c2Ugc2FtZSBvcHRpb25zIGFzIGFkZEV2ZW50TGlzdGVuZXJcclxuICAgICAgICApO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLmhhbmRsZVNjcm9sbFByb3h5LCB0cnVlIC8vIHVzZUNhcHR1cmVcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIC8vIFRvdWNoIEhhbmRsZXJzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIC8vIGlmIGEgcHJldmlvdXMgdG91Y2ggaW50ZXJhY3Rpb24gbmV2ZXIgZW5kZWQgd2l0aCBhIHRvdWNoZW5kLCB0aGVuIGltcGxpY2l0bHkgZW5kIGl0LFxyXG4gICAgICAgIC8vIGJ1dCBzaW5jZSBhIG5ldyB0b3VjaCBpbnRlcmFjdGlvbiBpcyBhYm91dCB0byBiZWdpbiwgZG9uJ3Qgc3RhcnQgdGhlIG1vdXNlIGlnbm9yZSBwZXJpb2QuXHJcbiAgICAgICAgdGhpcy5zdG9wVG91Y2goZXYsIHRydWUpOyAvLyBza2lwTW91c2VJZ25vcmU9dHJ1ZVxyXG4gICAgICAgIHRoaXMuaXNUb3VjaGluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCd0b3VjaHN0YXJ0JywgZXYpO1xyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzVG91Y2hpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd0b3VjaG1vdmUnLCBldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZVRvdWNoQ2FuY2VsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNUb3VjaGluZykge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3RvdWNoY2FuY2VsJywgZXYpO1xyXG4gICAgICAgICAgICAvLyBIYXZlIHRvdWNoY2FuY2VsIGZpcmUgYW4gYXJ0aWZpY2lhbCB0b3VjaGVuZC4gVGhhdCB3YXksIGhhbmRsZXJzIHdvbid0IG5lZWQgdG8gbGlzdGVuIHRvIGJvdGguXHJcbiAgICAgICAgICAgIC8vIElmIHRvdWNoZW5kIGZpcmVzIGxhdGVyLCBpdCB3b24ndCBoYXZlIGFueSBlZmZlY3QgYi9jIGlzVG91Y2hpbmcgd2lsbCBiZSBmYWxzZS5cclxuICAgICAgICAgICAgdGhpcy5zdG9wVG91Y2goZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVUb3VjaEVuZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMuc3RvcFRvdWNoKGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBNb3VzZSBIYW5kbGVyc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlRG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2Vkb3duJywgZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVNb3VzZU1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ21vdXNlbW92ZScsIGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlTW91c2VVcCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICghdGhpcy5zaG91bGRJZ25vcmVNb3VzZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignbW91c2V1cCcsIGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2NsaWNrJywgZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBNaXNjIEhhbmRsZXJzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuaGFuZGxlU2VsZWN0U3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3NlbGVjdHN0YXJ0JywgZXYpO1xyXG4gICAgfTtcclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLmhhbmRsZUNvbnRleHRNZW51ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdjb250ZXh0bWVudScsIGV2KTtcclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5oYW5kbGVTY3JvbGwgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3Njcm9sbCcsIGV2KTtcclxuICAgIH07XHJcbiAgICAvLyBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEdsb2JhbEVtaXR0ZXIucHJvdG90eXBlLnN0b3BUb3VjaCA9IGZ1bmN0aW9uIChldiwgc2tpcE1vdXNlSWdub3JlKSB7XHJcbiAgICAgICAgaWYgKHNraXBNb3VzZUlnbm9yZSA9PT0gdm9pZCAwKSB7IHNraXBNb3VzZUlnbm9yZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNUb3VjaGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzVG91Y2hpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd0b3VjaGVuZCcsIGV2KTtcclxuICAgICAgICAgICAgaWYgKCFza2lwTW91c2VJZ25vcmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRUb3VjaE1vdXNlSWdub3JlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsRW1pdHRlci5wcm90b3R5cGUuc3RhcnRUb3VjaE1vdXNlSWdub3JlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHdhaXQgPSBleHBvcnRIb29rcy50b3VjaE1vdXNlSWdub3JlV2FpdDtcclxuICAgICAgICBpZiAod2FpdCkge1xyXG4gICAgICAgICAgICB0aGlzLm1vdXNlSWdub3JlRGVwdGgrKztcclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5tb3VzZUlnbm9yZURlcHRoLS07XHJcbiAgICAgICAgICAgIH0sIHdhaXQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBHbG9iYWxFbWl0dGVyLnByb3RvdHlwZS5zaG91bGRJZ25vcmVNb3VzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pc1RvdWNoaW5nIHx8IEJvb2xlYW4odGhpcy5tb3VzZUlnbm9yZURlcHRoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gR2xvYmFsRW1pdHRlcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gR2xvYmFsRW1pdHRlcjtcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhHbG9iYWxFbWl0dGVyKTtcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKEdsb2JhbEVtaXR0ZXIpO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBleHBvcnRIb29rcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG5leHBvcnRzLnZpZXdIYXNoID0ge307XHJcbmV4cG9ydEhvb2tzLnZpZXdzID0gZXhwb3J0cy52aWV3SGFzaDtcclxuZnVuY3Rpb24gZGVmaW5lVmlldyh2aWV3TmFtZSwgdmlld0NvbmZpZykge1xyXG4gICAgZXhwb3J0cy52aWV3SGFzaFt2aWV3TmFtZV0gPSB2aWV3Q29uZmlnO1xyXG59XHJcbmV4cG9ydHMuZGVmaW5lVmlldyA9IGRlZmluZVZpZXc7XHJcbmZ1bmN0aW9uIGdldFZpZXdDb25maWcodmlld05hbWUpIHtcclxuICAgIHJldHVybiBleHBvcnRzLnZpZXdIYXNoW3ZpZXdOYW1lXTtcclxufVxyXG5leHBvcnRzLmdldFZpZXdDb25maWcgPSBnZXRWaWV3Q29uZmlnO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNSAqLyxcbi8qIDI2ICovLFxuLyogMjcgKi8sXG4vKiAyOCAqLyxcbi8qIDI5ICovLFxuLyogMzAgKi8sXG4vKiAzMSAqLyxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIGV4cG9ydEhvb2tzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XHJcbnZhciBvcHRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbmV4cG9ydHMubG9jYWxlT3B0aW9uSGFzaCA9IHt9O1xyXG5leHBvcnRIb29rcy5sb2NhbGVzID0gZXhwb3J0cy5sb2NhbGVPcHRpb25IYXNoO1xyXG4vLyBOT1RFOiBjYW4ndCBndWFyYW50ZWUgYW55IG9mIHRoZXNlIGNvbXB1dGF0aW9ucyB3aWxsIHJ1biBiZWNhdXNlIG5vdCBldmVyeSBsb2NhbGUgaGFzIGRhdGVwaWNrZXJcclxuLy8gY29uZmlncywgc28gbWFrZSBzdXJlIHRoZXJlIGFyZSBFbmdsaXNoIGZhbGxiYWNrcyBmb3IgdGhlc2UgaW4gdGhlIGRlZmF1bHRzIGZpbGUuXHJcbnZhciBkcENvbXB1dGFibGVPcHRpb25zID0ge1xyXG4gICAgYnV0dG9uVGV4dDogZnVuY3Rpb24gKGRwT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vIHRoZSB0cmFuc2xhdGlvbnMgc29tZXRpbWVzIHdyb25nbHkgY29udGFpbiBIVE1MIGVudGl0aWVzXHJcbiAgICAgICAgICAgIHByZXY6IHV0aWxfMS5zdHJpcEh0bWxFbnRpdGllcyhkcE9wdGlvbnMucHJldlRleHQpLFxyXG4gICAgICAgICAgICBuZXh0OiB1dGlsXzEuc3RyaXBIdG1sRW50aXRpZXMoZHBPcHRpb25zLm5leHRUZXh0KSxcclxuICAgICAgICAgICAgdG9kYXk6IHV0aWxfMS5zdHJpcEh0bWxFbnRpdGllcyhkcE9wdGlvbnMuY3VycmVudFRleHQpXHJcbiAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiTU1NTSBZWVlZXCIgLT4gXCJTZXB0ZW1iZXIgMjAxNFwiXHJcbiAgICBtb250aFllYXJGb3JtYXQ6IGZ1bmN0aW9uIChkcE9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gZHBPcHRpb25zLnNob3dNb250aEFmdGVyWWVhciA/XHJcbiAgICAgICAgICAgICdZWVlZWycgKyBkcE9wdGlvbnMueWVhclN1ZmZpeCArICddIE1NTU0nIDpcclxuICAgICAgICAgICAgJ01NTU0gWVlZWVsnICsgZHBPcHRpb25zLnllYXJTdWZmaXggKyAnXSc7XHJcbiAgICB9XHJcbn07XHJcbnZhciBtb21Db21wdXRhYmxlT3B0aW9ucyA9IHtcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGxpa2UgXCJkZGQgTS9EXCIgLT4gXCJGcmkgOS8xNVwiXHJcbiAgICBkYXlPZk1vbnRoRm9ybWF0OiBmdW5jdGlvbiAobW9tT3B0aW9ucywgZmNPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGZvcm1hdCA9IG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ2wnKTsgLy8gZm9yIHRoZSBmb3JtYXQgbGlrZSBcIk0vRC9ZWVlZXCJcclxuICAgICAgICAvLyBzdHJpcCB0aGUgeWVhciBvZmYgdGhlIGVkZ2UsIGFzIHdlbGwgYXMgb3RoZXIgbWlzYyBub24td2hpdGVzcGFjZSBjaGFyc1xyXG4gICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKC9eWStbXlxcd1xcc10qfFteXFx3XFxzXSpZKyQvZywgJycpO1xyXG4gICAgICAgIGlmIChmY09wdGlvbnMuaXNSVEwpIHtcclxuICAgICAgICAgICAgZm9ybWF0ICs9ICcgZGRkJzsgLy8gZm9yIFJUTCwgYWRkIGRheS1vZi13ZWVrIHRvIGVuZFxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9ybWF0ID0gJ2RkZCAnICsgZm9ybWF0OyAvLyBmb3IgTFRSLCBhZGQgZGF5LW9mLXdlZWsgdG8gYmVnaW5uaW5nXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3JtYXQ7XHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImg6bW1hXCIgLT4gXCI2OjAwcG1cIlxyXG4gICAgbWVkaXVtVGltZUZvcm1hdDogZnVuY3Rpb24gKG1vbU9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gbW9tT3B0aW9ucy5sb25nRGF0ZUZvcm1hdCgnTFQnKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxzKmEkL2ksICdhJyk7IC8vIGNvbnZlcnQgQU0vUE0vYW0vcG0gdG8gbG93ZXJjYXNlLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImgoOm1tKWFcIiAtPiBcIjZwbVwiIC8gXCI2OjMwcG1cIlxyXG4gICAgc21hbGxUaW1lRm9ybWF0OiBmdW5jdGlvbiAobW9tT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKCc6bW0nLCAnKDptbSknKVxyXG4gICAgICAgICAgICAucmVwbGFjZSgvKFxcV21tKSQvLCAnKCQxKScpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsb2NhbGVzXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqYSQvaSwgJ2EnKTsgLy8gY29udmVydCBBTS9QTS9hbS9wbSB0byBsb3dlcmNhc2UuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaCg6bW0pdFwiIC0+IFwiNnBcIiAvIFwiNjozMHBcIlxyXG4gICAgZXh0cmFTbWFsbFRpbWVGb3JtYXQ6IGZ1bmN0aW9uIChtb21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoJzptbScsICcoOm1tKScpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8oXFxXbW0pJC8sICcoJDEpJykgLy8gbGlrZSBhYm92ZSwgYnV0IGZvciBmb3JlaWduIGxvY2FsZXNcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccyphJC9pLCAndCcpOyAvLyBjb252ZXJ0IHRvIEFNL1BNL2FtL3BtIHRvIGxvd2VyY2FzZSBvbmUtbGV0dGVyLiByZW1vdmUgYW55IHNwYWNlcyBiZWZvcmVoYW5kXHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgbGlrZSBcImhhXCIgLyBcIkhcIiAtPiBcIjZwbVwiIC8gXCIxOFwiXHJcbiAgICBob3VyRm9ybWF0OiBmdW5jdGlvbiAobW9tT3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBtb21PcHRpb25zLmxvbmdEYXRlRm9ybWF0KCdMVCcpXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKCc6bW0nLCAnJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoLyhcXFdtbSkkLywgJycpIC8vIGxpa2UgYWJvdmUsIGJ1dCBmb3IgZm9yZWlnbiBsb2NhbGVzXHJcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHMqYSQvaSwgJ2EnKTsgLy8gY29udmVydCBBTS9QTS9hbS9wbSB0byBsb3dlcmNhc2UuIHJlbW92ZSBhbnkgc3BhY2VzIGJlZm9yZWhhbmRcclxuICAgIH0sXHJcbiAgICAvLyBQcm9kdWNlcyBmb3JtYXQgc3RyaW5ncyBsaWtlIFwiaDptbVwiIC0+IFwiNjozMFwiICh3aXRoIG5vIEFNL1BNKVxyXG4gICAgbm9NZXJpZGllbVRpbWVGb3JtYXQ6IGZ1bmN0aW9uIChtb21PcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbU9wdGlvbnMubG9uZ0RhdGVGb3JtYXQoJ0xUJylcclxuICAgICAgICAgICAgLnJlcGxhY2UoL1xccyphJC9pLCAnJyk7IC8vIHJlbW92ZSB0cmFpbGluZyBBTS9QTVxyXG4gICAgfVxyXG59O1xyXG4vLyBvcHRpb25zIHRoYXQgc2hvdWxkIGJlIGNvbXB1dGVkIG9mZiBsaXZlIGNhbGVuZGFyIG9wdGlvbnMgKGNvbnNpZGVycyBvdmVycmlkZSBvcHRpb25zKVxyXG4vLyBUT0RPOiBiZXN0IHBsYWNlIGZvciB0aGlzPyByZWxhdGVkIHRvIGxvY2FsZT9cclxuLy8gVE9ETzogZmxpcHBpbmcgdGV4dCBiYXNlZCBvbiBpc1JUTCBpcyBhIGJhZCBpZGVhIGJlY2F1c2UgdGhlIENTUyBgZGlyZWN0aW9uYCBtaWdodCB3YW50IHRvIGhhbmRsZSBpdFxyXG52YXIgaW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyA9IHtcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGZvciByZXN1bHRzIGxpa2UgXCJNbyAxNlwiXHJcbiAgICBzbWFsbERheURhdGVGb3JtYXQ6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuaXNSVEwgP1xyXG4gICAgICAgICAgICAnRCBkZCcgOlxyXG4gICAgICAgICAgICAnZGQgRCc7XHJcbiAgICB9LFxyXG4gICAgLy8gUHJvZHVjZXMgZm9ybWF0IHN0cmluZ3MgZm9yIHJlc3VsdHMgbGlrZSBcIldrIDVcIlxyXG4gICAgd2Vla0Zvcm1hdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gb3B0aW9ucy5pc1JUTCA/XHJcbiAgICAgICAgICAgICd3WyAnICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnXScgOlxyXG4gICAgICAgICAgICAnWycgKyBvcHRpb25zLndlZWtOdW1iZXJUaXRsZSArICcgXXcnO1xyXG4gICAgfSxcclxuICAgIC8vIFByb2R1Y2VzIGZvcm1hdCBzdHJpbmdzIGZvciByZXN1bHRzIGxpa2UgXCJXazVcIlxyXG4gICAgc21hbGxXZWVrRm9ybWF0OiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBvcHRpb25zLmlzUlRMID9cclxuICAgICAgICAgICAgJ3dbJyArIG9wdGlvbnMud2Vla051bWJlclRpdGxlICsgJ10nIDpcclxuICAgICAgICAgICAgJ1snICsgb3B0aW9ucy53ZWVrTnVtYmVyVGl0bGUgKyAnXXcnO1xyXG4gICAgfVxyXG59O1xyXG4vLyBUT0RPOiBtYWtlIHRoZXNlIGNvbXB1dGFibGUgcHJvcGVydGllcyBpbiBvcHRpb25zTWFuYWdlclxyXG5mdW5jdGlvbiBwb3B1bGF0ZUluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgJC5lYWNoKGluc3RhbmNlQ29tcHV0YWJsZU9wdGlvbnMsIGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0gPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBvcHRpb25zW25hbWVdID0gZnVuYyhvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLnBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyA9IHBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucztcclxuLy8gSW5pdGlhbGl6ZSBqUXVlcnkgVUkgZGF0ZXBpY2tlciB0cmFuc2xhdGlvbnMgd2hpbGUgdXNpbmcgc29tZSBvZiB0aGUgdHJhbnNsYXRpb25zXHJcbi8vIFdpbGwgc2V0IHRoaXMgYXMgdGhlIGRlZmF1bHQgbG9jYWxlcyBmb3IgZGF0ZXBpY2tlci5cclxuZnVuY3Rpb24gZGF0ZXBpY2tlckxvY2FsZShsb2NhbGVDb2RlLCBkcExvY2FsZUNvZGUsIGRwT3B0aW9ucykge1xyXG4gICAgLy8gZ2V0IHRoZSBGdWxsQ2FsZW5kYXIgaW50ZXJuYWwgb3B0aW9uIGhhc2ggZm9yIHRoaXMgbG9jYWxlLiBjcmVhdGUgaWYgbmVjZXNzYXJ5XHJcbiAgICB2YXIgZmNPcHRpb25zID0gZXhwb3J0cy5sb2NhbGVPcHRpb25IYXNoW2xvY2FsZUNvZGVdIHx8IChleHBvcnRzLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gPSB7fSk7XHJcbiAgICAvLyB0cmFuc2ZlciBzb21lIHNpbXBsZSBvcHRpb25zIGZyb20gZGF0ZXBpY2tlciB0byBmY1xyXG4gICAgZmNPcHRpb25zLmlzUlRMID0gZHBPcHRpb25zLmlzUlRMO1xyXG4gICAgZmNPcHRpb25zLndlZWtOdW1iZXJUaXRsZSA9IGRwT3B0aW9ucy53ZWVrSGVhZGVyO1xyXG4gICAgLy8gY29tcHV0ZSBzb21lIG1vcmUgY29tcGxleCBvcHRpb25zIGZyb20gZGF0ZXBpY2tlclxyXG4gICAgJC5lYWNoKGRwQ29tcHV0YWJsZU9wdGlvbnMsIGZ1bmN0aW9uIChuYW1lLCBmdW5jKSB7XHJcbiAgICAgICAgZmNPcHRpb25zW25hbWVdID0gZnVuYyhkcE9wdGlvbnMpO1xyXG4gICAgfSk7XHJcbiAgICB2YXIganFEYXRlUGlja2VyID0gJC5kYXRlcGlja2VyO1xyXG4gICAgLy8gaXMgalF1ZXJ5IFVJIERhdGVwaWNrZXIgaXMgb24gdGhlIHBhZ2U/XHJcbiAgICBpZiAoanFEYXRlUGlja2VyKSB7XHJcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGxvY2FsZSBkYXRhLlxyXG4gICAgICAgIC8vIEZ1bGxDYWxlbmRhciBhbmQgTW9tZW50SlMgdXNlIGxvY2FsZSBjb2RlcyBsaWtlIFwicHQtYnJcIiBidXQgRGF0ZXBpY2tlclxyXG4gICAgICAgIC8vIGRvZXMgaXQgbGlrZSBcInB0LUJSXCIgb3IgaWYgaXQgZG9lc24ndCBoYXZlIHRoZSBsb2NhbGUsIG1heWJlIGp1c3QgXCJwdFwiLlxyXG4gICAgICAgIC8vIE1ha2UgYW4gYWxpYXMgc28gdGhlIGxvY2FsZSBjYW4gYmUgcmVmZXJlbmNlZCBlaXRoZXIgd2F5LlxyXG4gICAgICAgIGpxRGF0ZVBpY2tlci5yZWdpb25hbFtkcExvY2FsZUNvZGVdID1cclxuICAgICAgICAgICAganFEYXRlUGlja2VyLnJlZ2lvbmFsW2xvY2FsZUNvZGVdID0gLy8gYWxpYXNcclxuICAgICAgICAgICAgICAgIGRwT3B0aW9ucztcclxuICAgICAgICAvLyBBbGlhcyAnZW4nIHRvIHRoZSBkZWZhdWx0IGxvY2FsZSBkYXRhLiBEbyB0aGlzIGV2ZXJ5IHRpbWUuXHJcbiAgICAgICAganFEYXRlUGlja2VyLnJlZ2lvbmFsLmVuID0ganFEYXRlUGlja2VyLnJlZ2lvbmFsWycnXTtcclxuICAgICAgICAvLyBTZXQgYXMgRGF0ZXBpY2tlcidzIGdsb2JhbCBkZWZhdWx0cy5cclxuICAgICAgICBqcURhdGVQaWNrZXIuc2V0RGVmYXVsdHMoZHBPcHRpb25zKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmRhdGVwaWNrZXJMb2NhbGUgPSBkYXRlcGlja2VyTG9jYWxlO1xyXG4vLyBTZXRzIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyB0cmFuc2xhdGlvbnMuIFdpbGwgc2V0IHRoZSBsb2NhbGVzIGFzIHRoZSBnbG9iYWwgZGVmYXVsdC5cclxuZnVuY3Rpb24gbG9jYWxlKGxvY2FsZUNvZGUsIG5ld0ZjT3B0aW9ucykge1xyXG4gICAgdmFyIGZjT3B0aW9ucztcclxuICAgIHZhciBtb21PcHRpb25zO1xyXG4gICAgLy8gZ2V0IHRoZSBGdWxsQ2FsZW5kYXIgaW50ZXJuYWwgb3B0aW9uIGhhc2ggZm9yIHRoaXMgbG9jYWxlLiBjcmVhdGUgaWYgbmVjZXNzYXJ5XHJcbiAgICBmY09wdGlvbnMgPSBleHBvcnRzLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gfHwgKGV4cG9ydHMubG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVDb2RlXSA9IHt9KTtcclxuICAgIC8vIHByb3ZpZGVkIG5ldyBvcHRpb25zIGZvciB0aGlzIGxvY2FsZXM/IG1lcmdlIHRoZW0gaW5cclxuICAgIGlmIChuZXdGY09wdGlvbnMpIHtcclxuICAgICAgICBmY09wdGlvbnMgPSBleHBvcnRzLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlQ29kZV0gPSBvcHRpb25zXzEubWVyZ2VPcHRpb25zKFtmY09wdGlvbnMsIG5ld0ZjT3B0aW9uc10pO1xyXG4gICAgfVxyXG4gICAgLy8gY29tcHV0ZSBsb2NhbGUgb3B0aW9ucyB0aGF0IHdlcmVuJ3QgZGVmaW5lZC5cclxuICAgIC8vIGFsd2F5cyBkbyB0aGlzLiBuZXdGY09wdGlvbnMgY2FuIGJlIHVuZGVmaW5lZCB3aGVuIGluaXRpYWxpemluZyBmcm9tIGkxOG4gZmlsZSxcclxuICAgIC8vIHNvIG5vIHdheSB0byB0ZWxsIGlmIHRoaXMgaXMgYW4gaW5pdGlhbGl6YXRpb24gb3IgYSBkZWZhdWx0LXNldHRpbmcuXHJcbiAgICBtb21PcHRpb25zID0gZ2V0TW9tZW50TG9jYWxlRGF0YShsb2NhbGVDb2RlKTsgLy8gd2lsbCBmYWxsIGJhY2sgdG8gZW5cclxuICAgICQuZWFjaChtb21Db21wdXRhYmxlT3B0aW9ucywgZnVuY3Rpb24gKG5hbWUsIGZ1bmMpIHtcclxuICAgICAgICBpZiAoZmNPcHRpb25zW25hbWVdID09IG51bGwpIHtcclxuICAgICAgICAgICAgZmNPcHRpb25zW25hbWVdID0gKGZ1bmMpKG1vbU9wdGlvbnMsIGZjT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICAvLyBzZXQgaXQgYXMgdGhlIGRlZmF1bHQgbG9jYWxlIGZvciBGdWxsQ2FsZW5kYXJcclxuICAgIG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cy5sb2NhbGUgPSBsb2NhbGVDb2RlO1xyXG59XHJcbmV4cG9ydHMubG9jYWxlID0gbG9jYWxlO1xyXG4vLyBSZXR1cm5zIG1vbWVudCdzIGludGVybmFsIGxvY2FsZSBkYXRhLiBJZiBkb2Vzbid0IGV4aXN0LCByZXR1cm5zIEVuZ2xpc2guXHJcbmZ1bmN0aW9uIGdldE1vbWVudExvY2FsZURhdGEobG9jYWxlQ29kZSkge1xyXG4gICAgcmV0dXJuIG1vbWVudC5sb2NhbGVEYXRhKGxvY2FsZUNvZGUpIHx8IG1vbWVudC5sb2NhbGVEYXRhKCdlbicpO1xyXG59XHJcbmV4cG9ydHMuZ2V0TW9tZW50TG9jYWxlRGF0YSA9IGdldE1vbWVudExvY2FsZURhdGE7XHJcbi8vIEluaXRpYWxpemUgRW5nbGlzaCBieSBmb3JjaW5nIGNvbXB1dGF0aW9uIG9mIG1vbWVudC1kZXJpdmVkIG9wdGlvbnMuXHJcbi8vIEFsc28sIHNldHMgaXQgYXMgdGhlIGRlZmF1bHQuXHJcbmxvY2FsZSgnZW4nLCBvcHRpb25zXzEuZW5nbGlzaERlZmF1bHRzKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuZXhwb3J0cy5nbG9iYWxEZWZhdWx0cyA9IHtcclxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6ICcgXFx1MjAxMyAnLFxyXG4gICAgbW9udGhZZWFyRm9ybWF0OiAnTU1NTSBZWVlZJyxcclxuICAgIGRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb246ICcwMjowMDowMCcsXHJcbiAgICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogeyBkYXlzOiAxIH0sXHJcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IGZhbHNlLFxyXG4gICAgbmV4dERheVRocmVzaG9sZDogJzA5OjAwOjAwJyxcclxuICAgIC8vIGRpc3BsYXlcclxuICAgIGNvbHVtbkhlYWRlcjogdHJ1ZSxcclxuICAgIGRlZmF1bHRWaWV3OiAnbW9udGgnLFxyXG4gICAgYXNwZWN0UmF0aW86IDEuMzUsXHJcbiAgICBoZWFkZXI6IHtcclxuICAgICAgICBsZWZ0OiAndGl0bGUnLFxyXG4gICAgICAgIGNlbnRlcjogJycsXHJcbiAgICAgICAgcmlnaHQ6ICd0b2RheSBwcmV2LG5leHQnXHJcbiAgICB9LFxyXG4gICAgd2Vla2VuZHM6IHRydWUsXHJcbiAgICB3ZWVrTnVtYmVyczogZmFsc2UsXHJcbiAgICB3ZWVrTnVtYmVyVGl0bGU6ICdXJyxcclxuICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogJ2xvY2FsJyxcclxuICAgIC8vIGVkaXRhYmxlOiBmYWxzZSxcclxuICAgIC8vIG5vd0luZGljYXRvcjogZmFsc2UsXHJcbiAgICBzY3JvbGxUaW1lOiAnMDY6MDA6MDAnLFxyXG4gICAgbWluVGltZTogJzAwOjAwOjAwJyxcclxuICAgIG1heFRpbWU6ICcyNDowMDowMCcsXHJcbiAgICBzaG93Tm9uQ3VycmVudERhdGVzOiB0cnVlLFxyXG4gICAgLy8gZXZlbnQgYWpheFxyXG4gICAgbGF6eUZldGNoaW5nOiB0cnVlLFxyXG4gICAgc3RhcnRQYXJhbTogJ3N0YXJ0JyxcclxuICAgIGVuZFBhcmFtOiAnZW5kJyxcclxuICAgIHRpbWV6b25lUGFyYW06ICd0aW1lem9uZScsXHJcbiAgICB0aW1lem9uZTogZmFsc2UsXHJcbiAgICAvLyBhbGxEYXlEZWZhdWx0OiB1bmRlZmluZWQsXHJcbiAgICAvLyBsb2NhbGVcclxuICAgIGxvY2FsZTogbnVsbCxcclxuICAgIGlzUlRMOiBmYWxzZSxcclxuICAgIGJ1dHRvblRleHQ6IHtcclxuICAgICAgICBwcmV2OiAncHJldicsXHJcbiAgICAgICAgbmV4dDogJ25leHQnLFxyXG4gICAgICAgIHByZXZZZWFyOiAncHJldiB5ZWFyJyxcclxuICAgICAgICBuZXh0WWVhcjogJ25leHQgeWVhcicsXHJcbiAgICAgICAgeWVhcjogJ3llYXInLFxyXG4gICAgICAgIHRvZGF5OiAndG9kYXknLFxyXG4gICAgICAgIG1vbnRoOiAnbW9udGgnLFxyXG4gICAgICAgIHdlZWs6ICd3ZWVrJyxcclxuICAgICAgICBkYXk6ICdkYXknXHJcbiAgICB9LFxyXG4gICAgLy8gYnV0dG9uSWNvbnM6IG51bGwsXHJcbiAgICBhbGxEYXlUZXh0OiAnYWxsLWRheScsXHJcbiAgICAvLyBhbGxvd3Mgc2V0dGluZyBhIG1pbi1oZWlnaHQgdG8gdGhlIGV2ZW50IHNlZ21lbnQgdG8gcHJldmVudCBzaG9ydCBldmVudHMgb3ZlcmxhcHBpbmcgZWFjaCBvdGhlclxyXG4gICAgYWdlbmRhRXZlbnRNaW5IZWlnaHQ6IDAsXHJcbiAgICAvLyBqcXVlcnktdWkgdGhlbWluZ1xyXG4gICAgdGhlbWU6IGZhbHNlLFxyXG4gICAgLy8gdGhlbWVCdXR0b25JY29uczogbnVsbCxcclxuICAgIC8vIGV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0OiBmYWxzZSxcclxuICAgIGRyYWdPcGFjaXR5OiAuNzUsXHJcbiAgICBkcmFnUmV2ZXJ0RHVyYXRpb246IDUwMCxcclxuICAgIGRyYWdTY3JvbGw6IHRydWUsXHJcbiAgICAvLyBzZWxlY3RhYmxlOiBmYWxzZSxcclxuICAgIHVuc2VsZWN0QXV0bzogdHJ1ZSxcclxuICAgIC8vIHNlbGVjdE1pbkRpc3RhbmNlOiAwLFxyXG4gICAgZHJvcEFjY2VwdDogJyonLFxyXG4gICAgZXZlbnRPcmRlcjogJ3RpdGxlJyxcclxuICAgIC8vIGV2ZW50UmVuZGVyV2FpdDogbnVsbCxcclxuICAgIGV2ZW50TGltaXQ6IGZhbHNlLFxyXG4gICAgZXZlbnRMaW1pdFRleHQ6ICdtb3JlJyxcclxuICAgIGV2ZW50TGltaXRDbGljazogJ3BvcG92ZXInLFxyXG4gICAgZGF5UG9wb3ZlckZvcm1hdDogJ0xMJyxcclxuICAgIGhhbmRsZVdpbmRvd1Jlc2l6ZTogdHJ1ZSxcclxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiAxMDAsXHJcbiAgICBsb25nUHJlc3NEZWxheTogMTAwMFxyXG59O1xyXG5leHBvcnRzLmVuZ2xpc2hEZWZhdWx0cyA9IHtcclxuICAgIGRheVBvcG92ZXJGb3JtYXQ6ICdkZGRkLCBNTU1NIEQnXHJcbn07XHJcbmV4cG9ydHMucnRsRGVmYXVsdHMgPSB7XHJcbiAgICBoZWFkZXI6IHtcclxuICAgICAgICBsZWZ0OiAnbmV4dCxwcmV2IHRvZGF5JyxcclxuICAgICAgICBjZW50ZXI6ICcnLFxyXG4gICAgICAgIHJpZ2h0OiAndGl0bGUnXHJcbiAgICB9LFxyXG4gICAgYnV0dG9uSWNvbnM6IHtcclxuICAgICAgICBwcmV2OiAncmlnaHQtc2luZ2xlLWFycm93JyxcclxuICAgICAgICBuZXh0OiAnbGVmdC1zaW5nbGUtYXJyb3cnLFxyXG4gICAgICAgIHByZXZZZWFyOiAncmlnaHQtZG91YmxlLWFycm93JyxcclxuICAgICAgICBuZXh0WWVhcjogJ2xlZnQtZG91YmxlLWFycm93J1xyXG4gICAgfSxcclxuICAgIHRoZW1lQnV0dG9uSWNvbnM6IHtcclxuICAgICAgICBwcmV2OiAnY2lyY2xlLXRyaWFuZ2xlLWUnLFxyXG4gICAgICAgIG5leHQ6ICdjaXJjbGUtdHJpYW5nbGUtdycsXHJcbiAgICAgICAgbmV4dFllYXI6ICdzZWVrLXByZXYnLFxyXG4gICAgICAgIHByZXZZZWFyOiAnc2Vlay1uZXh0J1xyXG4gICAgfVxyXG59O1xyXG52YXIgY29tcGxleE9wdGlvbnMgPSBbXHJcbiAgICAnaGVhZGVyJyxcclxuICAgICdmb290ZXInLFxyXG4gICAgJ2J1dHRvblRleHQnLFxyXG4gICAgJ2J1dHRvbkljb25zJyxcclxuICAgICd0aGVtZUJ1dHRvbkljb25zJ1xyXG5dO1xyXG4vLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb3B0aW9uIG9iamVjdHMgaW50byBhIHNpbmdsZSBvYmplY3RcclxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbk9ianMpIHtcclxuICAgIHJldHVybiB1dGlsXzEubWVyZ2VQcm9wcyhvcHRpb25PYmpzLCBjb21wbGV4T3B0aW9ucyk7XHJcbn1cclxuZXhwb3J0cy5tZXJnZU9wdGlvbnMgPSBtZXJnZU9wdGlvbnM7XHJcblxuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEV2ZW50Rm9vdHByaW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRGb290cHJpbnQoY29tcG9uZW50Rm9vdHByaW50LCBldmVudERlZiwgZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50Rm9vdHByaW50ID0gY29tcG9uZW50Rm9vdHByaW50O1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWYgPSBldmVudERlZjtcclxuICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50SW5zdGFuY2UgPSBldmVudEluc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEV2ZW50Rm9vdHByaW50LnByb3RvdHlwZS5nZXRFdmVudExlZ2FjeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZXZlbnRJbnN0YW5jZSB8fCB0aGlzLmV2ZW50RGVmKS50b0xlZ2FjeSgpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudEZvb3RwcmludDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRGb290cHJpbnQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuLy8gQ2xhc3MgdGhhdCBhbGwgb3RoZXIgY2xhc3NlcyB3aWxsIGluaGVyaXQgZnJvbVxyXG52YXIgQ2xhc3MgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBDbGFzcygpIHtcclxuICAgIH1cclxuICAgIC8vIENhbGxlZCBvbiBhIGNsYXNzIHRvIGNyZWF0ZSBhIHN1YmNsYXNzLlxyXG4gICAgLy8gTElNSVRBVElPTjogY2Fubm90IHByb3ZpZGUgYSBjb25zdHJ1Y3RvciFcclxuICAgIENsYXNzLmV4dGVuZCA9IGZ1bmN0aW9uIChtZW1iZXJzKSB7XHJcbiAgICAgICAgdmFyIFN1YkNsYXNzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhTdWJDbGFzcywgX3N1cGVyKTtcclxuICAgICAgICAgICAgZnVuY3Rpb24gU3ViQ2xhc3MoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFN1YkNsYXNzO1xyXG4gICAgICAgIH0odGhpcykpO1xyXG4gICAgICAgIHV0aWxfMS5jb3B5T3duUHJvcHMobWVtYmVycywgU3ViQ2xhc3MucHJvdG90eXBlKTtcclxuICAgICAgICByZXR1cm4gU3ViQ2xhc3M7XHJcbiAgICB9O1xyXG4gICAgLy8gQWRkcyBuZXcgbWVtYmVyIHZhcmlhYmxlcy9tZXRob2RzIHRvIHRoZSBjbGFzcydzIHByb3RvdHlwZS5cclxuICAgIC8vIENhbiBiZSBjYWxsZWQgd2l0aCBhbm90aGVyIGNsYXNzLCBvciBhIHBsYWluIG9iamVjdCBoYXNoIGNvbnRhaW5pbmcgbmV3IG1lbWJlcnMuXHJcbiAgICBDbGFzcy5taXhpbiA9IGZ1bmN0aW9uIChtZW1iZXJzKSB7XHJcbiAgICAgICAgdXRpbF8xLmNvcHlPd25Qcm9wcyhtZW1iZXJzLCB0aGlzLnByb3RvdHlwZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIENsYXNzO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDbGFzcztcclxuXG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxudmFyIFJlY3VycmluZ0V2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU0KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0ge1xyXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChldmVudElucHV0LCBzb3VyY2UpIHtcclxuICAgICAgICBpZiAodXRpbF8xLmlzVGltZVN0cmluZyhldmVudElucHV0LnN0YXJ0KSB8fCBtb21lbnQuaXNEdXJhdGlvbihldmVudElucHV0LnN0YXJ0KSB8fFxyXG4gICAgICAgICAgICB1dGlsXzEuaXNUaW1lU3RyaW5nKGV2ZW50SW5wdXQuZW5kKSB8fCBtb21lbnQuaXNEdXJhdGlvbihldmVudElucHV0LmVuZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlY3VycmluZ0V2ZW50RGVmXzEuZGVmYXVsdC5wYXJzZShldmVudElucHV0LCBzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdC5wYXJzZShldmVudElucHV0LCBzb3VyY2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuXG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBQYXJzYWJsZU1vZGVsTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTIpO1xyXG52YXIgRXZlbnREZWYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudERlZihzb3VyY2UpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcclxuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IFtdO1xyXG4gICAgICAgIHRoaXMubWlzY1Byb3BzID0ge307XHJcbiAgICB9XHJcbiAgICBFdmVudERlZi5wYXJzZSA9IGZ1bmN0aW9uIChyYXdJbnB1dCwgc291cmNlKSB7XHJcbiAgICAgICAgdmFyIGRlZiA9IG5ldyB0aGlzKHNvdXJjZSk7XHJcbiAgICAgICAgaWYgKGRlZi5hcHBseVByb3BzKHJhd0lucHV0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYubm9ybWFsaXplSWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gU3RyaW5nKGlkKTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5nZW5lcmF0ZUlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnX2ZjJyArIChFdmVudERlZi51dWlkKyspO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY29weSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMuc291cmNlKTtcclxuICAgICAgICBjb3B5LmlkID0gdGhpcy5pZDtcclxuICAgICAgICBjb3B5LnJhd0lkID0gdGhpcy5yYXdJZDtcclxuICAgICAgICBjb3B5LnVpZCA9IHRoaXMudWlkOyAvLyBub3QgcmVhbGx5IHVuaXF1ZSBhbnltb3JlIDooXHJcbiAgICAgICAgRXZlbnREZWYuY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyh0aGlzLCBjb3B5KTtcclxuICAgICAgICBjb3B5LmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lLnNsaWNlKCk7IC8vIGNvcHlcclxuICAgICAgICBjb3B5Lm1pc2NQcm9wcyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm1pc2NQcm9wcyk7XHJcbiAgICAgICAgcmV0dXJuIGNvcHk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmhhc0ludmVyc2VSZW5kZXJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyaW5nKCkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5oYXNCZ1JlbmRlcmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVuZGVyaW5nID0gdGhpcy5nZXRSZW5kZXJpbmcoKTtcclxuICAgICAgICByZXR1cm4gcmVuZGVyaW5nID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJyB8fCByZW5kZXJpbmcgPT09ICdiYWNrZ3JvdW5kJztcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuZ2V0UmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmluZyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnJlbmRlcmluZztcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuZ2V0Q29uc3RyYWludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25zdHJhaW50ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RyYWludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc291cmNlLmNvbnN0cmFpbnQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2UuY29uc3RyYWludDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmNhbGVuZGFyLm9wdCgnZXZlbnRDb25zdHJhaW50Jyk7IC8vIHdoYXQgYWJvdXQgVmlldyBvcHRpb24/XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmdldE92ZXJsYXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxhcCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZS5vdmVybGFwICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLm92ZXJsYXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5jYWxlbmRhci5vcHQoJ2V2ZW50T3ZlcmxhcCcpOyAvLyB3aGF0IGFib3V0IFZpZXcgb3B0aW9uP1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnByb3RvdHlwZS5pc1N0YXJ0RXhwbGljaXRseUVkaXRhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0RWRpdGFibGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydEVkaXRhYmxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2Uuc3RhcnRFZGl0YWJsZTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuaXNEdXJhdGlvbkV4cGxpY2l0bHlFZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kdXJhdGlvbkVkaXRhYmxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZHVyYXRpb25FZGl0YWJsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlLmR1cmF0aW9uRWRpdGFibGU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWYucHJvdG90eXBlLmlzRXhwbGljaXRseUVkaXRhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVkaXRhYmxlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWRpdGFibGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZS5lZGl0YWJsZTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUudG9MZWdhY3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG9iaiA9ICQuZXh0ZW5kKHt9LCB0aGlzLm1pc2NQcm9wcyk7XHJcbiAgICAgICAgb2JqLl9pZCA9IHRoaXMudWlkO1xyXG4gICAgICAgIG9iai5zb3VyY2UgPSB0aGlzLnNvdXJjZTtcclxuICAgICAgICBvYmouY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUuc2xpY2UoKTsgLy8gY29weVxyXG4gICAgICAgIG9iai5hbGxEYXkgPSB0aGlzLmlzQWxsRGF5KCk7XHJcbiAgICAgICAgaWYgKHRoaXMucmF3SWQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBvYmouaWQgPSB0aGlzLnJhd0lkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBFdmVudERlZi5jb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzKHRoaXMsIG9iaik7XHJcbiAgICAgICAgcmV0dXJuIG9iajtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzID0gZnVuY3Rpb24gKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgaWYgKHJhd1Byb3BzLmlkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IEV2ZW50RGVmLm5vcm1hbGl6ZUlkKCh0aGlzLnJhd0lkID0gcmF3UHJvcHMuaWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWQgPSBFdmVudERlZi5nZW5lcmF0ZUlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdQcm9wcy5faWQgIT0gbnVsbCkgeyAvLyBhY2NlcHQgdGhpcyBwcm9wLCBldmVuIHRobyBzb21ld2hhdCBpbnRlcm5hbFxyXG4gICAgICAgICAgICB0aGlzLnVpZCA9IFN0cmluZyhyYXdQcm9wcy5faWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy51aWQgPSBFdmVudERlZi5nZW5lcmF0ZUlkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE86IGNvbnZlcmdlIHdpdGggRXZlbnRTb3VyY2VcclxuICAgICAgICBpZiAoJC5pc0FycmF5KHJhd1Byb3BzLmNsYXNzTmFtZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGFzc05hbWUgPSByYXdQcm9wcy5jbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHJhd1Byb3BzLmNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZi5wcm90b3R5cGUuYXBwbHlNaXNjUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICAkLmV4dGVuZCh0aGlzLm1pc2NQcm9wcywgcmF3UHJvcHMpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmLnV1aWQgPSAwO1xyXG4gICAgRXZlbnREZWYuZGVmaW5lU3RhbmRhcmRQcm9wcyA9IFBhcnNhYmxlTW9kZWxNaXhpbl8xLmRlZmF1bHQuZGVmaW5lU3RhbmRhcmRQcm9wcztcclxuICAgIEV2ZW50RGVmLmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0LmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHM7XHJcbiAgICByZXR1cm4gRXZlbnREZWY7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RGVmO1xyXG5QYXJzYWJsZU1vZGVsTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRXZlbnREZWYpO1xyXG5FdmVudERlZi5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIC8vIG5vdCBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIChgZmFsc2VgKVxyXG4gICAgX2lkOiBmYWxzZSxcclxuICAgIGlkOiBmYWxzZSxcclxuICAgIGNsYXNzTmFtZTogZmFsc2UsXHJcbiAgICBzb3VyY2U6IGZhbHNlLFxyXG4gICAgLy8gYXV0b21hdGljYWxseSBhc3NpZ25lZCAoYHRydWVgKVxyXG4gICAgdGl0bGU6IHRydWUsXHJcbiAgICB1cmw6IHRydWUsXHJcbiAgICByZW5kZXJpbmc6IHRydWUsXHJcbiAgICBjb25zdHJhaW50OiB0cnVlLFxyXG4gICAgb3ZlcmxhcDogdHJ1ZSxcclxuICAgIGVkaXRhYmxlOiB0cnVlLFxyXG4gICAgc3RhcnRFZGl0YWJsZTogdHJ1ZSxcclxuICAgIGR1cmF0aW9uRWRpdGFibGU6IHRydWUsXHJcbiAgICBjb2xvcjogdHJ1ZSxcclxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcclxuICAgIGJvcmRlckNvbG9yOiB0cnVlLFxyXG4gICAgdGV4dENvbG9yOiB0cnVlXHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IHtcclxuICAgIHNvdXJjZUNsYXNzZXM6IFtdLFxyXG4gICAgcmVnaXN0ZXJDbGFzczogZnVuY3Rpb24gKEV2ZW50U291cmNlQ2xhc3MpIHtcclxuICAgICAgICB0aGlzLnNvdXJjZUNsYXNzZXMudW5zaGlmdChFdmVudFNvdXJjZUNsYXNzKTsgLy8gZ2l2ZSBoaWdoZXN0IHByaW9yaXR5XHJcbiAgICB9LFxyXG4gICAgcGFyc2U6IGZ1bmN0aW9uIChyYXdJbnB1dCwgY2FsZW5kYXIpIHtcclxuICAgICAgICB2YXIgc291cmNlQ2xhc3NlcyA9IHRoaXMuc291cmNlQ2xhc3NlcztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgZXZlbnRTb3VyY2U7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUNsYXNzZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRTb3VyY2UgPSBzb3VyY2VDbGFzc2VzW2ldLnBhcnNlKHJhd0lucHV0LCBjYWxlbmRhcik7XHJcbiAgICAgICAgICAgIGlmIChldmVudFNvdXJjZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5cblxuLyoqKi8gfSksXG4vKiAzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRXZlbnREYXRlUHJvZmlsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XHJcbnZhciBFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XHJcbnZhciBFdmVudERlZkRhdGVNdXRhdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxudmFyIEV2ZW50RGVmTXV0YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBFdmVudERlZk11dGF0aW9uKCkge1xyXG4gICAgfVxyXG4gICAgRXZlbnREZWZNdXRhdGlvbi5jcmVhdGVGcm9tUmF3UHJvcHMgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgcmF3UHJvcHMsIGxhcmdlVW5pdCkge1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IGV2ZW50SW5zdGFuY2UuZGVmO1xyXG4gICAgICAgIHZhciBkYXRlUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgc3RhbmRhcmRQcm9wcyA9IHt9O1xyXG4gICAgICAgIHZhciBtaXNjUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgdmVyYmF0aW1TdGFuZGFyZFByb3BzID0ge307XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmSWQgPSBudWxsO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBudWxsO1xyXG4gICAgICAgIHZhciBwcm9wTmFtZTtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIGRhdGVNdXRhdGlvbjtcclxuICAgICAgICB2YXIgZGVmTXV0YXRpb247XHJcbiAgICAgICAgZm9yIChwcm9wTmFtZSBpbiByYXdQcm9wcykge1xyXG4gICAgICAgICAgICBpZiAoRXZlbnREYXRlUHJvZmlsZV8xLmRlZmF1bHQuaXNTdGFuZGFyZFByb3AocHJvcE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvcHNbcHJvcE5hbWVdID0gcmF3UHJvcHNbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50RGVmLmlzU3RhbmRhcmRQcm9wKHByb3BOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wc1twcm9wTmFtZV0gPSByYXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnREZWYubWlzY1Byb3BzW3Byb3BOYW1lXSAhPT0gcmF3UHJvcHNbcHJvcE5hbWVdKSB7IC8vIG9ubHkgaWYgY2hhbmdlZFxyXG4gICAgICAgICAgICAgICAgbWlzY1Byb3BzW3Byb3BOYW1lXSA9IHJhd1Byb3BzW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRlUHJvZmlsZSA9IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0LnBhcnNlKGRhdGVQcm9wcywgZXZlbnREZWYuc291cmNlKTtcclxuICAgICAgICBpZiAoZGF0ZVByb2ZpbGUpIHsgLy8gbm8gZmFpbHVyZT9cclxuICAgICAgICAgICAgZGF0ZU11dGF0aW9uID0gRXZlbnREZWZEYXRlTXV0YXRpb25fMS5kZWZhdWx0LmNyZWF0ZUZyb21EaWZmKGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUsIGRhdGVQcm9maWxlLCBsYXJnZVVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhbmRhcmRQcm9wcy5pZCAhPT0gZXZlbnREZWYuaWQpIHtcclxuICAgICAgICAgICAgZXZlbnREZWZJZCA9IHN0YW5kYXJkUHJvcHMuaWQ7IC8vIG9ubHkgYXBwbHkgaWYgdGhlcmUncyBhIGNoYW5nZVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXV0aWxfMS5pc0FycmF5c0VxdWFsKHN0YW5kYXJkUHJvcHMuY2xhc3NOYW1lLCBldmVudERlZi5jbGFzc05hbWUpKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHN0YW5kYXJkUHJvcHMuY2xhc3NOYW1lOyAvLyBvbmx5IGFwcGx5IGlmIHRoZXJlJ3MgYSBjaGFuZ2VcclxuICAgICAgICB9XHJcbiAgICAgICAgRXZlbnREZWZfMS5kZWZhdWx0LmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHMoc3RhbmRhcmRQcm9wcywgLy8gc3JjXHJcbiAgICAgICAgdmVyYmF0aW1TdGFuZGFyZFByb3BzIC8vIGRlc3RcclxuICAgICAgICApO1xyXG4gICAgICAgIGRlZk11dGF0aW9uID0gbmV3IEV2ZW50RGVmTXV0YXRpb24oKTtcclxuICAgICAgICBkZWZNdXRhdGlvbi5ldmVudERlZklkID0gZXZlbnREZWZJZDtcclxuICAgICAgICBkZWZNdXRhdGlvbi5jbGFzc05hbWUgPSBjbGFzc05hbWU7XHJcbiAgICAgICAgZGVmTXV0YXRpb24udmVyYmF0aW1TdGFuZGFyZFByb3BzID0gdmVyYmF0aW1TdGFuZGFyZFByb3BzO1xyXG4gICAgICAgIGRlZk11dGF0aW9uLm1pc2NQcm9wcyA9IG1pc2NQcm9wcztcclxuICAgICAgICBpZiAoZGF0ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGRlZk11dGF0aW9uLmRhdGVNdXRhdGlvbiA9IGRhdGVNdXRhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGRlZk11dGF0aW9uO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBldmVudERlZiBhc3N1bWVkIHRvIGJlIGEgU2luZ2xlRXZlbnREZWYuXHJcbiAgICByZXR1cm5zIGFuIHVuZG8gZnVuY3Rpb24uXHJcbiAgICAqL1xyXG4gICAgRXZlbnREZWZNdXRhdGlvbi5wcm90b3R5cGUubXV0YXRlU2luZ2xlID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIG9yaWdEYXRlUHJvZmlsZTtcclxuICAgICAgICBpZiAodGhpcy5kYXRlTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgb3JpZ0RhdGVQcm9maWxlID0gZXZlbnREZWYuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmLmRhdGVQcm9maWxlID0gdGhpcy5kYXRlTXV0YXRpb24uYnVpbGROZXdEYXRlUHJvZmlsZShvcmlnRGF0ZVByb2ZpbGUsIGV2ZW50RGVmLnNvdXJjZS5jYWxlbmRhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbid0IHVuZG9cclxuICAgICAgICAvLyBUT0RPOiBtb3JlIERSWSB3aXRoIEV2ZW50RGVmOjphcHBseU1hbnVhbFN0YW5kYXJkUHJvcHNcclxuICAgICAgICBpZiAodGhpcy5ldmVudERlZklkICE9IG51bGwpIHtcclxuICAgICAgICAgICAgZXZlbnREZWYuaWQgPSBFdmVudERlZl8xLmRlZmF1bHQubm9ybWFsaXplSWQoKGV2ZW50RGVmLnJhd0lkID0gdGhpcy5ldmVudERlZklkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbid0IHVuZG9cclxuICAgICAgICAvLyBUT0RPOiBtb3JlIERSWSB3aXRoIEV2ZW50RGVmOjphcHBseU1hbnVhbFN0YW5kYXJkUHJvcHNcclxuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIHtcclxuICAgICAgICAgICAgZXZlbnREZWYuY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbid0IHVuZG9cclxuICAgICAgICBpZiAodGhpcy52ZXJiYXRpbVN0YW5kYXJkUHJvcHMpIHtcclxuICAgICAgICAgICAgU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0LmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHModGhpcy52ZXJiYXRpbVN0YW5kYXJkUHJvcHMsIC8vIHNyY1xyXG4gICAgICAgICAgICBldmVudERlZiAvLyBkZXN0XHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbid0IHVuZG9cclxuICAgICAgICBpZiAodGhpcy5taXNjUHJvcHMpIHtcclxuICAgICAgICAgICAgZXZlbnREZWYuYXBwbHlNaXNjUHJvcHModGhpcy5taXNjUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3JpZ0RhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudERlZi5kYXRlUHJvZmlsZSA9IG9yaWdEYXRlUHJvZmlsZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50RGVmTXV0YXRpb24ucHJvdG90eXBlLnNldERhdGVNdXRhdGlvbiA9IGZ1bmN0aW9uIChkYXRlTXV0YXRpb24pIHtcclxuICAgICAgICBpZiAoZGF0ZU11dGF0aW9uICYmICFkYXRlTXV0YXRpb24uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZU11dGF0aW9uID0gZGF0ZU11dGF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERlZk11dGF0aW9uLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5kYXRlTXV0YXRpb247XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RGVmTXV0YXRpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RGVmTXV0YXRpb247XHJcblxuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBFdmVudERhdGVQcm9maWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxudmFyIEV2ZW50RGVmRGF0ZU11dGF0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnREZWZEYXRlTXV0YXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckVuZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZm9yY2VUaW1lZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZm9yY2VBbGxEYXkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIEV2ZW50RGVmRGF0ZU11dGF0aW9uLmNyZWF0ZUZyb21EaWZmID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlMCwgZGF0ZVByb2ZpbGUxLCBsYXJnZVVuaXQpIHtcclxuICAgICAgICB2YXIgY2xlYXJFbmQgPSBkYXRlUHJvZmlsZTAuZW5kICYmICFkYXRlUHJvZmlsZTEuZW5kO1xyXG4gICAgICAgIHZhciBmb3JjZVRpbWVkID0gZGF0ZVByb2ZpbGUwLmlzQWxsRGF5KCkgJiYgIWRhdGVQcm9maWxlMS5pc0FsbERheSgpO1xyXG4gICAgICAgIHZhciBmb3JjZUFsbERheSA9ICFkYXRlUHJvZmlsZTAuaXNBbGxEYXkoKSAmJiBkYXRlUHJvZmlsZTEuaXNBbGxEYXkoKTtcclxuICAgICAgICB2YXIgZGF0ZURlbHRhO1xyXG4gICAgICAgIHZhciBlbmREaWZmO1xyXG4gICAgICAgIHZhciBlbmREZWx0YTtcclxuICAgICAgICB2YXIgbXV0YXRpb247XHJcbiAgICAgICAgLy8gc3VidHJhY3RzIHRoZSBkYXRlcyBpbiB0aGUgYXBwcm9wcmlhdGUgd2F5LCByZXR1cm5pbmcgYSBkdXJhdGlvblxyXG4gICAgICAgIGZ1bmN0aW9uIHN1YnRyYWN0RGF0ZXMoZGF0ZTEsIGRhdGUwKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXJnZVVuaXQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsXzEuZGlmZkJ5VW5pdChkYXRlMSwgZGF0ZTAsIGxhcmdlVW5pdCk7IC8vIHBvb3JseSBuYW1lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGVQcm9maWxlMS5pc0FsbERheSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmRpZmZEYXkoZGF0ZTEsIGRhdGUwKTsgLy8gcG9vcmx5IG5hbWVkXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbF8xLmRpZmZEYXlUaW1lKGRhdGUxLCBkYXRlMCk7IC8vIHBvb3JseSBuYW1lZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGVEZWx0YSA9IHN1YnRyYWN0RGF0ZXMoZGF0ZVByb2ZpbGUxLnN0YXJ0LCBkYXRlUHJvZmlsZTAuc3RhcnQpO1xyXG4gICAgICAgIGlmIChkYXRlUHJvZmlsZTEuZW5kKSB7XHJcbiAgICAgICAgICAgIC8vIHVzZSB1bnpvbmVkUmFuZ2VzIGJlY2F1c2UgZGF0ZVByb2ZpbGUwLmVuZCBtaWdodCBiZSBudWxsXHJcbiAgICAgICAgICAgIGVuZERpZmYgPSBzdWJ0cmFjdERhdGVzKGRhdGVQcm9maWxlMS51bnpvbmVkUmFuZ2UuZ2V0RW5kKCksIGRhdGVQcm9maWxlMC51bnpvbmVkUmFuZ2UuZ2V0RW5kKCkpO1xyXG4gICAgICAgICAgICBlbmREZWx0YSA9IGVuZERpZmYuc3VidHJhY3QoZGF0ZURlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbXV0YXRpb24gPSBuZXcgRXZlbnREZWZEYXRlTXV0YXRpb24oKTtcclxuICAgICAgICBtdXRhdGlvbi5jbGVhckVuZCA9IGNsZWFyRW5kO1xyXG4gICAgICAgIG11dGF0aW9uLmZvcmNlVGltZWQgPSBmb3JjZVRpbWVkO1xyXG4gICAgICAgIG11dGF0aW9uLmZvcmNlQWxsRGF5ID0gZm9yY2VBbGxEYXk7XHJcbiAgICAgICAgbXV0YXRpb24uc2V0RGF0ZURlbHRhKGRhdGVEZWx0YSk7XHJcbiAgICAgICAgbXV0YXRpb24uc2V0RW5kRGVsdGEoZW5kRGVsdGEpO1xyXG4gICAgICAgIHJldHVybiBtdXRhdGlvbjtcclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgcmV0dXJucyBhbiB1bmRvIGZ1bmN0aW9uLlxyXG4gICAgKi9cclxuICAgIEV2ZW50RGVmRGF0ZU11dGF0aW9uLnByb3RvdHlwZS5idWlsZE5ld0RhdGVQcm9maWxlID0gZnVuY3Rpb24gKGV2ZW50RGF0ZVByb2ZpbGUsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gZXZlbnREYXRlUHJvZmlsZS5zdGFydC5jbG9uZSgpO1xyXG4gICAgICAgIHZhciBlbmQgPSBudWxsO1xyXG4gICAgICAgIHZhciBzaG91bGRSZXpvbmUgPSBmYWxzZTtcclxuICAgICAgICBpZiAoZXZlbnREYXRlUHJvZmlsZS5lbmQgJiYgIXRoaXMuY2xlYXJFbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gZXZlbnREYXRlUHJvZmlsZS5lbmQuY2xvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5lbmREZWx0YSAmJiAhZW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGNhbGVuZGFyLmdldERlZmF1bHRFdmVudEVuZChldmVudERhdGVQcm9maWxlLmlzQWxsRGF5KCksIHN0YXJ0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VUaW1lZCkge1xyXG4gICAgICAgICAgICBzaG91bGRSZXpvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0Lmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQudGltZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW5kICYmICFlbmQuaGFzVGltZSgpKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQudGltZSgwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmZvcmNlQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGlmIChzdGFydC5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbmQgJiYgZW5kLmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kLnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGVEZWx0YSkge1xyXG4gICAgICAgICAgICBzaG91bGRSZXpvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdGFydC5hZGQodGhpcy5kYXRlRGVsdGEpO1xyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQuYWRkKHRoaXMuZGF0ZURlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkbyB0aGlzIGJlZm9yZSBhZGRpbmcgc3RhcnREZWx0YSB0byBzdGFydCwgc28gd2UgY2FuIHdvcmsgb2ZmIG9mIHN0YXJ0XHJcbiAgICAgICAgaWYgKHRoaXMuZW5kRGVsdGEpIHtcclxuICAgICAgICAgICAgc2hvdWxkUmV6b25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgZW5kLmFkZCh0aGlzLmVuZERlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhcnREZWx0YSkge1xyXG4gICAgICAgICAgICBzaG91bGRSZXpvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICBzdGFydC5hZGQodGhpcy5zdGFydERlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3VsZFJlem9uZSkge1xyXG4gICAgICAgICAgICBzdGFydCA9IGNhbGVuZGFyLmFwcGx5VGltZXpvbmUoc3RhcnQpO1xyXG4gICAgICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgICAgICBlbmQgPSBjYWxlbmRhci5hcHBseVRpbWV6b25lKGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETzogb2theSB0byBhY2Nlc3MgY2FsZW5kYXIgb3B0aW9uP1xyXG4gICAgICAgIGlmICghZW5kICYmIGNhbGVuZGFyLm9wdCgnZm9yY2VFdmVudER1cmF0aW9uJykpIHtcclxuICAgICAgICAgICAgZW5kID0gY2FsZW5kYXIuZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGF0ZVByb2ZpbGUuaXNBbGxEYXkoKSwgc3RhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0KHN0YXJ0LCBlbmQsIGNhbGVuZGFyKTtcclxuICAgIH07XHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5wcm90b3R5cGUuc2V0RGF0ZURlbHRhID0gZnVuY3Rpb24gKGRhdGVEZWx0YSkge1xyXG4gICAgICAgIGlmIChkYXRlRGVsdGEgJiYgZGF0ZURlbHRhLnZhbHVlT2YoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVEZWx0YSA9IGRhdGVEZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF0ZURlbHRhID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREZWZEYXRlTXV0YXRpb24ucHJvdG90eXBlLnNldFN0YXJ0RGVsdGEgPSBmdW5jdGlvbiAoc3RhcnREZWx0YSkge1xyXG4gICAgICAgIGlmIChzdGFydERlbHRhICYmIHN0YXJ0RGVsdGEudmFsdWVPZigpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RhcnREZWx0YSA9IHN0YXJ0RGVsdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN0YXJ0RGVsdGEgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5wcm90b3R5cGUuc2V0RW5kRGVsdGEgPSBmdW5jdGlvbiAoZW5kRGVsdGEpIHtcclxuICAgICAgICBpZiAoZW5kRGVsdGEgJiYgZW5kRGVsdGEudmFsdWVPZigpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kRGVsdGEgPSBlbmREZWx0YTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kRGVsdGEgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudERlZkRhdGVNdXRhdGlvbi5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuY2xlYXJFbmQgJiYgIXRoaXMuZm9yY2VUaW1lZCAmJiAhdGhpcy5mb3JjZUFsbERheSAmJlxyXG4gICAgICAgICAgICAhdGhpcy5kYXRlRGVsdGEgJiYgIXRoaXMuc3RhcnREZWx0YSAmJiAhdGhpcy5lbmREZWx0YTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnREZWZEYXRlTXV0YXRpb247XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RGVmRGF0ZU11dGF0aW9uO1xyXG5cblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIENsYXNzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KTtcclxuLypcclxuRW1ib2RpZXMgYSBkaXYgdGhhdCBoYXMgcG90ZW50aWFsIHNjcm9sbGJhcnNcclxuKi9cclxudmFyIFNjcm9sbGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU2Nyb2xsZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTY3JvbGxlcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgICAgICBfdGhpcy5vdmVyZmxvd1ggPSBvcHRpb25zLm92ZXJmbG93WCB8fCBvcHRpb25zLm92ZXJmbG93IHx8ICdhdXRvJztcclxuICAgICAgICBfdGhpcy5vdmVyZmxvd1kgPSBvcHRpb25zLm92ZXJmbG93WSB8fCBvcHRpb25zLm92ZXJmbG93IHx8ICdhdXRvJztcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZWwgPSB0aGlzLnJlbmRlckVsKCk7XHJcbiAgICAgICAgdGhpcy5hcHBseU92ZXJmbG93KCk7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLnJlbmRlckVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zY3JvbGxFbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1zY3JvbGxlclwiPjwvZGl2PicpKTtcclxuICAgIH07XHJcbiAgICAvLyBzZXRzIHRvIG5hdHVyYWwgaGVpZ2h0LCB1bmxvY2tzIG92ZXJmbG93XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zZXRIZWlnaHQoJ2F1dG8nKTtcclxuICAgICAgICB0aGlzLmFwcGx5T3ZlcmZsb3coKTtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xyXG4gICAgfTtcclxuICAgIC8vIE92ZXJmbG93XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmFwcGx5T3ZlcmZsb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxFbC5jc3Moe1xyXG4gICAgICAgICAgICAnb3ZlcmZsb3cteCc6IHRoaXMub3ZlcmZsb3dYLFxyXG4gICAgICAgICAgICAnb3ZlcmZsb3cteSc6IHRoaXMub3ZlcmZsb3dZXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2F1c2VzIGFueSAnYXV0bycgb3ZlcmZsb3cgdmFsdWVzIHRvIHJlc29sdmVzIHRvICdzY3JvbGwnIG9yICdoaWRkZW4nLlxyXG4gICAgLy8gVXNlZnVsIGZvciBwcmVzZXJ2aW5nIHNjcm9sbGJhciB3aWR0aHMgcmVnYXJkbGVzcyBvZiBmdXR1cmUgcmVzaXplcy5cclxuICAgIC8vIENhbiBwYXNzIGluIHNjcm9sbGJhcldpZHRocyBmb3Igb3B0aW1pemF0aW9uLlxyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmxvY2tPdmVyZmxvdyA9IGZ1bmN0aW9uIChzY3JvbGxiYXJXaWR0aHMpIHtcclxuICAgICAgICB2YXIgb3ZlcmZsb3dYID0gdGhpcy5vdmVyZmxvd1g7XHJcbiAgICAgICAgdmFyIG92ZXJmbG93WSA9IHRoaXMub3ZlcmZsb3dZO1xyXG4gICAgICAgIHNjcm9sbGJhcldpZHRocyA9IHNjcm9sbGJhcldpZHRocyB8fCB0aGlzLmdldFNjcm9sbGJhcldpZHRocygpO1xyXG4gICAgICAgIGlmIChvdmVyZmxvd1ggPT09ICdhdXRvJykge1xyXG4gICAgICAgICAgICBvdmVyZmxvd1ggPSAoc2Nyb2xsYmFyV2lkdGhzLnRvcCB8fCBzY3JvbGxiYXJXaWR0aHMuYm90dG9tIHx8IC8vIGhvcml6b250YWwgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIC8vIE9SIHNjcm9sbGluZyBwYW5lIHdpdGggbWFzc2xlc3Mgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxbMF0uc2Nyb2xsV2lkdGggLSAxID4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRXaWR0aFxyXG4gICAgICAgICAgICAvLyBzdWJ0cmFjdCAxIGJlY2F1c2Ugb2YgSUUgb2ZmLWJ5LW9uZSBpc3N1ZVxyXG4gICAgICAgICAgICApID8gJ3Njcm9sbCcgOiAnaGlkZGVuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG92ZXJmbG93WSA9PT0gJ2F1dG8nKSB7XHJcbiAgICAgICAgICAgIG92ZXJmbG93WSA9IChzY3JvbGxiYXJXaWR0aHMubGVmdCB8fCBzY3JvbGxiYXJXaWR0aHMucmlnaHQgfHwgLy8gdmVydGljYWwgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIC8vIE9SIHNjcm9sbGluZyBwYW5lIHdpdGggbWFzc2xlc3Mgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxbMF0uc2Nyb2xsSGVpZ2h0IC0gMSA+IHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50SGVpZ2h0XHJcbiAgICAgICAgICAgIC8vIHN1YnRyYWN0IDEgYmVjYXVzZSBvZiBJRSBvZmYtYnktb25lIGlzc3VlXHJcbiAgICAgICAgICAgICkgPyAnc2Nyb2xsJyA6ICdoaWRkZW4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNjcm9sbEVsLmNzcyh7ICdvdmVyZmxvdy14Jzogb3ZlcmZsb3dYLCAnb3ZlcmZsb3cteSc6IG92ZXJmbG93WSB9KTtcclxuICAgIH07XHJcbiAgICAvLyBHZXR0ZXJzIC8gU2V0dGVyc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5zZXRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxFbC5oZWlnaHQoaGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcm9sbEVsLnNjcm9sbFRvcCgpO1xyXG4gICAgfTtcclxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAodG9wKSB7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxFbC5zY3JvbGxUb3AodG9wKTtcclxuICAgIH07XHJcbiAgICBTY3JvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50V2lkdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsRWxbMF0uY2xpZW50V2lkdGg7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmdldENsaWVudEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxFbFswXS5jbGllbnRIZWlnaHQ7XHJcbiAgICB9O1xyXG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbGJhcldpZHRocyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdXRpbF8xLmdldFNjcm9sbGJhcldpZHRocyh0aGlzLnNjcm9sbEVsKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gU2Nyb2xsZXI7XHJcbn0oQ2xhc3NfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFNjcm9sbGVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIERhdGVDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMxKTtcclxudmFyIEdsb2JhbEVtaXR0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG52YXIgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50KF92aWV3LCBfb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIF92aWV3LCBfb3B0aW9ucykgfHwgdGhpcztcclxuICAgICAgICAvLyBzZWxmLWNvbmZpZywgb3ZlcnJpZGFibGUgYnkgc3ViY2xhc3Nlc1xyXG4gICAgICAgIF90aGlzLnNlZ1NlbGVjdG9yID0gJy5mYy1ldmVudC1jb250YWluZXIgPiAqJzsgLy8gd2hhdCBjb25zdGl0dXRlcyBhbiBldmVudCBlbGVtZW50P1xyXG4gICAgICAgIGlmIChfdGhpcy5kYXRlU2VsZWN0aW5nQ2xhc3MpIHtcclxuICAgICAgICAgICAgX3RoaXMuZGF0ZUNsaWNraW5nID0gbmV3IF90aGlzLmRhdGVDbGlja2luZ0NsYXNzKF90aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF90aGlzLmRhdGVTZWxlY3RpbmdDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5kYXRlU2VsZWN0aW5nID0gbmV3IF90aGlzLmRhdGVTZWxlY3RpbmdDbGFzcyhfdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5ldmVudFBvaW50aW5nQ2xhc3MpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZyA9IG5ldyBfdGhpcy5ldmVudFBvaW50aW5nQ2xhc3MoX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuZXZlbnREcmFnZ2luZ0NsYXNzICYmIF90aGlzLmV2ZW50UG9pbnRpbmcpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXZlbnREcmFnZ2luZyA9IG5ldyBfdGhpcy5ldmVudERyYWdnaW5nQ2xhc3MoX3RoaXMsIF90aGlzLmV2ZW50UG9pbnRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuZXZlbnRSZXNpemluZ0NsYXNzICYmIF90aGlzLmV2ZW50UG9pbnRpbmcpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXZlbnRSZXNpemluZyA9IG5ldyBfdGhpcy5ldmVudFJlc2l6aW5nQ2xhc3MoX3RoaXMsIF90aGlzLmV2ZW50UG9pbnRpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuZXh0ZXJuYWxEcm9wcGluZ0NsYXNzKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV4dGVybmFsRHJvcHBpbmcgPSBuZXcgX3RoaXMuZXh0ZXJuYWxEcm9wcGluZ0NsYXNzKF90aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gU2V0cyB0aGUgY29udGFpbmVyIGVsZW1lbnQgdGhhdCB0aGUgdmlldyBzaG91bGQgcmVuZGVyIGluc2lkZSBvZiwgZG9lcyBnbG9iYWwgRE9NLXJlbGF0ZWQgaW5pdGlhbGl6YXRpb25zLFxyXG4gICAgLy8gYW5kIHJlbmRlcnMgYWxsIHRoZSBub24tZGF0ZS1yZWxhdGVkIGNvbnRlbnQgaW5zaWRlLlxyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5zZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5zZXRFbGVtZW50LmNhbGwodGhpcywgZWwpO1xyXG4gICAgICAgIGlmICh0aGlzLmRhdGVDbGlja2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVDbGlja2luZy5iaW5kVG9FbChlbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRhdGVTZWxlY3RpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXRlU2VsZWN0aW5nLmJpbmRUb0VsKGVsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5iaW5kQWxsU2VnSGFuZGxlcnNUb0VsKGVsKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbmRJbnRlcmFjdGlvbnMoKTtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmV4ZWN1dGVFdmVudFVucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZW5kSW50ZXJhY3Rpb25zKCk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5leGVjdXRlRXZlbnRVbnJlbmRlci5jYWxsKHRoaXMpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYmluZEdsb2JhbEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmluZEdsb2JhbEhhbmRsZXJzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuZXh0ZXJuYWxEcm9wcGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsRHJvcHBpbmcuYmluZFRvRG9jdW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bmJpbmRHbG9iYWxIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuYmluZEdsb2JhbEhhbmRsZXJzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgaWYgKHRoaXMuZXh0ZXJuYWxEcm9wcGluZykge1xyXG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsRHJvcHBpbmcudW5iaW5kRnJvbURvY3VtZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuYmluZERhdGVIYW5kbGVyVG9FbCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgLy8gYXR0YWNoIGEgaGFuZGxlciB0byB0aGUgZ3JpZCdzIHJvb3QgZWxlbWVudC5cclxuICAgICAgICAvLyBqUXVlcnkgd2lsbCB0YWtlIGNhcmUgb2YgdW5yZWdpc3RlcmluZyB0aGVtIHdoZW4gcmVtb3ZlRWxlbWVudCBnZXRzIGNhbGxlZC5cclxuICAgICAgICB0aGlzLmVsLm9uKG5hbWUsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAoISQoZXYudGFyZ2V0KS5pcyhfdGhpcy5zZWdTZWxlY3RvciArICc6bm90KC5mYy1oZWxwZXIpLCcgKyAvLyBkaXJlY3RseSBvbiBhbiBldmVudCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWdTZWxlY3RvciArICc6bm90KC5mYy1oZWxwZXIpICosJyArIC8vIHdpdGhpbiBhbiBldmVudCBlbGVtZW50XHJcbiAgICAgICAgICAgICAgICAnLmZjLW1vcmUsJyArIC8vIGEgXCJtb3JlLi5cIiBsaW5rXHJcbiAgICAgICAgICAgICAgICAnYVtkYXRhLWdvdG9dJyAvLyBhIGNsaWNrYWJsZSBuYXYgbGlua1xyXG4gICAgICAgICAgICApKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5jYWxsKF90aGlzLCBldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmJpbmRBbGxTZWdIYW5kbGVyc1RvRWwgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICBbXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRQb2ludGluZyxcclxuICAgICAgICAgICAgdGhpcy5ldmVudERyYWdnaW5nLFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UmVzaXppbmdcclxuICAgICAgICBdLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50SW50ZXJhY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50SW50ZXJhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50SW50ZXJhY3Rpb24uYmluZFRvRWwoZWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kU2VnSGFuZGxlclRvRWwgPSBmdW5jdGlvbiAoZWwsIG5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGVsLm9uKG5hbWUsIHRoaXMuc2VnU2VsZWN0b3IsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgc2VnRWwgPSAkKGV2LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICBpZiAoIXNlZ0VsLmlzKCcuZmMtaGVscGVyJykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWcgPSBzZWdFbC5kYXRhKCdmYy1zZWcnKTsgLy8gZ3JhYiBzZWdtZW50IGRhdGEuIHB1dCB0aGVyZSBieSBWaWV3OjpyZW5kZXJFdmVudHNQYXlsb2FkXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnICYmICFfdGhpcy5zaG91bGRJZ25vcmVFdmVudFBvaW50aW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlci5jYWxsKF90aGlzLCBzZWcsIGV2KTsgLy8gY29udGV4dCB3aWxsIGJlIHRoZSBHcmlkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZElnbm9yZU1vdXNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIEhBQ0tcclxuICAgICAgICAvLyBUaGlzIHdpbGwgc3RpbGwgd29yayBldmVuIHRob3VnaCBiaW5kRGF0ZUhhbmRsZXJUb0VsIGRvZXNuJ3QgdXNlIEdsb2JhbEVtaXR0ZXIuXHJcbiAgICAgICAgcmV0dXJuIEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LmdldCgpLnNob3VsZElnbm9yZU1vdXNlKCk7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRJZ25vcmVUb3VjaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX2dldFZpZXcoKTtcclxuICAgICAgICAvLyBPbiBpT1MgKGFuZCBBbmRyb2lkPykgd2hlbiBhIG5ldyBzZWxlY3Rpb24gaXMgaW5pdGlhdGVkIG92ZXJ0b3AgYW5vdGhlciBzZWxlY3Rpb24sXHJcbiAgICAgICAgLy8gdGhlIHRvdWNoZW5kIG5ldmVyIGZpcmVzIGJlY2F1c2UgdGhlIGVsZW1lbnRzIGdldHMgcmVtb3ZlZCBtaWQtdG91Y2gtaW50ZXJhY3Rpb24gKG15IHRoZW9yeSkuXHJcbiAgICAgICAgLy8gSEFDSzogc2ltcGx5IGRvbid0IGFsbG93IHRoaXMgdG8gaGFwcGVuLlxyXG4gICAgICAgIC8vIEFMU086IHByZXZlbnQgc2VsZWN0aW9uIHdoZW4gYW4gKmV2ZW50KiBpcyBhbHJlYWR5IHJhaXNlZC5cclxuICAgICAgICByZXR1cm4gdmlldy5pc1NlbGVjdGVkIHx8IHZpZXcuc2VsZWN0ZWRFdmVudDtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZElnbm9yZUV2ZW50UG9pbnRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gb25seSBjYWxsIHRoZSBoYW5kbGVycyBpZiB0aGVyZSBpcyBub3QgYSBkcmFnL3Jlc2l6ZSBpbiBwcm9ncmVzc1xyXG4gICAgICAgIHJldHVybiAodGhpcy5ldmVudERyYWdnaW5nICYmIHRoaXMuZXZlbnREcmFnZ2luZy5pc0RyYWdnaW5nKSB8fFxyXG4gICAgICAgICAgICAodGhpcy5ldmVudFJlc2l6aW5nICYmIHRoaXMuZXZlbnRSZXNpemluZy5pc1Jlc2l6aW5nKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmNhblN0YXJ0U2VsZWN0aW9uID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICByZXR1cm4gdXRpbF8xLmdldEV2SXNUb3VjaChldikgJiZcclxuICAgICAgICAgICAgIXRoaXMuY2FuU3RhcnRSZXNpemUoc2VnLCBldikgJiZcclxuICAgICAgICAgICAgKHRoaXMuaXNFdmVudERlZkRyYWdnYWJsZShzZWcuZm9vdHByaW50LmV2ZW50RGVmKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5pc0V2ZW50RGVmUmVzaXphYmxlKHNlZy5mb290cHJpbnQuZXZlbnREZWYpKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmNhblN0YXJ0RHJhZyA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmNhblN0YXJ0UmVzaXplKHNlZywgZXYpICYmXHJcbiAgICAgICAgICAgIHRoaXMuaXNFdmVudERlZkRyYWdnYWJsZShzZWcuZm9vdHByaW50LmV2ZW50RGVmKTtcclxuICAgIH07XHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmNhblN0YXJ0UmVzaXplID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX2dldFZpZXcoKTtcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHJldHVybiAoIXV0aWxfMS5nZXRFdklzVG91Y2goZXYpIHx8IHZpZXcuaXNFdmVudERlZlNlbGVjdGVkKGV2ZW50RGVmKSkgJiZcclxuICAgICAgICAgICAgdGhpcy5pc0V2ZW50RGVmUmVzaXphYmxlKGV2ZW50RGVmKSAmJlxyXG4gICAgICAgICAgICAkKGV2LnRhcmdldCkuaXMoJy5mYy1yZXNpemVyJyk7XHJcbiAgICB9O1xyXG4gICAgLy8gS2lsbHMgYWxsIGluLXByb2dyZXNzIGRyYWdnaW5nLlxyXG4gICAgLy8gVXNlZnVsIGZvciB3aGVuIHB1YmxpYyBBUEkgbWV0aG9kcyB0aGF0IHJlc3VsdCBpbiByZS1yZW5kZXJpbmcgYXJlIGludm9rZWQgZHVyaW5nIGEgZHJhZy5cclxuICAgIC8vIEFsc28gdXNlZnVsIGZvciB3aGVuIHRvdWNoIGRldmljZXMgbWlzYmVoYXZlIGFuZCBkb24ndCBmaXJlIHRoZWlyIHRvdWNoZW5kLlxyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5lbmRJbnRlcmFjdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICB0aGlzLmRhdGVDbGlja2luZyxcclxuICAgICAgICAgICAgdGhpcy5kYXRlU2VsZWN0aW5nLFxyXG4gICAgICAgICAgICB0aGlzLmV2ZW50UG9pbnRpbmcsXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREcmFnZ2luZyxcclxuICAgICAgICAgICAgdGhpcy5ldmVudFJlc2l6aW5nXHJcbiAgICAgICAgXS5mb3JFYWNoKGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoaW50ZXJhY3Rpb24pIHtcclxuICAgICAgICAgICAgICAgIGludGVyYWN0aW9uLmVuZCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgRHJhZy1uLURyb3BcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgZHJhZ2dlZCBieSB0aGUgdXNlclxyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V2ZW50RGVmRHJhZ2dhYmxlID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFdmVudERlZlN0YXJ0RWRpdGFibGUoZXZlbnREZWYpO1xyXG4gICAgfTtcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFdmVudERlZlN0YXJ0RWRpdGFibGUgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgaXNFZGl0YWJsZSA9IGV2ZW50RGVmLmlzU3RhcnRFeHBsaWNpdGx5RWRpdGFibGUoKTtcclxuICAgICAgICBpZiAoaXNFZGl0YWJsZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlzRWRpdGFibGUgPSB0aGlzLm9wdCgnZXZlbnRTdGFydEVkaXRhYmxlJyk7XHJcbiAgICAgICAgICAgIGlmIChpc0VkaXRhYmxlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlzRWRpdGFibGUgPSB0aGlzLmlzRXZlbnREZWZHZW5lcmFsbHlFZGl0YWJsZShldmVudERlZik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzRWRpdGFibGU7XHJcbiAgICB9O1xyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V2ZW50RGVmR2VuZXJhbGx5RWRpdGFibGUgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgaXNFZGl0YWJsZSA9IGV2ZW50RGVmLmlzRXhwbGljaXRseUVkaXRhYmxlKCk7XHJcbiAgICAgICAgaWYgKGlzRWRpdGFibGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpc0VkaXRhYmxlID0gdGhpcy5vcHQoJ2VkaXRhYmxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpc0VkaXRhYmxlO1xyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IFJlc2l6aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIENvbXB1dGVzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhbGxvd2VkIHRvIGJlIHJlc2l6ZWQgZnJvbSBpdHMgc3RhcnRpbmcgZWRnZVxyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V2ZW50RGVmUmVzaXphYmxlRnJvbVN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdldmVudFJlc2l6YWJsZUZyb21TdGFydCcpICYmIHRoaXMuaXNFdmVudERlZlJlc2l6YWJsZShldmVudERlZik7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgaWYgdGhlIGdpdmVuIGV2ZW50IGlzIGFsbG93ZWQgdG8gYmUgcmVzaXplZCBmcm9tIGl0cyBlbmRpbmcgZWRnZVxyXG4gICAgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc0V2ZW50RGVmUmVzaXphYmxlRnJvbUVuZCA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmlzRXZlbnREZWZSZXNpemFibGUoZXZlbnREZWYpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIGlmIHRoZSBnaXZlbiBldmVudCBpcyBhbGxvd2VkIHRvIGJlIHJlc2l6ZWQgYnkgdGhlIHVzZXIgYXQgYWxsXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXZlbnREZWZSZXNpemFibGUgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgaXNSZXNpemFibGUgPSBldmVudERlZi5pc0R1cmF0aW9uRXhwbGljaXRseUVkaXRhYmxlKCk7XHJcbiAgICAgICAgaWYgKGlzUmVzaXphYmxlID09IG51bGwpIHtcclxuICAgICAgICAgICAgaXNSZXNpemFibGUgPSB0aGlzLm9wdCgnZXZlbnREdXJhdGlvbkVkaXRhYmxlJyk7XHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2l6YWJsZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpc1Jlc2l6YWJsZSA9IHRoaXMuaXNFdmVudERlZkdlbmVyYWxseUVkaXRhYmxlKGV2ZW50RGVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaXNSZXNpemFibGU7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgTXV0YXRpb24gLyBDb25zdHJhaW50c1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBEaWZmcyB0aGUgdHdvIGRhdGVzLCByZXR1cm5pbmcgYSBkdXJhdGlvbiwgYmFzZWQgb24gZ3JhbnVsYXJpdHkgb2YgdGhlIGdyaWRcclxuICAgIC8vIFRPRE86IHBvcnQgaXNUaW1lU2NhbGUgaW50byB0aGlzIHN5c3RlbT9cclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZGlmZkRhdGVzID0gZnVuY3Rpb24gKGEsIGIpIHtcclxuICAgICAgICBpZiAodGhpcy5sYXJnZVVuaXQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5kaWZmQnlVbml0KGEsIGIsIHRoaXMubGFyZ2VVbml0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1dGlsXzEuZGlmZkRheVRpbWUoYSwgYik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGlzIGl0IGFsbG93ZWQsIGluIHJlbGF0aW9uIHRvIHRoZSB2aWV3J3MgdmFsaWRSYW5nZT9cclxuICAgIC8vIE5PVEU6IHZlcnkgc2ltaWxhciB0byBpc0V4dGVybmFsSW5zdGFuY2VHcm91cEFsbG93ZWRcclxuICAgIEludGVyYWN0aXZlRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2VHcm91cCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZ2V0VmlldygpO1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IHRoaXMuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudEluc3RhbmNlR3JvdXAuZ2V0QWxsRXZlbnRSYW5nZXMoKSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBqdXN0IHVzZSBnZXRBbGxFdmVudFJhbmdlcyBkaXJlY3RseVxyXG4gICAgICAgICAgICBpZiAoIWRhdGVQcm9maWxlLnZhbGlkVW56b25lZFJhbmdlLmNvbnRhaW5zUmFuZ2UoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZpZXcuY2FsZW5kYXIuY29uc3RyYWludHMuaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkKGV2ZW50SW5zdGFuY2VHcm91cCk7XHJcbiAgICB9O1xyXG4gICAgLy8gTk9URTogdmVyeSBzaW1pbGFyIHRvIGlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZFxyXG4gICAgLy8gd2hlbiBpdCdzIGEgY29tcGxldGVseSBhbm9ueW1vdXMgZXh0ZXJuYWwgZHJhZywgbm8gZXZlbnQuXHJcbiAgICBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQucHJvdG90eXBlLmlzRXh0ZXJuYWxJbnN0YW5jZUdyb3VwQWxsb3dlZCA9IGZ1bmN0aW9uIChldmVudEluc3RhbmNlR3JvdXApIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMuX2dldFZpZXcoKTtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSB0aGlzLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMoZXZlbnRJbnN0YW5jZUdyb3VwLmdldEFsbEV2ZW50UmFuZ2VzKCkpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCFkYXRlUHJvZmlsZS52YWxpZFVuem9uZWRSYW5nZS5jb250YWluc1JhbmdlKGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gdHJlYXQgaXQgYXMgYSBzZWxlY3Rpb25cclxuICAgICAgICAgICAgLy8gVE9ETzogcGFzcyBpbiBldmVudEluc3RhbmNlR3JvdXAgaW5zdGVhZFxyXG4gICAgICAgICAgICAvLyAgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGNhbGVuZGFyJ3MgY29uc3RyYWludCBzeXN0ZW0gdG8gZGVwZW5kIG9uIGEgY29tcG9uZW50J3NcclxuICAgICAgICAgICAgLy8gIGRldGVybWluYXRpb24gb2YgZm9vdHByaW50cy5cclxuICAgICAgICAgICAgaWYgKCF2aWV3LmNhbGVuZGFyLmNvbnN0cmFpbnRzLmlzU2VsZWN0aW9uRm9vdHByaW50QWxsb3dlZChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnQ7XHJcbn0oRGF0ZUNvbXBvbmVudF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50O1xyXG5cblxuLyoqKi8gfSksXG4vKiA0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBSZW5kZXJRdWV1ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjkpO1xyXG52YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xyXG52YXIgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcclxudmFyIEdsb2JhbEVtaXR0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG4vKiBBbiBhYnN0cmFjdCBjbGFzcyBmcm9tIHdoaWNoIG90aGVyIHZpZXdzIGluaGVyaXQgZnJvbVxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIFZpZXcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhWaWV3LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gVmlldyhjYWxlbmRhciwgdmlld1NwZWMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBudWxsLCB2aWV3U3BlYy5vcHRpb25zKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmJhdGNoUmVuZGVyRGVwdGggPSAwO1xyXG4gICAgICAgIF90aGlzLmlzU2VsZWN0ZWQgPSBmYWxzZTsgLy8gYm9vbGVhbiB3aGV0aGVyIGEgcmFuZ2Ugb2YgdGltZSBpcyB1c2VyLXNlbGVjdGVkIG9yIG5vdFxyXG4gICAgICAgIF90aGlzLmNhbGVuZGFyID0gY2FsZW5kYXI7XHJcbiAgICAgICAgX3RoaXMudmlld1NwZWMgPSB2aWV3U3BlYztcclxuICAgICAgICAvLyBzaG9ydGN1dHNcclxuICAgICAgICBfdGhpcy50eXBlID0gdmlld1NwZWMudHlwZTtcclxuICAgICAgICAvLyAubmFtZSBpcyBkZXByZWNhdGVkXHJcbiAgICAgICAgX3RoaXMubmFtZSA9IF90aGlzLnR5cGU7XHJcbiAgICAgICAgX3RoaXMuaW5pdFJlbmRlclF1ZXVlKCk7XHJcbiAgICAgICAgX3RoaXMuaW5pdEhpZGRlbkRheXMoKTtcclxuICAgICAgICBfdGhpcy5kYXRlUHJvZmlsZUdlbmVyYXRvciA9IG5ldyBfdGhpcy5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzKF90aGlzKTtcclxuICAgICAgICBfdGhpcy5iaW5kQmFzZVJlbmRlckhhbmRsZXJzKCk7XHJcbiAgICAgICAgX3RoaXMuZXZlbnRPcmRlclNwZWNzID0gdXRpbF8xLnBhcnNlRmllbGRTcGVjcyhfdGhpcy5vcHQoJ2V2ZW50T3JkZXInKSk7XHJcbiAgICAgICAgLy8gbGVnYWN5XHJcbiAgICAgICAgaWYgKF90aGlzWydpbml0aWFsaXplJ10pIHtcclxuICAgICAgICAgICAgX3RoaXNbJ2luaXRpYWxpemUnXSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBWaWV3LnByb3RvdHlwZS5fZ2V0VmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH07XHJcbiAgICAvLyBSZXRyaWV2ZXMgYW4gb3B0aW9uIHdpdGggdGhlIGdpdmVuIG5hbWVcclxuICAgIFZpZXcucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1tuYW1lXTtcclxuICAgIH07XHJcbiAgICAvKiBSZW5kZXIgUXVldWVcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS5pbml0UmVuZGVyUXVldWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZSA9IG5ldyBSZW5kZXJRdWV1ZV8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBldmVudDogdGhpcy5vcHQoJ2V2ZW50UmVuZGVyV2FpdCcpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5vbignc3RhcnQnLCB0aGlzLm9uUmVuZGVyUXVldWVTdGFydC5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLnJlbmRlclF1ZXVlLm9uKCdzdG9wJywgdGhpcy5vblJlbmRlclF1ZXVlU3RvcC5iaW5kKHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uKCdiZWZvcmU6Y2hhbmdlJywgdGhpcy5zdGFydEJhdGNoUmVuZGVyKTtcclxuICAgICAgICB0aGlzLm9uKCdjaGFuZ2UnLCB0aGlzLnN0b3BCYXRjaFJlbmRlcik7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUub25SZW5kZXJRdWV1ZVN0YXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsZW5kYXIuZnJlZXplQ29udGVudEhlaWdodCgpO1xyXG4gICAgICAgIHRoaXMuYWRkU2Nyb2xsKHRoaXMucXVlcnlTY3JvbGwoKSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUub25SZW5kZXJRdWV1ZVN0b3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY2FsZW5kYXIudXBkYXRlVmlld1NpemUoKSkgeyAvLyBzdWNjZXNzP1xyXG4gICAgICAgICAgICB0aGlzLnBvcFNjcm9sbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGVuZGFyLnRoYXdDb250ZW50SGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuc3RhcnRCYXRjaFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoISh0aGlzLmJhdGNoUmVuZGVyRGVwdGgrKykpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5wYXVzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5zdG9wQmF0Y2hSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEoLS10aGlzLmJhdGNoUmVuZGVyRGVwdGgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyUXVldWUucmVzdW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3RSZW5kZXIgPSBmdW5jdGlvbiAoZnVuYywgbmFtZXNwYWNlLCBhY3Rpb25UeXBlKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJRdWV1ZS5xdWV1ZShmdW5jLCBuYW1lc3BhY2UsIGFjdGlvblR5cGUpO1xyXG4gICAgfTtcclxuICAgIC8vIGdpdmVuIGZ1bmMgd2lsbCBhdXRvLWJpbmQgdG8gYHRoaXNgXHJcbiAgICBWaWV3LnByb3RvdHlwZS53aGVuU2l6ZVVwZGF0ZWQgPSBmdW5jdGlvbiAoZnVuYykge1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlclF1ZXVlLmlzUnVubmluZykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlclF1ZXVlLm9uZSgnc3RvcCcsIGZ1bmMuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmdW5jLmNhbGwodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIFRpdGxlIGFuZCBEYXRlIEZvcm1hdHRpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBDb21wdXRlcyB3aGF0IHRoZSB0aXRsZSBhdCB0aGUgdG9wIG9mIHRoZSBjYWxlbmRhciBzaG91bGQgYmUgZm9yIHRoaXMgdmlld1xyXG4gICAgVmlldy5wcm90b3R5cGUuY29tcHV0ZVRpdGxlID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIHVuem9uZWRSYW5nZTtcclxuICAgICAgICAvLyBmb3Igdmlld3MgdGhhdCBzcGFuIGEgbGFyZ2UgdW5pdCBvZiB0aW1lLCBzaG93IHRoZSBwcm9wZXIgaW50ZXJ2YWwsIGlnbm9yaW5nIHN0cmF5IGRheXMgYmVmb3JlIGFuZCBhZnRlclxyXG4gICAgICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpIHtcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7IC8vIGZvciBkYXkgdW5pdHMgb3Igc21hbGxlciwgdXNlIHRoZSBhY3R1YWwgZGF5IHJhbmdlXHJcbiAgICAgICAgICAgIHVuem9uZWRSYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0UmFuZ2Uoe1xyXG4gICAgICAgICAgICBzdGFydDogdGhpcy5jYWxlbmRhci5tc1RvTW9tZW50KHVuem9uZWRSYW5nZS5zdGFydE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KSxcclxuICAgICAgICAgICAgZW5kOiB0aGlzLmNhbGVuZGFyLm1zVG9Nb21lbnQodW56b25lZFJhbmdlLmVuZE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KVxyXG4gICAgICAgIH0sIGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXksIHRoaXMub3B0KCd0aXRsZUZvcm1hdCcpIHx8IHRoaXMuY29tcHV0ZVRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSwgdGhpcy5vcHQoJ3RpdGxlUmFuZ2VTZXBhcmF0b3InKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBmb3JtYXQgc3RyaW5nIHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIHRpdGxlIGZvciB0aGUgY3VycmVudCBkYXRlIHJhbmdlLlxyXG4gICAgLy8gQXR0ZW1wdHMgdG8gY29tcHV0ZSB0aGUgbW9zdCBhcHByb3ByaWF0ZSBmb3JtYXQgaWYgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkIHdpdGggYHRpdGxlRm9ybWF0YC5cclxuICAgIFZpZXcucHJvdG90eXBlLmNvbXB1dGVUaXRsZUZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50UmFuZ2VVbml0ID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdDtcclxuICAgICAgICBpZiAoY3VycmVudFJhbmdlVW5pdCA9PT0gJ3llYXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnWVlZWSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1cnJlbnRSYW5nZVVuaXQgPT09ICdtb250aCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdtb250aFllYXJGb3JtYXQnKTsgLy8gbGlrZSBcIlNlcHRlbWJlciAyMDE0XCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZS5hcygnZGF5cycpID4gMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2xsJzsgLy8gbXVsdGktZGF5IHJhbmdlLiBzaG9ydGVyLCBsaWtlIFwiU2VwIDkgLSAxMCAyMDE0XCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnTEwnOyAvLyBvbmUgZGF5LiBsb25nZXIsIGxpa2UgXCJTZXB0ZW1iZXIgOSAyMDE0XCJcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRGF0ZSBTZXR0aW5nL1Vuc2V0dGluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIFZpZXcucHJvdG90eXBlLnNldERhdGUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHZhciBjdXJyZW50RGF0ZVByb2ZpbGUgPSB0aGlzLmdldCgnZGF0ZVByb2ZpbGUnKTtcclxuICAgICAgICB2YXIgbmV3RGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkKGRhdGUsIHVuZGVmaW5lZCwgdHJ1ZSk7IC8vIGZvcmNlVG9WYWxpZD10cnVlXHJcbiAgICAgICAgaWYgKCFjdXJyZW50RGF0ZVByb2ZpbGUgfHxcclxuICAgICAgICAgICAgIWN1cnJlbnREYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuZXF1YWxzKG5ld0RhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXQoJ2RhdGVQcm9maWxlJywgbmV3RGF0ZVByb2ZpbGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS51bnNldERhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnNldCgnZGF0ZVByb2ZpbGUnKTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBEYXRhXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgVmlldy5wcm90b3R5cGUuZmV0Y2hJbml0aWFsRXZlbnRzID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgZm9yY2VBbGxEYXkgPSBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5ICYmICF0aGlzLnVzZXNNaW5NYXhUaW1lO1xyXG4gICAgICAgIHJldHVybiBjYWxlbmRhci5yZXF1ZXN0RXZlbnRzKGNhbGVuZGFyLm1zVG9Nb21lbnQoZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLnN0YXJ0TXMsIGZvcmNlQWxsRGF5KSwgY2FsZW5kYXIubXNUb01vbWVudChkYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuZW5kTXMsIGZvcmNlQWxsRGF5KSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuYmluZEV2ZW50Q2hhbmdlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY2FsZW5kYXIsICdldmVudHNSZXNldCcsIHRoaXMucmVzZXRFdmVudHMpOyAvLyBUT0RPOiBtYWtlIHRoaXMgYSByZWFsIGV2ZW50XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudW5iaW5kRXZlbnRDaGFuZ2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKHRoaXMuY2FsZW5kYXIsICdldmVudHNSZXNldCcpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnNldEV2ZW50cyA9IGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgdGhpcy5zZXQoJ2N1cnJlbnRFdmVudHMnLCBldmVudHNQYXlsb2FkKTtcclxuICAgICAgICB0aGlzLnNldCgnaGFzRXZlbnRzJywgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudW5zZXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnNldCgnY3VycmVudEV2ZW50cycpO1xyXG4gICAgICAgIHRoaXMudW5zZXQoJ2hhc0V2ZW50cycpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlc2V0RXZlbnRzID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0QmF0Y2hSZW5kZXIoKTtcclxuICAgICAgICB0aGlzLnVuc2V0RXZlbnRzKCk7XHJcbiAgICAgICAgdGhpcy5zZXRFdmVudHMoZXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgdGhpcy5zdG9wQmF0Y2hSZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICAvLyBEYXRlIEhpZ2gtbGV2ZWwgUmVuZGVyaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdERhdGVSZW5kZXIgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV4ZWN1dGVEYXRlUmVuZGVyKGRhdGVQcm9maWxlKTtcclxuICAgICAgICB9LCAnZGF0ZScsICdpbml0Jyk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdERhdGVVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV4ZWN1dGVEYXRlVW5yZW5kZXIoKTtcclxuICAgICAgICB9LCAnZGF0ZScsICdkZXN0cm95Jyk7XHJcbiAgICB9O1xyXG4gICAgLy8gaWYgZGF0ZVByb2ZpbGUgbm90IHNwZWNpZmllZCwgdXNlcyBjdXJyZW50XHJcbiAgICBWaWV3LnByb3RvdHlwZS5leGVjdXRlRGF0ZVJlbmRlciA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZURhdGVSZW5kZXIuY2FsbCh0aGlzLCBkYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgaWYgKHRoaXNbJ3JlbmRlciddKSB7XHJcbiAgICAgICAgICAgIHRoaXNbJ3JlbmRlciddKCk7IC8vIFRPRE86IGRlcHJlY2F0ZVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2RhdGVzUmVuZGVyZWQnKTtcclxuICAgICAgICB0aGlzLmFkZFNjcm9sbCh7IGlzRGF0ZUluaXQ6IHRydWUgfSk7XHJcbiAgICAgICAgdGhpcy5zdGFydE5vd0luZGljYXRvcigpOyAvLyBzaG91bGRuJ3QgcmVuZGVyIHlldCBiZWNhdXNlIHVwZGF0ZVNpemUgd2lsbCBiZSBjYWxsZWQgc29vblxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmV4ZWN1dGVEYXRlVW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xyXG4gICAgICAgIHRoaXMuc3RvcE5vd0luZGljYXRvcigpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlOmRhdGVzVW5yZW5kZXJlZCcpO1xyXG4gICAgICAgIGlmICh0aGlzWydkZXN0cm95J10pIHtcclxuICAgICAgICAgICAgdGhpc1snZGVzdHJveSddKCk7IC8vIFRPRE86IGRlcHJlY2F0ZVxyXG4gICAgICAgIH1cclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmV4ZWN1dGVEYXRlVW5yZW5kZXIuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICAvLyBcIkJhc2VcIiByZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5iaW5kQmFzZVJlbmRlckhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5vbignZGF0ZXNSZW5kZXJlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMud2hlblNpemVVcGRhdGVkKF90aGlzLnRyaWdnZXJWaWV3UmVuZGVyKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm9uKCdiZWZvcmU6ZGF0ZXNVbnJlbmRlcmVkJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy50cmlnZ2VyVmlld0Rlc3Ryb3koKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyVmlld1JlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcigndmlld1JlbmRlcicsIHtcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgYXJnczogW3RoaXMsIHRoaXMuZWxdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlclZpZXdEZXN0cm95ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd2aWV3RGVzdHJveScsIHtcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcyxcclxuICAgICAgICAgICAgYXJnczogW3RoaXMsIHRoaXMuZWxdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgSGlnaC1sZXZlbCBSZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0RXZlbnRzUmVuZGVyID0gZnVuY3Rpb24gKGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmV4ZWN1dGVFdmVudFJlbmRlcihldmVudHNQYXlsb2FkKTtcclxuICAgICAgICAgICAgX3RoaXMud2hlblNpemVVcGRhdGVkKF90aGlzLnRyaWdnZXJBZnRlckV2ZW50c1JlbmRlcmVkKTtcclxuICAgICAgICB9LCAnZXZlbnQnLCAnaW5pdCcpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlcXVlc3RFdmVudHNVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnRyaWdnZXJCZWZvcmVFdmVudHNEZXN0cm95ZWQoKTtcclxuICAgICAgICAgICAgX3RoaXMuZXhlY3V0ZUV2ZW50VW5yZW5kZXIoKTtcclxuICAgICAgICB9LCAnZXZlbnQnLCAnZGVzdHJveScpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1c2luZXNzIEhvdXIgSGlnaC1sZXZlbCBSZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXF1ZXN0QnVzaW5lc3NIb3Vyc1JlbmRlciA9IGZ1bmN0aW9uIChidXNpbmVzc0hvdXJHZW5lcmF0b3IpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckJ1c2luZXNzSG91cnMoYnVzaW5lc3NIb3VyR2VuZXJhdG9yKTtcclxuICAgICAgICB9LCAnYnVzaW5lc3NIb3VycycsICdpbml0Jyk7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVxdWVzdEJ1c2luZXNzSG91cnNVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMucmVxdWVzdFJlbmRlcihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnVucmVuZGVyQnVzaW5lc3NIb3VycygpO1xyXG4gICAgICAgIH0sICdidXNpbmVzc0hvdXJzJywgJ2Rlc3Ryb3knKTtcclxuICAgIH07XHJcbiAgICAvLyBNaXNjIHZpZXcgcmVuZGVyaW5nIHV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gQmluZHMgRE9NIGhhbmRsZXJzIHRvIGVsZW1lbnRzIHRoYXQgcmVzaWRlIG91dHNpZGUgdGhlIHZpZXcgY29udGFpbmVyLCBzdWNoIGFzIHRoZSBkb2N1bWVudFxyXG4gICAgVmlldy5wcm90b3R5cGUuYmluZEdsb2JhbEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuYmluZEdsb2JhbEhhbmRsZXJzLmNhbGwodGhpcyk7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5UbyhHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKSwge1xyXG4gICAgICAgICAgICB0b3VjaHN0YXJ0OiB0aGlzLnByb2Nlc3NVbnNlbGVjdCxcclxuICAgICAgICAgICAgbW91c2Vkb3duOiB0aGlzLmhhbmRsZURvY3VtZW50TW91c2Vkb3duXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5iaW5kcyBET00gaGFuZGxlcnMgZnJvbSBlbGVtZW50cyB0aGF0IHJlc2lkZSBvdXRzaWRlIHRoZSB2aWV3IGNvbnRhaW5lclxyXG4gICAgVmlldy5wcm90b3R5cGUudW5iaW5kR2xvYmFsSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51bmJpbmRHbG9iYWxIYW5kbGVycy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LmdldCgpKTtcclxuICAgIH07XHJcbiAgICAvKiBOb3cgSW5kaWNhdG9yXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gSW1tZWRpYXRlbHkgcmVuZGVyIHRoZSBjdXJyZW50IHRpbWUgaW5kaWNhdG9yIGFuZCBiZWdpbnMgcmUtcmVuZGVyaW5nIGl0IGF0IGFuIGludGVydmFsLFxyXG4gICAgLy8gd2hpY2ggaXMgZGVmaW5lZCBieSB0aGlzLmdldE5vd0luZGljYXRvclVuaXQoKS5cclxuICAgIC8vIFRPRE86IHNvbWVob3cgZG8gdGhpcyBmb3IgdGhlIGN1cnJlbnQgd2hvbGUgZGF5J3MgYmFja2dyb3VuZCB0b29cclxuICAgIFZpZXcucHJvdG90eXBlLnN0YXJ0Tm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHVuaXQ7XHJcbiAgICAgICAgdmFyIHVwZGF0ZTtcclxuICAgICAgICB2YXIgZGVsYXk7IC8vIG1zIHdhaXQgdmFsdWVcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ25vd0luZGljYXRvcicpKSB7XHJcbiAgICAgICAgICAgIHVuaXQgPSB0aGlzLmdldE5vd0luZGljYXRvclVuaXQoKTtcclxuICAgICAgICAgICAgaWYgKHVuaXQpIHtcclxuICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHV0aWxfMS5wcm94eSh0aGlzLCAndXBkYXRlTm93SW5kaWNhdG9yJyk7IC8vIGJpbmQgdG8gYHRoaXNgXHJcbiAgICAgICAgICAgICAgICB0aGlzLmluaXRpYWxOb3dEYXRlID0gdGhpcy5jYWxlbmRhci5nZXROb3coKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyA9IG5ldyBEYXRlKCkudmFsdWVPZigpO1xyXG4gICAgICAgICAgICAgICAgLy8gd2FpdCB1bnRpbCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBuZXh0IGludGVydmFsXHJcbiAgICAgICAgICAgICAgICBkZWxheSA9IHRoaXMuaW5pdGlhbE5vd0RhdGUuY2xvbmUoKS5zdGFydE9mKHVuaXQpLmFkZCgxLCB1bml0KS52YWx1ZU9mKCkgLSB0aGlzLmluaXRpYWxOb3dEYXRlLnZhbHVlT2YoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBkZWxheSA9ICttb21lbnQuZHVyYXRpb24oMSwgdW5pdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSBNYXRoLm1heCgxMDAsIGRlbGF5KTsgLy8gcHJldmVudCB0b28gZnJlcXVlbnRcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEID0gc2V0SW50ZXJ2YWwodXBkYXRlLCBkZWxheSk7IC8vIHVwZGF0ZSBldmVyeSBpbnRlcnZhbFxyXG4gICAgICAgICAgICAgICAgfSwgZGVsYXkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHJlbmRlcmluZyB3aWxsIGJlIGluaXRpYXRlZCBpbiB1cGRhdGVTaXplXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIHJlcmVuZGVycyB0aGUgbm93IGluZGljYXRvciwgY29tcHV0aW5nIHRoZSBuZXcgY3VycmVudCB0aW1lIGZyb20gdGhlIGFtb3VudCBvZiB0aW1lIHRoYXQgaGFzIHBhc3NlZFxyXG4gICAgLy8gc2luY2UgdGhlIGluaXRpYWwgZ2V0Tm93IGNhbGwuXHJcbiAgICBWaWV3LnByb3RvdHlwZS51cGRhdGVOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEYXRlc1JlbmRlcmVkICYmXHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbE5vd0RhdGUgLy8gYWN0aXZhdGVkIGJlZm9yZT9cclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhpcy51bnJlbmRlck5vd0luZGljYXRvcigpOyAvLyB3b24ndCB1bnJlbmRlciBpZiB1bm5lY2Vzc2FyeVxyXG4gICAgICAgICAgICB0aGlzLnJlbmRlck5vd0luZGljYXRvcih0aGlzLmluaXRpYWxOb3dEYXRlLmNsb25lKCkuYWRkKG5ldyBEYXRlKCkudmFsdWVPZigpIC0gdGhpcy5pbml0aWFsTm93UXVlcmllZE1zKSAvLyBhZGQgbXNcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gSW1tZWRpYXRlbHkgdW5yZW5kZXJzIHRoZSB2aWV3J3MgY3VycmVudCB0aW1lIGluZGljYXRvciBhbmQgc3RvcHMgYW55IHJlLXJlbmRlcmluZyB0aW1lcnMuXHJcbiAgICAvLyBXb24ndCBjYXVzZSBzaWRlIGVmZmVjdHMgaWYgaW5kaWNhdG9yIGlzbid0IHJlbmRlcmVkLlxyXG4gICAgVmlldy5wcm90b3R5cGUuc3RvcE5vd0luZGljYXRvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm5vd0luZGljYXRvclRpbWVvdXRJRCkge1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9yVGltZW91dElEID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5ub3dJbmRpY2F0b3JJbnRlcnZhbElEKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMubm93SW5kaWNhdG9ySW50ZXJ2YWxJRCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm5vd0luZGljYXRvckludGVydmFsSUQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudW5yZW5kZXJOb3dJbmRpY2F0b3IoKTtcclxuICAgICAgICAgICAgdGhpcy5pc05vd0luZGljYXRvclJlbmRlcmVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIERpbWVuc2lvbnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKSB7XHJcbiAgICAgICAgaWYgKHRoaXNbJ3NldEhlaWdodCddKSB7IC8vIGZvciBsZWdhY3kgQVBJXHJcbiAgICAgICAgICAgIHRoaXNbJ3NldEhlaWdodCddKHRvdGFsSGVpZ2h0LCBpc0F1dG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVTaXplLmNhbGwodGhpcywgdG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnVwZGF0ZU5vd0luZGljYXRvcigpO1xyXG4gICAgfTtcclxuICAgIC8qIFNjcm9sbGVyXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVmlldy5wcm90b3R5cGUuYWRkU2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgIHZhciBxdWV1ZWRTY3JvbGwgPSB0aGlzLnF1ZXVlZFNjcm9sbCB8fCAodGhpcy5xdWV1ZWRTY3JvbGwgPSB7fSk7XHJcbiAgICAgICAgJC5leHRlbmQocXVldWVkU2Nyb2xsLCBzY3JvbGwpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnBvcFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFwcGx5UXVldWVkU2Nyb2xsKCk7XHJcbiAgICAgICAgdGhpcy5xdWV1ZWRTY3JvbGwgPSBudWxsO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmFwcGx5UXVldWVkU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnF1ZXVlZFNjcm9sbCkge1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5U2Nyb2xsKHRoaXMucXVldWVkU2Nyb2xsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucXVlcnlTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbCA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGF0ZXNSZW5kZXJlZCkge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChzY3JvbGwsIHRoaXMucXVlcnlEYXRlU2Nyb2xsKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2Nyb2xsO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLmFwcGx5U2Nyb2xsID0gZnVuY3Rpb24gKHNjcm9sbCkge1xyXG4gICAgICAgIGlmIChzY3JvbGwuaXNEYXRlSW5pdCAmJiB0aGlzLmlzRGF0ZXNSZW5kZXJlZCkge1xyXG4gICAgICAgICAgICAkLmV4dGVuZChzY3JvbGwsIHRoaXMuY29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0RhdGVzUmVuZGVyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5hcHBseURhdGVTY3JvbGwoc2Nyb2xsKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUuY29tcHV0ZUluaXRpYWxEYXRlU2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB7fTsgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnF1ZXJ5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge307IC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5hcHBseURhdGVTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IERyYWctbi1Ecm9wXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVmlldy5wcm90b3R5cGUucmVwb3J0RXZlbnREcm9wID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UsIGV2ZW50TXV0YXRpb24sIGVsLCBldikge1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSB0aGlzLmNhbGVuZGFyLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgdW5kb0Z1bmMgPSBldmVudE1hbmFnZXIubXV0YXRlRXZlbnRzV2l0aElkKGV2ZW50SW5zdGFuY2UuZGVmLmlkLCBldmVudE11dGF0aW9uKTtcclxuICAgICAgICB2YXIgZGF0ZU11dGF0aW9uID0gZXZlbnRNdXRhdGlvbi5kYXRlTXV0YXRpb247XHJcbiAgICAgICAgLy8gdXBkYXRlIHRoZSBFdmVudEluc3RhbmNlLCBmb3IgaGFuZGxlcnNcclxuICAgICAgICBpZiAoZGF0ZU11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UuZGF0ZVByb2ZpbGUgPSBkYXRlTXV0YXRpb24uYnVpbGROZXdEYXRlUHJvZmlsZShldmVudEluc3RhbmNlLmRhdGVQcm9maWxlLCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnREcm9wKGV2ZW50SW5zdGFuY2UsIFxyXG4gICAgICAgIC8vIGEgZHJvcCBkb2Vzbid0IG5lY2Vzc2FyaWx5IG1lYW4gYSBkYXRlIG11dGF0aW9uIChleDogcmVzb3VyY2UgY2hhbmdlKVxyXG4gICAgICAgIChkYXRlTXV0YXRpb24gJiYgZGF0ZU11dGF0aW9uLmRhdGVEZWx0YSkgfHwgbW9tZW50LmR1cmF0aW9uKCksIHVuZG9GdW5jLCBlbCwgZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIFRyaWdnZXJzIGV2ZW50LWRyb3AgaGFuZGxlcnMgdGhhdCBoYXZlIHN1YnNjcmliZWQgdmlhIHRoZSBBUElcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJFdmVudERyb3AgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZGF0ZURlbHRhLCB1bmRvRnVuYywgZWwsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RHJvcCcsIHtcclxuICAgICAgICAgICAgY29udGV4dDogZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIGV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSxcclxuICAgICAgICAgICAgICAgIGRhdGVEZWx0YSxcclxuICAgICAgICAgICAgICAgIHVuZG9GdW5jLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qIEV4dGVybmFsIEVsZW1lbnQgRHJhZy1uLURyb3BcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBNdXN0IGJlIGNhbGxlZCB3aGVuIGFuIGV4dGVybmFsIGVsZW1lbnQsIHZpYSBqUXVlcnkgVUksIGhhcyBiZWVuIGRyb3BwZWQgb250byB0aGUgY2FsZW5kYXIuXHJcbiAgICAvLyBgbWV0YWAgaXMgdGhlIHBhcnNlZCBkYXRhIHRoYXQgaGFzIGJlZW4gZW1iZWRkZWQgaW50byB0aGUgZHJhZ2dpbmcgZXZlbnQuXHJcbiAgICAvLyBgZHJvcExvY2F0aW9uYCBpcyBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgbmV3IHpvbmVkIHN0YXJ0L2VuZC9hbGxEYXkgdmFsdWVzIGZvciB0aGUgZXZlbnQuXHJcbiAgICBWaWV3LnByb3RvdHlwZS5yZXBvcnRFeHRlcm5hbERyb3AgPSBmdW5jdGlvbiAoc2luZ2xlRXZlbnREZWYsIGlzRXZlbnQsIGlzU3RpY2t5LCBlbCwgZXYsIHVpKSB7XHJcbiAgICAgICAgaWYgKGlzRXZlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhci5ldmVudE1hbmFnZXIuYWRkRXZlbnREZWYoc2luZ2xlRXZlbnREZWYsIGlzU3RpY2t5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyRXh0ZXJuYWxEcm9wKHNpbmdsZUV2ZW50RGVmLCBpc0V2ZW50LCBlbCwgZXYsIHVpKTtcclxuICAgIH07XHJcbiAgICAvLyBUcmlnZ2VycyBleHRlcm5hbC1kcm9wIGhhbmRsZXJzIHRoYXQgaGF2ZSBzdWJzY3JpYmVkIHZpYSB0aGUgQVBJXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyRXh0ZXJuYWxEcm9wID0gZnVuY3Rpb24gKHNpbmdsZUV2ZW50RGVmLCBpc0V2ZW50LCBlbCwgZXYsIHVpKSB7XHJcbiAgICAgICAgLy8gdHJpZ2dlciAnZHJvcCcgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIGVsZW1lbnQgcmVwcmVzZW50cyBhbiBldmVudFxyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdkcm9wJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBlbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2luZ2xlRXZlbnREZWYuZGF0ZVByb2ZpbGUuc3RhcnQuY2xvbmUoKSxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAgdWksXHJcbiAgICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgIF1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoaXNFdmVudCkge1xyXG4gICAgICAgICAgICAvLyBzaWduYWwgYW4gZXh0ZXJuYWwgZXZlbnQgbGFuZGVkXHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudFJlY2VpdmUnLCB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUV2ZW50RGVmLmJ1aWxkSW5zdGFuY2UoKS50b0xlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFJlc2l6aW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gTXVzdCBiZSBjYWxsZWQgd2hlbiBhbiBldmVudCBpbiB0aGUgdmlldyBoYXMgYmVlbiByZXNpemVkIHRvIGEgbmV3IGxlbmd0aFxyXG4gICAgVmlldy5wcm90b3R5cGUucmVwb3J0RXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZXZlbnRNdXRhdGlvbiwgZWwsIGV2KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuY2FsZW5kYXIuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciB1bmRvRnVuYyA9IGV2ZW50TWFuYWdlci5tdXRhdGVFdmVudHNXaXRoSWQoZXZlbnRJbnN0YW5jZS5kZWYuaWQsIGV2ZW50TXV0YXRpb24pO1xyXG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgRXZlbnRJbnN0YW5jZSwgZm9yIGhhbmRsZXJzXHJcbiAgICAgICAgZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZSA9IGV2ZW50TXV0YXRpb24uZGF0ZU11dGF0aW9uLmJ1aWxkTmV3RGF0ZVByb2ZpbGUoZXZlbnRJbnN0YW5jZS5kYXRlUHJvZmlsZSwgdGhpcy5jYWxlbmRhcik7XHJcbiAgICAgICAgdmFyIHJlc2l6ZURlbHRhID0gZXZlbnRNdXRhdGlvbi5kYXRlTXV0YXRpb24uZW5kRGVsdGEgfHwgZXZlbnRNdXRhdGlvbi5kYXRlTXV0YXRpb24uc3RhcnREZWx0YTtcclxuICAgICAgICB0aGlzLnRyaWdnZXJFdmVudFJlc2l6ZShldmVudEluc3RhbmNlLCByZXNpemVEZWx0YSwgdW5kb0Z1bmMsIGVsLCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcnMgZXZlbnQtcmVzaXplIGhhbmRsZXJzIHRoYXQgaGF2ZSBzdWJzY3JpYmVkIHZpYSB0aGUgQVBJXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgcmVzaXplRGVsdGEsIHVuZG9GdW5jLCBlbCwgZXYpIHtcclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnRSZXNpemUnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IGVsWzBdLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlLnRvTGVnYWN5KCksXHJcbiAgICAgICAgICAgICAgICByZXNpemVEZWx0YSxcclxuICAgICAgICAgICAgICAgIHVuZG9GdW5jLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXNcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qIFNlbGVjdGlvbiAodGltZSByYW5nZSlcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBTZWxlY3RzIGEgZGF0ZSBzcGFuIG9uIHRoZSB2aWV3LiBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgYm90aCBNb21lbnRzLlxyXG4gICAgLy8gYGV2YCBpcyB0aGUgbmF0aXZlIG1vdXNlIGV2ZW50IHRoYXQgYmVnaW4gdGhlIGludGVyYWN0aW9uLlxyXG4gICAgVmlldy5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGZvb3RwcmludCwgZXYpIHtcclxuICAgICAgICB0aGlzLnVuc2VsZWN0KGV2KTtcclxuICAgICAgICB0aGlzLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludChmb290cHJpbnQpO1xyXG4gICAgICAgIHRoaXMucmVwb3J0U2VsZWN0aW9uKGZvb3RwcmludCwgZXYpO1xyXG4gICAgfTtcclxuICAgIFZpZXcucHJvdG90eXBlLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludCA9IGZ1bmN0aW9uIChmb290cHJpbnQpIHtcclxuICAgICAgICBpZiAodGhpc1sncmVuZGVyU2VsZWN0aW9uJ10pIHsgLy8gbGVnYWN5IG1ldGhvZCBpbiBjdXN0b20gdmlldyBjbGFzc2VzXHJcbiAgICAgICAgICAgIHRoaXNbJ3JlbmRlclNlbGVjdGlvbiddKGZvb3RwcmludC50b0xlZ2FjeSh0aGlzLmNhbGVuZGFyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfc3VwZXIucHJvdG90eXBlLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludC5jYWxsKHRoaXMsIGZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIGEgbmV3IHNlbGVjdGlvbiBpcyBtYWRlLiBVcGRhdGVzIGludGVybmFsIHN0YXRlIGFuZCB0cmlnZ2VycyBoYW5kbGVycy5cclxuICAgIFZpZXcucHJvdG90eXBlLnJlcG9ydFNlbGVjdGlvbiA9IGZ1bmN0aW9uIChmb290cHJpbnQsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5pc1NlbGVjdGVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnRyaWdnZXJTZWxlY3QoZm9vdHByaW50LCBldik7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcnMgaGFuZGxlcnMgdG8gJ3NlbGVjdCdcclxuICAgIFZpZXcucHJvdG90eXBlLnRyaWdnZXJTZWxlY3QgPSBmdW5jdGlvbiAoZm9vdHByaW50LCBldikge1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuY2FsZW5kYXIuZm9vdHByaW50VG9EYXRlUHJvZmlsZShmb290cHJpbnQpOyAvLyBhYnVzZSBvZiBcIkV2ZW50XCJEYXRlUHJvZmlsZT9cclxuICAgICAgICB0aGlzLnB1YmxpY2x5VHJpZ2dlcignc2VsZWN0Jywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbXHJcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZS5zdGFydCxcclxuICAgICAgICAgICAgICAgIGRhdGVQcm9maWxlLmVuZCxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAgdGhpc1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5kb2VzIGEgc2VsZWN0aW9uLiB1cGRhdGVzIGluIHRoZSBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMuXHJcbiAgICAvLyBgZXZgIGlzIHRoZSBuYXRpdmUgbW91c2UgZXZlbnQgdGhhdCBiZWdhbiB0aGUgaW50ZXJhY3Rpb24uXHJcbiAgICBWaWV3LnByb3RvdHlwZS51bnNlbGVjdCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzU2VsZWN0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pc1NlbGVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzWydkZXN0cm95U2VsZWN0aW9uJ10pIHtcclxuICAgICAgICAgICAgICAgIHRoaXNbJ2Rlc3Ryb3lTZWxlY3Rpb24nXSgpOyAvLyBUT0RPOiBkZXByZWNhdGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnVucmVuZGVyU2VsZWN0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd1bnNlbGVjdCcsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMsXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBbZXYsIHRoaXNdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBTZWxlY3Rpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS5zZWxlY3RFdmVudEluc3RhbmNlID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2UpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlIHx8XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlICE9PSBldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5zZWxlY3RFdmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0RXZlbnRTZWdzKCkuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlID09PSBldmVudEluc3RhbmNlICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVsIC8vIG5lY2Vzc2FyeT9cclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5lbC5hZGRDbGFzcygnZmMtc2VsZWN0ZWQnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlID0gZXZlbnRJbnN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUudW5zZWxlY3RFdmVudEluc3RhbmNlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdldEV2ZW50U2VncygpLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZy5lbCkgeyAvLyBuZWNlc3Nhcnk/XHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVsLnJlbW92ZUNsYXNzKCdmYy1zZWxlY3RlZCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEV2ZW50SW5zdGFuY2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5pc0V2ZW50RGVmU2VsZWN0ZWQgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICAvLyBldmVudCByZWZlcmVuY2VzIG1pZ2h0IGNoYW5nZSBvbiByZWZldGNoRXZlbnRzKCksIHdoaWxlIHNlbGVjdGVkRXZlbnRJbnN0YW5jZSBkb2Vzbid0LFxyXG4gICAgICAgIC8vIHNvIGNvbXBhcmUgSURzXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlICYmIHRoaXMuc2VsZWN0ZWRFdmVudEluc3RhbmNlLmRlZi5pZCA9PT0gZXZlbnREZWYuaWQ7XHJcbiAgICB9O1xyXG4gICAgLyogTW91c2UgLyBUb3VjaCBVbnNlbGVjdGluZyAodGltZSByYW5nZSAmIGV2ZW50IHVuc2VsZWN0aW9uKVxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFRPRE86IG1vdmUgY29uc2lzdGVudGx5IHRvIGRvd24vc3RhcnQgb3IgdXAvZW5kP1xyXG4gICAgLy8gVE9ETzogZG9uJ3Qga2lsbCBwcmV2aW91cyBzZWxlY3Rpb24gaWYgdG91Y2ggc2Nyb2xsaW5nXHJcbiAgICBWaWV3LnByb3RvdHlwZS5oYW5kbGVEb2N1bWVudE1vdXNlZG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICh1dGlsXzEuaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1Vuc2VsZWN0KGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucHJvY2Vzc1Vuc2VsZWN0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzUmFuZ2VVbnNlbGVjdChldik7XHJcbiAgICAgICAgdGhpcy5wcm9jZXNzRXZlbnRVbnNlbGVjdChldik7XHJcbiAgICB9O1xyXG4gICAgVmlldy5wcm90b3R5cGUucHJvY2Vzc1JhbmdlVW5zZWxlY3QgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB2YXIgaWdub3JlO1xyXG4gICAgICAgIC8vIGlzIHRoZXJlIGEgdGltZS1yYW5nZSBzZWxlY3Rpb24/XHJcbiAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RlZCAmJiB0aGlzLm9wdCgndW5zZWxlY3RBdXRvJykpIHtcclxuICAgICAgICAgICAgLy8gb25seSB1bnNlbGVjdCBpZiB0aGUgY2xpY2tlZCBlbGVtZW50IGlzIG5vdCBpZGVudGljYWwgdG8gb3IgaW5zaWRlIG9mIGFuICd1bnNlbGVjdENhbmNlbCcgZWxlbWVudFxyXG4gICAgICAgICAgICBpZ25vcmUgPSB0aGlzLm9wdCgndW5zZWxlY3RDYW5jZWwnKTtcclxuICAgICAgICAgICAgaWYgKCFpZ25vcmUgfHwgISQoZXYudGFyZ2V0KS5jbG9zZXN0KGlnbm9yZSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnVuc2VsZWN0KGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS5wcm9jZXNzRXZlbnRVbnNlbGVjdCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkRXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBpZiAoISQoZXYudGFyZ2V0KS5jbG9zZXN0KCcuZmMtc2VsZWN0ZWQnKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW5zZWxlY3RFdmVudEluc3RhbmNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogVHJpZ2dlcnNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyQmFzZVJlbmRlcmVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCd2aWV3UmVuZGVyJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbdGhpcywgdGhpcy5lbF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmlnZ2VyQmFzZVVucmVuZGVyZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3ZpZXdEZXN0cm95Jywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbdGhpcywgdGhpcy5lbF1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBUcmlnZ2VycyBoYW5kbGVycyB0byAnZGF5Q2xpY2snXHJcbiAgICAvLyBTcGFuIGhhcyBzdGFydC9lbmQgb2YgdGhlIGNsaWNrZWQgYXJlYS4gT25seSB0aGUgc3RhcnQgaXMgdXNlZnVsLlxyXG4gICAgVmlldy5wcm90b3R5cGUudHJpZ2dlckRheUNsaWNrID0gZnVuY3Rpb24gKGZvb3RwcmludCwgZGF5RWwsIGV2KSB7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5jYWxlbmRhci5mb290cHJpbnRUb0RhdGVQcm9maWxlKGZvb3RwcmludCk7IC8vIGFidXNlIG9mIFwiRXZlbnRcIkRhdGVQcm9maWxlP1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdkYXlDbGljaycsIHtcclxuICAgICAgICAgICAgY29udGV4dDogZGF5RWwsXHJcbiAgICAgICAgICAgIGFyZ3M6IFtkYXRlUHJvZmlsZS5zdGFydCwgZXYsIHRoaXNdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyogRGF0ZSBVdGlsc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEZvciBEYXRlQ29tcG9uZW50OjpnZXREYXlDbGFzc2VzXHJcbiAgICBWaWV3LnByb3RvdHlwZS5pc0RhdGVJbk90aGVyTW9udGggPSBmdW5jdGlvbiAoZGF0ZSwgZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLy8gQXJndW1lbnRzIGFmdGVyIG5hbWUgd2lsbCBiZSBmb3J3YXJkZWQgdG8gYSBoeXBvdGhldGljYWwgZnVuY3Rpb24gdmFsdWVcclxuICAgIC8vIFdBUk5JTkc6IHBhc3NlZC1pbiBhcmd1bWVudHMgd2lsbCBiZSBnaXZlbiB0byBnZW5lcmF0b3IgZnVuY3Rpb25zIGFzLWlzIGFuZCBjYW4gY2F1c2Ugc2lkZS1lZmZlY3RzLlxyXG4gICAgLy8gQWx3YXlzIGNsb25lIHlvdXIgb2JqZWN0cyBpZiB5b3UgZmVhciBtdXRhdGlvbi5cclxuICAgIFZpZXcucHJvdG90eXBlLmdldFVuem9uZWRSYW5nZU9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMub3B0KG5hbWUpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IHZhbC5hcHBseShudWxsLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhci5wYXJzZVVuem9uZWRSYW5nZSh2YWwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBIaWRkZW4gRGF5c1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEluaXRpYWxpemVzIGludGVybmFsIHZhcmlhYmxlcyByZWxhdGVkIHRvIGNhbGN1bGF0aW5nIGhpZGRlbiBkYXlzLW9mLXdlZWtcclxuICAgIFZpZXcucHJvdG90eXBlLmluaXRIaWRkZW5EYXlzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBoaWRkZW5EYXlzID0gdGhpcy5vcHQoJ2hpZGRlbkRheXMnKSB8fCBbXTsgLy8gYXJyYXkgb2YgZGF5LW9mLXdlZWsgaW5kaWNlcyB0aGF0IGFyZSBoaWRkZW5cclxuICAgICAgICB2YXIgaXNIaWRkZW5EYXlIYXNoID0gW107IC8vIGlzIHRoZSBkYXktb2Ytd2VlayBoaWRkZW4/IChoYXNoIHdpdGggZGF5LW9mLXdlZWstaW5kZXggLT4gYm9vbClcclxuICAgICAgICB2YXIgZGF5Q250ID0gMDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAodGhpcy5vcHQoJ3dlZWtlbmRzJykgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGhpZGRlbkRheXMucHVzaCgwLCA2KTsgLy8gMD1zdW5kYXksIDY9c2F0dXJkYXlcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIShpc0hpZGRlbkRheUhhc2hbaV0gPSAkLmluQXJyYXkoaSwgaGlkZGVuRGF5cykgIT09IC0xKSkge1xyXG4gICAgICAgICAgICAgICAgZGF5Q250Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkYXlDbnQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGhpZGRlbkRheXMnKTsgLy8gYWxsIGRheXMgd2VyZSBoaWRkZW4/IGJhZC5cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pc0hpZGRlbkRheUhhc2ggPSBpc0hpZGRlbkRheUhhc2g7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVtb3ZlIGRheXMgZnJvbSB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIHJhbmdlIHRoYXQgYXJlIGNvbXB1dGVkIGFzIGhpZGRlbi5cclxuICAgIC8vIElmIHRoZSB3aG9sZSByYW5nZSBpcyB0cmltbWVkIG9mZiwgcmV0dXJucyBudWxsXHJcbiAgICBWaWV3LnByb3RvdHlwZS50cmltSGlkZGVuRGF5cyA9IGZ1bmN0aW9uIChpbnB1dFVuem9uZWRSYW5nZSkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IGlucHV0VW56b25lZFJhbmdlLmdldFN0YXJ0KCk7XHJcbiAgICAgICAgdmFyIGVuZCA9IGlucHV0VW56b25lZFJhbmdlLmdldEVuZCgpO1xyXG4gICAgICAgIGlmIChzdGFydCkge1xyXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZW5kLCAtMSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGFydCA9PT0gbnVsbCB8fCBlbmQgPT09IG51bGwgfHwgc3RhcnQgPCBlbmQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBJcyB0aGUgY3VycmVudCBkYXkgaGlkZGVuP1xyXG4gICAgLy8gYGRheWAgaXMgYSBkYXktb2Ytd2VlayBpbmRleCAoMC02KSwgb3IgYSBNb21lbnRcclxuICAgIFZpZXcucHJvdG90eXBlLmlzSGlkZGVuRGF5ID0gZnVuY3Rpb24gKGRheSkge1xyXG4gICAgICAgIGlmIChtb21lbnQuaXNNb21lbnQoZGF5KSkge1xyXG4gICAgICAgICAgICBkYXkgPSBkYXkuZGF5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmlzSGlkZGVuRGF5SGFzaFtkYXldO1xyXG4gICAgfTtcclxuICAgIC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cclxuICAgIC8vIERPRVMgTk9UIENPTlNJREVSIHZhbGlkVW56b25lZFJhbmdlIVxyXG4gICAgLy8gSWYgdGhlIGluaXRpYWwgdmFsdWUgb2YgYGRhdGVgIGlzIG5vdCBhIGhpZGRlbiBkYXksIGRvbid0IGRvIGFueXRoaW5nLlxyXG4gICAgLy8gUGFzcyBgaXNFeGNsdXNpdmVgIGFzIGB0cnVlYCBpZiB5b3UgYXJlIGRlYWxpbmcgd2l0aCBhbiBlbmQgZGF0ZS5cclxuICAgIC8vIGBpbmNgIGRlZmF1bHRzIHRvIGAxYCAoaW5jcmVtZW50IG9uZSBkYXkgZm9yd2FyZCBlYWNoIHRpbWUpXHJcbiAgICBWaWV3LnByb3RvdHlwZS5za2lwSGlkZGVuRGF5cyA9IGZ1bmN0aW9uIChkYXRlLCBpbmMsIGlzRXhjbHVzaXZlKSB7XHJcbiAgICAgICAgaWYgKGluYyA9PT0gdm9pZCAwKSB7IGluYyA9IDE7IH1cclxuICAgICAgICBpZiAoaXNFeGNsdXNpdmUgPT09IHZvaWQgMCkgeyBpc0V4Y2x1c2l2ZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIG91dCA9IGRhdGUuY2xvbmUoKTtcclxuICAgICAgICB3aGlsZSAodGhpcy5pc0hpZGRlbkRheUhhc2hbKG91dC5kYXkoKSArIChpc0V4Y2x1c2l2ZSA/IGluYyA6IDApICsgNykgJSA3XSkge1xyXG4gICAgICAgICAgICBvdXQuYWRkKGluYywgJ2RheXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG91dDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVmlldztcclxufShJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFZpZXc7XHJcblZpZXcucHJvdG90eXBlLnVzZXNNaW5NYXhUaW1lID0gZmFsc2U7XHJcblZpZXcucHJvdG90eXBlLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSBEYXRlUHJvZmlsZUdlbmVyYXRvcl8xLmRlZmF1bHQ7XHJcblZpZXcud2F0Y2goJ2Rpc3BsYXlpbmdEYXRlcycsIFsnaXNJbkRvbScsICdkYXRlUHJvZmlsZSddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgdGhpcy5yZXF1ZXN0RGF0ZVJlbmRlcihkZXBzLmRhdGVQcm9maWxlKTtcclxufSwgZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZXF1ZXN0RGF0ZVVucmVuZGVyKCk7XHJcbn0pO1xyXG5WaWV3LndhdGNoKCdkaXNwbGF5aW5nQnVzaW5lc3NIb3VycycsIFsnZGlzcGxheWluZ0RhdGVzJywgJ2J1c2luZXNzSG91ckdlbmVyYXRvciddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgdGhpcy5yZXF1ZXN0QnVzaW5lc3NIb3Vyc1JlbmRlcihkZXBzLmJ1c2luZXNzSG91ckdlbmVyYXRvcik7XHJcbn0sIGZ1bmN0aW9uICgpIHtcclxuICAgIHRoaXMucmVxdWVzdEJ1c2luZXNzSG91cnNVbnJlbmRlcigpO1xyXG59KTtcclxuVmlldy53YXRjaCgnaW5pdGlhbEV2ZW50cycsIFsnZGF0ZVByb2ZpbGUnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgIHJldHVybiB0aGlzLmZldGNoSW5pdGlhbEV2ZW50cyhkZXBzLmRhdGVQcm9maWxlKTtcclxufSk7XHJcblZpZXcud2F0Y2goJ2JpbmRpbmdFdmVudHMnLCBbJ2luaXRpYWxFdmVudHMnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgIHRoaXMuc2V0RXZlbnRzKGRlcHMuaW5pdGlhbEV2ZW50cyk7XHJcbiAgICB0aGlzLmJpbmRFdmVudENoYW5nZXMoKTtcclxufSwgZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy51bmJpbmRFdmVudENoYW5nZXMoKTtcclxuICAgIHRoaXMudW5zZXRFdmVudHMoKTtcclxufSk7XHJcblZpZXcud2F0Y2goJ2Rpc3BsYXlpbmdFdmVudHMnLCBbJ2Rpc3BsYXlpbmdEYXRlcycsICdoYXNFdmVudHMnXSwgZnVuY3Rpb24gKCkge1xyXG4gICAgdGhpcy5yZXF1ZXN0RXZlbnRzUmVuZGVyKHRoaXMuZ2V0KCdjdXJyZW50RXZlbnRzJykpO1xyXG59LCBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLnJlcXVlc3RFdmVudHNVbnJlbmRlcigpO1xyXG59KTtcclxuVmlldy53YXRjaCgndGl0bGUnLCBbJ2RhdGVQcm9maWxlJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICByZXR1cm4gKHRoaXMudGl0bGUgPSB0aGlzLmNvbXB1dGVUaXRsZShkZXBzLmRhdGVQcm9maWxlKSk7IC8vIGFzc2lnbiB0byBWaWV3IGZvciBsZWdhY3kgcmVhc29uc1xyXG59KTtcclxuVmlldy53YXRjaCgnbGVnYWN5RGF0ZVByb3BzJywgWydkYXRlUHJvZmlsZSddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgdmFyIGNhbGVuZGFyID0gdGhpcy5jYWxlbmRhcjtcclxuICAgIHZhciBkYXRlUHJvZmlsZSA9IGRlcHMuZGF0ZVByb2ZpbGU7XHJcbiAgICAvLyBERVBSRUNBVEVELCBidXQgd2UgbmVlZCB0byBrZWVwIGl0IHVwZGF0ZWQuLi5cclxuICAgIHRoaXMuc3RhcnQgPSBjYWxlbmRhci5tc1RvTW9tZW50KGRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZS5zdGFydE1zLCBkYXRlUHJvZmlsZS5pc1JhbmdlQWxsRGF5KTtcclxuICAgIHRoaXMuZW5kID0gY2FsZW5kYXIubXNUb01vbWVudChkYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuZW5kTXMsIGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgdGhpcy5pbnRlcnZhbFN0YXJ0ID0gY2FsZW5kYXIubXNUb01vbWVudChkYXRlUHJvZmlsZS5jdXJyZW50VW56b25lZFJhbmdlLnN0YXJ0TXMsIGRhdGVQcm9maWxlLmlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgdGhpcy5pbnRlcnZhbEVuZCA9IGNhbGVuZGFyLm1zVG9Nb21lbnQoZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZS5lbmRNcywgZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSk7XHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBFdmVudFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRSZW5kZXJlcihjb21wb25lbnQsIGZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgIHRoaXMudmlldyA9IGNvbXBvbmVudC5fZ2V0VmlldygpO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xyXG4gICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyID0gZmlsbFJlbmRlcmVyO1xyXG4gICAgfVxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUub3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3Lm9wdChuYW1lKTtcclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIHZhbHVlcyB0aGF0IHJlbHkgb24gb3B0aW9ucyBhbmQgYWxzbyByZWxhdGUgdG8gcmFuZ2VcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJhbmdlVXBkYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGlzcGxheUV2ZW50VGltZTtcclxuICAgICAgICB2YXIgZGlzcGxheUV2ZW50RW5kO1xyXG4gICAgICAgIHRoaXMuZXZlbnRUaW1lRm9ybWF0ID1cclxuICAgICAgICAgICAgdGhpcy5vcHQoJ2V2ZW50VGltZUZvcm1hdCcpIHx8XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdCgndGltZUZvcm1hdCcpIHx8IC8vIGRlcHJlY2F0ZWRcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZUV2ZW50VGltZUZvcm1hdCgpO1xyXG4gICAgICAgIGRpc3BsYXlFdmVudFRpbWUgPSB0aGlzLm9wdCgnZGlzcGxheUV2ZW50VGltZScpO1xyXG4gICAgICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGlzcGxheUV2ZW50VGltZSA9IHRoaXMuY29tcHV0ZURpc3BsYXlFdmVudFRpbWUoKTsgLy8gbWlnaHQgYmUgYmFzZWQgb2ZmIG9mIHJhbmdlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpc3BsYXlFdmVudEVuZCA9IHRoaXMub3B0KCdkaXNwbGF5RXZlbnRFbmQnKTtcclxuICAgICAgICBpZiAoZGlzcGxheUV2ZW50RW5kID09IG51bGwpIHtcclxuICAgICAgICAgICAgZGlzcGxheUV2ZW50RW5kID0gdGhpcy5jb21wdXRlRGlzcGxheUV2ZW50RW5kKCk7IC8vIG1pZ2h0IGJlIGJhc2VkIG9mZiBvZiByYW5nZVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRpc3BsYXlFdmVudFRpbWUgPSBkaXNwbGF5RXZlbnRUaW1lO1xyXG4gICAgICAgIHRoaXMuZGlzcGxheUV2ZW50RW5kID0gZGlzcGxheUV2ZW50RW5kO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5jb21wb25lbnQuX2dldERhdGVQcm9maWxlKCk7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmSWQ7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgdmFyIGV2ZW50UmFuZ2VzO1xyXG4gICAgICAgIHZhciBiZ1JhbmdlcyA9IFtdO1xyXG4gICAgICAgIHZhciBmZ1JhbmdlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoZXZlbnREZWZJZCBpbiBldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgICAgIGluc3RhbmNlR3JvdXAgPSBldmVudHNQYXlsb2FkW2V2ZW50RGVmSWRdO1xyXG4gICAgICAgICAgICBldmVudFJhbmdlcyA9IGluc3RhbmNlR3JvdXAuc2xpY2VSZW5kZXJSYW5nZXMoZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlKTtcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlR3JvdXAuZ2V0RXZlbnREZWYoKS5oYXNCZ1JlbmRlcmluZygpKSB7XHJcbiAgICAgICAgICAgICAgICBiZ1Jhbmdlcy5wdXNoLmFwcGx5KGJnUmFuZ2VzLCBldmVudFJhbmdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmZ1Jhbmdlcy5wdXNoLmFwcGx5KGZnUmFuZ2VzLCBldmVudFJhbmdlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZW5kZXJCZ1JhbmdlcyhiZ1Jhbmdlcyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGZ1JhbmdlcyhmZ1Jhbmdlcyk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckJnUmFuZ2VzKCk7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckZnUmFuZ2VzKCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmdSYW5nZXMgPSBmdW5jdGlvbiAoZXZlbnRSYW5nZXMpIHtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnRzID0gdGhpcy5jb21wb25lbnQuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhldmVudFJhbmdlcyk7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLmNvbXBvbmVudC5ldmVudEZvb3RwcmludHNUb1NlZ3MoZXZlbnRGb290cHJpbnRzKTtcclxuICAgICAgICAvLyByZW5kZXIgYW4gYC5lbGAgb24gZWFjaCBzZWdcclxuICAgICAgICAvLyByZXR1cm5zIGEgc3Vic2V0IG9mIHRoZSBzZWdzLiBzZWdzIHRoYXQgd2VyZSBhY3R1YWxseSByZW5kZXJlZFxyXG4gICAgICAgIHNlZ3MgPSB0aGlzLnJlbmRlckZnU2VnRWxzKHNlZ3MpO1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlckZnU2VncyhzZWdzKSAhPT0gZmFsc2UpIHsgLy8gbm8gZmFpbHVyZT9cclxuICAgICAgICAgICAgdGhpcy5mZ1NlZ3MgPSBzZWdzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlckZnUmFuZ2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJGZ1NlZ3ModGhpcy5mZ1NlZ3MgfHwgW10pO1xyXG4gICAgICAgIHRoaXMuZmdTZWdzID0gbnVsbDtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJCZ1JhbmdlcyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcykge1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSB0aGlzLmNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50UmFuZ2VzKTtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuY29tcG9uZW50LmV2ZW50Rm9vdHByaW50c1RvU2VncyhldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIGlmICh0aGlzLnJlbmRlckJnU2VncyhzZWdzKSAhPT0gZmFsc2UpIHsgLy8gbm8gZmFpbHVyZT9cclxuICAgICAgICAgICAgdGhpcy5iZ1NlZ3MgPSBzZWdzO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlckJnUmFuZ2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJCZ1NlZ3MoKTtcclxuICAgICAgICB0aGlzLmJnU2VncyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuYmdTZWdzIHx8IFtdKS5jb25jYXQodGhpcy5mZ1NlZ3MgfHwgW10pO1xyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50cyBvbnRvIHRoZSBncmlkXHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1NlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgICAgICAvLyBzZWdzIGFscmVhZHkgaGFzIHJlbmRlcmVkIGVscywgYW5kIGhhcyBiZWVuIGZpbHRlcmVkLlxyXG4gICAgICAgIHJldHVybiBmYWxzZTsgLy8gc2lnbmFsIGZhaWx1cmUgaWYgbm90IGltcGxlbWVudGVkXHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGFsbCBjdXJyZW50bHkgcmVuZGVyZWQgZm9yZWdyb3VuZCBzZWdtZW50c1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXJGZ1NlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJCZ1NlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnJlbmRlclNlZ3MoJ2JnRXZlbnQnLCBzZWdzLCB7XHJcbiAgICAgICAgICAgICAgICBnZXRDbGFzc2VzOiBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmdldEJnQ2xhc3NlcyhzZWcuZm9vdHByaW50LmV2ZW50RGVmKTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBnZXRDc3M6IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFja2dyb3VuZC1jb2xvcic6IF90aGlzLmdldEJnQ29sb3Ioc2VnLmZvb3RwcmludC5ldmVudERlZilcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGZpbHRlckVsOiBmdW5jdGlvbiAoc2VnLCBlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5maWx0ZXJFdmVudFJlbmRlckVsKHNlZy5mb290cHJpbnQsIGVsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHNpZ25hbCBmYWlsdXJlIGlmIG5vIGZpbGxSZW5kZXJlclxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlckJnU2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIudW5yZW5kZXIoJ2JnRXZlbnQnKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVycyBhbmQgYXNzaWducyBhbiBgZWxgIHByb3BlcnR5IGZvciBlYWNoIGZvcmVncm91bmQgZXZlbnQgc2VnbWVudC5cclxuICAgIC8vIE9ubHkgcmV0dXJucyBzZWdtZW50cyB0aGF0IHN1Y2Nlc3NmdWxseSByZW5kZXJlZC5cclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2VnRWxzID0gZnVuY3Rpb24gKHNlZ3MsIGRpc2FibGVSZXNpemluZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKGRpc2FibGVSZXNpemluZyA9PT0gdm9pZCAwKSB7IGRpc2FibGVSZXNpemluZyA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGhhc0V2ZW50UmVuZGVySGFuZGxlcnMgPSB0aGlzLnZpZXcuaGFzUHVibGljSGFuZGxlcnMoJ2V2ZW50UmVuZGVyJyk7XHJcbiAgICAgICAgdmFyIGh0bWwgPSAnJztcclxuICAgICAgICB2YXIgcmVuZGVyZWRTZWdzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHNlZ3MubGVuZ3RoKSB7IC8vIGRvbid0IGJ1aWxkIGFuIGVtcHR5IGh0bWwgc3RyaW5nXHJcbiAgICAgICAgICAgIC8vIGJ1aWxkIGEgbGFyZ2UgY29uY2F0ZW5hdGlvbiBvZiBldmVudCBzZWdtZW50IEhUTUxcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYmVmb3JlRmdTZWdIdG1sKHNlZ3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSB0aGlzLmZnU2VnSHRtbChzZWdzW2ldLCBkaXNhYmxlUmVzaXppbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEdyYWIgaW5kaXZpZHVhbCBlbGVtZW50cyBmcm9tIHRoZSBjb21iaW5lZCBIVE1MIHN0cmluZy4gVXNlIGVhY2ggYXMgdGhlIGRlZmF1bHQgcmVuZGVyaW5nLlxyXG4gICAgICAgICAgICAvLyBUaGVuLCBjb21wdXRlIHRoZSAnZWwnIGZvciBlYWNoIHNlZ21lbnQuIEFuIGVsIG1pZ2h0IGJlIG51bGwgaWYgdGhlIGV2ZW50UmVuZGVyIGNhbGxiYWNrIHJldHVybmVkIGZhbHNlLlxyXG4gICAgICAgICAgICAkKGh0bWwpLmVhY2goZnVuY3Rpb24gKGksIG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICAgICAgdmFyIGVsID0gJChub2RlKTtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNFdmVudFJlbmRlckhhbmRsZXJzKSB7IC8vIG9wdGltaXphdGlvblxyXG4gICAgICAgICAgICAgICAgICAgIGVsID0gX3RoaXMuZmlsdGVyRXZlbnRSZW5kZXJFbChzZWcuZm9vdHByaW50LCBlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbC5kYXRhKCdmYy1zZWcnLCBzZWcpOyAvLyB1c2VkIGJ5IGhhbmRsZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnLmVsID0gZWw7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRTZWdzLnB1c2goc2VnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW5kZXJlZFNlZ3M7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuYmVmb3JlRmdTZWdIdG1sID0gZnVuY3Rpb24gKHNlZykge1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIGRlZmF1bHQgcmVuZGVyaW5nIG9mIGEgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50LiBVc2VkIGJ5IHJlbmRlckZnU2VnRWxzKClcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmZnU2VnSHRtbCA9IGZ1bmN0aW9uIChzZWcsIGRpc2FibGVSZXNpemluZykge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyaWMgdXRpbGl0eSBmb3IgZ2VuZXJhdGluZyB0aGUgSFRNTCBjbGFzc05hbWVzIGZvciBhbiBldmVudCBzZWdtZW50J3MgZWxlbWVudFxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2VnQ2xhc3NlcyA9IGZ1bmN0aW9uIChzZWcsIGlzRHJhZ2dhYmxlLCBpc1Jlc2l6YWJsZSkge1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gW1xyXG4gICAgICAgICAgICAnZmMtZXZlbnQnLFxyXG4gICAgICAgICAgICBzZWcuaXNTdGFydCA/ICdmYy1zdGFydCcgOiAnZmMtbm90LXN0YXJ0JyxcclxuICAgICAgICAgICAgc2VnLmlzRW5kID8gJ2ZjLWVuZCcgOiAnZmMtbm90LWVuZCdcclxuICAgICAgICBdLmNvbmNhdCh0aGlzLmdldENsYXNzZXMoc2VnLmZvb3RwcmludC5ldmVudERlZikpO1xyXG4gICAgICAgIGlmIChpc0RyYWdnYWJsZSkge1xyXG4gICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLWRyYWdnYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZXNpemFibGUpIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1yZXNpemFibGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXZlbnQgaXMgY3VycmVudGx5IHNlbGVjdGVkPyBhdHRhY2ggYSBjbGFzc05hbWUuXHJcbiAgICAgICAgaWYgKHRoaXMudmlldy5pc0V2ZW50RGVmU2VsZWN0ZWQoc2VnLmZvb3RwcmludC5ldmVudERlZikpIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1zZWxlY3RlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xhc3NlcztcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBldmVudCBhbmQgdGhlIGRlZmF1bHQgZWxlbWVudCB1c2VkIGZvciByZW5kZXJpbmcsIHJldHVybnMgdGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgYWN0dWFsbHkgYmUgdXNlZC5cclxuICAgIC8vIEJhc2ljYWxseSBydW5zIGV2ZW50cyBhbmQgZWxlbWVudHMgdGhyb3VnaCB0aGUgZXZlbnRSZW5kZXIgaG9vay5cclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmZpbHRlckV2ZW50UmVuZGVyRWwgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnQsIGVsKSB7XHJcbiAgICAgICAgdmFyIGxlZ2FjeSA9IGV2ZW50Rm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCk7XHJcbiAgICAgICAgdmFyIGN1c3RvbSA9IHRoaXMudmlldy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVuZGVyJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBsZWdhY3ksXHJcbiAgICAgICAgICAgIGFyZ3M6IFtsZWdhY3ksIGVsLCB0aGlzLnZpZXddXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGN1c3RvbSA9PT0gZmFsc2UpIHsgLy8gbWVhbnMgZG9uJ3QgcmVuZGVyIGF0IGFsbFxyXG4gICAgICAgICAgICBlbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGN1c3RvbSAmJiBjdXN0b20gIT09IHRydWUpIHtcclxuICAgICAgICAgICAgZWwgPSAkKGN1c3RvbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlbDtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlIHRoZSB0ZXh0IHRoYXQgc2hvdWxkIGJlIGRpc3BsYXllZCBvbiBhbiBldmVudCdzIGVsZW1lbnQuXHJcbiAgICAvLyBgcmFuZ2VgIGNhbiBiZSB0aGUgRXZlbnQgb2JqZWN0IGl0c2VsZiwgb3Igc29tZXRoaW5nIHJhbmdlLWxpa2UsIHdpdGggYXQgbGVhc3QgYSBgc3RhcnRgLlxyXG4gICAgLy8gSWYgZXZlbnQgdGltZXMgYXJlIGRpc2FibGVkLCBvciB0aGUgZXZlbnQgaGFzIG5vIHRpbWUsIHdpbGwgcmV0dXJuIGEgYmxhbmsgc3RyaW5nLlxyXG4gICAgLy8gSWYgbm90IHNwZWNpZmllZCwgZm9ybWF0U3RyIHdpbGwgZGVmYXVsdCB0byB0aGUgZXZlbnRUaW1lRm9ybWF0IHNldHRpbmcsXHJcbiAgICAvLyBhbmQgZGlzcGxheUVuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGRpc3BsYXlFdmVudEVuZCBzZXR0aW5nLlxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0VGltZVRleHQgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnQsIGZvcm1hdFN0ciwgZGlzcGxheUVuZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUaW1lVGV4dChldmVudEZvb3RwcmludC5ldmVudEluc3RhbmNlLmRhdGVQcm9maWxlLnN0YXJ0LCBldmVudEZvb3RwcmludC5ldmVudEluc3RhbmNlLmRhdGVQcm9maWxlLmVuZCwgZXZlbnRGb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5LCBmb3JtYXRTdHIsIGRpc3BsYXlFbmQpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLl9nZXRUaW1lVGV4dCA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBpc0FsbERheSwgZm9ybWF0U3RyLCBkaXNwbGF5RW5kKSB7XHJcbiAgICAgICAgaWYgKGZvcm1hdFN0ciA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdFN0ciA9IHRoaXMuZXZlbnRUaW1lRm9ybWF0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGlzcGxheUVuZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGRpc3BsYXlFbmQgPSB0aGlzLmRpc3BsYXlFdmVudEVuZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheUV2ZW50VGltZSAmJiAhaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgaWYgKGRpc3BsYXlFbmQgJiYgZW5kKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aWV3LmZvcm1hdFJhbmdlKHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9LCBmYWxzZSwgLy8gYWxsRGF5XHJcbiAgICAgICAgICAgICAgICBmb3JtYXRTdHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0LmZvcm1hdChmb3JtYXRTdHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRXZlbnRUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnc21hbGxUaW1lRm9ybWF0Jyk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZURpc3BsYXlFdmVudFRpbWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcHV0ZURpc3BsYXlFdmVudEVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRCZ0NsYXNzZXMgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IHRoaXMuZ2V0Q2xhc3NlcyhldmVudERlZik7XHJcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1iZ2V2ZW50Jyk7XHJcbiAgICAgICAgcmV0dXJuIGNsYXNzTmFtZXM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0Q2xhc3NlcyA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBvYmpzID0gdGhpcy5nZXRTdHlsaW5nT2JqcyhldmVudERlZik7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2guYXBwbHkoLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMsIG9ianNbaV0uZXZlbnRDbGFzc05hbWUgfHwgb2Jqc1tpXS5jbGFzc05hbWUgfHwgW10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lcztcclxuICAgIH07XHJcbiAgICAvLyBVdGlsaXR5IGZvciBnZW5lcmF0aW5nIGV2ZW50IHNraW4tcmVsYXRlZCBDU1MgcHJvcGVydGllc1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0U2tpbkNzcyA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICdiYWNrZ3JvdW5kLWNvbG9yJzogdGhpcy5nZXRCZ0NvbG9yKGV2ZW50RGVmKSxcclxuICAgICAgICAgICAgJ2JvcmRlci1jb2xvcic6IHRoaXMuZ2V0Qm9yZGVyQ29sb3IoZXZlbnREZWYpLFxyXG4gICAgICAgICAgICBjb2xvcjogdGhpcy5nZXRUZXh0Q29sb3IoZXZlbnREZWYpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvLyBRdWVyaWVzIGZvciBjYWxsZXItc3BlY2lmaWVkIGNvbG9yLCB0aGVuIGZhbGxzIGJhY2sgdG8gZGVmYXVsdFxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0QmdDb2xvciA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBvYmpzID0gdGhpcy5nZXRTdHlsaW5nT2JqcyhldmVudERlZik7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHZhbDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGggJiYgIXZhbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IG9ianNbaV0uZXZlbnRCYWNrZ3JvdW5kQ29sb3IgfHwgb2Jqc1tpXS5ldmVudENvbG9yIHx8XHJcbiAgICAgICAgICAgICAgICBvYmpzW2ldLmJhY2tncm91bmRDb2xvciB8fCBvYmpzW2ldLmNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXZhbCkge1xyXG4gICAgICAgICAgICB2YWwgPSB0aGlzLm9wdCgnZXZlbnRCYWNrZ3JvdW5kQ29sb3InKSB8fCB0aGlzLm9wdCgnZXZlbnRDb2xvcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfTtcclxuICAgIC8vIFF1ZXJpZXMgZm9yIGNhbGxlci1zcGVjaWZpZWQgY29sb3IsIHRoZW4gZmFsbHMgYmFjayB0byBkZWZhdWx0XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRCb3JkZXJDb2xvciA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBvYmpzID0gdGhpcy5nZXRTdHlsaW5nT2JqcyhldmVudERlZik7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHZhbDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2Jqcy5sZW5ndGggJiYgIXZhbDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhbCA9IG9ianNbaV0uZXZlbnRCb3JkZXJDb2xvciB8fCBvYmpzW2ldLmV2ZW50Q29sb3IgfHxcclxuICAgICAgICAgICAgICAgIG9ianNbaV0uYm9yZGVyQ29sb3IgfHwgb2Jqc1tpXS5jb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF2YWwpIHtcclxuICAgICAgICAgICAgdmFsID0gdGhpcy5vcHQoJ2V2ZW50Qm9yZGVyQ29sb3InKSB8fCB0aGlzLm9wdCgnZXZlbnRDb2xvcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsO1xyXG4gICAgfTtcclxuICAgIC8vIFF1ZXJpZXMgZm9yIGNhbGxlci1zcGVjaWZpZWQgY29sb3IsIHRoZW4gZmFsbHMgYmFjayB0byBkZWZhdWx0XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRUZXh0Q29sb3IgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgb2JqcyA9IHRoaXMuZ2V0U3R5bGluZ09ianMoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciB2YWw7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG9ianMubGVuZ3RoICYmICF2YWw7IGkrKykge1xyXG4gICAgICAgICAgICB2YWwgPSBvYmpzW2ldLmV2ZW50VGV4dENvbG9yIHx8XHJcbiAgICAgICAgICAgICAgICBvYmpzW2ldLnRleHRDb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF2YWwpIHtcclxuICAgICAgICAgICAgdmFsID0gdGhpcy5vcHQoJ2V2ZW50VGV4dENvbG9yJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ2V0U3R5bGluZ09ianMgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgb2JqcyA9IHRoaXMuZ2V0RmFsbGJhY2tTdHlsaW5nT2JqcyhldmVudERlZik7XHJcbiAgICAgICAgb2Jqcy51bnNoaWZ0KGV2ZW50RGVmKTtcclxuICAgICAgICByZXR1cm4gb2JqcztcclxuICAgIH07XHJcbiAgICBFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZXRGYWxsYmFja1N0eWxpbmdPYmpzID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIFtldmVudERlZi5zb3VyY2VdO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnNvcnRFdmVudFNlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHNlZ3Muc29ydCh1dGlsXzEucHJveHkodGhpcywgJ2NvbXBhcmVFdmVudFNlZ3MnKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQSBjbXAgZnVuY3Rpb24gZm9yIGRldGVybWluaW5nIHdoaWNoIHNlZ21lbnRzIHNob3VsZCB0YWtlIHZpc3VhbCBwcmlvcml0eVxyXG4gICAgRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuY29tcGFyZUV2ZW50U2VncyA9IGZ1bmN0aW9uIChzZWcxLCBzZWcyKSB7XHJcbiAgICAgICAgdmFyIGYxID0gc2VnMS5mb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIGYyID0gc2VnMi5mb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIGNmMSA9IGYxLmNvbXBvbmVudEZvb3RwcmludDtcclxuICAgICAgICB2YXIgY2YyID0gZjIuY29tcG9uZW50Rm9vdHByaW50O1xyXG4gICAgICAgIHZhciByMSA9IGNmMS51bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIHIyID0gY2YyLnVuem9uZWRSYW5nZTtcclxuICAgICAgICByZXR1cm4gcjEuc3RhcnRNcyAtIHIyLnN0YXJ0TXMgfHwgLy8gZWFybGllciBldmVudHMgZ28gZmlyc3RcclxuICAgICAgICAgICAgKHIyLmVuZE1zIC0gcjIuc3RhcnRNcykgLSAocjEuZW5kTXMgLSByMS5zdGFydE1zKSB8fCAvLyB0aWU/IGxvbmdlciBldmVudHMgZ28gZmlyc3RcclxuICAgICAgICAgICAgY2YyLmlzQWxsRGF5IC0gY2YxLmlzQWxsRGF5IHx8IC8vIHRpZT8gcHV0IGFsbC1kYXkgZXZlbnRzIGZpcnN0IChib29sZWFucyBjYXN0IHRvIDAvMSlcclxuICAgICAgICAgICAgdXRpbF8xLmNvbXBhcmVCeUZpZWxkU3BlY3MoZjEuZXZlbnREZWYsIGYyLmV2ZW50RGVmLCB0aGlzLnZpZXcuZXZlbnRPcmRlclNwZWNzLCBmMS5ldmVudERlZi5taXNjUHJvcHMsIGYyLmV2ZW50RGVmLm1pc2NQcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50UmVuZGVyZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50UmVuZGVyZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDQ1ICovLFxuLyogNDYgKi8sXG4vKiA0NyAqLyxcbi8qIDQ4ICovLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbW9tZW50X2V4dF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcbi8vIFBsdWdpblxyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbm1vbWVudF9leHRfMS5uZXdNb21lbnRQcm90by5mb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5fZnVsbENhbGVuZGFyICYmIGFyZ3VtZW50c1swXSkgeyAvLyBhbiBlbmhhbmNlZCBtb21lbnQ/IGFuZCBhIGZvcm1hdCBzdHJpbmcgcHJvdmlkZWQ/XHJcbiAgICAgICAgcmV0dXJuIGZvcm1hdERhdGUodGhpcywgYXJndW1lbnRzWzBdKTsgLy8gb3VyIGV4dGVuZGVkIGZvcm1hdHRpbmdcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9hbWJpZ1RpbWUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpLCAnWVlZWS1NTS1ERCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuX2FtYmlnWm9uZSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGVuZ2xpc2hNb21lbnQodGhpcyksICdZWVlZLU1NLUREW1RdSEg6bW06c3MnKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9mdWxsQ2FsZW5kYXIpIHsgLy8gZW5oYW5jZWQgbm9uLWFtYmlnIG1vbWVudD9cclxuICAgICAgICAvLyBtb21lbnQuZm9ybWF0KCkgZG9lc24ndCBlbnN1cmUgZW5nbGlzaCwgYnV0IHdlIHdhbnQgdG8uXHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudFByb3RvLmZvcm1hdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5tb21lbnRfZXh0XzEubmV3TW9tZW50UHJvdG8udG9JU09TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodGhpcy5fYW1iaWdUaW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudF9leHRfMS5vbGRNb21lbnRGb3JtYXQoZW5nbGlzaE1vbWVudCh0aGlzKSwgJ1lZWVktTU0tREQnKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLl9hbWJpZ1pvbmUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChlbmdsaXNoTW9tZW50KHRoaXMpLCAnWVlZWS1NTS1ERFtUXUhIOm1tOnNzJyk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5fZnVsbENhbGVuZGFyKSB7IC8vIGVuaGFuY2VkIG5vbi1hbWJpZyBtb21lbnQ/XHJcbiAgICAgICAgLy8gZGVwZW5kaW5nIG9uIGJyb3dzZXIsIG1vbWVudCBtaWdodCBub3Qgb3V0cHV0IGVuZ2xpc2guIGVuc3VyZSBlbmdsaXNoLlxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tb21lbnQvbW9tZW50L2Jsb2IvMi4xOC4xL3NyYy9saWIvbW9tZW50L2Zvcm1hdC5qcyNMMjJcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudFByb3RvLnRvSVNPU3RyaW5nLmFwcGx5KGVuZ2xpc2hNb21lbnQodGhpcyksIGFyZ3VtZW50cyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudFByb3RvLnRvSVNPU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcbmZ1bmN0aW9uIGVuZ2xpc2hNb21lbnQobW9tKSB7XHJcbiAgICBpZiAobW9tLmxvY2FsZSgpICE9PSAnZW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbS5jbG9uZSgpLmxvY2FsZSgnZW4nKTtcclxuICAgIH1cclxuICAgIHJldHVybiBtb207XHJcbn1cclxuLy8gQ29uZmlnXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vKlxyXG5JbnNlcnRlZCBiZXR3ZWVuIGNodW5rcyBpbiB0aGUgZmFrZSAoXCJpbnRlcm1lZGlhdGVcIikgZm9ybWF0dGluZyBzdHJpbmcuXHJcbkltcG9ydGFudCB0aGF0IGl0IHBhc3NlcyBhcyB3aGl0ZXNwYWNlIChcXHMpIGJlY2F1c2UgbW9tZW50IG9mdGVuIGlkZW50aWZpZXMgbm9uLXN0YW5kYWxvbmUgbW9udGhzXHJcbnZpYSBhIHJlZ2V4cCB3aXRoIGFuIFxccy5cclxuKi9cclxudmFyIFBBUlRfU0VQQVJBVE9SID0gJ1xcdTAwMGInOyAvLyB2ZXJ0aWNhbCB0YWJcclxuLypcclxuSW5zZXJ0ZWQgYXMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIGxpdGVyYWwtdGV4dCBjaHVuayB0byBpbmRpY2F0ZSB0aGF0IHRoZSBsaXRlcmFsIHRleHQgaXMgbm90IGFjdHVhbGx5IGxpdGVyYWwgdGV4dCxcclxuYnV0IHJhdGhlciwgYSBcInNwZWNpYWxcIiB0b2tlbiB0aGF0IGhhcyBjdXN0b20gcmVuZGVyaW5nIChzZWUgc3BlY2lhbFRva2VucyBtYXApLlxyXG4qL1xyXG52YXIgU1BFQ0lBTF9UT0tFTl9NQVJLRVIgPSAnXFx1MDAxZic7IC8vIGluZm9ybWF0aW9uIHNlcGFyYXRvciAxXHJcbi8qXHJcbkluc2VydGVkIGF0IHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHNwYW4gb2YgdGV4dCB0aGF0IG11c3QgaGF2ZSBub24temVybyBudW1lcmljIGNoYXJhY3RlcnMuXHJcbkhhbmRsaW5nIG9mIHRoZXNlIG1hcmtlcnMgaXMgZG9uZSBpbiBhIHBvc3QtcHJvY2Vzc2luZyBzdGVwIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0ZXh0IHJlbmRlcmluZy5cclxuKi9cclxudmFyIE1BWUJFX01BUktFUiA9ICdcXHUwMDFlJzsgLy8gaW5mb3JtYXRpb24gc2VwYXJhdG9yIDJcclxudmFyIE1BWUJFX1JFR0VYUCA9IG5ldyBSZWdFeHAoTUFZQkVfTUFSS0VSICsgJyhbXicgKyBNQVlCRV9NQVJLRVIgKyAnXSopJyArIE1BWUJFX01BUktFUiwgJ2cnKTsgLy8gbXVzdCBiZSBnbG9iYWxcclxuLypcclxuQWRkaXRpb24gZm9ybWF0dGluZyB0b2tlbnMgd2Ugd2FudCByZWNvZ25pemVkXHJcbiovXHJcbnZhciBzcGVjaWFsVG9rZW5zID0ge1xyXG4gICAgdDogZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChkYXRlLCAnYScpLmNoYXJBdCgwKTtcclxuICAgIH0sXHJcbiAgICBUOiBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHJldHVybiBtb21lbnRfZXh0XzEub2xkTW9tZW50Rm9ybWF0KGRhdGUsICdBJykuY2hhckF0KDApO1xyXG4gICAgfVxyXG59O1xyXG4vKlxyXG5UaGUgZmlyc3QgY2hhcmFjdGVycyBvZiBmb3JtYXR0aW5nIHRva2VucyBmb3IgdW5pdHMgdGhhdCBhcmUgMSBkYXkgb3IgbGFyZ2VyLlxyXG5gdmFsdWVgIGlzIGZvciByYW5raW5nIHJlbGF0aXZlIHNpemUgKGxvd2VyIG1lYW5zIGJpZ2dlcikuXHJcbmB1bml0YCBpcyBhIG5vcm1hbGl6ZWQgdW5pdCwgdXNlZCBmb3IgY29tcGFyaW5nIG1vbWVudHMuXHJcbiovXHJcbnZhciBsYXJnZVRva2VuTWFwID0ge1xyXG4gICAgWTogeyB2YWx1ZTogMSwgdW5pdDogJ3llYXInIH0sXHJcbiAgICBNOiB7IHZhbHVlOiAyLCB1bml0OiAnbW9udGgnIH0sXHJcbiAgICBXOiB7IHZhbHVlOiAzLCB1bml0OiAnd2VlaycgfSxcclxuICAgIHc6IHsgdmFsdWU6IDMsIHVuaXQ6ICd3ZWVrJyB9LFxyXG4gICAgRDogeyB2YWx1ZTogNCwgdW5pdDogJ2RheScgfSxcclxuICAgIGQ6IHsgdmFsdWU6IDQsIHVuaXQ6ICdkYXknIH0gLy8gZGF5IG9mIHdlZWtcclxufTtcclxuLy8gU2luZ2xlIERhdGUgRm9ybWF0dGluZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLypcclxuRm9ybWF0cyBgZGF0ZWAgd2l0aCBhIE1vbWVudCBmb3JtYXR0aW5nIHN0cmluZywgYnV0IGFsbG93IG91ciBub24temVybyBhcmVhcyBhbmQgc3BlY2lhbCB0b2tlblxyXG4qL1xyXG5mdW5jdGlvbiBmb3JtYXREYXRlKGRhdGUsIGZvcm1hdFN0cikge1xyXG4gICAgcmV0dXJuIHJlbmRlckZha2VGb3JtYXRTdHJpbmcoZ2V0UGFyc2VkRm9ybWF0U3RyaW5nKGZvcm1hdFN0cikuZmFrZUZvcm1hdFN0cmluZywgZGF0ZSk7XHJcbn1cclxuZXhwb3J0cy5mb3JtYXREYXRlID0gZm9ybWF0RGF0ZTtcclxuLy8gRGF0ZSBSYW5nZSBGb3JtYXR0aW5nXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLy8gVE9ETzogbWFrZSBpdCB3b3JrIHdpdGggdGltZXpvbmUgb2Zmc2V0XHJcbi8qXHJcblVzaW5nIGEgZm9ybWF0dGluZyBzdHJpbmcgbWVhbnQgZm9yIGEgc2luZ2xlIGRhdGUsIGdlbmVyYXRlIGEgcmFuZ2Ugc3RyaW5nLCBsaWtlXHJcblwiU2VwIDIgLSA5IDIwMTNcIiwgdGhhdCBpbnRlbGxpZ2VudGx5IGluc2VydHMgYSBzZXBhcmF0b3Igd2hlcmUgdGhlIGRhdGVzIGRpZmZlci5cclxuSWYgdGhlIGRhdGVzIGFyZSB0aGUgc2FtZSBhcyBmYXIgYXMgdGhlIGZvcm1hdCBzdHJpbmcgaXMgY29uY2VybmVkLCBqdXN0IHJldHVybiBhIHNpbmdsZVxyXG5yZW5kZXJpbmcgb2Ygb25lIGRhdGUsIHdpdGhvdXQgYW55IHNlcGFyYXRvci5cclxuKi9cclxuZnVuY3Rpb24gZm9ybWF0UmFuZ2UoZGF0ZTEsIGRhdGUyLCBmb3JtYXRTdHIsIHNlcGFyYXRvciwgaXNSVEwpIHtcclxuICAgIHZhciBsb2NhbGVEYXRhO1xyXG4gICAgZGF0ZTEgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC5wYXJzZVpvbmUoZGF0ZTEpO1xyXG4gICAgZGF0ZTIgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC5wYXJzZVpvbmUoZGF0ZTIpO1xyXG4gICAgbG9jYWxlRGF0YSA9IGRhdGUxLmxvY2FsZURhdGEoKTtcclxuICAgIC8vIEV4cGFuZCBsb2NhbGl6ZWQgZm9ybWF0IHN0cmluZ3MsIGxpa2UgXCJMTFwiIC0+IFwiTU1NTSBEIFlZWVlcIi5cclxuICAgIC8vIEJUVywgdGhpcyBpcyBub3QgaW1wb3J0YW50IGZvciBgZm9ybWF0RGF0ZWAgYmVjYXVzZSBpdCBpcyBpbXBvc3NpYmxlIHRvIHB1dCBjdXN0b20gdG9rZW5zXHJcbiAgICAvLyBvciBub24temVybyBhcmVhcyBpbiBNb21lbnQncyBsb2NhbGl6ZWQgZm9ybWF0IHN0cmluZ3MuXHJcbiAgICBmb3JtYXRTdHIgPSBsb2NhbGVEYXRhLmxvbmdEYXRlRm9ybWF0KGZvcm1hdFN0cikgfHwgZm9ybWF0U3RyO1xyXG4gICAgcmV0dXJuIHJlbmRlclBhcnNlZEZvcm1hdChnZXRQYXJzZWRGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSwgZGF0ZTEsIGRhdGUyLCBzZXBhcmF0b3IgfHwgJyAtICcsIGlzUlRMKTtcclxufVxyXG5leHBvcnRzLmZvcm1hdFJhbmdlID0gZm9ybWF0UmFuZ2U7XHJcbi8qXHJcblJlbmRlcnMgYSByYW5nZSB3aXRoIGFuIGFscmVhZHktcGFyc2VkIGZvcm1hdCBzdHJpbmcuXHJcbiovXHJcbmZ1bmN0aW9uIHJlbmRlclBhcnNlZEZvcm1hdChwYXJzZWRGb3JtYXQsIGRhdGUxLCBkYXRlMiwgc2VwYXJhdG9yLCBpc1JUTCkge1xyXG4gICAgdmFyIHNhbWVVbml0cyA9IHBhcnNlZEZvcm1hdC5zYW1lVW5pdHM7XHJcbiAgICB2YXIgdW56b25lZERhdGUxID0gZGF0ZTEuY2xvbmUoKS5zdHJpcFpvbmUoKTsgLy8gZm9yIHNhbWUtdW5pdCBjb21wYXJpc29uc1xyXG4gICAgdmFyIHVuem9uZWREYXRlMiA9IGRhdGUyLmNsb25lKCkuc3RyaXBab25lKCk7IC8vIFwiXHJcbiAgICB2YXIgcmVuZGVyZWRQYXJ0czEgPSByZW5kZXJGYWtlRm9ybWF0U3RyaW5nUGFydHMocGFyc2VkRm9ybWF0LmZha2VGb3JtYXRTdHJpbmcsIGRhdGUxKTtcclxuICAgIHZhciByZW5kZXJlZFBhcnRzMiA9IHJlbmRlckZha2VGb3JtYXRTdHJpbmdQYXJ0cyhwYXJzZWRGb3JtYXQuZmFrZUZvcm1hdFN0cmluZywgZGF0ZTIpO1xyXG4gICAgdmFyIGxlZnRJO1xyXG4gICAgdmFyIGxlZnRTdHIgPSAnJztcclxuICAgIHZhciByaWdodEk7XHJcbiAgICB2YXIgcmlnaHRTdHIgPSAnJztcclxuICAgIHZhciBtaWRkbGVJO1xyXG4gICAgdmFyIG1pZGRsZVN0cjEgPSAnJztcclxuICAgIHZhciBtaWRkbGVTdHIyID0gJyc7XHJcbiAgICB2YXIgbWlkZGxlU3RyID0gJyc7XHJcbiAgICAvLyBTdGFydCBhdCB0aGUgbGVmdG1vc3Qgc2lkZSBvZiB0aGUgZm9ybWF0dGluZyBzdHJpbmcgYW5kIGNvbnRpbnVlIHVudGlsIHlvdSBoaXQgYSB0b2tlblxyXG4gICAgLy8gdGhhdCBpcyBub3QgdGhlIHNhbWUgYmV0d2VlbiBkYXRlcy5cclxuICAgIGZvciAobGVmdEkgPSAwOyBsZWZ0SSA8IHNhbWVVbml0cy5sZW5ndGggJiYgKCFzYW1lVW5pdHNbbGVmdEldIHx8IHVuem9uZWREYXRlMS5pc1NhbWUodW56b25lZERhdGUyLCBzYW1lVW5pdHNbbGVmdEldKSk7IGxlZnRJKyspIHtcclxuICAgICAgICBsZWZ0U3RyICs9IHJlbmRlcmVkUGFydHMxW2xlZnRJXTtcclxuICAgIH1cclxuICAgIC8vIFNpbWlsYXJseSwgc3RhcnQgYXQgdGhlIHJpZ2h0bW9zdCBzaWRlIG9mIHRoZSBmb3JtYXR0aW5nIHN0cmluZyBhbmQgbW92ZSBsZWZ0XHJcbiAgICBmb3IgKHJpZ2h0SSA9IHNhbWVVbml0cy5sZW5ndGggLSAxOyByaWdodEkgPiBsZWZ0SSAmJiAoIXNhbWVVbml0c1tyaWdodEldIHx8IHVuem9uZWREYXRlMS5pc1NhbWUodW56b25lZERhdGUyLCBzYW1lVW5pdHNbcmlnaHRJXSkpOyByaWdodEktLSkge1xyXG4gICAgICAgIC8vIElmIGN1cnJlbnQgY2h1bmsgaXMgb24gdGhlIGJvdW5kYXJ5IG9mIHVuaXF1ZSBkYXRlLWNvbnRlbnQsIGFuZCBpcyBhIHNwZWNpYWwtY2FzZVxyXG4gICAgICAgIC8vIGRhdGUtZm9ybWF0dGluZyBwb3N0Zml4IGNoYXJhY3RlciwgdGhlbiBkb24ndCBjb25zdW1lIGl0LiBDb25zaWRlciBpdCB1bmlxdWUgZGF0ZS1jb250ZW50LlxyXG4gICAgICAgIC8vIFRPRE86IG1ha2UgY29uZmlndXJhYmxlXHJcbiAgICAgICAgaWYgKHJpZ2h0SSAtIDEgPT09IGxlZnRJICYmIHJlbmRlcmVkUGFydHMxW3JpZ2h0SV0gPT09ICcuJykge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmlnaHRTdHIgPSByZW5kZXJlZFBhcnRzMVtyaWdodEldICsgcmlnaHRTdHI7XHJcbiAgICB9XHJcbiAgICAvLyBUaGUgYXJlYSBpbiB0aGUgbWlkZGxlIGlzIGRpZmZlcmVudCBmb3IgYm90aCBvZiB0aGUgZGF0ZXMuXHJcbiAgICAvLyBDb2xsZWN0IHRoZW0gZGlzdGluY3RseSBzbyB3ZSBjYW4gamFtIHRoZW0gdG9nZXRoZXIgbGF0ZXIuXHJcbiAgICBmb3IgKG1pZGRsZUkgPSBsZWZ0STsgbWlkZGxlSSA8PSByaWdodEk7IG1pZGRsZUkrKykge1xyXG4gICAgICAgIG1pZGRsZVN0cjEgKz0gcmVuZGVyZWRQYXJ0czFbbWlkZGxlSV07XHJcbiAgICAgICAgbWlkZGxlU3RyMiArPSByZW5kZXJlZFBhcnRzMlttaWRkbGVJXTtcclxuICAgIH1cclxuICAgIGlmIChtaWRkbGVTdHIxIHx8IG1pZGRsZVN0cjIpIHtcclxuICAgICAgICBpZiAoaXNSVEwpIHtcclxuICAgICAgICAgICAgbWlkZGxlU3RyID0gbWlkZGxlU3RyMiArIHNlcGFyYXRvciArIG1pZGRsZVN0cjE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtaWRkbGVTdHIgPSBtaWRkbGVTdHIxICsgc2VwYXJhdG9yICsgbWlkZGxlU3RyMjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJvY2Vzc01heWJlTWFya2VycyhsZWZ0U3RyICsgbWlkZGxlU3RyICsgcmlnaHRTdHIpO1xyXG59XHJcbi8vIEZvcm1hdCBTdHJpbmcgUGFyc2luZ1xyXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxudmFyIHBhcnNlZEZvcm1hdFN0ckNhY2hlID0ge307XHJcbi8qXHJcblJldHVybnMgYSBwYXJzZWQgZm9ybWF0IHN0cmluZywgbGV2ZXJhZ2luZyBhIGNhY2hlLlxyXG4qL1xyXG5mdW5jdGlvbiBnZXRQYXJzZWRGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSB7XHJcbiAgICByZXR1cm4gcGFyc2VkRm9ybWF0U3RyQ2FjaGVbZm9ybWF0U3RyXSB8fFxyXG4gICAgICAgIChwYXJzZWRGb3JtYXRTdHJDYWNoZVtmb3JtYXRTdHJdID0gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSk7XHJcbn1cclxuLypcclxuUGFyc2VzIGEgZm9ybWF0IHN0cmluZyBpbnRvIHRoZSBmb2xsb3dpbmc6XHJcbi0gZmFrZUZvcm1hdFN0cmluZzogYSBtb21lbnRKUyBmb3JtYXR0aW5nIHN0cmluZywgbGl0dGVyZWQgd2l0aCBzcGVjaWFsIGNvbnRyb2wgY2hhcmFjdGVycyB0aGF0IGdldCBwb3N0LXByb2Nlc3NlZC5cclxuLSBzYW1lVW5pdHM6IGZvciBldmVyeSBwYXJ0IGluIGZha2VGb3JtYXRTdHJpbmcsIGlmIHRoZSBwYXJ0IGlzIGEgdG9rZW4sIHRoZSB2YWx1ZSB3aWxsIGJlIGEgdW5pdCBzdHJpbmcgKGxpa2UgXCJkYXlcIiksXHJcbiAgdGhhdCBpbmRpY2F0ZXMgaG93IHNpbWlsYXIgYSByYW5nZSdzIHN0YXJ0ICYgZW5kIG11c3QgYmUgaW4gb3JkZXIgdG8gc2hhcmUgdGhlIHNhbWUgZm9ybWF0dGVkIHRleHQuXHJcbiAgSWYgbm90IGEgdG9rZW4sIHRoZW4gdGhlIHZhbHVlIGlzIG51bGwuXHJcbiAgQWx3YXlzIGEgZmxhdCBhcnJheSAobm90IG5lc3RlZCBsaWtlZCBcImNodW5rc1wiKS5cclxuKi9cclxuZnVuY3Rpb24gcGFyc2VGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKSB7XHJcbiAgICB2YXIgY2h1bmtzID0gY2h1bmtGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZmFrZUZvcm1hdFN0cmluZzogYnVpbGRGYWtlRm9ybWF0U3RyaW5nKGNodW5rcyksXHJcbiAgICAgICAgc2FtZVVuaXRzOiBidWlsZFNhbWVVbml0cyhjaHVua3MpXHJcbiAgICB9O1xyXG59XHJcbi8qXHJcbkJyZWFrIHRoZSBmb3JtYXR0aW5nIHN0cmluZyBpbnRvIGFuIGFycmF5IG9mIGNodW5rcy5cclxuQSAnbWF5YmUnIGNodW5rIHdpbGwgaGF2ZSBuZXN0ZWQgY2h1bmtzLlxyXG4qL1xyXG5mdW5jdGlvbiBjaHVua0Zvcm1hdFN0cmluZyhmb3JtYXRTdHIpIHtcclxuICAgIHZhciBjaHVua3MgPSBbXTtcclxuICAgIHZhciBtYXRjaDtcclxuICAgIC8vIFRPRE86IG1vcmUgZGVzY3JpbWluYXRpb25cclxuICAgIC8vIFxcNCBpcyBhIGJhY2tyZWZlcmVuY2UgdG8gdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBhIG11bHRpLWNoYXJhY3RlciBzZXQuXHJcbiAgICB2YXIgY2h1bmtlciA9IC9cXFsoW15cXF1dKilcXF18XFwoKFteXFwpXSopXFwpfChMVFN8TFR8KFxcdylcXDQqbz8pfChbXlxcd1xcW1xcKF0rKS9nO1xyXG4gICAgd2hpbGUgKChtYXRjaCA9IGNodW5rZXIuZXhlYyhmb3JtYXRTdHIpKSkge1xyXG4gICAgICAgIGlmIChtYXRjaFsxXSkgeyAvLyBhIGxpdGVyYWwgc3RyaW5nIGluc2lkZSBbIC4uLiBdXHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoLmFwcGx5KGNodW5rcywgLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIHNwbGl0U3RyaW5nTGl0ZXJhbChtYXRjaFsxXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXRjaFsyXSkgeyAvLyBub24temVybyBmb3JtYXR0aW5nIGluc2lkZSAoIC4uLiApXHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKHsgbWF5YmU6IGNodW5rRm9ybWF0U3RyaW5nKG1hdGNoWzJdKSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobWF0Y2hbM10pIHsgLy8gYSBmb3JtYXR0aW5nIHRva2VuXHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoKHsgdG9rZW46IG1hdGNoWzNdIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChtYXRjaFs1XSkgeyAvLyBhbiB1bmVuY2xvc2VkIGxpdGVyYWwgc3RyaW5nXHJcbiAgICAgICAgICAgIGNodW5rcy5wdXNoLmFwcGx5KGNodW5rcywgLy8gYXBwZW5kXHJcbiAgICAgICAgICAgIHNwbGl0U3RyaW5nTGl0ZXJhbChtYXRjaFs1XSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjaHVua3M7XHJcbn1cclxuLypcclxuUG90ZW50aWFsbHkgc3BsaXRzIGEgbGl0ZXJhbC10ZXh0IHN0cmluZyBpbnRvIG11bHRpcGxlIHBhcnRzLiBGb3Igc3BlY2lhbCBjYXNlcy5cclxuKi9cclxuZnVuY3Rpb24gc3BsaXRTdHJpbmdMaXRlcmFsKHMpIHtcclxuICAgIGlmIChzID09PSAnLiAnKSB7XHJcbiAgICAgICAgcmV0dXJuIFsnLicsICcgJ107IC8vIGZvciBsb2NhbGVzIHdpdGggcGVyaW9kcyBib3VuZCB0byB0aGUgZW5kIG9mIGVhY2ggeWVhci9tb250aC9kYXRlXHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gW3NdO1xyXG4gICAgfVxyXG59XHJcbi8qXHJcbkdpdmVuIGNodW5rcyBwYXJzZWQgZnJvbSBhIHJlYWwgZm9ybWF0IHN0cmluZywgZ2VuZXJhdGUgYSBmYWtlIChha2EgXCJpbnRlcm1lZGlhdGVcIikgZm9ybWF0IHN0cmluZyB3aXRoIHNwZWNpYWwgY29udHJvbFxyXG5jaGFyYWN0ZXJzIHRoYXQgd2lsbCBldmVudHVhbGx5IGJlIGdpdmVuIHRvIG1vbWVudCBmb3IgZm9ybWF0dGluZywgYW5kIHRoZW4gcG9zdC1wcm9jZXNzZWQuXHJcbiovXHJcbmZ1bmN0aW9uIGJ1aWxkRmFrZUZvcm1hdFN0cmluZyhjaHVua3MpIHtcclxuICAgIHZhciBwYXJ0cyA9IFtdO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgY2h1bms7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2h1bmsgPSBjaHVua3NbaV07XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaCgnWycgKyBjaHVuayArICddJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNodW5rLnRva2VuKSB7XHJcbiAgICAgICAgICAgIGlmIChjaHVuay50b2tlbiBpbiBzcGVjaWFsVG9rZW5zKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKFNQRUNJQUxfVE9LRU5fTUFSS0VSICsgLy8gdXNlZnVsIGR1cmluZyBwb3N0LXByb2Nlc3NpbmdcclxuICAgICAgICAgICAgICAgICAgICAnWycgKyBjaHVuay50b2tlbiArICddJyAvLyBwcmVzZXJ2ZSBhcyBsaXRlcmFsIHRleHRcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwYXJ0cy5wdXNoKGNodW5rLnRva2VuKTsgLy8gdW5wcm90ZWN0ZWQgdGV4dCBpbXBsaWVzIGEgZm9ybWF0IHN0cmluZ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNodW5rLm1heWJlKSB7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goTUFZQkVfTUFSS0VSICsgLy8gdXNlZnVsIGR1cmluZyBwb3N0LXByb2Nlc3NpbmdcclxuICAgICAgICAgICAgICAgIGJ1aWxkRmFrZUZvcm1hdFN0cmluZyhjaHVuay5tYXliZSkgK1xyXG4gICAgICAgICAgICAgICAgTUFZQkVfTUFSS0VSKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFydHMuam9pbihQQVJUX1NFUEFSQVRPUik7XHJcbn1cclxuLypcclxuR2l2ZW4gcGFyc2VkIGNodW5rcyBmcm9tIGEgcmVhbCBmb3JtYXR0aW5nIHN0cmluZywgZ2VuZXJhdGVzIGFuIGFycmF5IG9mIHVuaXQgc3RyaW5ncyAobGlrZSBcImRheVwiKSB0aGF0IGluZGljYXRlXHJcbmluIHdoaWNoIHJlZ2FyZCB0d28gZGF0ZXMgbXVzdCBiZSBzaW1pbGFyIGluIG9yZGVyIHRvIHNoYXJlIHJhbmdlIGZvcm1hdHRpbmcgdGV4dC5cclxuVGhlIGBjaHVua3NgIGNhbiBiZSBuZXN0ZWQgKGJlY2F1c2Ugb2YgXCJtYXliZVwiIGNodW5rcyksIGhvd2V2ZXIsIHRoZSByZXR1cm5lZCBhcnJheSB3aWxsIGJlIGZsYXQuXHJcbiovXHJcbmZ1bmN0aW9uIGJ1aWxkU2FtZVVuaXRzKGNodW5rcykge1xyXG4gICAgdmFyIHVuaXRzID0gW107XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBjaHVuaztcclxuICAgIHZhciB0b2tlbkluZm87XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgY2h1bmtzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY2h1bmsgPSBjaHVua3NbaV07XHJcbiAgICAgICAgaWYgKGNodW5rLnRva2VuKSB7XHJcbiAgICAgICAgICAgIHRva2VuSW5mbyA9IGxhcmdlVG9rZW5NYXBbY2h1bmsudG9rZW4uY2hhckF0KDApXTtcclxuICAgICAgICAgICAgdW5pdHMucHVzaCh0b2tlbkluZm8gPyB0b2tlbkluZm8udW5pdCA6ICdzZWNvbmQnKTsgLy8gZGVmYXVsdCB0byBhIHZlcnkgc3RyaWN0IHNhbWUtc2Vjb25kXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNodW5rLm1heWJlKSB7XHJcbiAgICAgICAgICAgIHVuaXRzLnB1c2guYXBwbHkodW5pdHMsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBidWlsZFNhbWVVbml0cyhjaHVuay5tYXliZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdW5pdHMucHVzaChudWxsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdW5pdHM7XHJcbn1cclxuLy8gUmVuZGVyaW5nIHRvIHRleHRcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8qXHJcbkZvcm1hdHMgYSBkYXRlIHdpdGggYSBmYWtlIGZvcm1hdCBzdHJpbmcsIHBvc3QtcHJvY2Vzc2VzIHRoZSBjb250cm9sIGNoYXJhY3RlcnMsIHRoZW4gcmV0dXJucy5cclxuKi9cclxuZnVuY3Rpb24gcmVuZGVyRmFrZUZvcm1hdFN0cmluZyhmYWtlRm9ybWF0U3RyaW5nLCBkYXRlKSB7XHJcbiAgICByZXR1cm4gcHJvY2Vzc01heWJlTWFya2VycyhyZW5kZXJGYWtlRm9ybWF0U3RyaW5nUGFydHMoZmFrZUZvcm1hdFN0cmluZywgZGF0ZSkuam9pbignJykpO1xyXG59XHJcbi8qXHJcbkZvcm1hdHMgYSBkYXRlIGludG8gcGFydHMgdGhhdCB3aWxsIGhhdmUgYmVlbiBwb3N0LXByb2Nlc3NlZCwgRVhDRVBUIGZvciB0aGUgXCJtYXliZVwiIG1hcmtlcnMuXHJcbiovXHJcbmZ1bmN0aW9uIHJlbmRlckZha2VGb3JtYXRTdHJpbmdQYXJ0cyhmYWtlRm9ybWF0U3RyaW5nLCBkYXRlKSB7XHJcbiAgICB2YXIgcGFydHMgPSBbXTtcclxuICAgIHZhciBmYWtlUmVuZGVyID0gbW9tZW50X2V4dF8xLm9sZE1vbWVudEZvcm1hdChkYXRlLCBmYWtlRm9ybWF0U3RyaW5nKTtcclxuICAgIHZhciBmYWtlUGFydHMgPSBmYWtlUmVuZGVyLnNwbGl0KFBBUlRfU0VQQVJBVE9SKTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGZha2VQYXJ0O1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGZha2VQYXJ0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGZha2VQYXJ0ID0gZmFrZVBhcnRzW2ldO1xyXG4gICAgICAgIGlmIChmYWtlUGFydC5jaGFyQXQoMCkgPT09IFNQRUNJQUxfVE9LRU5fTUFSS0VSKSB7XHJcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXHJcbiAgICAgICAgICAgIC8vIHRoZSBsaXRlcmFsIHN0cmluZyBJUyB0aGUgdG9rZW4ncyBuYW1lLlxyXG4gICAgICAgICAgICAvLyBjYWxsIHNwZWNpYWwgdG9rZW4ncyByZWdpc3RlcmVkIGZ1bmN0aW9uLlxyXG4gICAgICAgICAgICBzcGVjaWFsVG9rZW5zW2Zha2VQYXJ0LnN1YnN0cmluZygxKV0oZGF0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcGFydHMucHVzaChmYWtlUGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHBhcnRzO1xyXG59XHJcbi8qXHJcbkFjY2VwdHMgYW4gYWxtb3N0LWZpbmFsbHktZm9ybWF0dGVkIHN0cmluZyBhbmQgcHJvY2Vzc2VzIHRoZSBcIm1heWJlXCIgY29udHJvbCBjaGFyYWN0ZXJzLCByZXR1cm5pbmcgYSBuZXcgc3RyaW5nLlxyXG4qL1xyXG5mdW5jdGlvbiBwcm9jZXNzTWF5YmVNYXJrZXJzKHMpIHtcclxuICAgIHJldHVybiBzLnJlcGxhY2UoTUFZQkVfUkVHRVhQLCBmdW5jdGlvbiAobTAsIG0xKSB7XHJcbiAgICAgICAgaWYgKG0xLm1hdGNoKC9bMS05XS8pKSB7IC8vIGFueSBub24temVybyBudW1lcmljIGNoYXJhY3RlcnM/XHJcbiAgICAgICAgICAgIHJldHVybiBtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vLyBNaXNjIFV0aWxzXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuLypcclxuUmV0dXJucyBhIHVuaXQgc3RyaW5nLCBlaXRoZXIgJ3llYXInLCAnbW9udGgnLCAnZGF5Jywgb3IgbnVsbCBmb3IgdGhlIG1vc3QgZ3JhbnVsYXIgZm9ybWF0dGluZyB0b2tlbiBpbiB0aGUgc3RyaW5nLlxyXG4qL1xyXG5mdW5jdGlvbiBxdWVyeU1vc3RHcmFudWxhckZvcm1hdFVuaXQoZm9ybWF0U3RyKSB7XHJcbiAgICB2YXIgY2h1bmtzID0gY2h1bmtGb3JtYXRTdHJpbmcoZm9ybWF0U3RyKTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGNodW5rO1xyXG4gICAgdmFyIGNhbmRpZGF0ZTtcclxuICAgIHZhciBiZXN0O1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGNodW5rcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNodW5rID0gY2h1bmtzW2ldO1xyXG4gICAgICAgIGlmIChjaHVuay50b2tlbikge1xyXG4gICAgICAgICAgICBjYW5kaWRhdGUgPSBsYXJnZVRva2VuTWFwW2NodW5rLnRva2VuLmNoYXJBdCgwKV07XHJcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGUpIHtcclxuICAgICAgICAgICAgICAgIGlmICghYmVzdCB8fCBjYW5kaWRhdGUudmFsdWUgPiBiZXN0LnZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmVzdCA9IGNhbmRpZGF0ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChiZXN0KSB7XHJcbiAgICAgICAgcmV0dXJuIGJlc3QudW5pdDtcclxuICAgIH1cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmV4cG9ydHMucXVlcnlNb3N0R3JhbnVsYXJGb3JtYXRVbml0ID0gcXVlcnlNb3N0R3JhbnVsYXJGb3JtYXRVbml0O1xyXG5cblxuLyoqKi8gfSksXG4vKiA1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFdmVudFJhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRSYW5nZSh1bnpvbmVkUmFuZ2UsIGV2ZW50RGVmLCBldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy51bnpvbmVkUmFuZ2UgPSB1bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdGhpcy5ldmVudERlZiA9IGV2ZW50RGVmO1xyXG4gICAgICAgIGlmIChldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRJbnN0YW5jZSA9IGV2ZW50SW5zdGFuY2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIEV2ZW50UmFuZ2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50UmFuZ2U7XHJcblxuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgQ2xhc3NfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIExpc3RlbmVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbnZhciBNb2RlbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKE1vZGVsLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTW9kZWwoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fd2F0Y2hlcnMgPSB7fTtcclxuICAgICAgICBfdGhpcy5fcHJvcHMgPSB7fTtcclxuICAgICAgICBfdGhpcy5hcHBseUdsb2JhbFdhdGNoZXJzKCk7XHJcbiAgICAgICAgX3RoaXMuY29uc3RydWN0ZWQoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBNb2RlbC53YXRjaCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBtYWtlIGEgbWFza2VkLWNvcHkgb2YgdGhlIHN1cGVyY2xhc3MncyBtYXBcclxuICAgICAgICAvLyBUT0RPOiB3cml0ZSB0ZXN0XHJcbiAgICAgICAgaWYgKCF0aGlzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnX2dsb2JhbFdhdGNoQXJncycpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvdG90eXBlLl9nbG9iYWxXYXRjaEFyZ3MgPSBPYmplY3QuY3JlYXRlKHRoaXMucHJvdG90eXBlLl9nbG9iYWxXYXRjaEFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnByb3RvdHlwZS5fZ2xvYmFsV2F0Y2hBcmdzW25hbWVdID0gYXJncztcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUuY29uc3RydWN0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gdXNlZnVsIGZvciBtb25rZXlwYXRjaGluZy4gVE9ETzogQmFzZUNsYXNzP1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5hcHBseUdsb2JhbFdhdGNoZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9nbG9iYWxXYXRjaEFyZ3M7XHJcbiAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgZm9yIChuYW1lIGluIG1hcCkge1xyXG4gICAgICAgICAgICB0aGlzLndhdGNoLmFwcGx5KHRoaXMsIFtuYW1lXS5jb25jYXQobWFwW25hbWVdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuYW1lIGluIHRoaXMuX3Byb3BzO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcHJvcHNbbmFtZV07XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWwpIHtcclxuICAgICAgICB2YXIgbmV3UHJvcHM7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICBuZXdQcm9wcyA9IHt9O1xyXG4gICAgICAgICAgICBuZXdQcm9wc1tuYW1lXSA9IHZhbCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1Byb3BzID0gbmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQcm9wcyhuZXdQcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKG5ld1Byb3BzKSB7XHJcbiAgICAgICAgdmFyIG9sZFByb3BzID0gdGhpcy5fcHJvcHM7XHJcbiAgICAgICAgdmFyIGNoYW5nZXNldCA9IHt9OyAvLyB3aWxsIGhhdmUgdW5kZWZpbmVkJ3MgdG8gc2lnbmFsIHVuc2V0c1xyXG4gICAgICAgIHZhciBuYW1lO1xyXG4gICAgICAgIGZvciAobmFtZSBpbiBvbGRQcm9wcykge1xyXG4gICAgICAgICAgICBjaGFuZ2VzZXRbbmFtZV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobmFtZSBpbiBuZXdQcm9wcykge1xyXG4gICAgICAgICAgICBjaGFuZ2VzZXRbbmFtZV0gPSBuZXdQcm9wc1tuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zZXRQcm9wcyhjaGFuZ2VzZXQpO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS51bnNldCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIG5ld1Byb3BzID0ge307XHJcbiAgICAgICAgdmFyIG5hbWVzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbmFtZXMgPSBbbmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBuYW1lcyA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBuZXdQcm9wc1tuYW1lc1tpXV0gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0UHJvcHMobmV3UHJvcHMpO1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5zZXRQcm9wcyA9IGZ1bmN0aW9uIChuZXdQcm9wcykge1xyXG4gICAgICAgIHZhciBjaGFuZ2VkUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgY2hhbmdlZENudCA9IDA7XHJcbiAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgdmFyIHZhbDtcclxuICAgICAgICBmb3IgKG5hbWUgaW4gbmV3UHJvcHMpIHtcclxuICAgICAgICAgICAgdmFsID0gbmV3UHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgIC8vIGEgY2hhbmdlIGluIHZhbHVlP1xyXG4gICAgICAgICAgICAvLyBpZiBhbiBvYmplY3QsIGRvbid0IGNoZWNrIGVxdWFsaXR5LCBiZWNhdXNlIG1pZ2h0IGhhdmUgYmVlbiBtdXRhdGVkIGludGVybmFsbHkuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IGV2ZW50dWFsbHkgZW5mb3JjZSBpbW11dGFiaWxpdHkuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0JyB8fFxyXG4gICAgICAgICAgICAgICAgdmFsICE9PSB0aGlzLl9wcm9wc1tuYW1lXSkge1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZFByb3BzW25hbWVdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgY2hhbmdlZENudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjaGFuZ2VkQ250KSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlOmJhdGNoQ2hhbmdlJywgY2hhbmdlZFByb3BzKTtcclxuICAgICAgICAgICAgZm9yIChuYW1lIGluIGNoYW5nZWRQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgdmFsID0gY2hhbmdlZFByb3BzW25hbWVdO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdiZWZvcmU6Y2hhbmdlJywgbmFtZSwgdmFsKTtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmVmb3JlOmNoYW5nZTonICsgbmFtZSwgdmFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKG5hbWUgaW4gY2hhbmdlZFByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBjaGFuZ2VkUHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcHJvcHNbbmFtZV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wcm9wc1tuYW1lXSA9IHZhbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlOicgKyBuYW1lLCB2YWwpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdjaGFuZ2UnLCBuYW1lLCB2YWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignYmF0Y2hDaGFuZ2UnLCBjaGFuZ2VkUHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiAobmFtZSwgZGVwTGlzdCwgc3RhcnRGdW5jLCBzdG9wRnVuYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy51bndhdGNoKG5hbWUpO1xyXG4gICAgICAgIHRoaXMuX3dhdGNoZXJzW25hbWVdID0gdGhpcy5fd2F0Y2hEZXBzKGRlcExpc3QsIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICAgICAgICAgIHZhciByZXMgPSBzdGFydEZ1bmMuY2FsbChfdGhpcywgZGVwcyk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgJiYgcmVzLnRoZW4pIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnVuc2V0KG5hbWUpOyAvLyBwdXQgaW4gYW4gdW5zZXQgc3RhdGUgd2hpbGUgcmVzb2x2aW5nXHJcbiAgICAgICAgICAgICAgICByZXMudGhlbihmdW5jdGlvbiAodmFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0KG5hbWUsIHZhbCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNldChuYW1lLCByZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgICAgICAgICAgX3RoaXMudW5zZXQobmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChzdG9wRnVuYykge1xyXG4gICAgICAgICAgICAgICAgc3RvcEZ1bmMuY2FsbChfdGhpcywgZGVwcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBNb2RlbC5wcm90b3R5cGUudW53YXRjaCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyc1tuYW1lXTtcclxuICAgICAgICBpZiAod2F0Y2hlcikge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fd2F0Y2hlcnNbbmFtZV07XHJcbiAgICAgICAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTW9kZWwucHJvdG90eXBlLl93YXRjaERlcHMgPSBmdW5jdGlvbiAoZGVwTGlzdCwgc3RhcnRGdW5jLCBzdG9wRnVuYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHF1ZXVlZENoYW5nZUNudCA9IDA7XHJcbiAgICAgICAgdmFyIGRlcENudCA9IGRlcExpc3QubGVuZ3RoO1xyXG4gICAgICAgIHZhciBzYXRpc2Z5Q250ID0gMDtcclxuICAgICAgICB2YXIgdmFsdWVzID0ge307IC8vIHdoYXQncyBwYXNzZWQgYXMgdGhlIGBkZXBzYCBhcmd1bWVudHNcclxuICAgICAgICB2YXIgYmluZFR1cGxlcyA9IFtdOyAvLyBhcnJheSBvZiBbIGV2ZW50TmFtZSwgaGFuZGxlckZ1bmMgXSBhcnJheXNcclxuICAgICAgICB2YXIgaXNDYWxsaW5nU3RvcCA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBvbkJlZm9yZURlcENoYW5nZSA9IGZ1bmN0aW9uIChkZXBOYW1lLCB2YWwsIGlzT3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgcXVldWVkQ2hhbmdlQ250Kys7XHJcbiAgICAgICAgICAgIGlmIChxdWV1ZWRDaGFuZ2VDbnQgPT09IDEpIHsgLy8gZmlyc3QgY2hhbmdlIHRvIGNhdXNlIGEgXCJzdG9wXCIgP1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkgeyAvLyBhbGwgZGVwcyBwcmV2aW91c2x5IHNhdGlzZmllZD9cclxuICAgICAgICAgICAgICAgICAgICBpc0NhbGxpbmdTdG9wID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wRnVuYyh2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlzQ2FsbGluZ1N0b3AgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIG9uRGVwQ2hhbmdlID0gZnVuY3Rpb24gKGRlcE5hbWUsIHZhbCwgaXNPcHRpb25hbCkge1xyXG4gICAgICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHsgLy8gdW5zZXR0aW5nIGEgdmFsdWU/XHJcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlZCBkZXBlbmRlbmN5IHRoYXQgd2FzIHByZXZpb3VzbHkgc2V0P1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09wdGlvbmFsICYmIHZhbHVlc1tkZXBOYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F0aXNmeUNudC0tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIHZhbHVlc1tkZXBOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHsgLy8gc2V0dGluZyBhIHZhbHVlP1xyXG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgZGVwZW5kZW5jeSB0aGF0IHdhcyBwcmV2aW91c2x5IHVuc2V0P1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09wdGlvbmFsICYmIHZhbHVlc1tkZXBOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2F0aXNmeUNudCsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdmFsdWVzW2RlcE5hbWVdID0gdmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHF1ZXVlZENoYW5nZUNudC0tO1xyXG4gICAgICAgICAgICBpZiAoIXF1ZXVlZENoYW5nZUNudCkgeyAvLyBsYXN0IGNoYW5nZSB0byBjYXVzZSBhIFwic3RhcnRcIj9cclxuICAgICAgICAgICAgICAgIC8vIG5vdyBmaW5hbGx5IHNhdGlzZmllZCBvciBzYXRpc2ZpZWQgYWxsIGFsb25nP1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBzdG9wRnVuYyBpbml0aWF0ZWQgYW5vdGhlciB2YWx1ZSBjaGFuZ2UsIGlnbm9yZSBpdC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBpdCB3aWxsIGJlIHByb2Nlc3NlZCBieSBhbm90aGVyIGNoYW5nZSBldmVudCBhbnl3YXkuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0NhbGxpbmdTdG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0RnVuYyh2YWx1ZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gaW50ZXJjZXB0IGZvciAub24oKSB0aGF0IHJlbWVtYmVycyBoYW5kbGVyc1xyXG4gICAgICAgIHZhciBiaW5kID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgICAgICBfdGhpcy5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICBiaW5kVHVwbGVzLnB1c2goW2V2ZW50TmFtZSwgaGFuZGxlcl0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gbGlzdGVuIHRvIGRlcGVuZGVuY3kgY2hhbmdlc1xyXG4gICAgICAgIGRlcExpc3QuZm9yRWFjaChmdW5jdGlvbiAoZGVwTmFtZSkge1xyXG4gICAgICAgICAgICB2YXIgaXNPcHRpb25hbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAoZGVwTmFtZS5jaGFyQXQoMCkgPT09ICc/JykgeyAvLyBUT0RPOiBtb3JlIERSWVxyXG4gICAgICAgICAgICAgICAgZGVwTmFtZSA9IGRlcE5hbWUuc3Vic3RyaW5nKDEpO1xyXG4gICAgICAgICAgICAgICAgaXNPcHRpb25hbCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYmluZCgnYmVmb3JlOmNoYW5nZTonICsgZGVwTmFtZSwgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgb25CZWZvcmVEZXBDaGFuZ2UoZGVwTmFtZSwgdmFsLCBpc09wdGlvbmFsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGJpbmQoJ2NoYW5nZTonICsgZGVwTmFtZSwgZnVuY3Rpb24gKHZhbCkge1xyXG4gICAgICAgICAgICAgICAgb25EZXBDaGFuZ2UoZGVwTmFtZSwgdmFsLCBpc09wdGlvbmFsKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gcHJvY2VzcyBjdXJyZW50IGRlcGVuZGVuY3kgdmFsdWVzXHJcbiAgICAgICAgZGVwTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChkZXBOYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpc09wdGlvbmFsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmIChkZXBOYW1lLmNoYXJBdCgwKSA9PT0gJz8nKSB7IC8vIFRPRE86IG1vcmUgRFJZXHJcbiAgICAgICAgICAgICAgICBkZXBOYW1lID0gZGVwTmFtZS5zdWJzdHJpbmcoMSk7XHJcbiAgICAgICAgICAgICAgICBpc09wdGlvbmFsID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoX3RoaXMuaGFzKGRlcE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICB2YWx1ZXNbZGVwTmFtZV0gPSBfdGhpcy5nZXQoZGVwTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBzYXRpc2Z5Q250Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPcHRpb25hbCkge1xyXG4gICAgICAgICAgICAgICAgc2F0aXNmeUNudCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gaW5pdGlhbGx5IHNhdGlzZmllZFxyXG4gICAgICAgIGlmIChzYXRpc2Z5Q250ID09PSBkZXBDbnQpIHtcclxuICAgICAgICAgICAgc3RhcnRGdW5jKHZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHRlYXJkb3duOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmRUdXBsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmYoYmluZFR1cGxlc1tpXVswXSwgYmluZFR1cGxlc1tpXVsxXSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBiaW5kVHVwbGVzID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIC8vIHdhcyBzYXRpc2ZpZWQsIHNvIGNhbGwgc3RvcEZ1bmNcclxuICAgICAgICAgICAgICAgIGlmIChzYXRpc2Z5Q250ID09PSBkZXBDbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdG9wRnVuYygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBmbGFzaDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNhdGlzZnlDbnQgPT09IGRlcENudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3BGdW5jKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRGdW5jKHZhbHVlcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIE1vZGVsLnByb3RvdHlwZS5mbGFzaCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIHdhdGNoZXIgPSB0aGlzLl93YXRjaGVyc1tuYW1lXTtcclxuICAgICAgICBpZiAod2F0Y2hlcikge1xyXG4gICAgICAgICAgICB3YXRjaGVyLmZsYXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBNb2RlbDtcclxufShDbGFzc18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTW9kZWw7XHJcbk1vZGVsLnByb3RvdHlwZS5fZ2xvYmFsV2F0Y2hBcmdzID0ge307IC8vIG11dGF0aW9uIHByb3RlY3Rpb24gaW4gTW9kZWwud2F0Y2hcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKE1vZGVsKTtcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhNb2RlbCk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDUyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qXHJcblVTQUdFOlxyXG4gIGltcG9ydCB7IGRlZmF1bHQgYXMgUGFyc2FibGVNb2RlbE1peGluLCBQYXJzYWJsZU1vZGVsSW50ZXJmYWNlIH0gZnJvbSAnLi9QYXJzYWJsZU1vZGVsTWl4aW4nXHJcbmluIGNsYXNzOlxyXG4gIGFwcGx5UHJvcHM6IFBhcnNhYmxlTW9kZWxJbnRlcmZhY2VbJ2FwcGx5UHJvcHMnXVxyXG4gIGFwcGx5TWFudWFsU3RhbmRhcmRQcm9wczogUGFyc2FibGVNb2RlbEludGVyZmFjZVsnYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzJ11cclxuICBhcHBseU1pc2NQcm9wczogUGFyc2FibGVNb2RlbEludGVyZmFjZVsnYXBwbHlNaXNjUHJvcHMnXVxyXG4gIGlzU3RhbmRhcmRQcm9wOiBQYXJzYWJsZU1vZGVsSW50ZXJmYWNlWydpc1N0YW5kYXJkUHJvcCddXHJcbiAgc3RhdGljIGRlZmluZVN0YW5kYXJkUHJvcHMgPSBQYXJzYWJsZU1vZGVsTWl4aW4uZGVmaW5lU3RhbmRhcmRQcm9wc1xyXG4gIHN0YXRpYyBjb3B5VmVyYmF0aW1TdGFuZGFyZFByb3BzID0gUGFyc2FibGVNb2RlbE1peGluLmNvcHlWZXJiYXRpbVN0YW5kYXJkUHJvcHNcclxuYWZ0ZXIgY2xhc3M6XHJcbiAgUGFyc2FibGVNb2RlbE1peGluLm1peEludG8oVGhlQ2xhc3MpXHJcbiovXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIE1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxudmFyIFBhcnNhYmxlTW9kZWxNaXhpbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFBhcnNhYmxlTW9kZWxNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFBhcnNhYmxlTW9kZWxNaXhpbigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBQYXJzYWJsZU1vZGVsTWl4aW4uZGVmaW5lU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wRGVmcykge1xyXG4gICAgICAgIHZhciBwcm90byA9IHRoaXMucHJvdG90eXBlO1xyXG4gICAgICAgIGlmICghcHJvdG8uaGFzT3duUHJvcGVydHkoJ3N0YW5kYXJkUHJvcE1hcCcpKSB7XHJcbiAgICAgICAgICAgIHByb3RvLnN0YW5kYXJkUHJvcE1hcCA9IE9iamVjdC5jcmVhdGUocHJvdG8uc3RhbmRhcmRQcm9wTWFwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdXRpbF8xLmNvcHlPd25Qcm9wcyhwcm9wRGVmcywgcHJvdG8uc3RhbmRhcmRQcm9wTWFwKTtcclxuICAgIH07XHJcbiAgICBQYXJzYWJsZU1vZGVsTWl4aW4uY29weVZlcmJhdGltU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChzcmMsIGRlc3QpIHtcclxuICAgICAgICB2YXIgbWFwID0gdGhpcy5wcm90b3R5cGUuc3RhbmRhcmRQcm9wTWFwO1xyXG4gICAgICAgIHZhciBwcm9wTmFtZTtcclxuICAgICAgICBmb3IgKHByb3BOYW1lIGluIG1hcCkge1xyXG4gICAgICAgICAgICBpZiAoc3JjW3Byb3BOYW1lXSAhPSBudWxsICYmIC8vIGluIHRoZSBzcmMgb2JqZWN0P1xyXG4gICAgICAgICAgICAgICAgbWFwW3Byb3BOYW1lXSA9PT0gdHJ1ZSAvLyBmYWxzZSBtZWFucyBcImNvcHkgdmVyYmF0aW1cIlxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGRlc3RbcHJvcE5hbWVdID0gc3JjW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgUmV0dXJucyB0cnVlL2ZhbHNlIGZvciBzdWNjZXNzLlxyXG4gICAgTWVhbnQgdG8gYmUgb25seSBjYWxsZWQgT05DRSwgYXQgb2JqZWN0IGNyZWF0aW9uLlxyXG4gICAgKi9cclxuICAgIFBhcnNhYmxlTW9kZWxNaXhpbi5wcm90b3R5cGUuYXBwbHlQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHZhciBzdGFuZGFyZFByb3BNYXAgPSB0aGlzLnN0YW5kYXJkUHJvcE1hcDtcclxuICAgICAgICB2YXIgbWFudWFsUHJvcHMgPSB7fTtcclxuICAgICAgICB2YXIgbWlzY1Byb3BzID0ge307XHJcbiAgICAgICAgdmFyIHByb3BOYW1lO1xyXG4gICAgICAgIGZvciAocHJvcE5hbWUgaW4gcmF3UHJvcHMpIHtcclxuICAgICAgICAgICAgaWYgKHN0YW5kYXJkUHJvcE1hcFtwcm9wTmFtZV0gPT09IHRydWUpIHsgLy8gY29weSB2ZXJiYXRpbVxyXG4gICAgICAgICAgICAgICAgdGhpc1twcm9wTmFtZV0gPSByYXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhbmRhcmRQcm9wTWFwW3Byb3BOYW1lXSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIG1hbnVhbFByb3BzW3Byb3BOYW1lXSA9IHJhd1Byb3BzW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1pc2NQcm9wc1twcm9wTmFtZV0gPSByYXdQcm9wc1twcm9wTmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hcHBseU1pc2NQcm9wcyhtaXNjUHJvcHMpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyhtYW51YWxQcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIElmIHN1YmNsYXNzZXMgb3ZlcnJpZGUsIHRoZXkgbXVzdCBjYWxsIHRoaXMgc3VwZXJtZXRob2QgYW5kIHJldHVybiB0aGUgYm9vbGVhbiByZXNwb25zZS5cclxuICAgIE1lYW50IHRvIGJlIG9ubHkgY2FsbGVkIE9OQ0UsIGF0IG9iamVjdCBjcmVhdGlvbi5cclxuICAgICovXHJcbiAgICBQYXJzYWJsZU1vZGVsTWl4aW4ucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBDYW4gYmUgY2FsbGVkIGV2ZW4gYWZ0ZXIgaW5pdGlhbCBvYmplY3QgY3JlYXRpb24uXHJcbiAgICAqL1xyXG4gICAgUGFyc2FibGVNb2RlbE1peGluLnByb3RvdHlwZS5hcHBseU1pc2NQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgY2FuIGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBUT0RPOiB3aHkgaXMgdGhpcyBhIG1ldGhvZCB3aGVuIGRlZmluZVN0YW5kYXJkUHJvcHMgaXMgc3RhdGljXHJcbiAgICAqL1xyXG4gICAgUGFyc2FibGVNb2RlbE1peGluLnByb3RvdHlwZS5pc1N0YW5kYXJkUHJvcCA9IGZ1bmN0aW9uIChwcm9wTmFtZSkge1xyXG4gICAgICAgIHJldHVybiBwcm9wTmFtZSBpbiB0aGlzLnN0YW5kYXJkUHJvcE1hcDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gUGFyc2FibGVNb2RlbE1peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBQYXJzYWJsZU1vZGVsTWl4aW47XHJcblBhcnNhYmxlTW9kZWxNaXhpbi5wcm90b3R5cGUuc3RhbmRhcmRQcm9wTWFwID0ge307IC8vIHdpbGwgYmUgY2xvbmVkIGJ5IGRlZmluZVN0YW5kYXJkUHJvcHNcclxuXG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgRXZlbnRJbnN0YW5jZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50SW5zdGFuY2UoZGVmLCBkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHRoaXMuZGVmID0gZGVmO1xyXG4gICAgICAgIHRoaXMuZGF0ZVByb2ZpbGUgPSBkYXRlUHJvZmlsZTtcclxuICAgIH1cclxuICAgIEV2ZW50SW5zdGFuY2UucHJvdG90eXBlLnRvTGVnYWN5ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIG9iaiA9IHRoaXMuZGVmLnRvTGVnYWN5KCk7XHJcbiAgICAgICAgb2JqLnN0YXJ0ID0gZGF0ZVByb2ZpbGUuc3RhcnQuY2xvbmUoKTtcclxuICAgICAgICBvYmouZW5kID0gZGF0ZVByb2ZpbGUuZW5kID8gZGF0ZVByb2ZpbGUuZW5kLmNsb25lKCkgOiBudWxsO1xyXG4gICAgICAgIHJldHVybiBvYmo7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50SW5zdGFuY2U7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50SW5zdGFuY2U7XHJcblxuXG4vKioqLyB9KSxcbi8qIDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xyXG52YXIgRXZlbnRJbnN0YW5jZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XHJcbnZhciBFdmVudERhdGVQcm9maWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxudmFyIFJlY3VycmluZ0V2ZW50RGVmID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUmVjdXJyaW5nRXZlbnREZWYsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSZWN1cnJpbmdFdmVudERlZigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBSZWN1cnJpbmdFdmVudERlZi5wcm90b3R5cGUuaXNBbGxEYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLnN0YXJ0VGltZSAmJiAhdGhpcy5lbmRUaW1lO1xyXG4gICAgfTtcclxuICAgIFJlY3VycmluZ0V2ZW50RGVmLnByb3RvdHlwZS5idWlsZEluc3RhbmNlcyA9IGZ1bmN0aW9uICh1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLnNvdXJjZS5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgdW56b25lZERhdGUgPSB1bnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKTtcclxuICAgICAgICB2YXIgdW56b25lZEVuZCA9IHVuem9uZWRSYW5nZS5nZXRFbmQoKTtcclxuICAgICAgICB2YXIgem9uZWREYXlTdGFydDtcclxuICAgICAgICB2YXIgaW5zdGFuY2VTdGFydDtcclxuICAgICAgICB2YXIgaW5zdGFuY2VFbmQ7XHJcbiAgICAgICAgdmFyIGluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHdoaWxlICh1bnpvbmVkRGF0ZS5pc0JlZm9yZSh1bnpvbmVkRW5kKSkge1xyXG4gICAgICAgICAgICAvLyBpZiBldmVyeWRheSwgb3IgdGhpcyBwYXJ0aWN1bGFyIGRheS1vZi13ZWVrXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5kb3dIYXNoIHx8IHRoaXMuZG93SGFzaFt1bnpvbmVkRGF0ZS5kYXkoKV0pIHtcclxuICAgICAgICAgICAgICAgIHpvbmVkRGF5U3RhcnQgPSBjYWxlbmRhci5hcHBseVRpbWV6b25lKHVuem9uZWREYXRlKTtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlU3RhcnQgPSB6b25lZERheVN0YXJ0LmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZUVuZCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0LnRpbWUodGhpcy5zdGFydFRpbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmVuZFRpbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZUVuZCA9IHpvbmVkRGF5U3RhcnQuY2xvbmUoKS50aW1lKHRoaXMuZW5kVGltZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXMucHVzaChuZXcgRXZlbnRJbnN0YW5jZV8xLmRlZmF1bHQodGhpcywgLy8gZGVmaW5pdGlvblxyXG4gICAgICAgICAgICAgICAgbmV3IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0KGluc3RhbmNlU3RhcnQsIGluc3RhbmNlRW5kLCBjYWxlbmRhcikpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB1bnpvbmVkRGF0ZS5hZGQoMSwgJ2RheXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlcztcclxuICAgIH07XHJcbiAgICBSZWN1cnJpbmdFdmVudERlZi5wcm90b3R5cGUuc2V0RG93ID0gZnVuY3Rpb24gKGRvd051bWJlcnMpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZG93SGFzaCkge1xyXG4gICAgICAgICAgICB0aGlzLmRvd0hhc2ggPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb3dOdW1iZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZG93SGFzaFtkb3dOdW1iZXJzW2ldXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlY3VycmluZ0V2ZW50RGVmLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVmID0gX3N1cGVyLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIGlmIChkZWYuc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgIGRlZi5zdGFydFRpbWUgPSBtb21lbnQuZHVyYXRpb24odGhpcy5zdGFydFRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVmLmVuZFRpbWUpIHtcclxuICAgICAgICAgICAgZGVmLmVuZFRpbWUgPSBtb21lbnQuZHVyYXRpb24odGhpcy5lbmRUaW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZG93SGFzaCkge1xyXG4gICAgICAgICAgICBkZWYuZG93SGFzaCA9ICQuZXh0ZW5kKHt9LCB0aGlzLmRvd0hhc2gpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZWN1cnJpbmdFdmVudERlZjtcclxufShFdmVudERlZl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUmVjdXJyaW5nRXZlbnREZWY7XHJcbi8qXHJcbkhBQ0sgdG8gd29yayB3aXRoIFR5cGVTY3JpcHQgbWl4aW5zXHJcbk5PVEU6IGlmIHN1cGVyLW1ldGhvZCBmYWlscywgc2hvdWxkIHN0aWxsIGF0dGVtcHQgdG8gYXBwbHlcclxuKi9cclxuUmVjdXJyaW5nRXZlbnREZWYucHJvdG90eXBlLmFwcGx5UHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgIHZhciBzdXBlclN1Y2Nlc3MgPSBFdmVudERlZl8xLmRlZmF1bHQucHJvdG90eXBlLmFwcGx5UHJvcHMuY2FsbCh0aGlzLCByYXdQcm9wcyk7XHJcbiAgICBpZiAocmF3UHJvcHMuc3RhcnQpIHtcclxuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG1vbWVudC5kdXJhdGlvbihyYXdQcm9wcy5zdGFydCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmF3UHJvcHMuZW5kKSB7XHJcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gbW9tZW50LmR1cmF0aW9uKHJhd1Byb3BzLmVuZCk7XHJcbiAgICB9XHJcbiAgICBpZiAocmF3UHJvcHMuZG93KSB7XHJcbiAgICAgICAgdGhpcy5zZXREb3cocmF3UHJvcHMuZG93KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzdXBlclN1Y2Nlc3M7XHJcbn07XHJcbi8vIFBhcnNpbmdcclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblJlY3VycmluZ0V2ZW50RGVmLmRlZmluZVN0YW5kYXJkUHJvcHMoe1xyXG4gICAgc3RhcnQ6IGZhbHNlLFxyXG4gICAgZW5kOiBmYWxzZSxcclxuICAgIGRvdzogZmFsc2VcclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEYXRlUHJvZmlsZUdlbmVyYXRvcihfdmlldykge1xyXG4gICAgICAgIHRoaXMuX3ZpZXcgPSBfdmlldztcclxuICAgIH1cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5vcHQgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3Lm9wdChuYW1lKTtcclxuICAgIH07XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUudHJpbUhpZGRlbkRheXMgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXcudHJpbUhpZGRlbkRheXModW56b25lZFJhbmdlKTtcclxuICAgIH07XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUubXNUb1V0Y01vbWVudCA9IGZ1bmN0aW9uIChtcywgZm9yY2VBbGxEYXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5jYWxlbmRhci5tc1RvVXRjTW9tZW50KG1zLCBmb3JjZUFsbERheSk7XHJcbiAgICB9O1xyXG4gICAgLyogRGF0ZSBSYW5nZSBDb21wdXRhdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcInByZXZcIiB2aWV3LlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUHJldiA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgcHJldkRhdGUgPSBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZS5jbG9uZSgpXHJcbiAgICAgICAgICAgIC5zdGFydE9mKGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KVxyXG4gICAgICAgICAgICAuc3VidHJhY3QoY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKHByZXZEYXRlLCAtMSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB3aGF0IHRoZSBkYXRlcy9yYW5nZXMgd2lsbCBiZSBmb3IgdGhlIFwibmV4dFwiIHZpZXcuXHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGROZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnREYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHZhciBuZXh0RGF0ZSA9IGN1cnJlbnREYXRlUHJvZmlsZS5kYXRlLmNsb25lKClcclxuICAgICAgICAgICAgLnN0YXJ0T2YoY3VycmVudERhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpXHJcbiAgICAgICAgICAgIC5hZGQoY3VycmVudERhdGVQcm9maWxlLmRhdGVJbmNyZW1lbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKG5leHREYXRlLCAxKTtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgaG9sZGluZyBkYXRlcy9yYW5nZXMgZm9yIHJlbmRlcmluZyBhcm91bmQgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAvLyBPcHRpb25hbCBkaXJlY3Rpb24gcGFyYW0gaW5kaWNhdGVzIHdoZXRoZXIgdGhlIGRhdGUgaXMgYmVpbmcgaW5jcmVtZW50ZWQvZGVjcmVtZW50ZWRcclxuICAgIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gKGRhdGUsIGRpcmVjdGlvbiwgZm9yY2VUb1ZhbGlkKSB7XHJcbiAgICAgICAgaWYgKGZvcmNlVG9WYWxpZCA9PT0gdm9pZCAwKSB7IGZvcmNlVG9WYWxpZCA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIGlzRGF0ZUFsbERheSA9ICFkYXRlLmhhc1RpbWUoKTtcclxuICAgICAgICB2YXIgdmFsaWRVbnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIG1pblRpbWUgPSBudWxsO1xyXG4gICAgICAgIHZhciBtYXhUaW1lID0gbnVsbDtcclxuICAgICAgICB2YXIgY3VycmVudEluZm87XHJcbiAgICAgICAgdmFyIGlzUmFuZ2VBbGxEYXk7XHJcbiAgICAgICAgdmFyIHJlbmRlclVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgYWN0aXZlVW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBpc1ZhbGlkO1xyXG4gICAgICAgIHZhbGlkVW56b25lZFJhbmdlID0gdGhpcy5idWlsZFZhbGlkUmFuZ2UoKTtcclxuICAgICAgICB2YWxpZFVuem9uZWRSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXModmFsaWRVbnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIGlmIChmb3JjZVRvVmFsaWQpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMubXNUb1V0Y01vbWVudCh2YWxpZFVuem9uZWRSYW5nZS5jb25zdHJhaW5EYXRlKGRhdGUpLCAvLyByZXR1cm5zIE1TXHJcbiAgICAgICAgICAgIGlzRGF0ZUFsbERheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnRJbmZvID0gdGhpcy5idWlsZEN1cnJlbnRSYW5nZUluZm8oZGF0ZSwgZGlyZWN0aW9uKTtcclxuICAgICAgICBpc1JhbmdlQWxsRGF5ID0gL14oeWVhcnxtb250aHx3ZWVrfGRheSkkLy50ZXN0KGN1cnJlbnRJbmZvLnVuaXQpO1xyXG4gICAgICAgIHJlbmRlclVuem9uZWRSYW5nZSA9IHRoaXMuYnVpbGRSZW5kZXJSYW5nZSh0aGlzLnRyaW1IaWRkZW5EYXlzKGN1cnJlbnRJbmZvLnVuem9uZWRSYW5nZSksIGN1cnJlbnRJbmZvLnVuaXQsIGlzUmFuZ2VBbGxEYXkpO1xyXG4gICAgICAgIHJlbmRlclVuem9uZWRSYW5nZSA9IHRoaXMudHJpbUhpZGRlbkRheXMocmVuZGVyVW56b25lZFJhbmdlKTtcclxuICAgICAgICBhY3RpdmVVbnpvbmVkUmFuZ2UgPSByZW5kZXJVbnpvbmVkUmFuZ2UuY2xvbmUoKTtcclxuICAgICAgICBpZiAoIXRoaXMub3B0KCdzaG93Tm9uQ3VycmVudERhdGVzJykpIHtcclxuICAgICAgICAgICAgYWN0aXZlVW56b25lZFJhbmdlID0gYWN0aXZlVW56b25lZFJhbmdlLmludGVyc2VjdChjdXJyZW50SW5mby51bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBtaW5UaW1lID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdtaW5UaW1lJykpO1xyXG4gICAgICAgIG1heFRpbWUgPSBtb21lbnQuZHVyYXRpb24odGhpcy5vcHQoJ21heFRpbWUnKSk7XHJcbiAgICAgICAgYWN0aXZlVW56b25lZFJhbmdlID0gdGhpcy5hZGp1c3RBY3RpdmVSYW5nZShhY3RpdmVVbnpvbmVkUmFuZ2UsIG1pblRpbWUsIG1heFRpbWUpO1xyXG4gICAgICAgIGFjdGl2ZVVuem9uZWRSYW5nZSA9IGFjdGl2ZVVuem9uZWRSYW5nZS5pbnRlcnNlY3QodmFsaWRVbnpvbmVkUmFuZ2UpOyAvLyBtaWdodCByZXR1cm4gbnVsbFxyXG4gICAgICAgIGlmIChhY3RpdmVVbnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMubXNUb1V0Y01vbWVudChhY3RpdmVVbnpvbmVkUmFuZ2UuY29uc3RyYWluRGF0ZShkYXRlKSwgLy8gcmV0dXJucyBNU1xyXG4gICAgICAgICAgICBpc0RhdGVBbGxEYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpdCdzIGludmFsaWQgaWYgdGhlIG9yaWdpbmFsbHkgcmVxdWVzdGVkIGRhdGUgaXMgbm90IGNvbnRhaW5lZCxcclxuICAgICAgICAvLyBvciBpZiB0aGUgcmFuZ2UgaXMgY29tcGxldGVseSBvdXRzaWRlIG9mIHRoZSB2YWxpZCByYW5nZS5cclxuICAgICAgICBpc1ZhbGlkID0gY3VycmVudEluZm8udW56b25lZFJhbmdlLmludGVyc2VjdHNXaXRoKHZhbGlkVW56b25lZFJhbmdlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvLyBjb25zdHJhaW50IGZvciB3aGVyZSBwcmV2L25leHQgb3BlcmF0aW9ucyBjYW4gZ28gYW5kIHdoZXJlIGV2ZW50cyBjYW4gYmUgZHJhZ2dlZC9yZXNpemVkIHRvLlxyXG4gICAgICAgICAgICAvLyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydCBhbmQgZW5kIHByb3BlcnRpZXMuXHJcbiAgICAgICAgICAgIHZhbGlkVW56b25lZFJhbmdlOiB2YWxpZFVuem9uZWRSYW5nZSxcclxuICAgICAgICAgICAgLy8gcmFuZ2UgdGhlIHZpZXcgaXMgZm9ybWFsbHkgcmVzcG9uc2libGUgZm9yLlxyXG4gICAgICAgICAgICAvLyBmb3IgZXhhbXBsZSwgYSBtb250aCB2aWV3IG1pZ2h0IGhhdmUgMXN0LTMxc3QsIGV4Y2x1ZGluZyBwYWRkZWQgZGF0ZXNcclxuICAgICAgICAgICAgY3VycmVudFVuem9uZWRSYW5nZTogY3VycmVudEluZm8udW56b25lZFJhbmdlLFxyXG4gICAgICAgICAgICAvLyBuYW1lIG9mIGxhcmdlc3QgdW5pdCBiZWluZyBkaXNwbGF5ZWQsIGxpa2UgXCJtb250aFwiIG9yIFwid2Vla1wiXHJcbiAgICAgICAgICAgIGN1cnJlbnRSYW5nZVVuaXQ6IGN1cnJlbnRJbmZvLnVuaXQsXHJcbiAgICAgICAgICAgIGlzUmFuZ2VBbGxEYXk6IGlzUmFuZ2VBbGxEYXksXHJcbiAgICAgICAgICAgIC8vIGRhdGVzIHRoYXQgZGlzcGxheSBldmVudHMgYW5kIGFjY2VwdCBkcmFnLW4tZHJvcFxyXG4gICAgICAgICAgICAvLyB3aWxsIGJlIGBudWxsYCBpZiBubyBkYXRlcyBhY2NlcHQgZXZlbnRzXHJcbiAgICAgICAgICAgIGFjdGl2ZVVuem9uZWRSYW5nZTogYWN0aXZlVW56b25lZFJhbmdlLFxyXG4gICAgICAgICAgICAvLyBkYXRlIHJhbmdlIHdpdGggYSByZW5kZXJlZCBza2VsZXRvblxyXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyBub3QtYWN0aXZlIGRheXMgdGhhdCBuZWVkIHNvbWUgc29ydCBvZiBET01cclxuICAgICAgICAgICAgcmVuZGVyVW56b25lZFJhbmdlOiByZW5kZXJVbnpvbmVkUmFuZ2UsXHJcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGZpcnN0IHZpc2libGUgdGltZSBvZiBhbnkgZ2l2ZW4gZGF5XHJcbiAgICAgICAgICAgIG1pblRpbWU6IG1pblRpbWUsXHJcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGV4Y2x1c2l2ZSB2aXNpYmxlIGVuZCB0aW1lIG9mIGFueSBnaXZlbiBkYXlcclxuICAgICAgICAgICAgbWF4VGltZTogbWF4VGltZSxcclxuICAgICAgICAgICAgaXNWYWxpZDogaXNWYWxpZCxcclxuICAgICAgICAgICAgZGF0ZTogZGF0ZSxcclxuICAgICAgICAgICAgLy8gaG93IGZhciB0aGUgY3VycmVudCBkYXRlIHdpbGwgbW92ZSBmb3IgYSBwcmV2L25leHQgb3BlcmF0aW9uXHJcbiAgICAgICAgICAgIGRhdGVJbmNyZW1lbnQ6IHRoaXMuYnVpbGREYXRlSW5jcmVtZW50KGN1cnJlbnRJbmZvLmR1cmF0aW9uKVxyXG4gICAgICAgICAgICAvLyBwYXNzIGEgZmFsbGJhY2sgKG1pZ2h0IGJlIG51bGwpIF5cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydC9lbmQgcHJvcGVydGllcy5cclxuICAgIC8vIEluZGljYXRlcyB0aGUgbWluaW11bS9tYXhpbXVtIGRhdGVzIHRvIGRpc3BsYXkuXHJcbiAgICAvLyBub3QgcmVzcG9uc2libGUgZm9yIHRyaW1taW5nIGhpZGRlbiBkYXlzLlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkVmFsaWRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdmlldy5nZXRVbnpvbmVkUmFuZ2VPcHRpb24oJ3ZhbGlkUmFuZ2UnLCB0aGlzLl92aWV3LmNhbGVuZGFyLmdldE5vdygpKSB8fFxyXG4gICAgICAgICAgICBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdCgpOyAvLyBjb21wbGV0ZWx5IG9wZW4tZW5kZWRcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHRoZSBcImN1cnJlbnRcIiByYW5nZSwgdGhlIHJhbmdlIHRoYXQgaXNcclxuICAgIC8vIGhpZ2hsaWdodGVkIGFzIGJlaW5nIHRoZSBjdXJyZW50IG1vbnRoIGZvciBleGFtcGxlLlxyXG4gICAgLy8gU2VlIGJ1aWxkKCkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYGRpcmVjdGlvbmAuXHJcbiAgICAvLyBHdWFyYW50ZWVkIHRvIGhhdmUgYHJhbmdlYCBhbmQgYHVuaXRgIHByb3BlcnRpZXMuIGBkdXJhdGlvbmAgaXMgb3B0aW9uYWwuXHJcbiAgICAvLyBUT0RPOiBhY2NlcHQgYSBNUy10aW1lIGluc3RlYWQgb2YgYSBtb21lbnQgYGRhdGVgP1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VycmVudFJhbmdlSW5mbyA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24pIHtcclxuICAgICAgICB2YXIgdmlld1NwZWMgPSB0aGlzLl92aWV3LnZpZXdTcGVjO1xyXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdmFyIHVuaXQgPSBudWxsO1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2UgPSBudWxsO1xyXG4gICAgICAgIHZhciBkYXlDb3VudDtcclxuICAgICAgICBpZiAodmlld1NwZWMuZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSB2aWV3U3BlYy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgdW5pdCA9IHZpZXdTcGVjLmR1cmF0aW9uVW5pdDtcclxuICAgICAgICAgICAgdW56b25lZFJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbUR1cmF0aW9uKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgoZGF5Q291bnQgPSB0aGlzLm9wdCgnZGF5Q291bnQnKSkpIHtcclxuICAgICAgICAgICAgdW5pdCA9ICdkYXknO1xyXG4gICAgICAgICAgICB1bnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCh1bnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlKGRhdGUpKSkge1xyXG4gICAgICAgICAgICB1bml0ID0gdXRpbF8xLmNvbXB1dGVHcmVhdGVzdFVuaXQodW56b25lZFJhbmdlLmdldFN0YXJ0KCksIHVuem9uZWRSYW5nZS5nZXRFbmQoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHRoaXMuZ2V0RmFsbGJhY2tEdXJhdGlvbigpO1xyXG4gICAgICAgICAgICB1bml0ID0gdXRpbF8xLmNvbXB1dGVHcmVhdGVzdFVuaXQoZHVyYXRpb24pO1xyXG4gICAgICAgICAgICB1bnpvbmVkUmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24oZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7IGR1cmF0aW9uOiBkdXJhdGlvbiwgdW5pdDogdW5pdCwgdW56b25lZFJhbmdlOiB1bnpvbmVkUmFuZ2UgfTtcclxuICAgIH07XHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuZ2V0RmFsbGJhY2tEdXJhdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKHsgZGF5czogMSB9KTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGEgbmV3IGFjdGl2ZVVuem9uZWRSYW5nZSB0byBoYXZlIHRpbWUgdmFsdWVzICh1bi1hbWJpZ3VhdGUpXHJcbiAgICAvLyBtaW5UaW1lIG9yIG1heFRpbWUgY2F1c2VzIHRoZSByYW5nZSB0byBleHBhbmQuXHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYWRqdXN0QWN0aXZlUmFuZ2UgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlLCBtaW5UaW1lLCBtYXhUaW1lKSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdW56b25lZFJhbmdlLmdldFN0YXJ0KCk7XHJcbiAgICAgICAgdmFyIGVuZCA9IHVuem9uZWRSYW5nZS5nZXRFbmQoKTtcclxuICAgICAgICBpZiAodGhpcy5fdmlldy51c2VzTWluTWF4VGltZSkge1xyXG4gICAgICAgICAgICBpZiAobWluVGltZSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnRpbWUoMCkuYWRkKG1pblRpbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChtYXhUaW1lID4gMjQgKiA2MCAqIDYwICogMTAwMCkgeyAvLyBiZXlvbmQgMjQgaG91cnM/XHJcbiAgICAgICAgICAgICAgICBlbmQudGltZShtYXhUaW1lIC0gKDI0ICogNjAgKiA2MCAqIDEwMDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGl0IGlzIHNwZWNpZmllZCBhcyBhbiBleHBsaWNpdCBkdXJhdGlvbi5cclxuICAgIC8vIGB1bml0YCBpcyB0aGUgYWxyZWFkeS1jb21wdXRlZCBjb21wdXRlR3JlYXRlc3RVbml0IHZhbHVlIG9mIGR1cmF0aW9uLlxyXG4gICAgLy8gVE9ETzogYWNjZXB0IGEgTVMtdGltZSBpbnN0ZWFkIG9mIGEgbW9tZW50IGBkYXRlYD9cclxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJhbmdlRnJvbUR1cmF0aW9uID0gZnVuY3Rpb24gKGRhdGUsIGRpcmVjdGlvbiwgZHVyYXRpb24sIHVuaXQpIHtcclxuICAgICAgICB2YXIgYWxpZ25tZW50ID0gdGhpcy5vcHQoJ2RhdGVBbGlnbm1lbnQnKTtcclxuICAgICAgICB2YXIgZGF0ZUluY3JlbWVudElucHV0O1xyXG4gICAgICAgIHZhciBkYXRlSW5jcmVtZW50RHVyYXRpb247XHJcbiAgICAgICAgdmFyIHN0YXJ0O1xyXG4gICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgdmFyIHJlcztcclxuICAgICAgICAvLyBjb21wdXRlIHdoYXQgdGhlIGFsaWdubWVudCBzaG91bGQgYmVcclxuICAgICAgICBpZiAoIWFsaWdubWVudCkge1xyXG4gICAgICAgICAgICBkYXRlSW5jcmVtZW50SW5wdXQgPSB0aGlzLm9wdCgnZGF0ZUluY3JlbWVudCcpO1xyXG4gICAgICAgICAgICBpZiAoZGF0ZUluY3JlbWVudElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICBkYXRlSW5jcmVtZW50RHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24oZGF0ZUluY3JlbWVudElucHV0KTtcclxuICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgc21hbGxlciBvZiB0aGUgdHdvIHVuaXRzXHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0ZUluY3JlbWVudER1cmF0aW9uIDwgZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSB1dGlsXzEuY29tcHV0ZUR1cmF0aW9uR3JlYXRlc3RVbml0KGRhdGVJbmNyZW1lbnREdXJhdGlvbiwgZGF0ZUluY3JlbWVudElucHV0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudCA9IHVuaXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBhbGlnbm1lbnQgPSB1bml0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSB2aWV3IGRpc3BsYXlzIGEgc2luZ2xlIGRheSBvciBzbWFsbGVyXHJcbiAgICAgICAgaWYgKGR1cmF0aW9uLmFzKCdkYXlzJykgPD0gMSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fdmlldy5pc0hpZGRlbkRheShzdGFydCkpIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5fdmlldy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnN0YXJ0T2YoJ2RheScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSZXMoKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZS5jbG9uZSgpLnN0YXJ0T2YoYWxpZ25tZW50KTtcclxuICAgICAgICAgICAgZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQoZHVyYXRpb24pO1xyXG4gICAgICAgICAgICByZXMgPSBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcHV0ZVJlcygpO1xyXG4gICAgICAgIC8vIGlmIHJhbmdlIGlzIGNvbXBsZXRlbHkgZW52ZWxvcGVkIGJ5IGhpZGRlbiBkYXlzLCBnbyBwYXN0IHRoZSBoaWRkZW4gZGF5c1xyXG4gICAgICAgIGlmICghdGhpcy50cmltSGlkZGVuRGF5cyhyZXMpKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLl92aWV3LnNraXBIaWRkZW5EYXlzKGRhdGUsIGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGNvbXB1dGVSZXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlcztcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gYSBkYXlDb3VudCBpcyBzcGVjaWZpZWQuXHJcbiAgICAvLyBUT0RPOiBhY2NlcHQgYSBNUy10aW1lIGluc3RlYWQgb2YgYSBtb21lbnQgYGRhdGVgP1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmFuZ2VGcm9tRGF5Q291bnQgPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uLCBkYXlDb3VudCkge1xyXG4gICAgICAgIHZhciBjdXN0b21BbGlnbm1lbnQgPSB0aGlzLm9wdCgnZGF0ZUFsaWdubWVudCcpO1xyXG4gICAgICAgIHZhciBydW5uaW5nQ291bnQgPSAwO1xyXG4gICAgICAgIHZhciBzdGFydDtcclxuICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgIGlmIChjdXN0b21BbGlnbm1lbnQgfHwgZGlyZWN0aW9uICE9PSAtMSkge1xyXG4gICAgICAgICAgICBzdGFydCA9IGRhdGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgaWYgKGN1c3RvbUFsaWdubWVudCkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQuc3RhcnRPZihjdXN0b21BbGlnbm1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN0YXJ0LnN0YXJ0T2YoJ2RheScpO1xyXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuX3ZpZXcuc2tpcEhpZGRlbkRheXMoc3RhcnQpO1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBlbmQuYWRkKDEsICdkYXknKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdmlldy5pc0hpZGRlbkRheShlbmQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ0NvdW50Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHJ1bm5pbmdDb3VudCA8IGRheUNvdW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGVuZCA9IGRhdGUuY2xvbmUoKS5zdGFydE9mKCdkYXknKS5hZGQoMSwgJ2RheScpO1xyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLl92aWV3LnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpO1xyXG4gICAgICAgICAgICBzdGFydCA9IGVuZC5jbG9uZSgpO1xyXG4gICAgICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC5hZGQoLTEsICdkYXknKTtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fdmlldy5pc0hpZGRlbkRheShzdGFydCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBydW5uaW5nQ291bnQrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSB3aGlsZSAocnVubmluZ0NvdW50IDwgZGF5Q291bnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgbm9ybWFsaXplZCByYW5nZSBvYmplY3QgZm9yIHRoZSBcInZpc2libGVcIiByYW5nZSxcclxuICAgIC8vIHdoaWNoIGlzIGEgd2F5IHRvIGRlZmluZSB0aGUgY3VycmVudFVuem9uZWRSYW5nZSBhbmQgYWN0aXZlVW56b25lZFJhbmdlIGF0IHRoZSBzYW1lIHRpbWUuXHJcbiAgICAvLyBUT0RPOiBhY2NlcHQgYSBNUy10aW1lIGluc3RlYWQgb2YgYSBtb21lbnQgYGRhdGVgP1xyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICB2YXIgdmlzaWJsZVVuem9uZWRSYW5nZSA9IHRoaXMuX3ZpZXcuZ2V0VW56b25lZFJhbmdlT3B0aW9uKCd2aXNpYmxlUmFuZ2UnLCB0aGlzLl92aWV3LmNhbGVuZGFyLmFwcGx5VGltZXpvbmUoZGF0ZSkgLy8gY29ycmVjdCB6b25lLiBhbHNvIGdlbmVyYXRlcyBuZXcgb2JqIHRoYXQgYXZvaWRzIG11dGF0aW9uc1xyXG4gICAgICAgICk7XHJcbiAgICAgICAgaWYgKHZpc2libGVVbnpvbmVkUmFuZ2UgJiYgKHZpc2libGVVbnpvbmVkUmFuZ2Uuc3RhcnRNcyA9PSBudWxsIHx8IHZpc2libGVVbnpvbmVkUmFuZ2UuZW5kTXMgPT0gbnVsbCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2aXNpYmxlVW56b25lZFJhbmdlO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSByYW5nZSB0aGF0IHdpbGwgcmVwcmVzZW50IHRoZSBlbGVtZW50L2NlbGxzIGZvciAqcmVuZGVyaW5nKixcclxuICAgIC8vIGJ1dCB3aGljaCBtYXkgaGF2ZSB2b2lkZWQgZGF5cy90aW1lcy5cclxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXHJcbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSZW5kZXJSYW5nZSA9IGZ1bmN0aW9uIChjdXJyZW50VW56b25lZFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRVbnpvbmVkUmFuZ2UuY2xvbmUoKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlIHRoZSBkdXJhdGlvbiB2YWx1ZSB0aGF0IHNob3VsZCBiZSBhZGRlZC9zdWJzdHJhY3RlZCB0byB0aGUgY3VycmVudCBkYXRlXHJcbiAgICAvLyB3aGVuIGEgcHJldi9uZXh0IG9wZXJhdGlvbiBoYXBwZW5zLlxyXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkRGF0ZUluY3JlbWVudCA9IGZ1bmN0aW9uIChmYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBkYXRlSW5jcmVtZW50SW5wdXQgPSB0aGlzLm9wdCgnZGF0ZUluY3JlbWVudCcpO1xyXG4gICAgICAgIHZhciBjdXN0b21BbGlnbm1lbnQ7XHJcbiAgICAgICAgaWYgKGRhdGVJbmNyZW1lbnRJbnB1dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKGRhdGVJbmNyZW1lbnRJbnB1dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKChjdXN0b21BbGlnbm1lbnQgPSB0aGlzLm9wdCgnZGF0ZUFsaWdubWVudCcpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbW9tZW50LmR1cmF0aW9uKDEsIGN1c3RvbUFsaWdubWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGZhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oeyBkYXlzOiAxIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERhdGVQcm9maWxlR2VuZXJhdG9yO1xyXG5cblxuLyoqKi8gfSksXG4vKiA1NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIFByb21pc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxudmFyIEFycmF5RXZlbnRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhBcnJheUV2ZW50U291cmNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQXJyYXlFdmVudFNvdXJjZShjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbGVuZGFyKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLmV2ZW50RGVmcyA9IFtdOyAvLyBmb3IgaWYgc2V0UmF3RXZlbnREZWZzIGlzIG5ldmVyIGNhbGxlZFxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEFycmF5RXZlbnRTb3VyY2UucGFyc2UgPSBmdW5jdGlvbiAocmF3SW5wdXQsIGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdmFyIHJhd1Byb3BzO1xyXG4gICAgICAgIC8vIG5vcm1hbGl6ZSByYXcgaW5wdXRcclxuICAgICAgICBpZiAoJC5pc0FycmF5KHJhd0lucHV0LmV2ZW50cykpIHsgLy8gZXh0ZW5kZWQgZm9ybVxyXG4gICAgICAgICAgICByYXdQcm9wcyA9IHJhd0lucHV0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgkLmlzQXJyYXkocmF3SW5wdXQpKSB7IC8vIHNob3J0IGZvcm1cclxuICAgICAgICAgICAgcmF3UHJvcHMgPSB7IGV2ZW50czogcmF3SW5wdXQgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJhd1Byb3BzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBFdmVudFNvdXJjZV8xLmRlZmF1bHQucGFyc2UuY2FsbCh0aGlzLCByYXdQcm9wcywgY2FsZW5kYXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUuc2V0UmF3RXZlbnREZWZzID0gZnVuY3Rpb24gKHJhd0V2ZW50RGVmcykge1xyXG4gICAgICAgIHRoaXMucmF3RXZlbnREZWZzID0gcmF3RXZlbnREZWZzO1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzID0gdGhpcy5wYXJzZUV2ZW50RGVmcyhyYXdFdmVudERlZnMpO1xyXG4gICAgfTtcclxuICAgIEFycmF5RXZlbnRTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRpbWV6b25lKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmcyA9IHRoaXMuZXZlbnREZWZzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRUaW1lem9uZSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWV6b25lICE9PSB0aW1lem9uZSkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnREZWZzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnREZWZzW2ldIGluc3RhbmNlb2YgU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZlbnREZWZzW2ldLnJlem9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWV6b25lID0gdGltZXpvbmU7XHJcbiAgICAgICAgcmV0dXJuIFByb21pc2VfMS5kZWZhdWx0LnJlc29sdmUoZXZlbnREZWZzKTtcclxuICAgIH07XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5hZGRFdmVudERlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzLnB1c2goZXZlbnREZWYpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBldmVudERlZklkIGFscmVhZHkgbm9ybWFsaXplZCB0byBhIHN0cmluZ1xyXG4gICAgKi9cclxuICAgIEFycmF5RXZlbnRTb3VyY2UucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHJldHVybiB1dGlsXzEucmVtb3ZlTWF0Y2hpbmcodGhpcy5ldmVudERlZnMsIGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnREZWYuaWQgPT09IGV2ZW50RGVmSWQ7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnREZWZzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzID0gW107XHJcbiAgICB9O1xyXG4gICAgQXJyYXlFdmVudFNvdXJjZS5wcm90b3R5cGUuZ2V0UHJpbWl0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJhd0V2ZW50RGVmcztcclxuICAgIH07XHJcbiAgICBBcnJheUV2ZW50U291cmNlLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMgPSBmdW5jdGlvbiAocmF3UHJvcHMpIHtcclxuICAgICAgICB2YXIgc3VwZXJTdWNjZXNzID0gX3N1cGVyLnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHMuY2FsbCh0aGlzLCByYXdQcm9wcyk7XHJcbiAgICAgICAgdGhpcy5zZXRSYXdFdmVudERlZnMocmF3UHJvcHMuZXZlbnRzKTtcclxuICAgICAgICByZXR1cm4gc3VwZXJTdWNjZXNzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBBcnJheUV2ZW50U291cmNlO1xyXG59KEV2ZW50U291cmNlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBBcnJheUV2ZW50U291cmNlO1xyXG5BcnJheUV2ZW50U291cmNlLmRlZmluZVN0YW5kYXJkUHJvcHMoe1xyXG4gICAgZXZlbnRzOiBmYWxzZSAvLyBkb24ndCBhdXRvbWF0aWNhbGx5IHRyYW5zZmVyXHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiA1NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTdGFuZGFyZFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyMSk7XHJcbnZhciBKcXVlcnlVaVRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyMik7XHJcbnZhciB0aGVtZUNsYXNzSGFzaCA9IHt9O1xyXG5mdW5jdGlvbiBkZWZpbmVUaGVtZVN5c3RlbSh0aGVtZU5hbWUsIHRoZW1lQ2xhc3MpIHtcclxuICAgIHRoZW1lQ2xhc3NIYXNoW3RoZW1lTmFtZV0gPSB0aGVtZUNsYXNzO1xyXG59XHJcbmV4cG9ydHMuZGVmaW5lVGhlbWVTeXN0ZW0gPSBkZWZpbmVUaGVtZVN5c3RlbTtcclxuZnVuY3Rpb24gZ2V0VGhlbWVTeXN0ZW1DbGFzcyh0aGVtZVNldHRpbmcpIHtcclxuICAgIGlmICghdGhlbWVTZXR0aW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIFN0YW5kYXJkVGhlbWVfMS5kZWZhdWx0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodGhlbWVTZXR0aW5nID09PSB0cnVlKSB7XHJcbiAgICAgICAgcmV0dXJuIEpxdWVyeVVpVGhlbWVfMS5kZWZhdWx0O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIHRoZW1lQ2xhc3NIYXNoW3RoZW1lU2V0dGluZ107XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5nZXRUaGVtZVN5c3RlbUNsYXNzID0gZ2V0VGhlbWVTeXN0ZW1DbGFzcztcclxuXG5cbi8qKiovIH0pLFxuLyogNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG4vKlxyXG5BIGNhY2hlIGZvciB0aGUgbGVmdC9yaWdodC90b3AvYm90dG9tL3dpZHRoL2hlaWdodCB2YWx1ZXMgZm9yIG9uZSBvciBtb3JlIGVsZW1lbnRzLlxyXG5Xb3JrcyB3aXRoIGJvdGggb2Zmc2V0IChmcm9tIHRvcGxlZnQgZG9jdW1lbnQpIGFuZCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQpLlxyXG5cbm9wdGlvbnM6XHJcbi0gZWxzXHJcbi0gaXNIb3Jpem9udGFsXHJcbi0gaXNWZXJ0aWNhbFxyXG4qL1xyXG52YXIgQ29vcmRDYWNoZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvb3JkQ2FjaGUob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuaXNIb3Jpem9udGFsID0gZmFsc2U7IC8vIHdoZXRoZXIgdG8gcXVlcnkgZm9yIGxlZnQvcmlnaHQvd2lkdGhcclxuICAgICAgICB0aGlzLmlzVmVydGljYWwgPSBmYWxzZTsgLy8gd2hldGhlciB0byBxdWVyeSBmb3IgdG9wL2JvdHRvbS9oZWlnaHRcclxuICAgICAgICB0aGlzLmVscyA9ICQob3B0aW9ucy5lbHMpO1xyXG4gICAgICAgIHRoaXMuaXNIb3Jpem9udGFsID0gb3B0aW9ucy5pc0hvcml6b250YWw7XHJcbiAgICAgICAgdGhpcy5pc1ZlcnRpY2FsID0gb3B0aW9ucy5pc1ZlcnRpY2FsO1xyXG4gICAgICAgIHRoaXMuZm9yY2VkT2Zmc2V0UGFyZW50RWwgPSBvcHRpb25zLm9mZnNldFBhcmVudCA/ICQob3B0aW9ucy5vZmZzZXRQYXJlbnQpIDogbnVsbDtcclxuICAgIH1cclxuICAgIC8vIFF1ZXJpZXMgdGhlIGVscyBmb3IgY29vcmRpbmF0ZXMgYW5kIHN0b3JlcyB0aGVtLlxyXG4gICAgLy8gQ2FsbCB0aGlzIG1ldGhvZCBiZWZvcmUgdXNpbmcgYW5kIG9mIHRoZSBnZXQqIG1ldGhvZHMgYmVsb3cuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50RWwgPSB0aGlzLmZvcmNlZE9mZnNldFBhcmVudEVsO1xyXG4gICAgICAgIGlmICghb2Zmc2V0UGFyZW50RWwgJiYgdGhpcy5lbHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBvZmZzZXRQYXJlbnRFbCA9IHRoaXMuZWxzLmVxKDApLm9mZnNldFBhcmVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9yaWdpbiA9IG9mZnNldFBhcmVudEVsID9cclxuICAgICAgICAgICAgb2Zmc2V0UGFyZW50RWwub2Zmc2V0KCkgOlxyXG4gICAgICAgICAgICBudWxsO1xyXG4gICAgICAgIHRoaXMuYm91bmRpbmdSZWN0ID0gdGhpcy5xdWVyeUJvdW5kaW5nUmVjdCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxIb3Jpem9udGFscygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc1ZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRFbFZlcnRpY2FscygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBEZXN0cm95cyBhbGwgaW50ZXJuYWwgZGF0YSBhYm91dCBjb29yZGluYXRlcywgZnJlZWluZyBtZW1vcnlcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMub3JpZ2luID0gbnVsbDtcclxuICAgICAgICB0aGlzLmJvdW5kaW5nUmVjdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sZWZ0cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5yaWdodHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudG9wcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ib3R0b21zID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBXaGVuIGNhbGxlZCwgaWYgY29vcmQgY2FjaGVzIGFyZW4ndCBidWlsdCwgYnVpbGRzIHRoZW1cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmVuc3VyZUJ1aWx0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5vcmlnaW4pIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBQb3B1bGF0ZXMgdGhlIGxlZnQvcmlnaHQgaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmJ1aWxkRWxIb3Jpem9udGFscyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbGVmdHMgPSBbXTtcclxuICAgICAgICB2YXIgcmlnaHRzID0gW107XHJcbiAgICAgICAgdGhpcy5lbHMuZWFjaChmdW5jdGlvbiAoaSwgbm9kZSkge1xyXG4gICAgICAgICAgICB2YXIgZWwgPSAkKG5vZGUpO1xyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IGVsLm9mZnNldCgpLmxlZnQ7XHJcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGVsLm91dGVyV2lkdGgoKTtcclxuICAgICAgICAgICAgbGVmdHMucHVzaChsZWZ0KTtcclxuICAgICAgICAgICAgcmlnaHRzLnB1c2gobGVmdCArIHdpZHRoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmxlZnRzID0gbGVmdHM7XHJcbiAgICAgICAgdGhpcy5yaWdodHMgPSByaWdodHM7XHJcbiAgICB9O1xyXG4gICAgLy8gUG9wdWxhdGVzIHRoZSB0b3AvYm90dG9tIGludGVybmFsIGNvb3JkaW5hdGUgYXJyYXlzXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5idWlsZEVsVmVydGljYWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0b3BzID0gW107XHJcbiAgICAgICAgdmFyIGJvdHRvbXMgPSBbXTtcclxuICAgICAgICB0aGlzLmVscy5lYWNoKGZ1bmN0aW9uIChpLCBub2RlKSB7XHJcbiAgICAgICAgICAgIHZhciBlbCA9ICQobm9kZSk7XHJcbiAgICAgICAgICAgIHZhciB0b3AgPSBlbC5vZmZzZXQoKS50b3A7XHJcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBlbC5vdXRlckhlaWdodCgpO1xyXG4gICAgICAgICAgICB0b3BzLnB1c2godG9wKTtcclxuICAgICAgICAgICAgYm90dG9tcy5wdXNoKHRvcCArIGhlaWdodCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy50b3BzID0gdG9wcztcclxuICAgICAgICB0aGlzLmJvdHRvbXMgPSBib3R0b21zO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgbGVmdCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgbGVmdCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IGhvcml6b250YWxseSBpbnRlcnNlY3RzLlxyXG4gICAgLy8gSWYgbm8gaW50ZXJzZWN0aW9uIGlzIG1hZGUsIHJldHVybnMgdW5kZWZpbmVkLlxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0SG9yaXpvbnRhbEluZGV4ID0gZnVuY3Rpb24gKGxlZnRPZmZzZXQpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgdmFyIGxlZnRzID0gdGhpcy5sZWZ0cztcclxuICAgICAgICB2YXIgcmlnaHRzID0gdGhpcy5yaWdodHM7XHJcbiAgICAgICAgdmFyIGxlbiA9IGxlZnRzLmxlbmd0aDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGxlZnRPZmZzZXQgPj0gbGVmdHNbaV0gJiYgbGVmdE9mZnNldCA8IHJpZ2h0c1tpXSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSB0b3Agb2Zmc2V0IChmcm9tIGRvY3VtZW50IHRvcCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IHZlcnRpY2FsbHkgaW50ZXJzZWN0cy5cclxuICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldFZlcnRpY2FsSW5kZXggPSBmdW5jdGlvbiAodG9wT2Zmc2V0KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHZhciB0b3BzID0gdGhpcy50b3BzO1xyXG4gICAgICAgIHZhciBib3R0b21zID0gdGhpcy5ib3R0b21zO1xyXG4gICAgICAgIHZhciBsZW4gPSB0b3BzLmxlbmd0aDtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRvcE9mZnNldCA+PSB0b3BzW2ldICYmIHRvcE9mZnNldCA8IGJvdHRvbXNbaV0pIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIGxlZnQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleFxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0TGVmdE9mZnNldCA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdHNbbGVmdEluZGV4XTtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSBsZWZ0IHBvc2l0aW9uIChmcm9tIG9mZnNldFBhcmVudCBsZWZ0KSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldExlZnRQb3NpdGlvbiA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGVmdHNbbGVmdEluZGV4XSAtIHRoaXMub3JpZ2luLmxlZnQ7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgcmlnaHQgb2Zmc2V0IChmcm9tIGRvY3VtZW50IGxlZnQpIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBpbmRleC5cclxuICAgIC8vIFRoaXMgdmFsdWUgaXMgTk9UIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudCdzIHJpZ2h0IGVkZ2UsIGxpa2UgdGhlIENTUyBjb25jZXB0IG9mIFwicmlnaHRcIiB3b3VsZCBiZS5cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldFJpZ2h0T2Zmc2V0ID0gZnVuY3Rpb24gKGxlZnRJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XTtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSByaWdodCBwb3NpdGlvbiAoZnJvbSBvZmZzZXRQYXJlbnQgbGVmdCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4LlxyXG4gICAgLy8gVGhpcyB2YWx1ZSBpcyBOT1QgcmVsYXRpdmUgdG8gdGhlIG9mZnNldFBhcmVudCdzIHJpZ2h0IGVkZ2UsIGxpa2UgdGhlIENTUyBjb25jZXB0IG9mIFwicmlnaHRcIiB3b3VsZCBiZS5cclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldFJpZ2h0UG9zaXRpb24gPSBmdW5jdGlvbiAobGVmdEluZGV4KSB7XHJcbiAgICAgICAgdGhpcy5lbnN1cmVCdWlsdCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0c1tsZWZ0SW5kZXhdIC0gdGhpcy5vcmlnaW4ubGVmdDtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmdldFdpZHRoID0gZnVuY3Rpb24gKGxlZnRJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodHNbbGVmdEluZGV4XSAtIHRoaXMubGVmdHNbbGVmdEluZGV4XTtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSB0b3Agb2Zmc2V0IChmcm9tIGRvY3VtZW50IHRvcCkgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRUb3BPZmZzZXQgPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wc1t0b3BJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgdG9wIHBvc2l0aW9uIChmcm9tIG9mZnNldFBhcmVudCB0b3ApIG9mIHRoZSBlbGVtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvblxyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuZ2V0VG9wUG9zaXRpb24gPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9wc1t0b3BJbmRleF0gLSB0aGlzLm9yaWdpbi50b3A7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgYm90dG9tIG9mZnNldCAoZnJvbSB0aGUgZG9jdW1lbnQgdG9wKSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICAvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgb2Zmc2V0UGFyZW50J3MgYm90dG9tIGVkZ2UsIGxpa2UgdGhlIENTUyBjb25jZXB0IG9mIFwiYm90dG9tXCIgd291bGQgYmUuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRCb3R0b21PZmZzZXQgPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF07XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyB0aGUgYm90dG9tIHBvc2l0aW9uIChmcm9tIHRoZSBvZmZzZXRQYXJlbnQgdG9wKSBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICAvLyBUaGlzIHZhbHVlIGlzIE5PVCByZWxhdGl2ZSB0byB0aGUgb2Zmc2V0UGFyZW50J3MgYm90dG9tIGVkZ2UsIGxpa2UgdGhlIENTUyBjb25jZXB0IG9mIFwiYm90dG9tXCIgd291bGQgYmUuXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRCb3R0b21Qb3NpdGlvbiA9IGZ1bmN0aW9uICh0b3BJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZW5zdXJlQnVpbHQoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3R0b21zW3RvcEluZGV4XSAtIHRoaXMub3JpZ2luLnRvcDtcclxuICAgIH07XHJcbiAgICAvLyBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiAodG9wSW5kZXgpIHtcclxuICAgICAgICB0aGlzLmVuc3VyZUJ1aWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tc1t0b3BJbmRleF0gLSB0aGlzLnRvcHNbdG9wSW5kZXhdO1xyXG4gICAgfTtcclxuICAgIC8vIEJvdW5kaW5nIFJlY3RcclxuICAgIC8vIFRPRE86IGRlY291cGxlIHRoaXMgZnJvbSBDb29yZENhY2hlXHJcbiAgICAvLyBDb21wdXRlIGFuZCByZXR1cm4gd2hhdCB0aGUgZWxlbWVudHMnIGJvdW5kaW5nIHJlY3RhbmdsZSBpcywgZnJvbSB0aGUgdXNlcidzIHBlcnNwZWN0aXZlLlxyXG4gICAgLy8gUmlnaHQgbm93LCBvbmx5IHJldHVybnMgYSByZWN0YW5nbGUgaWYgY29uc3RyYWluZWQgYnkgYW4gb3ZlcmZsb3c6c2Nyb2xsIGVsZW1lbnQuXHJcbiAgICAvLyBSZXR1cm5zIG51bGwgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzXHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5xdWVyeUJvdW5kaW5nUmVjdCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2Nyb2xsUGFyZW50RWw7XHJcbiAgICAgICAgaWYgKHRoaXMuZWxzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgc2Nyb2xsUGFyZW50RWwgPSB1dGlsXzEuZ2V0U2Nyb2xsUGFyZW50KHRoaXMuZWxzLmVxKDApKTtcclxuICAgICAgICAgICAgaWYgKCFzY3JvbGxQYXJlbnRFbC5pcyhkb2N1bWVudCkgJiZcclxuICAgICAgICAgICAgICAgICFzY3JvbGxQYXJlbnRFbC5pcygnaHRtbCxib2R5JykgLy8gZG9uJ3QgY29uc2lkZXIgdGhlc2UgYm91bmRpbmcgcmVjdHMuIHNvbHZlcyBpc3N1ZSAzNjE1XHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfMS5nZXRDbGllbnRSZWN0KHNjcm9sbFBhcmVudEVsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH07XHJcbiAgICBDb29yZENhY2hlLnByb3RvdHlwZS5pc1BvaW50SW5Cb3VuZHMgPSBmdW5jdGlvbiAobGVmdE9mZnNldCwgdG9wT2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNMZWZ0SW5Cb3VuZHMobGVmdE9mZnNldCkgJiYgdGhpcy5pc1RvcEluQm91bmRzKHRvcE9mZnNldCk7XHJcbiAgICB9O1xyXG4gICAgQ29vcmRDYWNoZS5wcm90b3R5cGUuaXNMZWZ0SW5Cb3VuZHMgPSBmdW5jdGlvbiAobGVmdE9mZnNldCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5ib3VuZGluZ1JlY3QgfHwgKGxlZnRPZmZzZXQgPj0gdGhpcy5ib3VuZGluZ1JlY3QubGVmdCAmJiBsZWZ0T2Zmc2V0IDwgdGhpcy5ib3VuZGluZ1JlY3QucmlnaHQpO1xyXG4gICAgfTtcclxuICAgIENvb3JkQ2FjaGUucHJvdG90eXBlLmlzVG9wSW5Cb3VuZHMgPSBmdW5jdGlvbiAodG9wT2Zmc2V0KSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmJvdW5kaW5nUmVjdCB8fCAodG9wT2Zmc2V0ID49IHRoaXMuYm91bmRpbmdSZWN0LnRvcCAmJiB0b3BPZmZzZXQgPCB0aGlzLmJvdW5kaW5nUmVjdC5ib3R0b20pO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb29yZENhY2hlO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb29yZENhY2hlO1xyXG5cblxuLyoqKi8gfSksXG4vKiA1OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgR2xvYmFsRW1pdHRlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XHJcbi8qIFRyYWNrcyBhIGRyYWcncyBtb3VzZSBtb3ZlbWVudCwgZmlyaW5nIHZhcmlvdXMgaGFuZGxlcnNcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIFRPRE86IHVzZSBFbWl0dGVyXHJcbnZhciBEcmFnTGlzdGVuZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEcmFnTGlzdGVuZXIob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuaXNJbnRlcmFjdGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc1RvdWNoID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0dlbmVyaWMgPSBmYWxzZTsgLy8gaW5pdGlhdGVkIGJ5ICdkcmFnc3RhcnQnIChqcXVpKVxyXG4gICAgICAgIHRoaXMuc2hvdWxkQ2FuY2VsVG91Y2hTY3JvbGwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsQWx3YXlzS2lsbHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzQXV0b1Njcm9sbCA9IGZhbHNlO1xyXG4gICAgICAgIC8vIGRlZmF1bHRzXHJcbiAgICAgICAgdGhpcy5zY3JvbGxTZW5zaXRpdml0eSA9IDMwOyAvLyBwaXhlbHMgZnJvbSBlZGdlIGZvciBzY3JvbGxpbmcgdG8gc3RhcnRcclxuICAgICAgICB0aGlzLnNjcm9sbFNwZWVkID0gMjAwOyAvLyBwaXhlbHMgcGVyIHNlY29uZCwgYXQgbWF4aW11bSBzcGVlZFxyXG4gICAgICAgIHRoaXMuc2Nyb2xsSW50ZXJ2YWxNcyA9IDUwOyAvLyBtaWxsaXNlY29uZCB3YWl0IGJldHdlZW4gc2Nyb2xsIGluY3JlbWVudFxyXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICB9XHJcbiAgICAvLyBJbnRlcmFjdGlvbiAoaGlnaC1sZXZlbClcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnN0YXJ0SW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAoZXYsIGV4dHJhT3B0aW9ucykge1xyXG4gICAgICAgIGlmIChleHRyYU9wdGlvbnMgPT09IHZvaWQgMCkgeyBleHRyYU9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIGlmIChldi50eXBlID09PSAnbW91c2Vkb3duJykge1xyXG4gICAgICAgICAgICBpZiAoR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCkuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCF1dGlsXzEuaXNQcmltYXJ5TW91c2VCdXR0b24oZXYpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpOyAvLyBwcmV2ZW50cyBuYXRpdmUgc2VsZWN0aW9uIGluIG1vc3QgYnJvd3NlcnNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuaXNJbnRlcmFjdGluZykge1xyXG4gICAgICAgICAgICAvLyBwcm9jZXNzIG9wdGlvbnNcclxuICAgICAgICAgICAgdGhpcy5kZWxheSA9IHV0aWxfMS5maXJzdERlZmluZWQoZXh0cmFPcHRpb25zLmRlbGF5LCB0aGlzLm9wdGlvbnMuZGVsYXksIDApO1xyXG4gICAgICAgICAgICB0aGlzLm1pbkRpc3RhbmNlID0gdXRpbF8xLmZpcnN0RGVmaW5lZChleHRyYU9wdGlvbnMuZGlzdGFuY2UsIHRoaXMub3B0aW9ucy5kaXN0YW5jZSwgMCk7XHJcbiAgICAgICAgICAgIHRoaXMuc3ViamVjdEVsID0gdGhpcy5vcHRpb25zLnN1YmplY3RFbDtcclxuICAgICAgICAgICAgdXRpbF8xLnByZXZlbnRTZWxlY3Rpb24oJCgnYm9keScpKTtcclxuICAgICAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5pc1RvdWNoID0gdXRpbF8xLmdldEV2SXNUb3VjaChldik7XHJcbiAgICAgICAgICAgIHRoaXMuaXNHZW5lcmljID0gZXYudHlwZSA9PT0gJ2RyYWdzdGFydCc7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEZWxheUVuZGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdpblggPSB1dGlsXzEuZ2V0RXZYKGV2KTtcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW5ZID0gdXRpbF8xLmdldEV2WShldik7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWwgPSB1dGlsXzEuZ2V0U2Nyb2xsUGFyZW50KCQoZXYudGFyZ2V0KSk7XHJcbiAgICAgICAgICAgIHRoaXMuYmluZEhhbmRsZXJzKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdEF1dG9TY3JvbGwoKTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVJbnRlcmFjdGlvblN0YXJ0KGV2KTtcclxuICAgICAgICAgICAgdGhpcy5zdGFydERlbGF5KGV2KTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLm1pbkRpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkKGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZUludGVyYWN0aW9uU3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ2ludGVyYWN0aW9uU3RhcnQnLCBldik7XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5lbmRJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChldiwgaXNDYW5jZWxsZWQpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0ludGVyYWN0aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kRHJhZyhldik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGF5VGltZW91dElkKSB7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWxheVRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5VGltZW91dElkID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lBdXRvU2Nyb2xsKCk7XHJcbiAgICAgICAgICAgIHRoaXMudW5iaW5kSGFuZGxlcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5pc0ludGVyYWN0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW50ZXJhY3Rpb25FbmQoZXYsIGlzQ2FuY2VsbGVkKTtcclxuICAgICAgICAgICAgdXRpbF8xLmFsbG93U2VsZWN0aW9uKCQoJ2JvZHknKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlSW50ZXJhY3Rpb25FbmQgPSBmdW5jdGlvbiAoZXYsIGlzQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdpbnRlcmFjdGlvbkVuZCcsIGV2LCBpc0NhbmNlbGxlZCB8fCBmYWxzZSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQmluZGluZyBUbyBET01cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmJpbmRIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzb21lIGJyb3dzZXJzIChTYWZhcmkgaW4gaU9TIDEwKSBkb24ndCBhbGxvdyBwcmV2ZW50RGVmYXVsdCBvbiB0b3VjaCBldmVudHMgdGhhdCBhcmUgYm91bmQgYWZ0ZXIgdG91Y2hzdGFydCxcclxuICAgICAgICAvLyBzbyBsaXN0ZW4gdG8gdGhlIEdsb2JhbEVtaXR0ZXIgc2luZ2xldG9uLCB3aGljaCBpcyBhbHdheXMgYm91bmQsIGluc3RlYWQgb2YgdGhlIGRvY3VtZW50IGRpcmVjdGx5LlxyXG4gICAgICAgIHZhciBnbG9iYWxFbWl0dGVyID0gR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQuZ2V0KCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNHZW5lcmljKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksIHtcclxuICAgICAgICAgICAgICAgIGRyYWc6IHRoaXMuaGFuZGxlTW92ZSxcclxuICAgICAgICAgICAgICAgIGRyYWdzdG9wOiB0aGlzLmVuZEludGVyYWN0aW9uXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzVG91Y2gpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyhnbG9iYWxFbWl0dGVyLCB7XHJcbiAgICAgICAgICAgICAgICB0b3VjaG1vdmU6IHRoaXMuaGFuZGxlVG91Y2hNb3ZlLFxyXG4gICAgICAgICAgICAgICAgdG91Y2hlbmQ6IHRoaXMuZW5kSW50ZXJhY3Rpb24sXHJcbiAgICAgICAgICAgICAgICBzY3JvbGw6IHRoaXMuaGFuZGxlVG91Y2hTY3JvbGxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmxpc3RlblRvKGdsb2JhbEVtaXR0ZXIsIHtcclxuICAgICAgICAgICAgICAgIG1vdXNlbW92ZTogdGhpcy5oYW5kbGVNb3VzZU1vdmUsXHJcbiAgICAgICAgICAgICAgICBtb3VzZXVwOiB0aGlzLmVuZEludGVyYWN0aW9uXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxpc3RlblRvKGdsb2JhbEVtaXR0ZXIsIHtcclxuICAgICAgICAgICAgc2VsZWN0c3RhcnQ6IHV0aWxfMS5wcmV2ZW50RGVmYXVsdCxcclxuICAgICAgICAgICAgY29udGV4dG1lbnU6IHV0aWxfMS5wcmV2ZW50RGVmYXVsdCAvLyBsb25nIHRhcHMgd291bGQgb3BlbiBtZW51IG9uIENocm9tZSBkZXYgdG9vbHNcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnVuYmluZEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKEdsb2JhbEVtaXR0ZXJfMS5kZWZhdWx0LmdldCgpKTtcclxuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7IC8vIGZvciBpc0dlbmVyaWNcclxuICAgIH07XHJcbiAgICAvLyBEcmFnIChoaWdoLWxldmVsKVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIGV4dHJhT3B0aW9ucyBpZ25vcmVkIGlmIGRyYWcgYWxyZWFkeSBzdGFydGVkXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLnN0YXJ0RHJhZyA9IGZ1bmN0aW9uIChldiwgZXh0cmFPcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5zdGFydEludGVyYWN0aW9uKGV2LCBleHRyYU9wdGlvbnMpOyAvLyBlbnN1cmUgaW50ZXJhY3Rpb24gYmVnYW5cclxuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURyYWdTdGFydChldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkcmFnU3RhcnQnLCBldik7XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIGR4ID0gdXRpbF8xLmdldEV2WChldikgLSB0aGlzLm9yaWdpblg7XHJcbiAgICAgICAgdmFyIGR5ID0gdXRpbF8xLmdldEV2WShldikgLSB0aGlzLm9yaWdpblk7XHJcbiAgICAgICAgdmFyIG1pbkRpc3RhbmNlID0gdGhpcy5taW5EaXN0YW5jZTtcclxuICAgICAgICB2YXIgZGlzdGFuY2VTcTsgLy8gY3VycmVudCBkaXN0YW5jZSBmcm9tIHRoZSBvcmlnaW4sIHNxdWFyZWRcclxuICAgICAgICBpZiAoIXRoaXMuaXNEaXN0YW5jZVN1cnBhc3NlZCkge1xyXG4gICAgICAgICAgICBkaXN0YW5jZVNxID0gZHggKiBkeCArIGR5ICogZHk7XHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZVNxID49IG1pbkRpc3RhbmNlICogbWluRGlzdGFuY2UpIHsgLy8gdXNlIHB5dGhhZ29yZWFuIHRoZW9yZW1cclxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzdGFuY2VTdXJwYXNzZWQoZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnKGR4LCBkeSwgZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hpbGUgdGhlIG1vdXNlIGlzIGJlaW5nIG1vdmVkIGFuZCB3aGVuIHdlIGtub3cgYSBsZWdpdGltYXRlIGRyYWcgaXMgdGFraW5nIHBsYWNlXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURyYWcgPSBmdW5jdGlvbiAoZHgsIGR5LCBldikge1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignZHJhZycsIGR4LCBkeSwgZXYpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlQXV0b1Njcm9sbChldik7IC8vIHdpbGwgcG9zc2libHkgY2F1c2Ugc2Nyb2xsaW5nXHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5lbmREcmFnID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEcmFnRW5kKGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVEcmFnRW5kID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdkcmFnRW5kJywgZXYpO1xyXG4gICAgfTtcclxuICAgIC8vIERlbGF5XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5zdGFydERlbGF5ID0gZnVuY3Rpb24gKGluaXRpYWxFdikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuZGVsYXkpIHtcclxuICAgICAgICAgICAgdGhpcy5kZWxheVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlRGVsYXlFbmQoaW5pdGlhbEV2KTtcclxuICAgICAgICAgICAgfSwgdGhpcy5kZWxheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZURlbGF5RW5kKGluaXRpYWxFdik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlRGVsYXlFbmQgPSBmdW5jdGlvbiAoaW5pdGlhbEV2KSB7XHJcbiAgICAgICAgdGhpcy5pc0RlbGF5RW5kZWQgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRGlzdGFuY2VTdXJwYXNzZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydERyYWcoaW5pdGlhbEV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRGlzdGFuY2VcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURpc3RhbmNlU3VycGFzc2VkID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy5pc0Rpc3RhbmNlU3VycGFzc2VkID0gdHJ1ZTtcclxuICAgICAgICBpZiAodGhpcy5pc0RlbGF5RW5kZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFydERyYWcoZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBNb3VzZSAvIFRvdWNoXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVUb3VjaE1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAvLyBwcmV2ZW50IGluZXJ0aWEgYW5kIHRvdWNobW92ZS1zY3JvbGxpbmcgd2hpbGUgZHJhZ2dpbmdcclxuICAgICAgICBpZiAodGhpcy5pc0RyYWdnaW5nICYmIHRoaXMuc2hvdWxkQ2FuY2VsVG91Y2hTY3JvbGwpIHtcclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKGV2KTtcclxuICAgIH07XHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZU1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlTW92ZShldik7XHJcbiAgICB9O1xyXG4gICAgLy8gU2Nyb2xsaW5nICh1bnJlbGF0ZWQgdG8gYXV0by1zY3JvbGwpXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5oYW5kbGVUb3VjaFNjcm9sbCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIC8vIGlmIHRoZSBkcmFnIGlzIGJlaW5nIGluaXRpYXRlZCBieSB0b3VjaCwgYnV0IGEgc2Nyb2xsIGhhcHBlbnMgYmVmb3JlXHJcbiAgICAgICAgLy8gdGhlIGRyYWctaW5pdGlhdGluZyBkZWxheSBpcyBvdmVyLCBjYW5jZWwgdGhlIGRyYWdcclxuICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZyB8fCB0aGlzLnNjcm9sbEFsd2F5c0tpbGxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kSW50ZXJhY3Rpb24oZXYsIHRydWUpOyAvLyBpc0NhbmNlbGxlZD10cnVlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFV0aWxzXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gVHJpZ2dlcnMgYSBjYWxsYmFjay4gQ2FsbHMgYSBmdW5jdGlvbiBpbiB0aGUgb3B0aW9uIGhhc2ggb2YgdGhlIHNhbWUgbmFtZS5cclxuICAgIC8vIEFyZ3VtZW50cyBiZXlvbmQgdGhlIGZpcnN0IGBuYW1lYCBhcmUgZm9yd2FyZGVkIG9uLlxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtYWtlcyBfbWV0aG9kcyBjYWxsYWJsZSBieSBldmVudCBuYW1lLiBUT0RPOiBraWxsIHRoaXNcclxuICAgICAgICBpZiAodGhpc1snXycgKyBuYW1lXSkge1xyXG4gICAgICAgICAgICB0aGlzWydfJyArIG5hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBBdXRvLXNjcm9sbFxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaW5pdEF1dG9TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNjcm9sbEVsID0gdGhpcy5zY3JvbGxFbDtcclxuICAgICAgICB0aGlzLmlzQXV0b1Njcm9sbCA9XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zY3JvbGwgJiZcclxuICAgICAgICAgICAgICAgIHNjcm9sbEVsICYmXHJcbiAgICAgICAgICAgICAgICAhc2Nyb2xsRWwuaXMod2luZG93KSAmJlxyXG4gICAgICAgICAgICAgICAgIXNjcm9sbEVsLmlzKGRvY3VtZW50KTtcclxuICAgICAgICBpZiAodGhpcy5pc0F1dG9TY3JvbGwpIHtcclxuICAgICAgICAgICAgLy8gZGVib3VuY2UgbWFrZXMgc3VyZSByYXBpZCBjYWxscyBkb24ndCBoYXBwZW5cclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbyhzY3JvbGxFbCwgJ3Njcm9sbCcsIHV0aWxfMS5kZWJvdW5jZSh0aGlzLmhhbmRsZURlYm91bmNlZFNjcm9sbCwgMTAwKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuZGVzdHJveUF1dG9TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbmRBdXRvU2Nyb2xsKCk7IC8vIGtpbGwgYW55IGFuaW1hdGlvbiBsb29wXHJcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBzY3JvbGwgaGFuZGxlciBpZiB0aGVyZSBpcyBhIHNjcm9sbEVsXHJcbiAgICAgICAgaWYgKHRoaXMuaXNBdXRvU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKHRoaXMuc2Nyb2xsRWwsICdzY3JvbGwnKTsgLy8gd2lsbCBwcm9iYWJseSBnZXQgcmVtb3ZlZCBieSB1bmJpbmRIYW5kbGVycyB0b28gOihcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYW5kIHN0b3JlcyB0aGUgYm91bmRpbmcgcmVjdGFuZ2xlIG9mIHNjcm9sbEVsXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmNvbXB1dGVTY3JvbGxCb3VuZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBdXRvU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQm91bmRzID0gdXRpbF8xLmdldE91dGVyUmVjdCh0aGlzLnNjcm9sbEVsKTtcclxuICAgICAgICAgICAgLy8gVE9ETzogdXNlIGdldENsaWVudFJlY3QgaW4gZnV0dXJlLiBidXQgcHJldmVudHMgYXV0byBzY3JvbGxpbmcgd2hlbiBvbiB0b3Agb2Ygc2Nyb2xsYmFyc1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgZHJhZ2dpbmcgaXMgaW4gcHJvZ3Jlc3MgYW5kIHNjcm9sbGluZyBzaG91bGQgYmUgdXBkYXRlZFxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS51cGRhdGVBdXRvU2Nyb2xsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIHNlbnNpdGl2aXR5ID0gdGhpcy5zY3JvbGxTZW5zaXRpdml0eTtcclxuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5zY3JvbGxCb3VuZHM7XHJcbiAgICAgICAgdmFyIHRvcENsb3NlbmVzcztcclxuICAgICAgICB2YXIgYm90dG9tQ2xvc2VuZXNzO1xyXG4gICAgICAgIHZhciBsZWZ0Q2xvc2VuZXNzO1xyXG4gICAgICAgIHZhciByaWdodENsb3NlbmVzcztcclxuICAgICAgICB2YXIgdG9wVmVsID0gMDtcclxuICAgICAgICB2YXIgbGVmdFZlbCA9IDA7XHJcbiAgICAgICAgaWYgKGJvdW5kcykgeyAvLyBvbmx5IHNjcm9sbCBpZiBzY3JvbGxFbCBleGlzdHNcclxuICAgICAgICAgICAgLy8gY29tcHV0ZSBjbG9zZW5lc3MgdG8gZWRnZXMuIHZhbGlkIHJhbmdlIGlzIGZyb20gMC4wIC0gMS4wXHJcbiAgICAgICAgICAgIHRvcENsb3NlbmVzcyA9IChzZW5zaXRpdml0eSAtICh1dGlsXzEuZ2V0RXZZKGV2KSAtIGJvdW5kcy50b3ApKSAvIHNlbnNpdGl2aXR5O1xyXG4gICAgICAgICAgICBib3R0b21DbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAoYm91bmRzLmJvdHRvbSAtIHV0aWxfMS5nZXRFdlkoZXYpKSkgLyBzZW5zaXRpdml0eTtcclxuICAgICAgICAgICAgbGVmdENsb3NlbmVzcyA9IChzZW5zaXRpdml0eSAtICh1dGlsXzEuZ2V0RXZYKGV2KSAtIGJvdW5kcy5sZWZ0KSkgLyBzZW5zaXRpdml0eTtcclxuICAgICAgICAgICAgcmlnaHRDbG9zZW5lc3MgPSAoc2Vuc2l0aXZpdHkgLSAoYm91bmRzLnJpZ2h0IC0gdXRpbF8xLmdldEV2WChldikpKSAvIHNlbnNpdGl2aXR5O1xyXG4gICAgICAgICAgICAvLyB0cmFuc2xhdGUgdmVydGljYWwgY2xvc2VuZXNzIGludG8gdmVsb2NpdHkuXHJcbiAgICAgICAgICAgIC8vIG1vdXNlIG11c3QgYmUgY29tcGxldGVseSBpbiBib3VuZHMgZm9yIHZlbG9jaXR5IHRvIGhhcHBlbi5cclxuICAgICAgICAgICAgaWYgKHRvcENsb3NlbmVzcyA+PSAwICYmIHRvcENsb3NlbmVzcyA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICB0b3BWZWwgPSB0b3BDbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkICogLTE7IC8vIG5lZ2F0aXZlLiBmb3Igc2Nyb2xsaW5nIHVwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYm90dG9tQ2xvc2VuZXNzID49IDAgJiYgYm90dG9tQ2xvc2VuZXNzIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHRvcFZlbCA9IGJvdHRvbUNsb3NlbmVzcyAqIHRoaXMuc2Nyb2xsU3BlZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdHJhbnNsYXRlIGhvcml6b250YWwgY2xvc2VuZXNzIGludG8gdmVsb2NpdHlcclxuICAgICAgICAgICAgaWYgKGxlZnRDbG9zZW5lc3MgPj0gMCAmJiBsZWZ0Q2xvc2VuZXNzIDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRWZWwgPSBsZWZ0Q2xvc2VuZXNzICogdGhpcy5zY3JvbGxTcGVlZCAqIC0xOyAvLyBuZWdhdGl2ZS4gZm9yIHNjcm9sbGluZyBsZWZ0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmlnaHRDbG9zZW5lc3MgPj0gMCAmJiByaWdodENsb3NlbmVzcyA8PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0VmVsID0gcmlnaHRDbG9zZW5lc3MgKiB0aGlzLnNjcm9sbFNwZWVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsVmVsKHRvcFZlbCwgbGVmdFZlbCk7XHJcbiAgICB9O1xyXG4gICAgLy8gU2V0cyB0aGUgc3BlZWQtb2Ytc2Nyb2xsaW5nIGZvciB0aGUgc2Nyb2xsRWxcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuc2V0U2Nyb2xsVmVsID0gZnVuY3Rpb24gKHRvcFZlbCwgbGVmdFZlbCkge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsVG9wVmVsID0gdG9wVmVsO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsTGVmdFZlbCA9IGxlZnRWZWw7XHJcbiAgICAgICAgdGhpcy5jb25zdHJhaW5TY3JvbGxWZWwoKTsgLy8gbWFzc2FnZXMgaW50byByZWFsaXN0aWMgdmFsdWVzXHJcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm9uLXplcm8gdmVsb2NpdHksIGFuZCBhbiBhbmltYXRpb24gbG9vcCBoYXNuJ3QgYWxyZWFkeSBzdGFydGVkLCB0aGVuIFNUQVJUXHJcbiAgICAgICAgaWYgKCh0aGlzLnNjcm9sbFRvcFZlbCB8fCB0aGlzLnNjcm9sbExlZnRWZWwpICYmICF0aGlzLnNjcm9sbEludGVydmFsSWQpIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxJbnRlcnZhbElkID0gc2V0SW50ZXJ2YWwodXRpbF8xLnByb3h5KHRoaXMsICdzY3JvbGxJbnRlcnZhbEZ1bmMnKSwgLy8gc2NvcGUgdG8gYHRoaXNgXHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsSW50ZXJ2YWxNcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEZvcmNlcyBzY3JvbGxUb3BWZWwgYW5kIHNjcm9sbExlZnRWZWwgdG8gYmUgemVybyBpZiBzY3JvbGxpbmcgaGFzIGFscmVhZHkgZ29uZSBhbGwgdGhlIHdheVxyXG4gICAgRHJhZ0xpc3RlbmVyLnByb3RvdHlwZS5jb25zdHJhaW5TY3JvbGxWZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5zY3JvbGxFbDtcclxuICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3BWZWwgPCAwKSB7IC8vIHNjcm9sbGluZyB1cD9cclxuICAgICAgICAgICAgaWYgKGVsLnNjcm9sbFRvcCgpIDw9IDApIHsgLy8gYWxyZWFkeSBzY3JvbGxlZCBhbGwgdGhlIHdheSB1cD9cclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wVmVsID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnNjcm9sbFRvcFZlbCA+IDApIHsgLy8gc2Nyb2xsaW5nIGRvd24/XHJcbiAgICAgICAgICAgIGlmIChlbC5zY3JvbGxUb3AoKSArIGVsWzBdLmNsaWVudEhlaWdodCA+PSBlbFswXS5zY3JvbGxIZWlnaHQpIHsgLy8gYWxyZWFkeSBzY3JvbGxlZCBhbGwgdGhlIHdheSBkb3duP1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb3BWZWwgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNjcm9sbExlZnRWZWwgPCAwKSB7IC8vIHNjcm9sbGluZyBsZWZ0P1xyXG4gICAgICAgICAgICBpZiAoZWwuc2Nyb2xsTGVmdCgpIDw9IDApIHsgLy8gYWxyZWFkeSBzY3JvbGxlZCBhbGwgdGhlIGxlZnQ/XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbExlZnRWZWwgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc2Nyb2xsTGVmdFZlbCA+IDApIHsgLy8gc2Nyb2xsaW5nIHJpZ2h0P1xyXG4gICAgICAgICAgICBpZiAoZWwuc2Nyb2xsTGVmdCgpICsgZWxbMF0uY2xpZW50V2lkdGggPj0gZWxbMF0uc2Nyb2xsV2lkdGgpIHsgLy8gYWxyZWFkeSBzY3JvbGxlZCBhbGwgdGhlIHdheSByaWdodD9cclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsTGVmdFZlbCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBnZXRzIGNhbGxlZCBkdXJpbmcgZXZlcnkgaXRlcmF0aW9uIG9mIHRoZSBzY3JvbGxpbmcgYW5pbWF0aW9uIGxvb3BcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuc2Nyb2xsSW50ZXJ2YWxGdW5jID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuc2Nyb2xsRWw7XHJcbiAgICAgICAgdmFyIGZyYWMgPSB0aGlzLnNjcm9sbEludGVydmFsTXMgLyAxMDAwOyAvLyBjb25zaWRlcmluZyBhbmltYXRpb24gZnJlcXVlbmN5LCB3aGF0IHRoZSB2ZWwgc2hvdWxkIGJlIG11bHQnZCBieVxyXG4gICAgICAgIC8vIGNoYW5nZSB0aGUgdmFsdWUgb2Ygc2Nyb2xsRWwncyBzY3JvbGxcclxuICAgICAgICBpZiAodGhpcy5zY3JvbGxUb3BWZWwpIHtcclxuICAgICAgICAgICAgZWwuc2Nyb2xsVG9wKGVsLnNjcm9sbFRvcCgpICsgdGhpcy5zY3JvbGxUb3BWZWwgKiBmcmFjKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsTGVmdFZlbCkge1xyXG4gICAgICAgICAgICBlbC5zY3JvbGxMZWZ0KGVsLnNjcm9sbExlZnQoKSArIHRoaXMuc2Nyb2xsTGVmdFZlbCAqIGZyYWMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnN0cmFpblNjcm9sbFZlbCgpOyAvLyBzaW5jZSB0aGUgc2Nyb2xsIHZhbHVlcyBjaGFuZ2VkLCByZWNvbXB1dGUgdGhlIHZlbG9jaXRpZXNcclxuICAgICAgICAvLyBpZiBzY3JvbGxlZCBhbGwgdGhlIHdheSwgd2hpY2ggY2F1c2VzIHRoZSB2ZWxzIHRvIGJlIHplcm8sIHN0b3AgdGhlIGFuaW1hdGlvbiBsb29wXHJcbiAgICAgICAgaWYgKCF0aGlzLnNjcm9sbFRvcFZlbCAmJiAhdGhpcy5zY3JvbGxMZWZ0VmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5kQXV0b1Njcm9sbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBLaWxscyBhbnkgZXhpc3Rpbmcgc2Nyb2xsaW5nIGFuaW1hdGlvbiBsb29wXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmVuZEF1dG9TY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCkge1xyXG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsSW50ZXJ2YWxJZCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsRW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdldCBjYWxsZWQgd2hlbiB0aGUgc2Nyb2xsRWwgaXMgc2Nyb2xsZWQgKE5PVEU6IHRoaXMgaXMgZGVsYXllZCB2aWEgZGVib3VuY2UpXHJcbiAgICBEcmFnTGlzdGVuZXIucHJvdG90eXBlLmhhbmRsZURlYm91bmNlZFNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyByZWNvbXB1dGUgYWxsIGNvb3JkaW5hdGVzLCBidXQgKm9ubHkqIGlmIHRoaXMgaXMgKm5vdCogcGFydCBvZiBvdXIgc2Nyb2xsaW5nIGFuaW1hdGlvblxyXG4gICAgICAgIGlmICghdGhpcy5zY3JvbGxJbnRlcnZhbElkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsRW5kKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERyYWdMaXN0ZW5lci5wcm90b3R5cGUuaGFuZGxlU2Nyb2xsRW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIENhbGxlZCB3aGVuIHNjcm9sbGluZyBoYXMgc3RvcHBlZCwgd2hldGhlciB0aHJvdWdoIGF1dG8gc2Nyb2xsLCBvciB0aGUgdXNlciBzY3JvbGxpbmdcclxuICAgIH07XHJcbiAgICByZXR1cm4gRHJhZ0xpc3RlbmVyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEcmFnTGlzdGVuZXI7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRHJhZ0xpc3RlbmVyKTtcclxuXG5cbi8qKiovIH0pLFxuLyogNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG4vKlxyXG5BIHNldCBvZiByZW5kZXJpbmcgYW5kIGRhdGUtcmVsYXRlZCBtZXRob2RzIGZvciBhIHZpc3VhbCBjb21wb25lbnQgY29tcHJpc2VkIG9mIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNvbHVtbnMuXHJcblByZXJlcXVpc2l0ZTogdGhlIG9iamVjdCBiZWluZyBtaXhlZCBpbnRvIG5lZWRzIHRvIGJlIGEgKkdyaWQqXHJcbiovXHJcbnZhciBEYXlUYWJsZU1peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF5VGFibGVNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERheVRhYmxlTWl4aW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gUG9wdWxhdGVzIGludGVybmFsIHZhcmlhYmxlcyB1c2VkIGZvciBkYXRlIGNhbGN1bGF0aW9uIGFuZCByZW5kZXJpbmdcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnVwZGF0ZURheVRhYmxlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0ID0gdGhpcztcclxuICAgICAgICB2YXIgdmlldyA9IHQudmlldztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBkYXRlID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudCh0LmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zLCB0cnVlKTtcclxuICAgICAgICB2YXIgZW5kID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudCh0LmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5lbmRNcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIGRheUluZGV4ID0gLTE7XHJcbiAgICAgICAgdmFyIGRheUluZGljZXMgPSBbXTtcclxuICAgICAgICB2YXIgZGF5RGF0ZXMgPSBbXTtcclxuICAgICAgICB2YXIgZGF5c1BlclJvdztcclxuICAgICAgICB2YXIgZmlyc3REYXk7XHJcbiAgICAgICAgdmFyIHJvd0NudDtcclxuICAgICAgICB3aGlsZSAoZGF0ZS5pc0JlZm9yZShlbmQpKSB7IC8vIGxvb3AgZWFjaCBkYXkgZnJvbSBzdGFydCB0byBlbmRcclxuICAgICAgICAgICAgaWYgKHZpZXcuaXNIaWRkZW5EYXkoZGF0ZSkpIHtcclxuICAgICAgICAgICAgICAgIGRheUluZGljZXMucHVzaChkYXlJbmRleCArIDAuNSk7IC8vIG1hcmsgdGhhdCBpdCdzIGJldHdlZW4gaW5kaWNlc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZGF5SW5kZXgrKztcclxuICAgICAgICAgICAgICAgIGRheUluZGljZXMucHVzaChkYXlJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBkYXlEYXRlcy5wdXNoKGRhdGUuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGF0ZS5hZGQoMSwgJ2RheXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuYnJlYWtPbldlZWtzKSB7XHJcbiAgICAgICAgICAgIC8vIGNvdW50IGNvbHVtbnMgdW50aWwgdGhlIGRheS1vZi13ZWVrIHJlcGVhdHNcclxuICAgICAgICAgICAgZmlyc3REYXkgPSBkYXlEYXRlc1swXS5kYXkoKTtcclxuICAgICAgICAgICAgZm9yIChkYXlzUGVyUm93ID0gMTsgZGF5c1BlclJvdyA8IGRheURhdGVzLmxlbmd0aDsgZGF5c1BlclJvdysrKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF5RGF0ZXNbZGF5c1BlclJvd10uZGF5KCkgPT09IGZpcnN0RGF5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcm93Q250ID0gTWF0aC5jZWlsKGRheURhdGVzLmxlbmd0aCAvIGRheXNQZXJSb3cpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcm93Q250ID0gMTtcclxuICAgICAgICAgICAgZGF5c1BlclJvdyA9IGRheURhdGVzLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXlEYXRlcyA9IGRheURhdGVzO1xyXG4gICAgICAgIHRoaXMuZGF5SW5kaWNlcyA9IGRheUluZGljZXM7XHJcbiAgICAgICAgdGhpcy5kYXlzUGVyUm93ID0gZGF5c1BlclJvdztcclxuICAgICAgICB0aGlzLnJvd0NudCA9IHJvd0NudDtcclxuICAgICAgICB0aGlzLnVwZGF0ZURheVRhYmxlQ29scygpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIGFuZCBhc3NpZ25lZCB0aGUgY29sQ250IHByb3BlcnR5IGFuZCB1cGRhdGVzIGFueSBvcHRpb25zIHRoYXQgbWF5IGJlIGNvbXB1dGVkIGZyb20gaXRcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnVwZGF0ZURheVRhYmxlQ29scyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbENudCA9IHRoaXMuY29tcHV0ZUNvbENudCgpO1xyXG4gICAgICAgIHRoaXMuY29sSGVhZEZvcm1hdCA9XHJcbiAgICAgICAgICAgIHRoaXMub3B0KCdjb2x1bW5IZWFkZXJGb3JtYXQnKSB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5vcHQoJ2NvbHVtbkZvcm1hdCcpIHx8IC8vIGRlcHJlY2F0ZWRcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZUNvbEhlYWRGb3JtYXQoKTtcclxuICAgIH07XHJcbiAgICAvLyBEZXRlcm1pbmVzIGhvdyBtYW55IGNvbHVtbnMgdGhlcmUgc2hvdWxkIGJlIGluIHRoZSB0YWJsZVxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuY29tcHV0ZUNvbENudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXlzUGVyUm93O1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSBhbWJpZ3VvdXNseS10aW1lZCBtb21lbnQgZm9yIHRoZSBnaXZlbiBjZWxsXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5nZXRDZWxsRGF0ZSA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRheURhdGVzW3RoaXMuZ2V0Q2VsbERheUluZGV4KHJvdywgY29sKV0uY2xvbmUoKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgYW1iaWd1b3VzbHktdGltZWQgZGF0ZSByYW5nZSBmb3IgdGhlIGdpdmVuIGNlbGxcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmdldENlbGxSYW5nZSA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xyXG4gICAgICAgIHZhciBzdGFydCA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpO1xyXG4gICAgICAgIHZhciBlbmQgPSBzdGFydC5jbG9uZSgpLmFkZCgxLCAnZGF5cycpO1xyXG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZGF5IGNlbGxzLCBjaHJvbm9sb2dpY2FsbHksIGZyb20gdGhlIGZpcnN0IG9mIHRoZSBncmlkICgwLWJhc2VkKVxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUuZ2V0Q2VsbERheUluZGV4ID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XHJcbiAgICAgICAgcmV0dXJuIHJvdyAqIHRoaXMuZGF5c1BlclJvdyArIHRoaXMuZ2V0Q29sRGF5SW5kZXgoY29sKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBudW1uZXIgb2YgZGF5IGNlbGxzLCBjaHJvbm9sb2dpY2FsbHksIGZyb20gdGhlIGZpcnN0IGNlbGwgaW4gKmFueSBnaXZlbiByb3cqXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5nZXRDb2xEYXlJbmRleCA9IGZ1bmN0aW9uIChjb2wpIHtcclxuICAgICAgICBpZiAodGhpcy5pc1JUTCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xDbnQgLSAxIC0gY29sO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxyXG4gICAgLy8gSWYgdGhlIGRhdGUgbGllcyBiZXR3ZWVuIGNlbGxzIChiZWNhdXNlIG9mIGhpZGRlbkRheXMpLCByZXR1cm5zIGEgZmxvYXRpbmctcG9pbnQgdmFsdWUgYmV0d2VlbiBvZmZzZXRzLlxyXG4gICAgLy8gSWYgYmVmb3JlIHRoZSBmaXJzdCBvZmZzZXQsIHJldHVybnMgYSBuZWdhdGl2ZSBudW1iZXIuXHJcbiAgICAvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXHJcbiAgICAvLyBPbmx5IHdvcmtzIGZvciAqc3RhcnQqIGRhdGVzIG9mIGNlbGxzLiBXaWxsIG5vdCB3b3JrIGZvciBleGNsdXNpdmUgZW5kIGRhdGVzIGZvciBjZWxscy5cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmdldERhdGVEYXlJbmRleCA9IGZ1bmN0aW9uIChkYXRlKSB7XHJcbiAgICAgICAgdmFyIGRheUluZGljZXMgPSB0aGlzLmRheUluZGljZXM7XHJcbiAgICAgICAgdmFyIGRheU9mZnNldCA9IGRhdGUuZGlmZih0aGlzLmRheURhdGVzWzBdLCAnZGF5cycpO1xyXG4gICAgICAgIGlmIChkYXlPZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXlJbmRpY2VzWzBdIC0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGF5T2Zmc2V0ID49IGRheUluZGljZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkYXlJbmRpY2VzW2RheUluZGljZXMubGVuZ3RoIC0gMV0gKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRheUluZGljZXNbZGF5T2Zmc2V0XTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogT3B0aW9uc1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIENvbXB1dGVzIGEgZGVmYXVsdCBjb2x1bW4gaGVhZGVyIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGBjb2xGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmNvbXB1dGVDb2xIZWFkRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGlmIG1vcmUgdGhhbiBvbmUgd2VlayByb3csIG9yIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiBjb2x1bW5zIHdpdGggbm90IG11Y2ggc3BhY2UsXHJcbiAgICAgICAgLy8gcHV0IGp1c3QgdGhlIGRheSBudW1iZXJzIHdpbGwgYmUgaW4gZWFjaCBjZWxsXHJcbiAgICAgICAgaWYgKHRoaXMucm93Q250ID4gMSB8fCB0aGlzLmNvbENudCA+IDEwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZGRkJzsgLy8gXCJTYXRcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbENudCA+IDEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdkYXlPZk1vbnRoRm9ybWF0Jyk7IC8vIFwiU2F0IDEyLzEwXCJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnZGRkZCc7IC8vIFwiU2F0dXJkYXlcIlxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBTbGljaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gU2xpY2VzIHVwIGEgZGF0ZSByYW5nZSBpbnRvIGEgc2VnbWVudCBmb3IgZXZlcnkgd2Vlay1yb3cgaXQgaW50ZXJzZWN0cyB3aXRoXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5zbGljZVJhbmdlQnlSb3cgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGRheXNQZXJSb3cgPSB0aGlzLmRheXNQZXJSb3c7XHJcbiAgICAgICAgdmFyIG5vcm1hbFJhbmdlID0gdGhpcy52aWV3LmNvbXB1dGVEYXlSYW5nZSh1bnpvbmVkUmFuZ2UpOyAvLyBtYWtlIHdob2xlLWRheSByYW5nZSwgY29uc2lkZXJpbmcgbmV4dERheVRocmVzaG9sZFxyXG4gICAgICAgIHZhciByYW5nZUZpcnN0ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgobm9ybWFsUmFuZ2Uuc3RhcnQpOyAvLyBpbmNsdXNpdmUgZmlyc3QgaW5kZXhcclxuICAgICAgICB2YXIgcmFuZ2VMYXN0ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgobm9ybWFsUmFuZ2UuZW5kLmNsb25lKCkuc3VidHJhY3QoMSwgJ2RheXMnKSk7IC8vIGluY2x1c2l2ZSBsYXN0IGluZGV4XHJcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgcm93O1xyXG4gICAgICAgIHZhciByb3dGaXJzdDtcclxuICAgICAgICB2YXIgcm93TGFzdDsgLy8gaW5jbHVzaXZlIGRheS1pbmRleCByYW5nZSBmb3IgY3VycmVudCByb3dcclxuICAgICAgICB2YXIgc2VnRmlyc3Q7XHJcbiAgICAgICAgdmFyIHNlZ0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIHNlZ21lbnRcclxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3crKykge1xyXG4gICAgICAgICAgICByb3dGaXJzdCA9IHJvdyAqIGRheXNQZXJSb3c7XHJcbiAgICAgICAgICAgIHJvd0xhc3QgPSByb3dGaXJzdCArIGRheXNQZXJSb3cgLSAxO1xyXG4gICAgICAgICAgICAvLyBpbnRlcnNlY3Qgc2VnbWVudCdzIG9mZnNldCByYW5nZSB3aXRoIHRoZSByb3cnc1xyXG4gICAgICAgICAgICBzZWdGaXJzdCA9IE1hdGgubWF4KHJhbmdlRmlyc3QsIHJvd0ZpcnN0KTtcclxuICAgICAgICAgICAgc2VnTGFzdCA9IE1hdGgubWluKHJhbmdlTGFzdCwgcm93TGFzdCk7XHJcbiAgICAgICAgICAgIC8vIGRlYWwgd2l0aCBpbi1iZXR3ZWVuIGluZGljZXNcclxuICAgICAgICAgICAgc2VnRmlyc3QgPSBNYXRoLmNlaWwoc2VnRmlyc3QpOyAvLyBpbi1iZXR3ZWVuIHN0YXJ0cyByb3VuZCB0byBuZXh0IGNlbGxcclxuICAgICAgICAgICAgc2VnTGFzdCA9IE1hdGguZmxvb3Ioc2VnTGFzdCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcclxuICAgICAgICAgICAgaWYgKHNlZ0ZpcnN0IDw9IHNlZ0xhc3QpIHsgLy8gd2FzIHRoZXJlIGFueSBpbnRlcnNlY3Rpb24gd2l0aCB0aGUgY3VycmVudCByb3c/XHJcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0byBzdGFydCBvZiByb3dcclxuICAgICAgICAgICAgICAgICAgICBmaXJzdFJvd0RheUluZGV4OiBzZWdGaXJzdCAtIHJvd0ZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RSb3dEYXlJbmRleDogc2VnTGFzdCAtIHJvd0ZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG11c3QgYmUgbWF0Y2hpbmcgaW50ZWdlcnMgdG8gYmUgdGhlIHNlZ21lbnQncyBzdGFydC9lbmRcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWdGaXJzdCA9PT0gcmFuZ2VGaXJzdCxcclxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnTGFzdCA9PT0gcmFuZ2VMYXN0XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvLyBTbGljZXMgdXAgYSBkYXRlIHJhbmdlIGludG8gYSBzZWdtZW50IGZvciBldmVyeSBkYXktY2VsbCBpdCBpbnRlcnNlY3RzIHdpdGguXHJcbiAgICAvLyBUT0RPOiBtYWtlIG1vcmUgRFJZIHdpdGggc2xpY2VSYW5nZUJ5Um93IHNvbWVob3cuXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5zbGljZVJhbmdlQnlEYXkgPSBmdW5jdGlvbiAodW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGRheXNQZXJSb3cgPSB0aGlzLmRheXNQZXJSb3c7XHJcbiAgICAgICAgdmFyIG5vcm1hbFJhbmdlID0gdGhpcy52aWV3LmNvbXB1dGVEYXlSYW5nZSh1bnpvbmVkUmFuZ2UpOyAvLyBtYWtlIHdob2xlLWRheSByYW5nZSwgY29uc2lkZXJpbmcgbmV4dERheVRocmVzaG9sZFxyXG4gICAgICAgIHZhciByYW5nZUZpcnN0ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgobm9ybWFsUmFuZ2Uuc3RhcnQpOyAvLyBpbmNsdXNpdmUgZmlyc3QgaW5kZXhcclxuICAgICAgICB2YXIgcmFuZ2VMYXN0ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgobm9ybWFsUmFuZ2UuZW5kLmNsb25lKCkuc3VidHJhY3QoMSwgJ2RheXMnKSk7IC8vIGluY2x1c2l2ZSBsYXN0IGluZGV4XHJcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgcm93O1xyXG4gICAgICAgIHZhciByb3dGaXJzdDtcclxuICAgICAgICB2YXIgcm93TGFzdDsgLy8gaW5jbHVzaXZlIGRheS1pbmRleCByYW5nZSBmb3IgY3VycmVudCByb3dcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnRmlyc3Q7XHJcbiAgICAgICAgdmFyIHNlZ0xhc3Q7IC8vIGluY2x1c2l2ZSBkYXktaW5kZXggcmFuZ2UgZm9yIHNlZ21lbnRcclxuICAgICAgICBmb3IgKHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3crKykge1xyXG4gICAgICAgICAgICByb3dGaXJzdCA9IHJvdyAqIGRheXNQZXJSb3c7XHJcbiAgICAgICAgICAgIHJvd0xhc3QgPSByb3dGaXJzdCArIGRheXNQZXJSb3cgLSAxO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSByb3dGaXJzdDsgaSA8PSByb3dMYXN0OyBpKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIGludGVyc2VjdCBzZWdtZW50J3Mgb2Zmc2V0IHJhbmdlIHdpdGggdGhlIHJvdydzXHJcbiAgICAgICAgICAgICAgICBzZWdGaXJzdCA9IE1hdGgubWF4KHJhbmdlRmlyc3QsIGkpO1xyXG4gICAgICAgICAgICAgICAgc2VnTGFzdCA9IE1hdGgubWluKHJhbmdlTGFzdCwgaSk7XHJcbiAgICAgICAgICAgICAgICAvLyBkZWFsIHdpdGggaW4tYmV0d2VlbiBpbmRpY2VzXHJcbiAgICAgICAgICAgICAgICBzZWdGaXJzdCA9IE1hdGguY2VpbChzZWdGaXJzdCk7IC8vIGluLWJldHdlZW4gc3RhcnRzIHJvdW5kIHRvIG5leHQgY2VsbFxyXG4gICAgICAgICAgICAgICAgc2VnTGFzdCA9IE1hdGguZmxvb3Ioc2VnTGFzdCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcclxuICAgICAgICAgICAgICAgIGlmIChzZWdGaXJzdCA8PSBzZWdMYXN0KSB7IC8vIHdhcyB0aGVyZSBhbnkgaW50ZXJzZWN0aW9uIHdpdGggdGhlIGN1cnJlbnQgcm93P1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBub3JtYWxpemUgdG8gc3RhcnQgb2Ygcm93XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Um93RGF5SW5kZXg6IHNlZ0ZpcnN0IC0gcm93Rmlyc3QsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RSb3dEYXlJbmRleDogc2VnTGFzdCAtIHJvd0ZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGJlIG1hdGNoaW5nIGludGVnZXJzIHRvIGJlIHRoZSBzZWdtZW50J3Mgc3RhcnQvZW5kXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ0ZpcnN0ID09PSByYW5nZUZpcnN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnTGFzdCA9PT0gcmFuZ2VMYXN0XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLyogSGVhZGVyIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckhlYWRIdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXJvdyAnICsgdGhlbWUuZ2V0Q2xhc3MoJ2hlYWRlclJvdycpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzx0aGVhZD4nICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIZWFkVHJIdG1sKCkgK1xyXG4gICAgICAgICAgICAnPC90aGVhZD4nICtcclxuICAgICAgICAgICAgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nO1xyXG4gICAgfTtcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckhlYWRJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVySW50cm9IdG1sKCk7IC8vIGZhbGwgYmFjayB0byBnZW5lcmljXHJcbiAgICB9O1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZFRySHRtbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAodGhpcy5pc1JUTCA/ICcnIDogdGhpcy5yZW5kZXJIZWFkSW50cm9IdG1sKCkpICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJIZWFkRGF0ZUNlbGxzSHRtbCgpICtcclxuICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlckhlYWRJbnRyb0h0bWwoKSA6ICcnKSArXHJcbiAgICAgICAgICAgICc8L3RyPic7XHJcbiAgICB9O1xyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZERhdGVDZWxsc0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGh0bWxzID0gW107XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICB2YXIgZGF0ZTtcclxuICAgICAgICBmb3IgKGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wrKykge1xyXG4gICAgICAgICAgICBkYXRlID0gdGhpcy5nZXRDZWxsRGF0ZSgwLCBjb2wpO1xyXG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMucmVuZGVySGVhZERhdGVDZWxsSHRtbChkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBodG1scy5qb2luKCcnKTtcclxuICAgIH07XHJcbiAgICAvLyBUT0RPOiB3aGVuIGludGVybmFsQXBpVmVyc2lvbiwgYWNjZXB0IGFuIG9iamVjdCBmb3IgSFRNTCBhdHRyaWJ1dGVzXHJcbiAgICAvLyAoY29sc3BhbiBzaG91bGQgYmUgbm8gZGlmZmVyZW50KVxyXG4gICAgRGF5VGFibGVNaXhpbi5wcm90b3R5cGUucmVuZGVySGVhZERhdGVDZWxsSHRtbCA9IGZ1bmN0aW9uIChkYXRlLCBjb2xzcGFuLCBvdGhlckF0dHJzKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdC52aWV3O1xyXG4gICAgICAgIHZhciBpc0RhdGVWYWxpZCA9IHQuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmNvbnRhaW5zRGF0ZShkYXRlKTsgLy8gVE9ETzogY2FsbGVkIHRvbyBmcmVxdWVudGx5LiBjYWNoZSBzb21laG93LlxyXG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xyXG4gICAgICAgICAgICAnZmMtZGF5LWhlYWRlcicsXHJcbiAgICAgICAgICAgIHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpXHJcbiAgICAgICAgXTtcclxuICAgICAgICB2YXIgaW5uZXJIdG1sO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdC5vcHQoJ2NvbHVtbkhlYWRlckh0bWwnKSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpbm5lckh0bWwgPSB0Lm9wdCgnY29sdW1uSGVhZGVySHRtbCcpKGRhdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdC5vcHQoJ2NvbHVtbkhlYWRlclRleHQnKSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpbm5lckh0bWwgPSB1dGlsXzEuaHRtbEVzY2FwZSh0Lm9wdCgnY29sdW1uSGVhZGVyVGV4dCcpKGRhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlubmVySHRtbCA9IHV0aWxfMS5odG1sRXNjYXBlKGRhdGUuZm9ybWF0KHQuY29sSGVhZEZvcm1hdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBvbmx5IG9uZSByb3cgb2YgZGF5cywgdGhlIGNsYXNzTmFtZXMgb24gdGhlIGhlYWRlciBjYW4gcmVwcmVzZW50IHRoZSBzcGVjaWZpYyBkYXlzIGJlbmVhdGhcclxuICAgICAgICBpZiAodC5yb3dDbnQgPT09IDEpIHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lcyA9IGNsYXNzTmFtZXMuY29uY2F0KFxyXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyB0aGUgZGF5LW9mLXdlZWsgY2xhc3NcclxuICAgICAgICAgICAgLy8gbm9UaGVtZUhpZ2hsaWdodD10cnVlIChkb24ndCBoaWdobGlnaHQgdGhlIGhlYWRlcilcclxuICAgICAgICAgICAgdC5nZXREYXlDbGFzc2VzKGRhdGUsIHRydWUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtJyArIHV0aWxfMS5kYXlJRHNbZGF0ZS5kYXkoKV0pOyAvLyBvbmx5IGFkZCB0aGUgZGF5LW9mLXdlZWsgY2xhc3NcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzx0aCBjbGFzcz1cIicgKyBjbGFzc05hbWVzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAoKGlzRGF0ZVZhbGlkICYmIHQucm93Q250KSA9PT0gMSA/XHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAoY29sc3BhbiA+IDEgP1xyXG4gICAgICAgICAgICAgICAgJyBjb2xzcGFuPVwiJyArIGNvbHNwYW4gKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgIChvdGhlckF0dHJzID9cclxuICAgICAgICAgICAgICAgICcgJyArIG90aGVyQXR0cnMgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgKGlzRGF0ZVZhbGlkID9cclxuICAgICAgICAgICAgICAgIC8vIGRvbid0IG1ha2UgYSBsaW5rIGlmIHRoZSBoZWFkaW5nIGNvdWxkIHJlcHJlc2VudCBtdWx0aXBsZSBkYXlzLCBvciBpZiB0aGVyZSdzIG9ubHkgb25lIGRheSAoZm9yY2VPZmYpXHJcbiAgICAgICAgICAgICAgICB2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoeyBkYXRlOiBkYXRlLCBmb3JjZU9mZjogdC5yb3dDbnQgPiAxIHx8IHQuY29sQ250ID09PSAxIH0sIGlubmVySHRtbCkgOlxyXG4gICAgICAgICAgICAgICAgLy8gaWYgbm90IHZhbGlkLCBkaXNwbGF5IHRleHQsIGJ1dCBubyBsaW5rXHJcbiAgICAgICAgICAgICAgICBpbm5lckh0bWwpICtcclxuICAgICAgICAgICAgJzwvdGg+JztcclxuICAgIH07XHJcbiAgICAvKiBCYWNrZ3JvdW5kIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckJnVHJIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHJldHVybiAnJyArXHJcbiAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLmlzUlRMID8gJycgOiB0aGlzLnJlbmRlckJnSW50cm9IdG1sKHJvdykpICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJCZ0NlbGxzSHRtbChyb3cpICtcclxuICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyB0aGlzLnJlbmRlckJnSW50cm9IdG1sKHJvdykgOiAnJykgK1xyXG4gICAgICAgICAgICAnPC90cj4nO1xyXG4gICAgfTtcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckJnSW50cm9IdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckludHJvSHRtbCgpOyAvLyBmYWxsIGJhY2sgdG8gZ2VuZXJpY1xyXG4gICAgfTtcclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLnJlbmRlckJnQ2VsbHNIdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHZhciBodG1scyA9IFtdO1xyXG4gICAgICAgIHZhciBjb2w7XHJcbiAgICAgICAgdmFyIGRhdGU7XHJcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHtcclxuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpO1xyXG4gICAgICAgICAgICBodG1scy5wdXNoKHRoaXMucmVuZGVyQmdDZWxsSHRtbChkYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBodG1scy5qb2luKCcnKTtcclxuICAgIH07XHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJCZ0NlbGxIdG1sID0gZnVuY3Rpb24gKGRhdGUsIG90aGVyQXR0cnMpIHtcclxuICAgICAgICB2YXIgdCA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0LnZpZXc7XHJcbiAgICAgICAgdmFyIGlzRGF0ZVZhbGlkID0gdC5kYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuY29udGFpbnNEYXRlKGRhdGUpOyAvLyBUT0RPOiBjYWxsZWQgdG9vIGZyZXF1ZW50bHkuIGNhY2hlIHNvbWVob3cuXHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSB0LmdldERheUNsYXNzZXMoZGF0ZSk7XHJcbiAgICAgICAgY2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXknLCB2aWV3LmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykpO1xyXG4gICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiJyArIGNsYXNzZXMuam9pbignICcpICsgJ1wiJyArXHJcbiAgICAgICAgICAgIChpc0RhdGVWYWxpZCA/XHJcbiAgICAgICAgICAgICAgICAnIGRhdGEtZGF0ZT1cIicgKyBkYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiJyA6IC8vIGlmIGRhdGUgaGFzIGEgdGltZSwgd29uJ3QgZm9ybWF0IGl0XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAob3RoZXJBdHRycyA/XHJcbiAgICAgICAgICAgICAgICAnICcgKyBvdGhlckF0dHJzIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+PC90ZD4nO1xyXG4gICAgfTtcclxuICAgIC8qIEdlbmVyaWNcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBEYXlUYWJsZU1peGluLnByb3RvdHlwZS5yZW5kZXJJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBkZWZhdWx0IEhUTUwgaW50cm8gZm9yIGFueSByb3cuIFVzZXIgY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGVcclxuICAgIH07XHJcbiAgICAvLyBUT0RPOiBhIGdlbmVyaWMgbWV0aG9kIGZvciBkZWFsaW5nIHdpdGggPHRyPiwgUlRMLCBpbnRyb1xyXG4gICAgLy8gd2hlbiBpbmNyZW1lbnQgaW50ZXJuYWxBcGlWZXJzaW9uXHJcbiAgICAvLyB3cmFwVHIgKHNjaGVkdWxlcilcclxuICAgIC8qIFV0aWxzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQXBwbGllcyB0aGUgZ2VuZXJpYyBcImludHJvXCIgYW5kIFwib3V0cm9cIiBIVE1MIHRvIHRoZSBnaXZlbiBjZWxscy5cclxuICAgIC8vIEludHJvIG1lYW5zIHRoZSBsZWZ0bW9zdCBjZWxsIHdoZW4gdGhlIGNhbGVuZGFyIGlzIExUUiBhbmQgdGhlIHJpZ2h0bW9zdCBjZWxsIHdoZW4gUlRMLiBWaWNlLXZlcnNhIGZvciBvdXRyby5cclxuICAgIERheVRhYmxlTWl4aW4ucHJvdG90eXBlLmJvb2tlbmRDZWxscyA9IGZ1bmN0aW9uICh0ckVsKSB7XHJcbiAgICAgICAgdmFyIGludHJvSHRtbCA9IHRoaXMucmVuZGVySW50cm9IdG1sKCk7XHJcbiAgICAgICAgaWYgKGludHJvSHRtbCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5pc1JUTCkge1xyXG4gICAgICAgICAgICAgICAgdHJFbC5hcHBlbmQoaW50cm9IdG1sKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRyRWwucHJlcGVuZChpbnRyb0h0bWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXlUYWJsZU1peGluO1xyXG59KE1peGluXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXlUYWJsZU1peGluO1xyXG5cblxuLyoqKi8gfSksXG4vKiA2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBCdXNpbmVzc0hvdXJSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgaW1wbGVtZW50czpcclxuICAgICAgLSBldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzXHJcbiAgICAgIC0gZXZlbnRGb290cHJpbnRzVG9TZWdzXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gQnVzaW5lc3NIb3VyUmVuZGVyZXIoY29tcG9uZW50LCBmaWxsUmVuZGVyZXIpIHtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLmZpbGxSZW5kZXJlciA9IGZpbGxSZW5kZXJlcjtcclxuICAgIH1cclxuICAgIEJ1c2luZXNzSG91clJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoYnVzaW5lc3NIb3VyR2VuZXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2UgPSBjb21wb25lbnQuX2dldERhdGVQcm9maWxlKCkuYWN0aXZlVW56b25lZFJhbmdlO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXAgPSBidXNpbmVzc0hvdXJHZW5lcmF0b3IuYnVpbGRFdmVudEluc3RhbmNlR3JvdXAoY29tcG9uZW50Lmhhc0FsbERheUJ1c2luZXNzSG91cnMsIHVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IGV2ZW50SW5zdGFuY2VHcm91cCA/XHJcbiAgICAgICAgICAgIGNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKGV2ZW50SW5zdGFuY2VHcm91cC5zbGljZVJlbmRlclJhbmdlcyh1bnpvbmVkUmFuZ2UpKSA6XHJcbiAgICAgICAgICAgIFtdO1xyXG4gICAgICAgIHRoaXMucmVuZGVyRXZlbnRGb290cHJpbnRzKGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICB9O1xyXG4gICAgQnVzaW5lc3NIb3VyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckV2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuY29tcG9uZW50LmV2ZW50Rm9vdHByaW50c1RvU2VncyhldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyU2VncyhzZWdzKTtcclxuICAgICAgICB0aGlzLnNlZ3MgPSBzZWdzO1xyXG4gICAgfTtcclxuICAgIEJ1c2luZXNzSG91clJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICBpZiAodGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIucmVuZGVyU2VncygnYnVzaW5lc3NIb3VycycsIHNlZ3MsIHtcclxuICAgICAgICAgICAgICAgIGdldENsYXNzZXM6IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydmYy1ub25idXNpbmVzcycsICdmYy1iZ2V2ZW50J107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCdXNpbmVzc0hvdXJSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlbmRlcmVyLnVucmVuZGVyKCdidXNpbmVzc0hvdXJzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2VncyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgQnVzaW5lc3NIb3VyUmVuZGVyZXIucHJvdG90eXBlLmdldFNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VncyB8fCBbXTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQnVzaW5lc3NIb3VyUmVuZGVyZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJ1c2luZXNzSG91clJlbmRlcmVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiA2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBGaWxsUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGaWxsUmVuZGVyZXIoY29tcG9uZW50KSB7XHJcbiAgICAgICAgdGhpcy5maWxsU2VnVGFnID0gJ2Rpdic7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5lbHNCeUZpbGwgPSB7fTtcclxuICAgIH1cclxuICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRm9vdHByaW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbXBvbmVudEZvb3RwcmludCwgcHJvcHMpIHtcclxuICAgICAgICB0aGlzLnJlbmRlclNlZ3ModHlwZSwgdGhpcy5jb21wb25lbnQuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzKGNvbXBvbmVudEZvb3RwcmludCksIHByb3BzKTtcclxuICAgIH07XHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAodHlwZSwgc2VncywgcHJvcHMpIHtcclxuICAgICAgICB2YXIgZWxzO1xyXG4gICAgICAgIHNlZ3MgPSB0aGlzLmJ1aWxkU2VnRWxzKHR5cGUsIHNlZ3MsIHByb3BzKTsgLy8gYXNzaWduZXMgYC5lbGAgdG8gZWFjaCBzZWcuIHJldHVybnMgc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHNlZ3NcclxuICAgICAgICBlbHMgPSB0aGlzLmF0dGFjaFNlZ0Vscyh0eXBlLCBzZWdzKTtcclxuICAgICAgICBpZiAoZWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVwb3J0RWxzKHR5cGUsIGVscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhIHNwZWNpZmljIHR5cGUgb2YgZmlsbCB0aGF0IGlzIGN1cnJlbnRseSByZW5kZXJlZCBvbiB0aGUgZ3JpZFxyXG4gICAgRmlsbFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlciA9IGZ1bmN0aW9uICh0eXBlKSB7XHJcbiAgICAgICAgdmFyIGVsID0gdGhpcy5lbHNCeUZpbGxbdHlwZV07XHJcbiAgICAgICAgaWYgKGVsKSB7XHJcbiAgICAgICAgICAgIGVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5lbHNCeUZpbGxbdHlwZV07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgYW5kIGFzc2lnbnMgYW4gYGVsYCBwcm9wZXJ0eSBmb3IgZWFjaCBmaWxsIHNlZ21lbnQuIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBkaWZmZXJlbnQgdHlwZXMuXHJcbiAgICAvLyBPbmx5IHJldHVybnMgc2VnbWVudHMgdGhhdCBzdWNjZXNzZnVsbHkgcmVuZGVyZWQuXHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkU2VnRWxzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MsIHByb3BzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgaHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciByZW5kZXJlZFNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAoc2Vncy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gYnVpbGQgYSBsYXJnZSBjb25jYXRlbmF0aW9uIG9mIHNlZ21lbnQgSFRNTFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaHRtbCArPSB0aGlzLmJ1aWxkU2VnSHRtbCh0eXBlLCBzZWdzW2ldLCBwcm9wcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR3JhYiBpbmRpdmlkdWFsIGVsZW1lbnRzIGZyb20gdGhlIGNvbWJpbmVkIEhUTUwgc3RyaW5nLiBVc2UgZWFjaCBhcyB0aGUgZGVmYXVsdCByZW5kZXJpbmcuXHJcbiAgICAgICAgICAgIC8vIFRoZW4sIGNvbXB1dGUgdGhlICdlbCcgZm9yIGVhY2ggc2VnbWVudC5cclxuICAgICAgICAgICAgJChodG1sKS5lYWNoKGZ1bmN0aW9uIChpLCBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgICAgIHZhciBlbCA9ICQobm9kZSk7XHJcbiAgICAgICAgICAgICAgICAvLyBhbGxvdyBjdXN0b20gZmlsdGVyIG1ldGhvZHMgcGVyLXR5cGVcclxuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5maWx0ZXJFbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsID0gcHJvcHMuZmlsdGVyRWwoc2VnLCBlbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHsgLy8gY3VzdG9tIGZpbHRlcnMgZGlkIG5vdCBjYW5jZWwgdGhlIHJlbmRlclxyXG4gICAgICAgICAgICAgICAgICAgIGVsID0gJChlbCk7IC8vIGFsbG93IGN1c3RvbSBmaWx0ZXIgdG8gcmV0dXJuIHJhdyBET00gbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgZWxlbWVudCB0eXBlPyAod291bGQgYmUgYmFkIGlmIGEgbm9uLVREIHdlcmUgaW5zZXJ0ZWQgaW50byBhIHRhYmxlIGZvciBleGFtcGxlKVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbC5pcyhfdGhpcy5maWxsU2VnVGFnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWcuZWwgPSBlbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWRTZWdzLnB1c2goc2VnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVuZGVyZWRTZWdzO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgSFRNTCBuZWVkZWQgZm9yIG9uZSBmaWxsIHNlZ21lbnQuIEdlbmVyaWMgZW5vdWdoIHRvIHdvcmsgd2l0aCBkaWZmZXJlbnQgdHlwZXMuXHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkU2VnSHRtbCA9IGZ1bmN0aW9uICh0eXBlLCBzZWcsIHByb3BzKSB7XHJcbiAgICAgICAgLy8gY3VzdG9tIGhvb2tzIHBlci10eXBlXHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSBwcm9wcy5nZXRDbGFzc2VzID8gcHJvcHMuZ2V0Q2xhc3NlcyhzZWcpIDogW107XHJcbiAgICAgICAgdmFyIGNzcyA9IHV0aWxfMS5jc3NUb1N0cihwcm9wcy5nZXRDc3MgPyBwcm9wcy5nZXRDc3Moc2VnKSA6IHt9KTtcclxuICAgICAgICByZXR1cm4gJzwnICsgdGhpcy5maWxsU2VnVGFnICtcclxuICAgICAgICAgICAgKGNsYXNzZXMubGVuZ3RoID8gJyBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgOiAnJykgK1xyXG4gICAgICAgICAgICAoY3NzID8gJyBzdHlsZT1cIicgKyBjc3MgKyAnXCInIDogJycpICtcclxuICAgICAgICAgICAgJz48LycgKyB0aGlzLmZpbGxTZWdUYWcgKyAnPic7XHJcbiAgICB9O1xyXG4gICAgLy8gU2hvdWxkIHJldHVybiB3cmFwcGluZyBET00gc3RydWN0dXJlXHJcbiAgICBGaWxsUmVuZGVyZXIucHJvdG90eXBlLmF0dGFjaFNlZ0VscyA9IGZ1bmN0aW9uICh0eXBlLCBzZWdzKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBtdXN0IGltcGxlbWVudFxyXG4gICAgfTtcclxuICAgIEZpbGxSZW5kZXJlci5wcm90b3R5cGUucmVwb3J0RWxzID0gZnVuY3Rpb24gKHR5cGUsIG5vZGVzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWxzQnlGaWxsW3R5cGVdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxzQnlGaWxsW3R5cGVdID0gdGhpcy5lbHNCeUZpbGxbdHlwZV0uYWRkKG5vZGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWxzQnlGaWxsW3R5cGVdID0gJChub2Rlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBGaWxsUmVuZGVyZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEZpbGxSZW5kZXJlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU2luZ2xlRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcbnZhciBFdmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIEhlbHBlclJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSGVscGVyUmVuZGVyZXIoY29tcG9uZW50LCBldmVudFJlbmRlcmVyKSB7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gY29tcG9uZW50Ll9nZXRWaWV3KCk7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyID0gZXZlbnRSZW5kZXJlcjtcclxuICAgIH1cclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJDb21wb25lbnRGb290cHJpbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJFdmVudEZvb3RwcmludHMoW1xyXG4gICAgICAgICAgICB0aGlzLmZhYnJpY2F0ZUV2ZW50Rm9vdHByaW50KGNvbXBvbmVudEZvb3RwcmludClcclxuICAgICAgICBdKTtcclxuICAgIH07XHJcbiAgICBIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRXZlbnREcmFnZ2luZ0Zvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzb3VyY2VTZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckV2ZW50Rm9vdHByaW50cyhldmVudEZvb3RwcmludHMsIHNvdXJjZVNlZywgJ2ZjLWRyYWdnaW5nJywgaXNUb3VjaCA/IG51bGwgOiB0aGlzLnZpZXcub3B0KCdkcmFnT3BhY2l0eScpKTtcclxuICAgIH07XHJcbiAgICBIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRXZlbnRSZXNpemluZ0Zvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzb3VyY2VTZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckV2ZW50Rm9vdHByaW50cyhldmVudEZvb3RwcmludHMsIHNvdXJjZVNlZywgJ2ZjLXJlc2l6aW5nJyk7XHJcbiAgICB9O1xyXG4gICAgSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckV2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNvdXJjZVNlZywgZXh0cmFDbGFzc05hbWVzLCBvcGFjaXR5KSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLmNvbXBvbmVudC5ldmVudEZvb3RwcmludHNUb1NlZ3MoZXZlbnRGb290cHJpbnRzKTtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9ICdmYy1oZWxwZXIgJyArIChleHRyYUNsYXNzTmFtZXMgfHwgJycpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIC8vIGFzc2lnbnMgZWFjaCBzZWcncyBlbCBhbmQgcmV0dXJucyBhIHN1YnNldCBvZiBzZWdzIHRoYXQgd2VyZSByZW5kZXJlZFxyXG4gICAgICAgIHNlZ3MgPSB0aGlzLmV2ZW50UmVuZGVyZXIucmVuZGVyRmdTZWdFbHMoc2Vncyk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2Vnc1tpXS5lbC5hZGRDbGFzcyhjbGFzc05hbWVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG9wYWNpdHkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgc2Vnc1tpXS5lbC5jc3MoJ29wYWNpdHknLCBvcGFjaXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhlbHBlckVscyA9IHRoaXMucmVuZGVyU2VncyhzZWdzLCBzb3VyY2VTZWcpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBNdXN0IHJldHVybiBhbGwgbW9jayBldmVudCBlbGVtZW50c1xyXG4gICAgKi9cclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIHNvdXJjZVNlZykge1xyXG4gICAgICAgIC8vIFN1YmNsYXNzZXMgbXVzdCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUudW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVscGVyRWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVscGVyRWxzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBlckVscyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEhlbHBlclJlbmRlcmVyLnByb3RvdHlwZS5mYWJyaWNhdGVFdmVudEZvb3RwcmludCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGV2ZW50RGF0ZVByb2ZpbGUgPSBjYWxlbmRhci5mb290cHJpbnRUb0RhdGVQcm9maWxlKGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgdmFyIGR1bW15RXZlbnQgPSBuZXcgU2luZ2xlRXZlbnREZWZfMS5kZWZhdWx0KG5ldyBFdmVudFNvdXJjZV8xLmRlZmF1bHQoY2FsZW5kYXIpKTtcclxuICAgICAgICB2YXIgZHVtbXlJbnN0YW5jZTtcclxuICAgICAgICBkdW1teUV2ZW50LmRhdGVQcm9maWxlID0gZXZlbnREYXRlUHJvZmlsZTtcclxuICAgICAgICBkdW1teUluc3RhbmNlID0gZHVtbXlFdmVudC5idWlsZEluc3RhbmNlKCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZvb3RwcmludF8xLmRlZmF1bHQoY29tcG9uZW50Rm9vdHByaW50LCBkdW1teUV2ZW50LCBkdW1teUluc3RhbmNlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSGVscGVyUmVuZGVyZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEhlbHBlclJlbmRlcmVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiA2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIEdsb2JhbEVtaXR0ZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG52YXIgSW50ZXJhY3Rpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG52YXIgRXZlbnRQb2ludGluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEV2ZW50UG9pbnRpbmcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFdmVudFBvaW50aW5nKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgbXVzdCBpbXBsZW1lbnQ6XHJcbiAgICAgIC0gcHVibGljbHlUcmlnZ2VyXHJcbiAgICAqL1xyXG4gICAgRXZlbnRQb2ludGluZy5wcm90b3R5cGUuYmluZFRvRWwgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGljay5iaW5kKHRoaXMpKTtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnbW91c2VlbnRlcicsIHRoaXMuaGFuZGxlTW91c2VvdmVyLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICdtb3VzZWxlYXZlJywgdGhpcy5oYW5kbGVNb3VzZW91dC5iaW5kKHRoaXMpKTtcclxuICAgIH07XHJcbiAgICBFdmVudFBvaW50aW5nLnByb3RvdHlwZS5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuY29tcG9uZW50LnB1YmxpY2x5VHJpZ2dlcignZXZlbnRDbGljaycsIHtcclxuICAgICAgICAgICAgY29udGV4dDogc2VnLmVsWzBdLFxyXG4gICAgICAgICAgICBhcmdzOiBbc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLCBldiwgdGhpcy52aWV3XVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZXMgaW50ZXJuYWwgc3RhdGUgYW5kIHRyaWdnZXJzIGhhbmRsZXJzIGZvciB3aGVuIGFuIGV2ZW50IGVsZW1lbnQgaXMgbW91c2VkIG92ZXJcclxuICAgIEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmhhbmRsZU1vdXNlb3ZlciA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgaWYgKCFHbG9iYWxFbWl0dGVyXzEuZGVmYXVsdC5nZXQoKS5zaG91bGRJZ25vcmVNb3VzZSgpICYmXHJcbiAgICAgICAgICAgICF0aGlzLm1vdXNlZE92ZXJTZWcpIHtcclxuICAgICAgICAgICAgdGhpcy5tb3VzZWRPdmVyU2VnID0gc2VnO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBtb3ZlIHRvIEV2ZW50U2VsZWN0aW5nJ3MgcmVzcG9uc2liaWxpdHlcclxuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5pc0V2ZW50RGVmUmVzaXphYmxlKHNlZy5mb290cHJpbnQuZXZlbnREZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuZWwuYWRkQ2xhc3MoJ2ZjLWFsbG93LW1vdXNlLXJlc2l6ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnB1YmxpY2x5VHJpZ2dlcignZXZlbnRNb3VzZW92ZXInLCB7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgICAgICBhcmdzOiBbc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLCBldiwgdGhpcy52aWV3XVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gVXBkYXRlcyBpbnRlcm5hbCBzdGF0ZSBhbmQgdHJpZ2dlcnMgaGFuZGxlcnMgZm9yIHdoZW4gYW4gZXZlbnQgZWxlbWVudCBpcyBtb3VzZWQgb3V0LlxyXG4gICAgLy8gQ2FuIGJlIGdpdmVuIG5vIGFyZ3VtZW50cywgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIG1vdXNlb3V0IHRoZSBzZWdtZW50IHRoYXQgd2FzIHByZXZpb3VzbHkgbW91c2VkIG92ZXIuXHJcbiAgICBFdmVudFBvaW50aW5nLnByb3RvdHlwZS5oYW5kbGVNb3VzZW91dCA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgaWYgKHRoaXMubW91c2VkT3ZlclNlZykge1xyXG4gICAgICAgICAgICB0aGlzLm1vdXNlZE92ZXJTZWcgPSBudWxsO1xyXG4gICAgICAgICAgICAvLyBUT0RPOiBtb3ZlIHRvIEV2ZW50U2VsZWN0aW5nJ3MgcmVzcG9uc2liaWxpdHlcclxuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5pc0V2ZW50RGVmUmVzaXphYmxlKHNlZy5mb290cHJpbnQuZXZlbnREZWYpKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuZWwucmVtb3ZlQ2xhc3MoJ2ZjLWFsbG93LW1vdXNlLXJlc2l6ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnB1YmxpY2x5VHJpZ2dlcignZXZlbnRNb3VzZW91dCcsIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgICAgICBzZWcuZm9vdHByaW50LmdldEV2ZW50TGVnYWN5KCksXHJcbiAgICAgICAgICAgICAgICAgICAgZXYgfHwge30sXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aWV3XHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBvaW50aW5nLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubW91c2VkT3ZlclNlZykge1xyXG4gICAgICAgICAgICB0aGlzLmhhbmRsZU1vdXNlb3V0KHRoaXMubW91c2VkT3ZlclNlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudFBvaW50aW5nO1xyXG59KEludGVyYWN0aW9uXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudFBvaW50aW5nO1xyXG5cblxuLyoqKi8gfSksXG4vKiA2NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIE1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KTtcclxudmFyIERhdGVDbGlja2luZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzcpO1xyXG52YXIgRGF0ZVNlbGVjdGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzYpO1xyXG52YXIgRXZlbnRQb2ludGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XHJcbnZhciBFdmVudERyYWdnaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNSk7XHJcbnZhciBFdmVudFJlc2l6aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzNCk7XHJcbnZhciBFeHRlcm5hbERyb3BwaW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzMyk7XHJcbnZhciBTdGFuZGFyZEludGVyYWN0aW9uc01peGluID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW47XHJcbn0oTWl4aW5fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW47XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4ucHJvdG90eXBlLmRhdGVDbGlja2luZ0NsYXNzID0gRGF0ZUNsaWNraW5nXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZGF0ZVNlbGVjdGluZ0NsYXNzID0gRGF0ZVNlbGVjdGluZ18xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4ucHJvdG90eXBlLmV2ZW50UG9pbnRpbmdDbGFzcyA9IEV2ZW50UG9pbnRpbmdfMS5kZWZhdWx0O1xyXG5TdGFuZGFyZEludGVyYWN0aW9uc01peGluLnByb3RvdHlwZS5ldmVudERyYWdnaW5nQ2xhc3MgPSBFdmVudERyYWdnaW5nXzEuZGVmYXVsdDtcclxuU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbi5wcm90b3R5cGUuZXZlbnRSZXNpemluZ0NsYXNzID0gRXZlbnRSZXNpemluZ18xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW4ucHJvdG90eXBlLmV4dGVybmFsRHJvcHBpbmdDbGFzcyA9IEV4dGVybmFsRHJvcHBpbmdfMS5kZWZhdWx0O1xyXG5cblxuLyoqKi8gfSksXG4vKiA2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIENvb3JkQ2FjaGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xyXG52YXIgUG9wb3Zlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjcpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgQ29tcG9uZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxudmFyIEV2ZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcclxudmFyIEJ1c2luZXNzSG91clJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcclxudmFyIFN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xyXG52YXIgSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcclxudmFyIERheVRhYmxlTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xyXG52YXIgRGF5R3JpZEV2ZW50UmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQzKTtcclxudmFyIERheUdyaWRIZWxwZXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDQpO1xyXG52YXIgRGF5R3JpZEZpbGxSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDUpO1xyXG4vKiBBIGNvbXBvbmVudCB0aGF0IHJlbmRlcnMgYSBncmlkIG9mIHdob2xlLWRheXMgdGhhdCBydW5zIGhvcml6b250YWxseS4gVGhlcmUgY2FuIGJlIG11bHRpcGxlIHJvd3MsIG9uZSBwZXIgd2Vlay5cclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbnZhciBEYXlHcmlkID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF5R3JpZCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERheUdyaWQodmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHZpZXcpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSA9IGZhbHNlOyAvLyBkaXNwbGF5IHdlZWsgbnVtYmVycyBpbiBkYXkgY2VsbD9cclxuICAgICAgICBfdGhpcy5ib3R0b21Db29yZFBhZGRpbmcgPSAwOyAvLyBoYWNrIGZvciBleHRlbmRpbmcgdGhlIGhpdCBhcmVhIGZvciB0aGUgbGFzdCByb3cgb2YgdGhlIGNvb3JkaW5hdGUgZ3JpZFxyXG4gICAgICAgIC8vIGlzUmlnaWQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBpbmRpdmlkdWFsIHJvd3Mgc2hvdWxkIGlnbm9yZSB0aGUgY29udGVudHMgYW5kIGJlIGEgY29uc3RhbnQgaGVpZ2h0LlxyXG4gICAgICAgIC8vIFJlbGllcyBvbiB0aGUgdmlldydzIGNvbENudCBhbmQgcm93Q250LiBJbiB0aGUgZnV0dXJlLCB0aGlzIGNvbXBvbmVudCBzaG91bGQgcHJvYmFibHkgYmUgc2VsZi1zdWZmaWNpZW50LlxyXG4gICAgICAgIF90aGlzLmlzUmlnaWQgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5oYXNBbGxEYXlCdXNpbmVzc0hvdXJzID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBTbGljZXMgdXAgdGhlIGdpdmVuIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIHdpdGggb3RoZXIgbWlzYyBkYXRhKSBpbnRvIGFuIGFycmF5IG9mIHNlZ21lbnRzXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2VCeVJvdyhjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUlRMKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcubGVmdENvbCA9IHRoaXMuZGF5c1BlclJvdyAtIDEgLSBzZWcubGFzdFJvd0RheUluZGV4O1xyXG4gICAgICAgICAgICAgICAgc2VnLnJpZ2h0Q29sID0gdGhpcy5kYXlzUGVyUm93IC0gMSAtIHNlZy5maXJzdFJvd0RheUluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2VnLmxlZnRDb2wgPSBzZWcuZmlyc3RSb3dEYXlJbmRleDtcclxuICAgICAgICAgICAgICAgIHNlZy5yaWdodENvbCA9IHNlZy5sYXN0Um93RGF5SW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLyogRGF0ZSBSZW5kZXJpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHRoaXMuZGF0ZVByb2ZpbGUgPSBkYXRlUHJvZmlsZTtcclxuICAgICAgICB0aGlzLnVwZGF0ZURheVRhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJHcmlkKCk7XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUudW5yZW5kZXJEYXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZVNlZ1BvcG92ZXIoKTtcclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIHRoZSByb3dzIGFuZCBjb2x1bW5zIGludG8gdGhlIGNvbXBvbmVudCdzIGB0aGlzLmVsYCwgd2hpY2ggc2hvdWxkIGFscmVhZHkgYmUgYXNzaWduZWQuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJHcmlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciByb3dDbnQgPSB0aGlzLnJvd0NudDtcclxuICAgICAgICB2YXIgY29sQ250ID0gdGhpcy5jb2xDbnQ7XHJcbiAgICAgICAgdmFyIGh0bWwgPSAnJztcclxuICAgICAgICB2YXIgcm93O1xyXG4gICAgICAgIHZhciBjb2w7XHJcbiAgICAgICAgaWYgKHRoaXMuaGVhZENvbnRhaW5lckVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGVhZENvbnRhaW5lckVsLmh0bWwodGhpcy5yZW5kZXJIZWFkSHRtbCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCByb3dDbnQ7IHJvdysrKSB7XHJcbiAgICAgICAgICAgIGh0bWwgKz0gdGhpcy5yZW5kZXJEYXlSb3dIdG1sKHJvdywgdGhpcy5pc1JpZ2lkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5lbC5odG1sKGh0bWwpO1xyXG4gICAgICAgIHRoaXMucm93RWxzID0gdGhpcy5lbC5maW5kKCcuZmMtcm93Jyk7XHJcbiAgICAgICAgdGhpcy5jZWxsRWxzID0gdGhpcy5lbC5maW5kKCcuZmMtZGF5LCAuZmMtZGlzYWJsZWQtZGF5Jyk7XHJcbiAgICAgICAgdGhpcy5yb3dDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGVfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgZWxzOiB0aGlzLnJvd0VscyxcclxuICAgICAgICAgICAgaXNWZXJ0aWNhbDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZSA9IG5ldyBDb29yZENhY2hlXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIGVsczogdGhpcy5jZWxsRWxzLnNsaWNlKDAsIHRoaXMuY29sQ250KSxcclxuICAgICAgICAgICAgaXNIb3Jpem9udGFsOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gdHJpZ2dlciBkYXlSZW5kZXIgd2l0aCBlYWNoIGNlbGwncyBlbGVtZW50XHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCByb3dDbnQ7IHJvdysrKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgY29sQ250OyBjb2wrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2RheVJlbmRlcicsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB2aWV3LFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDZWxsRGF0ZShyb3csIGNvbCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld1xyXG4gICAgICAgICAgICAgICAgICAgIF1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgYSBzaW5nbGUgcm93LCB3aGljaCBpcyBhIGRpdiB0aGF0IHdyYXBzIGEgdGFibGUuXHJcbiAgICAvLyBgcm93YCBpcyB0aGUgcm93IG51bWJlci5cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlckRheVJvd0h0bWwgPSBmdW5jdGlvbiAocm93LCBpc1JpZ2lkKSB7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy52aWV3LmNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gWydmYy1yb3cnLCAnZmMtd2VlaycsIHRoZW1lLmdldENsYXNzKCdkYXlSb3cnKV07XHJcbiAgICAgICAgaWYgKGlzUmlnaWQpIHtcclxuICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1yaWdpZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1iZ1wiPicgK1xyXG4gICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJCZ1RySHRtbChyb3cpICtcclxuICAgICAgICAgICAgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1jb250ZW50LXNrZWxldG9uXCI+JyArXHJcbiAgICAgICAgICAgICc8dGFibGU+JyArXHJcbiAgICAgICAgICAgICh0aGlzLmdldElzTnVtYmVyc1Zpc2libGUoKSA/XHJcbiAgICAgICAgICAgICAgICAnPHRoZWFkPicgK1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTnVtYmVyVHJIdG1sKHJvdykgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RoZWFkPicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzwvZGl2Pic7XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0SXNOdW1iZXJzVmlzaWJsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRJc0RheU51bWJlcnNWaXNpYmxlKCkgfHwgdGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldElzRGF5TnVtYmVyc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm93Q250ID4gMTtcclxuICAgIH07XHJcbiAgICAvKiBHcmlkIE51bWJlciBSZW5kZXJpbmdcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJOdW1iZXJUckh0bWwgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzx0cj4nICtcclxuICAgICAgICAgICAgKHRoaXMuaXNSVEwgPyAnJyA6IHRoaXMucmVuZGVyTnVtYmVySW50cm9IdG1sKHJvdykpICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJOdW1iZXJDZWxsc0h0bWwocm93KSArXHJcbiAgICAgICAgICAgICh0aGlzLmlzUlRMID8gdGhpcy5yZW5kZXJOdW1iZXJJbnRyb0h0bWwocm93KSA6ICcnKSArXHJcbiAgICAgICAgICAgICc8L3RyPic7XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyTnVtYmVySW50cm9IdG1sID0gZnVuY3Rpb24gKHJvdykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlckludHJvSHRtbCgpO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck51bWJlckNlbGxzSHRtbCA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICB2YXIgaHRtbHMgPSBbXTtcclxuICAgICAgICB2YXIgY29sO1xyXG4gICAgICAgIHZhciBkYXRlO1xyXG4gICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpcy5jb2xDbnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgIGRhdGUgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgY29sKTtcclxuICAgICAgICAgICAgaHRtbHMucHVzaCh0aGlzLnJlbmRlck51bWJlckNlbGxIdG1sKGRhdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGh0bWxzLmpvaW4oJycpO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBmb3IgdGhlIDx0ZD5zIG9mIHRoZSBcIm51bWJlclwiIHJvdyBpbiB0aGUgRGF5R3JpZCdzIGNvbnRlbnQgc2tlbGV0b24uXHJcbiAgICAvLyBUaGUgbnVtYmVyIHJvdyB3aWxsIG9ubHkgZXhpc3QgaWYgZWl0aGVyIGRheSBudW1iZXJzIG9yIHdlZWsgbnVtYmVycyBhcmUgdHVybmVkIG9uLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyTnVtYmVyQ2VsbEh0bWwgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBodG1sID0gJyc7XHJcbiAgICAgICAgdmFyIGlzRGF0ZVZhbGlkID0gdGhpcy5kYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuY29udGFpbnNEYXRlKGRhdGUpOyAvLyBUT0RPOiBjYWxsZWQgdG9vIGZyZXF1ZW50bHkuIGNhY2hlIHNvbWVob3cuXHJcbiAgICAgICAgdmFyIGlzRGF5TnVtYmVyVmlzaWJsZSA9IHRoaXMuZ2V0SXNEYXlOdW1iZXJzVmlzaWJsZSgpICYmIGlzRGF0ZVZhbGlkO1xyXG4gICAgICAgIHZhciBjbGFzc2VzO1xyXG4gICAgICAgIHZhciB3ZWVrQ2FsY0ZpcnN0RG9XO1xyXG4gICAgICAgIGlmICghaXNEYXlOdW1iZXJWaXNpYmxlICYmICF0aGlzLmNlbGxXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgLy8gbm8gbnVtYmVycyBpbiBkYXkgY2VsbCAod2VlayBudW1iZXIgbXVzdCBiZSBhbG9uZyB0aGUgc2lkZSlcclxuICAgICAgICAgICAgcmV0dXJuICc8dGQ+PC90ZD4nOyAvLyAgd2lsbCBjcmVhdGUgYW4gZW1wdHkgc3BhY2UgYWJvdmUgZXZlbnRzIDooXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsYXNzZXMgPSB0aGlzLmdldERheUNsYXNzZXMoZGF0ZSk7XHJcbiAgICAgICAgY2xhc3Nlcy51bnNoaWZ0KCdmYy1kYXktdG9wJyk7XHJcbiAgICAgICAgaWYgKHRoaXMuY2VsbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAvLyBUbyBkZXRlcm1pbmUgdGhlIGRheSBvZiB3ZWVrIG51bWJlciBjaGFuZ2UgdW5kZXIgSVNPLCB3ZSBjYW5ub3RcclxuICAgICAgICAgICAgLy8gcmVseSBvbiBtb21lbnQuanMgbWV0aG9kcyBzdWNoIGFzIGZpcnN0RGF5T2ZXZWVrKCkgb3Igd2Vla2RheSgpLFxyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZXkgcmVseSBvbiB0aGUgbG9jYWxlJ3MgZG93IChwb3NzaWJseSBvdmVycmlkZGVuIGJ5XHJcbiAgICAgICAgICAgIC8vIG91ciBmaXJzdERheSBvcHRpb24pLCB3aGljaCBtYXkgbm90IGJlIE1vbmRheS4gV2UgY2Fubm90IGNoYW5nZVxyXG4gICAgICAgICAgICAvLyBkb3csIGJlY2F1c2UgdGhhdCB3b3VsZCBhZmZlY3QgdGhlIGNhbGVuZGFyIHN0YXJ0IGRheSBhcyB3ZWxsLlxyXG4gICAgICAgICAgICBpZiAoZGF0ZS5fbG9jYWxlLl9mdWxsQ2FsZW5kYXJfd2Vla0NhbGMgPT09ICdJU08nKSB7XHJcbiAgICAgICAgICAgICAgICB3ZWVrQ2FsY0ZpcnN0RG9XID0gMTsgLy8gTW9uZGF5IGJ5IElTTyA4NjAxIGRlZmluaXRpb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdlZWtDYWxjRmlyc3REb1cgPSBkYXRlLl9sb2NhbGUuZmlyc3REYXlPZldlZWsoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBodG1sICs9ICc8dGQgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcclxuICAgICAgICAgICAgKGlzRGF0ZVZhbGlkID9cclxuICAgICAgICAgICAgICAgICcgZGF0YS1kYXRlPVwiJyArIGRhdGUuZm9ybWF0KCkgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+JztcclxuICAgICAgICBpZiAodGhpcy5jZWxsV2Vla051bWJlcnNWaXNpYmxlICYmIChkYXRlLmRheSgpID09PSB3ZWVrQ2FsY0ZpcnN0RG9XKSkge1xyXG4gICAgICAgICAgICBodG1sICs9IHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbCh7IGRhdGU6IGRhdGUsIHR5cGU6ICd3ZWVrJyB9LCB7ICdjbGFzcyc6ICdmYy13ZWVrLW51bWJlcicgfSwgZGF0ZS5mb3JtYXQoJ3cnKSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0RheU51bWJlclZpc2libGUpIHtcclxuICAgICAgICAgICAgaHRtbCArPSB2aWV3LmJ1aWxkR290b0FuY2hvckh0bWwoZGF0ZSwgeyAnY2xhc3MnOiAnZmMtZGF5LW51bWJlcicgfSwgZGF0ZS5mb3JtYXQoJ0QnKSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGh0bWwgKz0gJzwvdGQ+JztcclxuICAgICAgICByZXR1cm4gaHRtbDtcclxuICAgIH07XHJcbiAgICAvKiBIaXQgU3lzdGVtXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucHJlcGFyZUhpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xDb29yZENhY2hlLmJ1aWxkKCk7XHJcbiAgICAgICAgdGhpcy5yb3dDb29yZENhY2hlLmJ1aWxkKCk7XHJcbiAgICAgICAgdGhpcy5yb3dDb29yZENhY2hlLmJvdHRvbXNbdGhpcy5yb3dDbnQgLSAxXSArPSB0aGlzLmJvdHRvbUNvb3JkUGFkZGluZzsgLy8gaGFja1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbGVhc2VIaXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29sQ29vcmRDYWNoZS5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMucm93Q29vcmRDYWNoZS5jbGVhcigpO1xyXG4gICAgfTtcclxuICAgIERheUdyaWQucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKGxlZnRPZmZzZXQsIHRvcE9mZnNldCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbENvb3JkQ2FjaGUuaXNMZWZ0SW5Cb3VuZHMobGVmdE9mZnNldCkgJiYgdGhpcy5yb3dDb29yZENhY2hlLmlzVG9wSW5Cb3VuZHModG9wT2Zmc2V0KSkge1xyXG4gICAgICAgICAgICB2YXIgY29sID0gdGhpcy5jb2xDb29yZENhY2hlLmdldEhvcml6b250YWxJbmRleChsZWZ0T2Zmc2V0KTtcclxuICAgICAgICAgICAgdmFyIHJvdyA9IHRoaXMucm93Q29vcmRDYWNoZS5nZXRWZXJ0aWNhbEluZGV4KHRvcE9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmIChyb3cgIT0gbnVsbCAmJiBjb2wgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2VsbEhpdChyb3csIGNvbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0SGl0Rm9vdHByaW50ID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMuZ2V0Q2VsbFJhbmdlKGhpdC5yb3csIGhpdC5jb2wpO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKSwgdHJ1ZSAvLyBhbGwtZGF5P1xyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0SGl0RWwgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q2VsbEVsKGhpdC5yb3csIGhpdC5jb2wpO1xyXG4gICAgfTtcclxuICAgIC8qIENlbGwgU3lzdGVtXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gRllJOiB0aGUgZmlyc3QgY29sdW1uIGlzIHRoZSBsZWZ0bW9zdCBjb2x1bW4sIHJlZ2FyZGxlc3Mgb2YgZGF0ZVxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0Q2VsbEhpdCA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHJvdzogcm93LFxyXG4gICAgICAgICAgICBjb2w6IGNvbCxcclxuICAgICAgICAgICAgY29tcG9uZW50OiB0aGlzLFxyXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLmNvbENvb3JkQ2FjaGUuZ2V0TGVmdE9mZnNldChjb2wpLFxyXG4gICAgICAgICAgICByaWdodDogdGhpcy5jb2xDb29yZENhY2hlLmdldFJpZ2h0T2Zmc2V0KGNvbCksXHJcbiAgICAgICAgICAgIHRvcDogdGhpcy5yb3dDb29yZENhY2hlLmdldFRvcE9mZnNldChyb3cpLFxyXG4gICAgICAgICAgICBib3R0b206IHRoaXMucm93Q29vcmRDYWNoZS5nZXRCb3R0b21PZmZzZXQocm93KVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0Q2VsbEVsID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbEVscy5lcShyb3cgKiB0aGlzLmNvbENudCArIGNvbCk7XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gVW5yZW5kZXJzIGFsbCBldmVudHMgY3VycmVudGx5IHJlbmRlcmVkIG9uIHRoZSBncmlkXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5leGVjdXRlRXZlbnRVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZVNlZ1BvcG92ZXIoKTsgLy8gcmVtb3ZlcyB0aGUgXCJtb3JlLi5cIiBldmVudHMgcG9wb3ZlclxyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZXhlY3V0ZUV2ZW50VW5yZW5kZXIuY2FsbCh0aGlzKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXRyaWV2ZXMgYWxsIHJlbmRlcmVkIHNlZ21lbnQgb2JqZWN0cyBjdXJyZW50bHkgcmVuZGVyZWQgb24gdGhlIGdyaWRcclxuICAgIERheUdyaWQucHJvdG90eXBlLmdldE93bkV2ZW50U2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBhcHBlbmQgdGhlIHNlZ21lbnRzIGZyb20gdGhlIFwibW9yZS4uLlwiIHBvcG92ZXJcclxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5nZXRPd25FdmVudFNlZ3MuY2FsbCh0aGlzKS5jb25jYXQodGhpcy5wb3BvdmVyU2VncyB8fCBbXSk7XHJcbiAgICB9O1xyXG4gICAgLyogRXZlbnQgRHJhZyBWaXN1YWxpemF0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IG9yIGV4dGVybmFsIGVsZW1lbnQgYmVpbmcgZHJhZ2dlZC5cclxuICAgIC8vIGBldmVudExvY2F0aW9uYCBoYXMgem9uZWQgc3RhcnQgYW5kIGVuZCAob3B0aW9uYWwpXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5yZW5kZXJEcmFnID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVuZGVyIGRyYWdzIGZyb20gT1RIRVIgY29tcG9uZW50cyBhcyBoZWxwZXJzXHJcbiAgICAgICAgaWYgKGV2ZW50Rm9vdHByaW50cy5sZW5ndGggJiYgc2VnICYmIHNlZy5jb21wb25lbnQgIT09IHRoaXMpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci5yZW5kZXJFdmVudERyYWdnaW5nRm9vdHByaW50cyhldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBzaWduYWwgaGVscGVycyByZW5kZXJlZFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgaG92ZXJpbmcgZXZlbnRcclxuICAgIERheUdyaWQucHJvdG90eXBlLnVucmVuZGVyRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFJlc2l6ZSBWaXN1YWxpemF0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci5yZW5kZXJFdmVudFJlc2l6aW5nRm9vdHByaW50cyhldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZFxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUudW5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIC8qIE1vcmUrIExpbmsgUG9wb3ZlclxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbW92ZVNlZ1BvcG92ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2VnUG9wb3Zlcikge1xyXG4gICAgICAgICAgICB0aGlzLnNlZ1BvcG92ZXIuaGlkZSgpOyAvLyBpbiBoYW5kbGVyLCB3aWxsIGNhbGwgc2VnUG9wb3ZlcidzIHJlbW92ZUVsZW1lbnRcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gTGltaXRzIHRoZSBudW1iZXIgb2YgXCJsZXZlbHNcIiAodmVydGljYWxseSBzdGFja2luZyBsYXllcnMgb2YgZXZlbnRzKSBmb3IgZWFjaCByb3cgb2YgdGhlIGdyaWQuXHJcbiAgICAvLyBgbGV2ZWxMaW1pdGAgY2FuIGJlIGZhbHNlIChkb24ndCBsaW1pdCksIGEgbnVtYmVyLCBvciB0cnVlIChzaG91bGQgYmUgY29tcHV0ZWQpLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUubGltaXRSb3dzID0gZnVuY3Rpb24gKGxldmVsTGltaXQpIHtcclxuICAgICAgICB2YXIgcm93U3RydWN0cyA9IHRoaXMuZXZlbnRSZW5kZXJlci5yb3dTdHJ1Y3RzIHx8IFtdO1xyXG4gICAgICAgIHZhciByb3c7IC8vIHJvdyAjXHJcbiAgICAgICAgdmFyIHJvd0xldmVsTGltaXQ7XHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCByb3dTdHJ1Y3RzLmxlbmd0aDsgcm93KyspIHtcclxuICAgICAgICAgICAgdGhpcy51bmxpbWl0Um93KHJvdyk7XHJcbiAgICAgICAgICAgIGlmICghbGV2ZWxMaW1pdCkge1xyXG4gICAgICAgICAgICAgICAgcm93TGV2ZWxMaW1pdCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsZXZlbExpbWl0ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgcm93TGV2ZWxMaW1pdCA9IGxldmVsTGltaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByb3dMZXZlbExpbWl0ID0gdGhpcy5jb21wdXRlUm93TGV2ZWxMaW1pdChyb3cpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChyb3dMZXZlbExpbWl0ICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saW1pdFJvdyhyb3csIHJvd0xldmVsTGltaXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIHRoZSBudW1iZXIgb2YgbGV2ZWxzIGEgcm93IHdpbGwgYWNjb21vZGF0ZSB3aXRob3V0IGdvaW5nIG91dHNpZGUgaXRzIGJvdW5kcy5cclxuICAgIC8vIEFzc3VtZXMgdGhlIHJvdyBpcyBcInJpZ2lkXCIgKG1haW50YWlucyBhIGNvbnN0YW50IGhlaWdodCByZWdhcmRsZXNzIG9mIHdoYXQgaXMgaW5zaWRlKS5cclxuICAgIC8vIGByb3dgIGlzIHRoZSByb3cgbnVtYmVyLlxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuY29tcHV0ZVJvd0xldmVsTGltaXQgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgdmFyIHJvd0VsID0gdGhpcy5yb3dFbHMuZXEocm93KTsgLy8gdGhlIGNvbnRhaW5pbmcgXCJmYWtlXCIgcm93IGRpdlxyXG4gICAgICAgIHZhciByb3dIZWlnaHQgPSByb3dFbC5oZWlnaHQoKTsgLy8gVE9ETzogY2FjaGUgc29tZWhvdz9cclxuICAgICAgICB2YXIgdHJFbHMgPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0c1tyb3ddLnRib2R5RWwuY2hpbGRyZW4oKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgdHJFbDtcclxuICAgICAgICB2YXIgdHJIZWlnaHQ7XHJcbiAgICAgICAgZnVuY3Rpb24gaXRlcklubmVySGVpZ2h0cyhpLCBjaGlsZE5vZGUpIHtcclxuICAgICAgICAgICAgdHJIZWlnaHQgPSBNYXRoLm1heCh0ckhlaWdodCwgJChjaGlsZE5vZGUpLm91dGVySGVpZ2h0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBSZXZlYWwgb25lIGxldmVsIDx0cj4gYXQgYSB0aW1lIGFuZCBzdG9wIHdoZW4gd2UgZmluZCBvbmUgb3V0IG9mIGJvdW5kc1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0ckVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0ckVsID0gdHJFbHMuZXEoaSkucmVtb3ZlQ2xhc3MoJ2ZjLWxpbWl0ZWQnKTsgLy8gcmVzZXQgdG8gb3JpZ2luYWwgc3RhdGUgKHJldmVhbClcclxuICAgICAgICAgICAgLy8gd2l0aCByb3dzcGFucz4xIGFuZCBJRTgsIHRyRWwub3V0ZXJIZWlnaHQoKSB3b3VsZCByZXR1cm4gdGhlIGhlaWdodCBvZiB0aGUgbGFyZ2VzdCBjZWxsLFxyXG4gICAgICAgICAgICAvLyBzbyBpbnN0ZWFkLCBmaW5kIHRoZSB0YWxsZXN0IGlubmVyIGNvbnRlbnQgZWxlbWVudC5cclxuICAgICAgICAgICAgdHJIZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICB0ckVsLmZpbmQoJz4gdGQgPiA6Zmlyc3QtY2hpbGQnKS5lYWNoKGl0ZXJJbm5lckhlaWdodHMpO1xyXG4gICAgICAgICAgICBpZiAodHJFbC5wb3NpdGlvbigpLnRvcCArIHRySGVpZ2h0ID4gcm93SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHNob3VsZCBub3QgbGltaXQgYXQgYWxsXHJcbiAgICB9O1xyXG4gICAgLy8gTGltaXRzIHRoZSBnaXZlbiBncmlkIHJvdyB0byB0aGUgbWF4aW11bSBudW1iZXIgb2YgbGV2ZWxzIGFuZCBpbmplY3RzIFwibW9yZVwiIGxpbmtzIGlmIG5lY2Vzc2FyeS5cclxuICAgIC8vIGByb3dgIGlzIHRoZSByb3cgbnVtYmVyLlxyXG4gICAgLy8gYGxldmVsTGltaXRgIGlzIGEgbnVtYmVyIGZvciB0aGUgbWF4aW11bSAoaW5jbHVzaXZlKSBudW1iZXIgb2YgbGV2ZWxzIGFsbG93ZWQuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5saW1pdFJvdyA9IGZ1bmN0aW9uIChyb3csIGxldmVsTGltaXQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3QgPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0c1tyb3ddO1xyXG4gICAgICAgIHZhciBtb3JlTm9kZXMgPSBbXTsgLy8gYXJyYXkgb2YgXCJtb3JlXCIgPGE+IGxpbmtzIGFuZCA8dGQ+IERPTSBub2Rlc1xyXG4gICAgICAgIHZhciBjb2wgPSAwOyAvLyBjb2wgIywgbGVmdC10by1yaWdodCAobm90IGNocm9ub2xvZ2ljYWxseSlcclxuICAgICAgICB2YXIgbGV2ZWxTZWdzOyAvLyBhcnJheSBvZiBzZWdtZW50IG9iamVjdHMgaW4gdGhlIGxhc3QgYWxsb3dhYmxlIGxldmVsLCBvcmRlcmVkIGxlZnQtdG8tcmlnaHRcclxuICAgICAgICB2YXIgY2VsbE1hdHJpeDsgLy8gYSBtYXRyaXggKGJ5IGxldmVsLCB0aGVuIGNvbHVtbikgb2YgYWxsIDx0ZD4galF1ZXJ5IGVsZW1lbnRzIGluIHRoZSByb3dcclxuICAgICAgICB2YXIgbGltaXRlZE5vZGVzOyAvLyBhcnJheSBvZiB0ZW1wb3JhcmlseSBoaWRkZW4gbGV2ZWwgPHRyPiBhbmQgc2VnbWVudCA8dGQ+IERPTSBub2Rlc1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgdmFyIHNlZ3NCZWxvdzsgLy8gYXJyYXkgb2Ygc2VnbWVudCBvYmplY3RzIGJlbG93IGBzZWdgIGluIHRoZSBjdXJyZW50IGBjb2xgXHJcbiAgICAgICAgdmFyIHRvdGFsU2Vnc0JlbG93OyAvLyB0b3RhbCBudW1iZXIgb2Ygc2VnbWVudHMgYmVsb3cgYHNlZ2AgaW4gYW55IG9mIHRoZSBjb2x1bW5zIGBzZWdgIG9jY3VwaWVzXHJcbiAgICAgICAgdmFyIGNvbFNlZ3NCZWxvdzsgLy8gYXJyYXkgb2Ygc2VnbWVudCBhcnJheXMsIGJlbG93IHNlZywgb25lIGZvciBlYWNoIGNvbHVtbiAob2Zmc2V0IGZyb20gc2VncydzIGZpcnN0IGNvbHVtbilcclxuICAgICAgICB2YXIgdGQ7XHJcbiAgICAgICAgdmFyIHJvd3NwYW47XHJcbiAgICAgICAgdmFyIHNlZ01vcmVOb2RlczsgLy8gYXJyYXkgb2YgXCJtb3JlXCIgPHRkPiBjZWxscyB0aGF0IHdpbGwgc3RhbmQtaW4gZm9yIHRoZSBjdXJyZW50IHNlZydzIGNlbGxcclxuICAgICAgICB2YXIgajtcclxuICAgICAgICB2YXIgbW9yZVRkO1xyXG4gICAgICAgIHZhciBtb3JlV3JhcDtcclxuICAgICAgICB2YXIgbW9yZUxpbms7XHJcbiAgICAgICAgLy8gSXRlcmF0ZXMgdGhyb3VnaCBlbXB0eSBsZXZlbCBjZWxscyBhbmQgcGxhY2VzIFwibW9yZVwiIGxpbmtzIGluc2lkZSBpZiBuZWVkIGJlXHJcbiAgICAgICAgdmFyIGVtcHR5Q2VsbHNVbnRpbCA9IGZ1bmN0aW9uIChlbmRDb2wpIHtcclxuICAgICAgICAgICAgd2hpbGUgKGNvbCA8IGVuZENvbCkge1xyXG4gICAgICAgICAgICAgICAgc2Vnc0JlbG93ID0gX3RoaXMuZ2V0Q2VsbFNlZ3Mocm93LCBjb2wsIGxldmVsTGltaXQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZ3NCZWxvdy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZCA9IGNlbGxNYXRyaXhbbGV2ZWxMaW1pdCAtIDFdW2NvbF07XHJcbiAgICAgICAgICAgICAgICAgICAgbW9yZUxpbmsgPSBfdGhpcy5yZW5kZXJNb3JlTGluayhyb3csIGNvbCwgc2Vnc0JlbG93KTtcclxuICAgICAgICAgICAgICAgICAgICBtb3JlV3JhcCA9ICQoJzxkaXY+JykuYXBwZW5kKG1vcmVMaW5rKTtcclxuICAgICAgICAgICAgICAgICAgICB0ZC5hcHBlbmQobW9yZVdyYXApO1xyXG4gICAgICAgICAgICAgICAgICAgIG1vcmVOb2Rlcy5wdXNoKG1vcmVXcmFwWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAobGV2ZWxMaW1pdCAmJiBsZXZlbExpbWl0IDwgcm93U3RydWN0LnNlZ0xldmVscy5sZW5ndGgpIHsgLy8gaXMgaXQgYWN0dWFsbHkgb3ZlciB0aGUgbGltaXQ/XHJcbiAgICAgICAgICAgIGxldmVsU2VncyA9IHJvd1N0cnVjdC5zZWdMZXZlbHNbbGV2ZWxMaW1pdCAtIDFdO1xyXG4gICAgICAgICAgICBjZWxsTWF0cml4ID0gcm93U3RydWN0LmNlbGxNYXRyaXg7XHJcbiAgICAgICAgICAgIGxpbWl0ZWROb2RlcyA9IHJvd1N0cnVjdC50Ym9keUVsLmNoaWxkcmVuKCkuc2xpY2UobGV2ZWxMaW1pdCkgLy8gZ2V0IGxldmVsIDx0cj4gZWxlbWVudHMgcGFzdCB0aGUgbGltaXRcclxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcygnZmMtbGltaXRlZCcpLmdldCgpOyAvLyBoaWRlIGVsZW1lbnRzIGFuZCBnZXQgYSBzaW1wbGUgRE9NLW5vZGVzIGFycmF5XHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGUgdGhvdWdoIHNlZ21lbnRzIGluIHRoZSBsYXN0IGFsbG93YWJsZSBsZXZlbFxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWxTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcgPSBsZXZlbFNlZ3NbaV07XHJcbiAgICAgICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwoc2VnLmxlZnRDb2wpOyAvLyBwcm9jZXNzIGVtcHR5IGNlbGxzIGJlZm9yZSB0aGUgc2VnbWVudFxyXG4gICAgICAgICAgICAgICAgLy8gZGV0ZXJtaW5lICphbGwqIHNlZ21lbnRzIGJlbG93IGBzZWdgIHRoYXQgb2NjdXB5IHRoZSBzYW1lIGNvbHVtbnNcclxuICAgICAgICAgICAgICAgIGNvbFNlZ3NCZWxvdyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdG90YWxTZWdzQmVsb3cgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbCA8PSBzZWcucmlnaHRDb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWdzQmVsb3cgPSB0aGlzLmdldENlbGxTZWdzKHJvdywgY29sLCBsZXZlbExpbWl0KTtcclxuICAgICAgICAgICAgICAgICAgICBjb2xTZWdzQmVsb3cucHVzaChzZWdzQmVsb3cpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsU2Vnc0JlbG93ICs9IHNlZ3NCZWxvdy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodG90YWxTZWdzQmVsb3cpIHsgLy8gZG8gd2UgbmVlZCB0byByZXBsYWNlIHRoaXMgc2VnbWVudCB3aXRoIG9uZSBvciBtYW55IFwibW9yZVwiIGxpbmtzP1xyXG4gICAgICAgICAgICAgICAgICAgIHRkID0gY2VsbE1hdHJpeFtsZXZlbExpbWl0IC0gMV1bc2VnLmxlZnRDb2xdOyAvLyB0aGUgc2VnbWVudCdzIHBhcmVudCBjZWxsXHJcbiAgICAgICAgICAgICAgICAgICAgcm93c3BhbiA9IHRkLmF0dHIoJ3Jvd3NwYW4nKSB8fCAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZ01vcmVOb2RlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYSByZXBsYWNlbWVudCA8dGQ+IGZvciBlYWNoIGNvbHVtbiB0aGUgc2VnbWVudCBvY2N1cGllcy4gd2lsbCBiZSBvbmUgZm9yIGVhY2ggY29sc3BhblxyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb2xTZWdzQmVsb3cubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZVRkID0gJCgnPHRkIGNsYXNzPVwiZmMtbW9yZS1jZWxsXCI+JykuYXR0cigncm93c3BhbicsIHJvd3NwYW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdzQmVsb3cgPSBjb2xTZWdzQmVsb3dbal07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVMaW5rID0gdGhpcy5yZW5kZXJNb3JlTGluayhyb3csIHNlZy5sZWZ0Q29sICsgaiwgW3NlZ10uY29uY2F0KHNlZ3NCZWxvdykgLy8gY291bnQgc2VnIGFzIGhpZGRlbiB0b29cclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9yZVdyYXAgPSAkKCc8ZGl2PicpLmFwcGVuZChtb3JlTGluayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vcmVUZC5hcHBlbmQobW9yZVdyYXApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWdNb3JlTm9kZXMucHVzaChtb3JlVGRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb3JlTm9kZXMucHVzaChtb3JlVGRbMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB0ZC5hZGRDbGFzcygnZmMtbGltaXRlZCcpLmFmdGVyKCQoc2VnTW9yZU5vZGVzKSk7IC8vIGhpZGUgb3JpZ2luYWwgPHRkPiBhbmQgaW5qZWN0IHJlcGxhY2VtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIGxpbWl0ZWROb2Rlcy5wdXNoKHRkWzBdKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwodGhpcy5jb2xDbnQpOyAvLyBmaW5pc2ggb2ZmIHRoZSBsZXZlbFxyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubW9yZUVscyA9ICQobW9yZU5vZGVzKTsgLy8gZm9yIGVhc3kgdW5kb2luZyBsYXRlclxyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubGltaXRlZEVscyA9ICQobGltaXRlZE5vZGVzKTsgLy8gZm9yIGVhc3kgdW5kb2luZyBsYXRlclxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZXZlYWxzIGFsbCBsZXZlbHMgYW5kIHJlbW92ZXMgYWxsIFwibW9yZVwiLXJlbGF0ZWQgZWxlbWVudHMgZm9yIGEgZ3JpZCdzIHJvdy5cclxuICAgIC8vIGByb3dgIGlzIGEgcm93IG51bWJlci5cclxuICAgIERheUdyaWQucHJvdG90eXBlLnVubGltaXRSb3cgPSBmdW5jdGlvbiAocm93KSB7XHJcbiAgICAgICAgdmFyIHJvd1N0cnVjdCA9IHRoaXMuZXZlbnRSZW5kZXJlci5yb3dTdHJ1Y3RzW3Jvd107XHJcbiAgICAgICAgaWYgKHJvd1N0cnVjdC5tb3JlRWxzKSB7XHJcbiAgICAgICAgICAgIHJvd1N0cnVjdC5tb3JlRWxzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubW9yZUVscyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyb3dTdHJ1Y3QubGltaXRlZEVscykge1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubGltaXRlZEVscy5yZW1vdmVDbGFzcygnZmMtbGltaXRlZCcpO1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QubGltaXRlZEVscyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgYW4gPGE+IGVsZW1lbnQgdGhhdCByZXByZXNlbnRzIGhpZGRlbiBldmVudCBlbGVtZW50IGZvciBhIGNlbGwuXHJcbiAgICAvLyBSZXNwb25zaWJsZSBmb3IgYXR0YWNoaW5nIGNsaWNrIGhhbmRsZXIgYXMgd2VsbC5cclxuICAgIERheUdyaWQucHJvdG90eXBlLnJlbmRlck1vcmVMaW5rID0gZnVuY3Rpb24gKHJvdywgY29sLCBoaWRkZW5TZWdzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICByZXR1cm4gJCgnPGEgY2xhc3M9XCJmYy1tb3JlXCI+JylcclxuICAgICAgICAgICAgLnRleHQodGhpcy5nZXRNb3JlTGlua1RleHQoaGlkZGVuU2Vncy5sZW5ndGgpKVxyXG4gICAgICAgICAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIHZhciBjbGlja09wdGlvbiA9IF90aGlzLm9wdCgnZXZlbnRMaW1pdENsaWNrJyk7XHJcbiAgICAgICAgICAgIHZhciBkYXRlID0gX3RoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpO1xyXG4gICAgICAgICAgICB2YXIgbW9yZUVsID0gJChldi5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAgICAgICAgdmFyIGRheUVsID0gX3RoaXMuZ2V0Q2VsbEVsKHJvdywgY29sKTtcclxuICAgICAgICAgICAgdmFyIGFsbFNlZ3MgPSBfdGhpcy5nZXRDZWxsU2Vncyhyb3csIGNvbCk7XHJcbiAgICAgICAgICAgIC8vIHJlc2NvcGUgdGhlIHNlZ21lbnRzIHRvIGJlIHdpdGhpbiB0aGUgY2VsbCdzIGRhdGVcclxuICAgICAgICAgICAgdmFyIHJlc2xpY2VkQWxsU2VncyA9IF90aGlzLnJlc2xpY2VEYXlTZWdzKGFsbFNlZ3MsIGRhdGUpO1xyXG4gICAgICAgICAgICB2YXIgcmVzbGljZWRIaWRkZW5TZWdzID0gX3RoaXMucmVzbGljZURheVNlZ3MoaGlkZGVuU2VncywgZGF0ZSk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2xpY2tPcHRpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXR1cm5lZCB2YWx1ZSBjYW4gYmUgYW4gYXRvbWljIG9wdGlvblxyXG4gICAgICAgICAgICAgICAgY2xpY2tPcHRpb24gPSBfdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50TGltaXRDbGljaycsIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiB2aWV3LFxyXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZTogZGF0ZS5jbG9uZSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF5RWw6IGRheUVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9yZUVsOiBtb3JlRWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWdzOiByZXNsaWNlZEFsbFNlZ3MsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW5TZWdzOiByZXNsaWNlZEhpZGRlblNlZ3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdcclxuICAgICAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY2xpY2tPcHRpb24gPT09ICdwb3BvdmVyJykge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2hvd1NlZ1BvcG92ZXIocm93LCBjb2wsIG1vcmVFbCwgcmVzbGljZWRBbGxTZWdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2xpY2tPcHRpb24gPT09ICdzdHJpbmcnKSB7IC8vIGEgdmlldyBuYW1lXHJcbiAgICAgICAgICAgICAgICB2aWV3LmNhbGVuZGFyLnpvb21UbyhkYXRlLCBjbGlja09wdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBSZXZlYWxzIHRoZSBwb3BvdmVyIHRoYXQgZGlzcGxheXMgYWxsIGV2ZW50cyB3aXRoaW4gYSBjZWxsXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5zaG93U2VnUG9wb3ZlciA9IGZ1bmN0aW9uIChyb3csIGNvbCwgbW9yZUxpbmssIHNlZ3MpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBtb3JlV3JhcCA9IG1vcmVMaW5rLnBhcmVudCgpOyAvLyB0aGUgPGRpdj4gd3JhcHBlciBhcm91bmQgdGhlIDxhPlxyXG4gICAgICAgIHZhciB0b3BFbDsgLy8gdGhlIGVsZW1lbnQgd2Ugd2FudCB0byBtYXRjaCB0aGUgdG9wIGNvb3JkaW5hdGUgb2ZcclxuICAgICAgICB2YXIgb3B0aW9ucztcclxuICAgICAgICBpZiAodGhpcy5yb3dDbnQgPT09IDEpIHtcclxuICAgICAgICAgICAgdG9wRWwgPSB2aWV3LmVsOyAvLyB3aWxsIGNhdXNlIHRoZSBwb3BvdmVyIHRvIGNvdmVyIGFueSBzb3J0IG9mIGhlYWRlclxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdG9wRWwgPSB0aGlzLnJvd0Vscy5lcShyb3cpOyAvLyB3aWxsIGFsaWduIHdpdGggdG9wIG9mIHJvd1xyXG4gICAgICAgIH1cclxuICAgICAgICBvcHRpb25zID0ge1xyXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmYy1tb3JlLXBvcG92ZXIgJyArIHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXInKSxcclxuICAgICAgICAgICAgY29udGVudDogdGhpcy5yZW5kZXJTZWdQb3BvdmVyQ29udGVudChyb3csIGNvbCwgc2VncyksXHJcbiAgICAgICAgICAgIHBhcmVudEVsOiB2aWV3LmVsLFxyXG4gICAgICAgICAgICB0b3A6IHRvcEVsLm9mZnNldCgpLnRvcCxcclxuICAgICAgICAgICAgYXV0b0hpZGU6IHRydWUsXHJcbiAgICAgICAgICAgIHZpZXdwb3J0Q29uc3RyYWluOiB0aGlzLm9wdCgncG9wb3ZlclZpZXdwb3J0Q29uc3RyYWluJyksXHJcbiAgICAgICAgICAgIGhpZGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIGtpbGwgZXZlcnl0aGluZyB3aGVuIHRoZSBwb3BvdmVyIGlzIGhpZGRlblxyXG4gICAgICAgICAgICAgICAgLy8gbm90aWZ5IGV2ZW50cyB0byBiZSByZW1vdmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMucG9wb3ZlclNlZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VyQmVmb3JlRXZlbnRTZWdzRGVzdHJveWVkKF90aGlzLnBvcG92ZXJTZWdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLnNlZ1BvcG92ZXIucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2VnUG9wb3ZlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5wb3BvdmVyU2VncyA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIERldGVybWluZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXHJcbiAgICAgICAgLy8gV2UgdXNlIHRoZSBtb3JlV3JhcCBpbnN0ZWFkIG9mIHRoZSA8dGQ+IHRvIGF2b2lkIGJvcmRlciBjb25mdXNpb24uXHJcbiAgICAgICAgaWYgKHRoaXMuaXNSVEwpIHtcclxuICAgICAgICAgICAgb3B0aW9ucy5yaWdodCA9IG1vcmVXcmFwLm9mZnNldCgpLmxlZnQgKyBtb3JlV3JhcC5vdXRlcldpZHRoKCkgKyAxOyAvLyArMSB0byBiZSBvdmVyIGNlbGwgYm9yZGVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvcHRpb25zLmxlZnQgPSBtb3JlV3JhcC5vZmZzZXQoKS5sZWZ0IC0gMTsgLy8gLTEgdG8gYmUgb3ZlciBjZWxsIGJvcmRlclxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnNlZ1BvcG92ZXIgPSBuZXcgUG9wb3Zlcl8xLmRlZmF1bHQob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5zZWdQb3BvdmVyLnNob3coKTtcclxuICAgICAgICAvLyB0aGUgcG9wb3ZlciBkb2Vzbid0IGxpdmUgd2l0aGluIHRoZSBncmlkJ3MgY29udGFpbmVyIGVsZW1lbnQsIGFuZCB0aHVzIHdvbid0IGdldCB0aGUgZXZlbnRcclxuICAgICAgICAvLyBkZWxlZ2F0ZWQtaGFuZGxlcnMgZm9yIGZyZWUuIGF0dGFjaCBldmVudC1yZWxhdGVkIGhhbmRsZXJzIHRvIHRoZSBwb3BvdmVyLlxyXG4gICAgICAgIHRoaXMuYmluZEFsbFNlZ0hhbmRsZXJzVG9FbCh0aGlzLnNlZ1BvcG92ZXIuZWwpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlckFmdGVyRXZlbnRTZWdzUmVuZGVyZWQoc2Vncyk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIHRoZSBpbm5lciBET00gY29udGVudHMgb2YgdGhlIHNlZ21lbnQgcG9wb3ZlclxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVuZGVyU2VnUG9wb3ZlckNvbnRlbnQgPSBmdW5jdGlvbiAocm93LCBjb2wsIHNlZ3MpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgdGhlbWUgPSB2aWV3LmNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHZhciB0aXRsZSA9IHRoaXMuZ2V0Q2VsbERhdGUocm93LCBjb2wpLmZvcm1hdCh0aGlzLm9wdCgnZGF5UG9wb3ZlckZvcm1hdCcpKTtcclxuICAgICAgICB2YXIgY29udGVudCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1oZWFkZXIgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVySGVhZGVyJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZjLWNsb3NlICcgKyB0aGVtZS5nZXRJY29uQ2xhc3MoJ2Nsb3NlJykgKyAnXCI+PC9zcGFuPicgK1xyXG4gICAgICAgICAgICAnPHNwYW4gY2xhc3M9XCJmYy10aXRsZVwiPicgK1xyXG4gICAgICAgICAgICB1dGlsXzEuaHRtbEVzY2FwZSh0aXRsZSkgK1xyXG4gICAgICAgICAgICAnPC9zcGFuPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNsZWFyXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1ib2R5ICcgKyB0aGVtZS5nZXRDbGFzcygncG9wb3ZlckNvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXJcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicpO1xyXG4gICAgICAgIHZhciBzZWdDb250YWluZXIgPSBjb250ZW50LmZpbmQoJy5mYy1ldmVudC1jb250YWluZXInKTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICAvLyByZW5kZXIgZWFjaCBzZWcncyBgZWxgIGFuZCBvbmx5IHJldHVybiB0aGUgdmlzaWJsZSBzZWdzXHJcbiAgICAgICAgc2VncyA9IHRoaXMuZXZlbnRSZW5kZXJlci5yZW5kZXJGZ1NlZ0VscyhzZWdzLCB0cnVlKTsgLy8gZGlzYWJsZVJlc2l6aW5nPXRydWVcclxuICAgICAgICB0aGlzLnBvcG92ZXJTZWdzID0gc2VncztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHNlZ21lbnRzIGluIHRoZSBwb3BvdmVyIGFyZSBub3QgcGFydCBvZiBhIGdyaWQgY29vcmRpbmF0ZSBzeXN0ZW0sIHByb3ZpZGUgYSBoaW50IHRvIGFueVxyXG4gICAgICAgICAgICAvLyBncmlkcyB0aGF0IHdhbnQgdG8gZG8gZHJhZy1uLWRyb3AgYWJvdXQgd2hpY2ggY2VsbCBpdCBjYW1lIGZyb21cclxuICAgICAgICAgICAgdGhpcy5oaXRzTmVlZGVkKCk7XHJcbiAgICAgICAgICAgIHNlZ3NbaV0uaGl0ID0gdGhpcy5nZXRDZWxsSGl0KHJvdywgY29sKTtcclxuICAgICAgICAgICAgdGhpcy5oaXRzTm90TmVlZGVkKCk7XHJcbiAgICAgICAgICAgIHNlZ0NvbnRhaW5lci5hcHBlbmQoc2Vnc1tpXS5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHRoZSBldmVudHMgd2l0aGluIGFuIGFycmF5IG9mIHNlZ21lbnQgb2JqZWN0cywgcmVzbGljZSB0aGVtIHRvIGJlIGluIGEgc2luZ2xlIGRheVxyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUucmVzbGljZURheVNlZ3MgPSBmdW5jdGlvbiAoc2VncywgZGF5RGF0ZSkge1xyXG4gICAgICAgIHZhciBkYXlTdGFydCA9IGRheURhdGUuY2xvbmUoKTtcclxuICAgICAgICB2YXIgZGF5RW5kID0gZGF5U3RhcnQuY2xvbmUoKS5hZGQoMSwgJ2RheXMnKTtcclxuICAgICAgICB2YXIgZGF5UmFuZ2UgPSBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChkYXlTdGFydCwgZGF5RW5kKTtcclxuICAgICAgICB2YXIgbmV3U2VncyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgdmFyIHNsaWNlZFJhbmdlO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIHNsaWNlZFJhbmdlID0gc2VnLmZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlLmludGVyc2VjdChkYXlSYW5nZSk7XHJcbiAgICAgICAgICAgIGlmIChzbGljZWRSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgbmV3U2Vncy5wdXNoKCQuZXh0ZW5kKHt9LCBzZWcsIHtcclxuICAgICAgICAgICAgICAgICAgICBmb290cHJpbnQ6IG5ldyBFdmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQoc2xpY2VkUmFuZ2UsIHNlZy5mb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSwgc2VnLmZvb3RwcmludC5ldmVudERlZiwgc2VnLmZvb3RwcmludC5ldmVudEluc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBzZWcuaXNTdGFydCAmJiBzbGljZWRSYW5nZS5pc1N0YXJ0LFxyXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWcuaXNFbmQgJiYgc2xpY2VkUmFuZ2UuaXNFbmRcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmb3JjZSBhbiBvcmRlciBiZWNhdXNlIGV2ZW50c1RvU2VncyBkb2Vzbid0IGd1YXJhbnRlZSBvbmVcclxuICAgICAgICAvLyBUT0RPOiByZXNlYXJjaCBpZiBzdGlsbCBuZWVkZWRcclxuICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIuc29ydEV2ZW50U2VncyhuZXdTZWdzKTtcclxuICAgICAgICByZXR1cm4gbmV3U2VncztcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIHRleHQgdGhhdCBzaG91bGQgYmUgaW5zaWRlIGEgXCJtb3JlXCIgbGluaywgZ2l2ZW4gdGhlIG51bWJlciBvZiBldmVudHMgaXQgcmVwcmVzZW50c1xyXG4gICAgRGF5R3JpZC5wcm90b3R5cGUuZ2V0TW9yZUxpbmtUZXh0ID0gZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgIHZhciBvcHQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdFRleHQnKTtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0KG51bSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJysnICsgbnVtICsgJyAnICsgb3B0O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIHNlZ21lbnRzIHdpdGhpbiBhIGdpdmVuIGNlbGwuXHJcbiAgICAvLyBJZiBgc3RhcnRMZXZlbGAgaXMgc3BlY2lmaWVkLCByZXR1cm5zIG9ubHkgZXZlbnRzIGluY2x1ZGluZyBhbmQgYmVsb3cgdGhhdCBsZXZlbC4gT3RoZXJ3aXNlIHJldHVybnMgYWxsIHNlZ3MuXHJcbiAgICBEYXlHcmlkLnByb3RvdHlwZS5nZXRDZWxsU2VncyA9IGZ1bmN0aW9uIChyb3csIGNvbCwgc3RhcnRMZXZlbCkge1xyXG4gICAgICAgIHZhciBzZWdNYXRyaXggPSB0aGlzLmV2ZW50UmVuZGVyZXIucm93U3RydWN0c1tyb3ddLnNlZ01hdHJpeDtcclxuICAgICAgICB2YXIgbGV2ZWwgPSBzdGFydExldmVsIHx8IDA7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHdoaWxlIChsZXZlbCA8IHNlZ01hdHJpeC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgc2VnID0gc2VnTWF0cml4W2xldmVsXVtjb2xdO1xyXG4gICAgICAgICAgICBpZiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goc2VnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXZlbCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF5R3JpZDtcclxufShJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IERheUdyaWQ7XHJcbkRheUdyaWQucHJvdG90eXBlLmV2ZW50UmVuZGVyZXJDbGFzcyA9IERheUdyaWRFdmVudFJlbmRlcmVyXzEuZGVmYXVsdDtcclxuRGF5R3JpZC5wcm90b3R5cGUuYnVzaW5lc3NIb3VyUmVuZGVyZXJDbGFzcyA9IEJ1c2luZXNzSG91clJlbmRlcmVyXzEuZGVmYXVsdDtcclxuRGF5R3JpZC5wcm90b3R5cGUuaGVscGVyUmVuZGVyZXJDbGFzcyA9IERheUdyaWRIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbkRheUdyaWQucHJvdG90eXBlLmZpbGxSZW5kZXJlckNsYXNzID0gRGF5R3JpZEZpbGxSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRGF5R3JpZCk7XHJcbkRheVRhYmxlTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oRGF5R3JpZCk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDY3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgU2Nyb2xsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xyXG52YXIgVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XHJcbnZhciBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OCk7XHJcbnZhciBEYXlHcmlkXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcclxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZm9yIHRoZSBcImJhc2ljXCIgdmlld3MsIGFzIHdlbGwgYXMgbW9udGggdmlldy4gUmVuZGVycyBvbmUgb3IgbW9yZSByb3dzIG9mIGRheSBjZWxscy5cclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbi8vIEl0IGlzIGEgbWFuYWdlciBmb3IgYSBEYXlHcmlkIHN1YmNvbXBvbmVudCwgd2hpY2ggZG9lcyBtb3N0IG9mIHRoZSBoZWF2eSBsaWZ0aW5nLlxyXG4vLyBJdCBpcyByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgd2lkdGgvaGVpZ2h0LlxyXG52YXIgQmFzaWNWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQmFzaWNWaWV3LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQmFzaWNWaWV3KGNhbGVuZGFyLCB2aWV3U3BlYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbGVuZGFyLCB2aWV3U3BlYykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5kYXlHcmlkID0gX3RoaXMuaW5zdGFudGlhdGVEYXlHcmlkKCk7XHJcbiAgICAgICAgX3RoaXMuZGF5R3JpZC5pc1JpZ2lkID0gX3RoaXMuaGFzUmlnaWRSb3dzKCk7XHJcbiAgICAgICAgaWYgKF90aGlzLm9wdCgnd2Vla051bWJlcnMnKSkge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0KCd3ZWVrTnVtYmVyc1dpdGhpbkRheXMnKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuZGF5R3JpZC5jZWxsV2Vla051bWJlcnNWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRheUdyaWQuY29sV2Vla051bWJlcnNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kYXlHcmlkLmNlbGxXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRheUdyaWQuY29sV2Vla051bWJlcnNWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBfdGhpcy5hZGRDaGlsZChfdGhpcy5kYXlHcmlkKTtcclxuICAgICAgICBfdGhpcy5zY3JvbGxlciA9IG5ldyBTY3JvbGxlcl8xLmRlZmF1bHQoe1xyXG4gICAgICAgICAgICBvdmVyZmxvd1g6ICdoaWRkZW4nLFxyXG4gICAgICAgICAgICBvdmVyZmxvd1k6ICdhdXRvJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgRGF5R3JpZCBvYmplY3QgdGhpcyB2aWV3IG5lZWRzLiBEcmF3cyBmcm9tIHRoaXMuZGF5R3JpZENsYXNzXHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmluc3RhbnRpYXRlRGF5R3JpZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBnZW5lcmF0ZSBhIHN1YmNsYXNzIG9uIHRoZSBmbHkgd2l0aCBCYXNpY1ZpZXctc3BlY2lmaWMgYmVoYXZpb3JcclxuICAgICAgICAvLyBUT0RPOiBjYWNoZSB0aGlzIHN1YmNsYXNzXHJcbiAgICAgICAgdmFyIHN1YmNsYXNzID0gbWFrZURheUdyaWRTdWJjbGFzcyh0aGlzLmRheUdyaWRDbGFzcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBzdWJjbGFzcyh0aGlzKTtcclxuICAgIH07XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmV4ZWN1dGVEYXRlUmVuZGVyID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdGhpcy5kYXlHcmlkLmJyZWFrT25XZWVrcyA9IC95ZWFyfG1vbnRofHdlZWsvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5leGVjdXRlRGF0ZVJlbmRlci5jYWxsKHRoaXMsIGRhdGVQcm9maWxlKTtcclxuICAgIH07XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkYXlHcmlkQ29udGFpbmVyRWw7XHJcbiAgICAgICAgdmFyIGRheUdyaWRFbDtcclxuICAgICAgICB0aGlzLmVsLmFkZENsYXNzKCdmYy1iYXNpYy12aWV3JykuaHRtbCh0aGlzLnJlbmRlclNrZWxldG9uSHRtbCgpKTtcclxuICAgICAgICB0aGlzLnNjcm9sbGVyLnJlbmRlcigpO1xyXG4gICAgICAgIGRheUdyaWRDb250YWluZXJFbCA9IHRoaXMuc2Nyb2xsZXIuZWwuYWRkQ2xhc3MoJ2ZjLWRheS1ncmlkLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIGRheUdyaWRFbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy1kYXktZ3JpZFwiPicpLmFwcGVuZFRvKGRheUdyaWRDb250YWluZXJFbCk7XHJcbiAgICAgICAgdGhpcy5lbC5maW5kKCcuZmMtYm9keSA+IHRyID4gdGQnKS5hcHBlbmQoZGF5R3JpZENvbnRhaW5lckVsKTtcclxuICAgICAgICB0aGlzLmRheUdyaWQuaGVhZENvbnRhaW5lckVsID0gdGhpcy5lbC5maW5kKCcuZmMtaGVhZC1jb250YWluZXInKTtcclxuICAgICAgICB0aGlzLmRheUdyaWQuc2V0RWxlbWVudChkYXlHcmlkRWwpO1xyXG4gICAgfTtcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUudW5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRheUdyaWQucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgSFRNTCBza2VsZXRvbiBmb3IgdGhlIHZpZXcuXHJcbiAgICAvLyBUaGUgZGF5LWdyaWQgY29tcG9uZW50IHdpbGwgcmVuZGVyIGluc2lkZSBvZiBhIGNvbnRhaW5lciBkZWZpbmVkIGJ5IHRoaXMgSFRNTC5cclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUucmVuZGVyU2tlbGV0b25IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICh0aGlzLm9wdCgnY29sdW1uSGVhZGVyJykgP1xyXG4gICAgICAgICAgICAgICAgJzx0aGVhZCBjbGFzcz1cImZjLWhlYWRcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGQgY2xhc3M9XCJmYy1oZWFkLWNvbnRhaW5lciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiPiZuYnNwOzwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGhlYWQ+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPHRib2R5IGNsYXNzPVwiZmMtYm9keVwiPicgK1xyXG4gICAgICAgICAgICAnPHRyPicgK1xyXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+PC90ZD4nICtcclxuICAgICAgICAgICAgJzwvdHI+JyArXHJcbiAgICAgICAgICAgICc8L3Rib2R5PicgK1xyXG4gICAgICAgICAgICAnPC90YWJsZT4nO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyBhbiBIVE1MIGF0dHJpYnV0ZSBzdHJpbmcgZm9yIHNldHRpbmcgdGhlIHdpZHRoIG9mIHRoZSB3ZWVrIG51bWJlciBjb2x1bW4sIGlmIGl0IGlzIGtub3duXHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLndlZWtOdW1iZXJTdHlsZUF0dHIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMud2Vla051bWJlcldpZHRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzdHlsZT1cIndpZHRoOicgKyB0aGlzLndlZWtOdW1iZXJXaWR0aCArICdweFwiJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIC8vIERldGVybWluZXMgd2hldGhlciBlYWNoIHJvdyBzaG91bGQgaGF2ZSBhIGNvbnN0YW50IGhlaWdodFxyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5oYXNSaWdpZFJvd3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TGltaXQgPSB0aGlzLm9wdCgnZXZlbnRMaW1pdCcpO1xyXG4gICAgICAgIHJldHVybiBldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ICE9PSAnbnVtYmVyJztcclxuICAgIH07XHJcbiAgICAvKiBEaW1lbnNpb25zXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVmcmVzaGVzIHRoZSBob3Jpem9udGFsIGRpbWVuc2lvbnMgb2YgdGhlIHZpZXdcclxuICAgIEJhc2ljVmlldy5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSkge1xyXG4gICAgICAgIHZhciBldmVudExpbWl0ID0gdGhpcy5vcHQoJ2V2ZW50TGltaXQnKTtcclxuICAgICAgICB2YXIgaGVhZFJvd0VsID0gdGhpcy5kYXlHcmlkLmhlYWRDb250YWluZXJFbC5maW5kKCcuZmMtcm93Jyk7XHJcbiAgICAgICAgdmFyIHNjcm9sbGVySGVpZ2h0O1xyXG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aHM7XHJcbiAgICAgICAgLy8gaGFjayB0byBnaXZlIHRoZSB2aWV3IHNvbWUgaGVpZ2h0IHByaW9yIHRvIGRheUdyaWQncyBjb2x1bW5zIGJlaW5nIHJlbmRlcmVkXHJcbiAgICAgICAgLy8gVE9ETzogc2VwYXJhdGUgc2V0dGluZyBoZWlnaHQgZnJvbSBzY3JvbGxlciBWUyBkYXlHcmlkLlxyXG4gICAgICAgIGlmICghdGhpcy5kYXlHcmlkLnJvd0Vscykge1xyXG4gICAgICAgICAgICBpZiAoIWlzQXV0bykge1xyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVNpemUuY2FsbCh0aGlzLCB0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZC5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFsbCB3ZWVrIG51bWJlciBjZWxscyBydW5uaW5nIGRvd24gdGhlIHNpZGUgaGF2ZSB0aGUgc2FtZSB3aWR0aC5cclxuICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSB3aWR0aCBmb3IgY2VsbHMgY3JlYXRlZCBsYXRlci5cclxuICAgICAgICAgICAgdGhpcy53ZWVrTnVtYmVyV2lkdGggPSB1dGlsXzEubWF0Y2hDZWxsV2lkdGhzKHRoaXMuZWwuZmluZCgnLmZjLXdlZWstbnVtYmVyJykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXNldCBhbGwgaGVpZ2h0cyB0byBiZSBuYXR1cmFsXHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5jbGVhcigpO1xyXG4gICAgICAgIHV0aWxfMS51bmNvbXBlbnNhdGVTY3JvbGwoaGVhZFJvd0VsKTtcclxuICAgICAgICB0aGlzLmRheUdyaWQucmVtb3ZlU2VnUG9wb3ZlcigpOyAvLyBraWxsIHRoZSBcIm1vcmVcIiBwb3BvdmVyIGlmIGRpc3BsYXllZFxyXG4gICAgICAgIC8vIGlzIHRoZSBldmVudCBsaW1pdCBhIGNvbnN0YW50IGxldmVsIG51bWJlcj9cclxuICAgICAgICBpZiAoZXZlbnRMaW1pdCAmJiB0eXBlb2YgZXZlbnRMaW1pdCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLmxpbWl0Um93cyhldmVudExpbWl0KTsgLy8gbGltaXQgdGhlIGxldmVscyBmaXJzdCBzbyB0aGUgaGVpZ2h0IGNhbiByZWRpc3RyaWJ1dGUgYWZ0ZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGlzdHJpYnV0ZSB0aGUgaGVpZ2h0IHRvIHRoZSByb3dzXHJcbiAgICAgICAgLy8gKHRvdGFsSGVpZ2h0IGlzIGEgXCJyZWNvbW1lbmRlZFwiIHZhbHVlIGlmIGlzQXV0bylcclxuICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICB0aGlzLnNldEdyaWRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQsIGlzQXV0byk7XHJcbiAgICAgICAgLy8gaXMgdGhlIGV2ZW50IGxpbWl0IGR5bmFtaWNhbGx5IGNhbGN1bGF0ZWQ/XHJcbiAgICAgICAgaWYgKGV2ZW50TGltaXQgJiYgdHlwZW9mIGV2ZW50TGltaXQgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5saW1pdFJvd3MoZXZlbnRMaW1pdCk7IC8vIGxpbWl0IHRoZSBsZXZlbHMgYWZ0ZXIgdGhlIGdyaWQncyByb3cgaGVpZ2h0cyBoYXZlIGJlZW4gc2V0XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNBdXRvKSB7IC8vIHNob3VsZCB3ZSBmb3JjZSBkaW1lbnNpb25zIG9mIHRoZSBzY3JvbGwgY29udGFpbmVyP1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgIHNjcm9sbGJhcldpZHRocyA9IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxiYXJXaWR0aHMubGVmdCB8fCBzY3JvbGxiYXJXaWR0aHMucmlnaHQpIHsgLy8gdXNpbmcgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIHV0aWxfMS5jb21wZW5zYXRlU2Nyb2xsKGhlYWRSb3dFbCwgc2Nyb2xsYmFyV2lkdGhzKTtcclxuICAgICAgICAgICAgICAgIC8vIGRvaW5nIHRoZSBzY3JvbGxiYXIgY29tcGVuc2F0aW9uIG1pZ2h0IGhhdmUgY3JlYXRlZCB0ZXh0IG92ZXJmbG93IHdoaWNoIGNyZWF0ZWQgbW9yZSBoZWlnaHQuIHJlZG9cclxuICAgICAgICAgICAgICAgIHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRIZWlnaHQoc2Nyb2xsZXJIZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGd1YXJhbnRlZXMgdGhlIHNhbWUgc2Nyb2xsYmFyIHdpZHRoc1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLmxvY2tPdmVyZmxvdyhzY3JvbGxiYXJXaWR0aHMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBnaXZlbiBhIGRlc2lyZWQgdG90YWwgaGVpZ2h0IG9mIHRoZSB2aWV3LCByZXR1cm5zIHdoYXQgdGhlIGhlaWdodCBvZiB0aGUgc2Nyb2xsZXIgc2hvdWxkIGJlXHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLmNvbXB1dGVTY3JvbGxlckhlaWdodCA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0b3RhbEhlaWdodCAtXHJcbiAgICAgICAgICAgIHV0aWxfMS5zdWJ0cmFjdElubmVyRWxIZWlnaHQodGhpcy5lbCwgdGhpcy5zY3JvbGxlci5lbCk7IC8vIGV2ZXJ5dGhpbmcgdGhhdCdzIE5PVCB0aGUgc2Nyb2xsZXJcclxuICAgIH07XHJcbiAgICAvLyBTZXRzIHRoZSBoZWlnaHQgb2YganVzdCB0aGUgRGF5R3JpZCBjb21wb25lbnQgaW4gdGhpcyB2aWV3XHJcbiAgICBCYXNpY1ZpZXcucHJvdG90eXBlLnNldEdyaWRIZWlnaHQgPSBmdW5jdGlvbiAoaGVpZ2h0LCBpc0F1dG8pIHtcclxuICAgICAgICBpZiAoaXNBdXRvKSB7XHJcbiAgICAgICAgICAgIHV0aWxfMS51bmRpc3RyaWJ1dGVIZWlnaHQodGhpcy5kYXlHcmlkLnJvd0Vscyk7IC8vIGxldCB0aGUgcm93cyBiZSB0aGVpciBuYXR1cmFsIGhlaWdodCB3aXRoIG5vIGV4cGFuZGluZ1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXRpbF8xLmRpc3RyaWJ1dGVIZWlnaHQodGhpcy5kYXlHcmlkLnJvd0VscywgaGVpZ2h0LCB0cnVlKTsgLy8gdHJ1ZSA9IGNvbXBlbnNhdGUgZm9yIGhlaWdodC1ob2dnaW5nIHJvd3NcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogU2Nyb2xsXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5jb21wdXRlSW5pdGlhbERhdGVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdG9wOiAwIH07XHJcbiAgICB9O1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5xdWVyeURhdGVTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgdG9wOiB0aGlzLnNjcm9sbGVyLmdldFNjcm9sbFRvcCgpIH07XHJcbiAgICB9O1xyXG4gICAgQmFzaWNWaWV3LnByb3RvdHlwZS5hcHBseURhdGVTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgaWYgKHNjcm9sbC50b3AgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldFNjcm9sbFRvcChzY3JvbGwudG9wKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJhc2ljVmlldztcclxufShWaWV3XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCYXNpY1ZpZXc7XHJcbkJhc2ljVmlldy5wcm90b3R5cGUuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yXzEuZGVmYXVsdDtcclxuQmFzaWNWaWV3LnByb3RvdHlwZS5kYXlHcmlkQ2xhc3MgPSBEYXlHcmlkXzEuZGVmYXVsdDtcclxuLy8gY3VzdG9taXplIHRoZSByZW5kZXJpbmcgYmVoYXZpb3Igb2YgQmFzaWNWaWV3J3MgZGF5R3JpZFxyXG5mdW5jdGlvbiBtYWtlRGF5R3JpZFN1YmNsYXNzKFN1cGVyQ2xhc3MpIHtcclxuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgdHNsaWJfMS5fX2V4dGVuZHMoU3ViQ2xhc3MsIF9zdXBlcik7XHJcbiAgICAgICAgZnVuY3Rpb24gU3ViQ2xhc3MoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgICAgICBfdGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUgPSBmYWxzZTsgLy8gZGlzcGxheSB3ZWVrIG51bWJlcnMgYWxvbmcgdGhlIHNpZGU/XHJcbiAgICAgICAgICAgIHJldHVybiBfdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgdGhlIGRheS1vZiB3ZWVrIGhlYWRlciBjZWxsc1xyXG4gICAgICAgIFN1YkNsYXNzLnByb3RvdHlwZS5yZW5kZXJIZWFkSW50cm9IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dGggY2xhc3M9XCJmYy13ZWVrLW51bWJlciAnICsgdmlldy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCIgJyArIHZpZXcud2Vla051bWJlclN0eWxlQXR0cigpICsgJz4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHNwYW4+JyArIC8vIG5lZWRlZCBmb3IgbWF0Y2hDZWxsV2lkdGhzXHJcbiAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmh0bWxFc2NhcGUodGhpcy5vcHQoJ3dlZWtOdW1iZXJUaXRsZScpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvc3Bhbj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90aD4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IHdpbGwgZ28gYmVmb3JlIGNvbnRlbnQtc2tlbGV0b24gY2VsbHMgdGhhdCBkaXNwbGF5IHRoZSBkYXkvd2VlayBudW1iZXJzXHJcbiAgICAgICAgU3ViQ2xhc3MucHJvdG90eXBlLnJlbmRlck51bWJlckludHJvSHRtbCA9IGZ1bmN0aW9uIChyb3cpIHtcclxuICAgICAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgICAgIHZhciB3ZWVrU3RhcnQgPSB0aGlzLmdldENlbGxEYXRlKHJvdywgMCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbFdlZWtOdW1iZXJzVmlzaWJsZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXJcIiAnICsgdmlldy53ZWVrTnVtYmVyU3R5bGVBdHRyKCkgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbCgvLyBhc2lkZSBmcm9tIGxpbmssIGltcG9ydGFudCBmb3IgbWF0Y2hDZWxsV2lkdGhzXHJcbiAgICAgICAgICAgICAgICAgICAgeyBkYXRlOiB3ZWVrU3RhcnQsIHR5cGU6ICd3ZWVrJywgZm9yY2VPZmY6IHRoaXMuY29sQ250ID09PSAxIH0sIHdlZWtTdGFydC5mb3JtYXQoJ3cnKSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGQ+JztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gJyc7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSB0aGUgZGF5IGJnIGNlbGxzIGZvciBlYWNoIGRheS1yb3dcclxuICAgICAgICBTdWJDbGFzcy5wcm90b3R5cGUucmVuZGVyQmdJbnRyb0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xXZWVrTnVtYmVyc1Zpc2libGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAnPHRkIGNsYXNzPVwiZmMtd2Vlay1udW1iZXIgJyArIHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIiAnICtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LndlZWtOdW1iZXJTdHlsZUF0dHIoKSArICc+PC90ZD4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCB0aGF0IGdvZXMgYmVmb3JlIGV2ZXJ5IG90aGVyIHR5cGUgb2Ygcm93IGdlbmVyYXRlZCBieSBEYXlHcmlkLlxyXG4gICAgICAgIC8vIEFmZmVjdHMgaGVscGVyLXNrZWxldG9uIGFuZCBoaWdobGlnaHQtc2tlbGV0b24gcm93cy5cclxuICAgICAgICBTdWJDbGFzcy5wcm90b3R5cGUucmVuZGVySW50cm9IdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cImZjLXdlZWstbnVtYmVyXCIgJyArIHZpZXcud2Vla051bWJlclN0eWxlQXR0cigpICsgJz48L3RkPic7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgU3ViQ2xhc3MucHJvdG90eXBlLmdldElzTnVtYmVyc1Zpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBEYXlHcmlkXzEuZGVmYXVsdC5wcm90b3R5cGUuZ2V0SXNOdW1iZXJzVmlzaWJsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXMuY29sV2Vla051bWJlcnNWaXNpYmxlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFN1YkNsYXNzO1xyXG4gICAgfShTdXBlckNsYXNzKSk7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogNjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBVbnpvbmVkUmFuZ2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbnZhciBEYXRlUHJvZmlsZUdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NSk7XHJcbnZhciBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gQ29tcHV0ZXMgdGhlIGRhdGUgcmFuZ2UgdGhhdCB3aWxsIGJlIHJlbmRlcmVkLlxyXG4gICAgQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmVuZGVyUmFuZ2UgPSBmdW5jdGlvbiAoY3VycmVudFVuem9uZWRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSkge1xyXG4gICAgICAgIHZhciByZW5kZXJVbnpvbmVkUmFuZ2UgPSBfc3VwZXIucHJvdG90eXBlLmJ1aWxkUmVuZGVyUmFuZ2UuY2FsbCh0aGlzLCBjdXJyZW50VW56b25lZFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KTsgLy8gYW4gVW56b25lZFJhbmdlXHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5tc1RvVXRjTW9tZW50KHJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zLCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICB2YXIgZW5kID0gdGhpcy5tc1RvVXRjTW9tZW50KHJlbmRlclVuem9uZWRSYW5nZS5lbmRNcywgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgLy8geWVhciBhbmQgbW9udGggdmlld3Mgc2hvdWxkIGJlIGFsaWduZWQgd2l0aCB3ZWVrcy4gdGhpcyBpcyBhbHJlYWR5IGRvbmUgZm9yIHdlZWtcclxuICAgICAgICBpZiAoL14oeWVhcnxtb250aCkkLy50ZXN0KGN1cnJlbnRSYW5nZVVuaXQpKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0LnN0YXJ0T2YoJ3dlZWsnKTtcclxuICAgICAgICAgICAgLy8gbWFrZSBlbmQtb2Ytd2VlayBpZiBub3QgYWxyZWFkeVxyXG4gICAgICAgICAgICBpZiAoZW5kLndlZWtkYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kLmFkZCgxLCAnd2VlaycpLnN0YXJ0T2YoJ3dlZWsnKTsgLy8gZXhjbHVzaXZlbHkgbW92ZSBiYWNrd2FyZHNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJhc2ljVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yO1xyXG59KERhdGVQcm9maWxlR2VuZXJhdG9yXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxuXG5cbi8qKiovIH0pLFxuLyogNjkgKi8sXG4vKiA3MCAqLyxcbi8qIDcxICovLFxuLyogNzIgKi8sXG4vKiA3MyAqLyxcbi8qIDc0ICovLFxuLyogNzUgKi8sXG4vKiA3NiAqLyxcbi8qIDc3ICovLFxuLyogNzggKi8sXG4vKiA3OSAqLyxcbi8qIDgwICovLFxuLyogODEgKi8sXG4vKiA4MiAqLyxcbi8qIDgzICovLFxuLyogODQgKi8sXG4vKiA4NSAqLyxcbi8qIDg2ICovLFxuLyogODcgKi8sXG4vKiA4OCAqLyxcbi8qIDg5ICovLFxuLyogOTAgKi8sXG4vKiA5MSAqLyxcbi8qIDkyICovLFxuLyogOTMgKi8sXG4vKiA5NCAqLyxcbi8qIDk1ICovLFxuLyogOTYgKi8sXG4vKiA5NyAqLyxcbi8qIDk4ICovLFxuLyogOTkgKi8sXG4vKiAxMDAgKi8sXG4vKiAxMDEgKi8sXG4vKiAxMDIgKi8sXG4vKiAxMDMgKi8sXG4vKiAxMDQgKi8sXG4vKiAxMDUgKi8sXG4vKiAxMDYgKi8sXG4vKiAxMDcgKi8sXG4vKiAxMDggKi8sXG4vKiAxMDkgKi8sXG4vKiAxMTAgKi8sXG4vKiAxMTEgKi8sXG4vKiAxMTIgKi8sXG4vKiAxMTMgKi8sXG4vKiAxMTQgKi8sXG4vKiAxMTUgKi8sXG4vKiAxMTYgKi8sXG4vKiAxMTcgKi8sXG4vKiAxMTggKi8sXG4vKiAxMTkgKi8sXG4vKiAxMjAgKi8sXG4vKiAxMjEgKi8sXG4vKiAxMjIgKi8sXG4vKiAxMjMgKi8sXG4vKiAxMjQgKi8sXG4vKiAxMjUgKi8sXG4vKiAxMjYgKi8sXG4vKiAxMjcgKi8sXG4vKiAxMjggKi8sXG4vKiAxMjkgKi8sXG4vKiAxMzAgKi8sXG4vKiAxMzEgKi8sXG4vKiAxMzIgKi8sXG4vKiAxMzMgKi8sXG4vKiAxMzQgKi8sXG4vKiAxMzUgKi8sXG4vKiAxMzYgKi8sXG4vKiAxMzcgKi8sXG4vKiAxMzggKi8sXG4vKiAxMzkgKi8sXG4vKiAxNDAgKi8sXG4vKiAxNDEgKi8sXG4vKiAxNDIgKi8sXG4vKiAxNDMgKi8sXG4vKiAxNDQgKi8sXG4vKiAxNDUgKi8sXG4vKiAxNDYgKi8sXG4vKiAxNDcgKi8sXG4vKiAxNDggKi8sXG4vKiAxNDkgKi8sXG4vKiAxNTAgKi8sXG4vKiAxNTEgKi8sXG4vKiAxNTIgKi8sXG4vKiAxNTMgKi8sXG4vKiAxNTQgKi8sXG4vKiAxNTUgKi8sXG4vKiAxNTYgKi8sXG4vKiAxNTcgKi8sXG4vKiAxNTggKi8sXG4vKiAxNTkgKi8sXG4vKiAxNjAgKi8sXG4vKiAxNjEgKi8sXG4vKiAxNjIgKi8sXG4vKiAxNjMgKi8sXG4vKiAxNjQgKi8sXG4vKiAxNjUgKi8sXG4vKiAxNjYgKi8sXG4vKiAxNjcgKi8sXG4vKiAxNjggKi8sXG4vKiAxNjkgKi8sXG4vKiAxNzAgKi8sXG4vKiAxNzEgKi8sXG4vKiAxNzIgKi8sXG4vKiAxNzMgKi8sXG4vKiAxNzQgKi8sXG4vKiAxNzUgKi8sXG4vKiAxNzYgKi8sXG4vKiAxNzcgKi8sXG4vKiAxNzggKi8sXG4vKiAxNzkgKi8sXG4vKiAxODAgKi8sXG4vKiAxODEgKi8sXG4vKiAxODIgKi8sXG4vKiAxODMgKi8sXG4vKiAxODQgKi8sXG4vKiAxODUgKi8sXG4vKiAxODYgKi8sXG4vKiAxODcgKi8sXG4vKiAxODggKi8sXG4vKiAxODkgKi8sXG4vKiAxOTAgKi8sXG4vKiAxOTEgKi8sXG4vKiAxOTIgKi8sXG4vKiAxOTMgKi8sXG4vKiAxOTQgKi8sXG4vKiAxOTUgKi8sXG4vKiAxOTYgKi8sXG4vKiAxOTcgKi8sXG4vKiAxOTggKi8sXG4vKiAxOTkgKi8sXG4vKiAyMDAgKi8sXG4vKiAyMDEgKi8sXG4vKiAyMDIgKi8sXG4vKiAyMDMgKi8sXG4vKiAyMDQgKi8sXG4vKiAyMDUgKi8sXG4vKiAyMDYgKi8sXG4vKiAyMDcgKi8sXG4vKiAyMDggKi8sXG4vKiAyMDkgKi8sXG4vKiAyMTAgKi8sXG4vKiAyMTEgKi8sXG4vKiAyMTIgKi8sXG4vKiAyMTMgKi8sXG4vKiAyMTQgKi8sXG4vKiAyMTUgKi8sXG4vKiAyMTYgKi8sXG4vKiAyMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgQ29tcG9uZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxudmFyIEV2ZW50RGVmUGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcclxudmFyIEV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcbnZhciBDb25zdHJhaW50cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIENvbnN0cmFpbnRzKGV2ZW50TWFuYWdlciwgX2NhbGVuZGFyKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIgPSBldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIgPSBfY2FsZW5kYXI7XHJcbiAgICB9XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUub3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FsZW5kYXIub3B0KG5hbWUpO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBkZXRlcm1pbmVzIGlmIGV2ZW50SW5zdGFuY2VHcm91cCBpcyBhbGxvd2VkLFxyXG4gICAgaW4gcmVsYXRpb24gdG8gb3RoZXIgRVZFTlRTIGFuZCBidXNpbmVzcyBob3Vycy5cclxuICAgICovXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkID0gZnVuY3Rpb24gKGV2ZW50SW5zdGFuY2VHcm91cCkge1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IGV2ZW50SW5zdGFuY2VHcm91cC5nZXRFdmVudERlZigpO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSB0aGlzLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMoZXZlbnRJbnN0YW5jZUdyb3VwLmdldEFsbEV2ZW50UmFuZ2VzKCkpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBwZWVyRXZlbnRJbnN0YW5jZXMgPSB0aGlzLmdldFBlZXJFdmVudEluc3RhbmNlcyhldmVudERlZik7XHJcbiAgICAgICAgdmFyIHBlZXJFdmVudFJhbmdlcyA9IHBlZXJFdmVudEluc3RhbmNlcy5tYXAodXRpbF8xLmV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UpO1xyXG4gICAgICAgIHZhciBwZWVyRXZlbnRGb290cHJpbnRzID0gdGhpcy5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKHBlZXJFdmVudFJhbmdlcyk7XHJcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRWYWwgPSBldmVudERlZi5nZXRDb25zdHJhaW50KCk7XHJcbiAgICAgICAgdmFyIG92ZXJsYXBWYWwgPSBldmVudERlZi5nZXRPdmVybGFwKCk7XHJcbiAgICAgICAgdmFyIGV2ZW50QWxsb3dGdW5jID0gdGhpcy5vcHQoJ2V2ZW50QWxsb3cnKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5pc0Zvb3RwcmludEFsbG93ZWQoZXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCwgcGVlckV2ZW50Rm9vdHByaW50cywgY29uc3RyYWludFZhbCwgb3ZlcmxhcFZhbCwgZXZlbnRGb290cHJpbnRzW2ldLmV2ZW50SW5zdGFuY2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV2ZW50QWxsb3dGdW5jKSB7XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChldmVudEFsbG93RnVuYyhldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50LnRvTGVnYWN5KHRoaXMuX2NhbGVuZGFyKSwgZXZlbnRGb290cHJpbnRzW2ldLmdldEV2ZW50TGVnYWN5KCkpID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuZ2V0UGVlckV2ZW50SW5zdGFuY2VzID0gZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRNYW5hZ2VyLmdldEV2ZW50SW5zdGFuY2VzV2l0aG91dElkKGV2ZW50RGVmLmlkKTtcclxuICAgIH07XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuaXNTZWxlY3Rpb25Gb290cHJpbnRBbGxvd2VkID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBwZWVyRXZlbnRJbnN0YW5jZXMgPSB0aGlzLmV2ZW50TWFuYWdlci5nZXRFdmVudEluc3RhbmNlcygpO1xyXG4gICAgICAgIHZhciBwZWVyRXZlbnRSYW5nZXMgPSBwZWVyRXZlbnRJbnN0YW5jZXMubWFwKHV0aWxfMS5ldmVudEluc3RhbmNlVG9FdmVudFJhbmdlKTtcclxuICAgICAgICB2YXIgcGVlckV2ZW50Rm9vdHByaW50cyA9IHRoaXMuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhwZWVyRXZlbnRSYW5nZXMpO1xyXG4gICAgICAgIHZhciBzZWxlY3RBbGxvd0Z1bmM7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNGb290cHJpbnRBbGxvd2VkKGNvbXBvbmVudEZvb3RwcmludCwgcGVlckV2ZW50Rm9vdHByaW50cywgdGhpcy5vcHQoJ3NlbGVjdENvbnN0cmFpbnQnKSwgdGhpcy5vcHQoJ3NlbGVjdE92ZXJsYXAnKSkpIHtcclxuICAgICAgICAgICAgc2VsZWN0QWxsb3dGdW5jID0gdGhpcy5vcHQoJ3NlbGVjdEFsbG93Jyk7XHJcbiAgICAgICAgICAgIGlmIChzZWxlY3RBbGxvd0Z1bmMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RBbGxvd0Z1bmMoY29tcG9uZW50Rm9vdHByaW50LnRvTGVnYWN5KHRoaXMuX2NhbGVuZGFyKSkgIT09IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5pc0Zvb3RwcmludEFsbG93ZWQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50LCBwZWVyRXZlbnRGb290cHJpbnRzLCBjb25zdHJhaW50VmFsLCBvdmVybGFwVmFsLCBzdWJqZWN0RXZlbnRJbnN0YW5jZSAvLyBvcHRpb25hbFxyXG4gICAgKSB7XHJcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRGb290cHJpbnRzOyAvLyBDb21wb25lbnRGb290cHJpbnRbXVxyXG4gICAgICAgIHZhciBvdmVybGFwRXZlbnRGb290cHJpbnRzOyAvLyBFdmVudEZvb3RwcmludFtdXHJcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRWYWwgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBjb25zdHJhaW50Rm9vdHByaW50cyA9IHRoaXMuY29uc3RyYWludFZhbFRvRm9vdHByaW50cyhjb25zdHJhaW50VmFsLCBjb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXkpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNGb290cHJpbnRXaXRoaW5Db25zdHJhaW50cyhjb21wb25lbnRGb290cHJpbnQsIGNvbnN0cmFpbnRGb290cHJpbnRzKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG92ZXJsYXBFdmVudEZvb3RwcmludHMgPSB0aGlzLmNvbGxlY3RPdmVybGFwRXZlbnRGb290cHJpbnRzKHBlZXJFdmVudEZvb3RwcmludHMsIGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgaWYgKG92ZXJsYXBWYWwgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIGlmIChvdmVybGFwRXZlbnRGb290cHJpbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBvdmVybGFwVmFsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNPdmVybGFwc0FsbG93ZWRCeUZ1bmMob3ZlcmxhcEV2ZW50Rm9vdHByaW50cywgb3ZlcmxhcFZhbCwgc3ViamVjdEV2ZW50SW5zdGFuY2UpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN1YmplY3RFdmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNPdmVybGFwRXZlbnRJbnN0YW5jZXNBbGxvd2VkKG92ZXJsYXBFdmVudEZvb3RwcmludHMsIHN1YmplY3RFdmVudEluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8vIENvbnN0cmFpbnRcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmlzRm9vdHByaW50V2l0aGluQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50LCBjb25zdHJhaW50Rm9vdHByaW50cykge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb25zdHJhaW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mb290cHJpbnRDb250YWluc0Zvb3RwcmludChjb25zdHJhaW50Rm9vdHByaW50c1tpXSwgY29tcG9uZW50Rm9vdHByaW50KSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5jb25zdHJhaW50VmFsVG9Gb290cHJpbnRzID0gZnVuY3Rpb24gKGNvbnN0cmFpbnRWYWwsIGlzQWxsRGF5KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VzO1xyXG4gICAgICAgIGlmIChjb25zdHJhaW50VmFsID09PSAnYnVzaW5lc3NIb3VycycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnVpbGRDdXJyZW50QnVzaW5lc3NGb290cHJpbnRzKGlzQWxsRGF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbnN0cmFpbnRWYWwgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VzID0gdGhpcy5wYXJzZUV2ZW50RGVmVG9JbnN0YW5jZXMoY29uc3RyYWludFZhbCk7IC8vIGhhbmRsZXMgcmVjdXJyaW5nIGV2ZW50c1xyXG4gICAgICAgICAgICBpZiAoIWV2ZW50SW5zdGFuY2VzKSB7IC8vIGludmFsaWQgaW5wdXQuIGZhbGxiYWNrIHRvIHBhcnNpbmcgZm9vdHByaW50IGRpcmVjdGx5XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZvb3RwcmludHMoY29uc3RyYWludFZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEluc3RhbmNlc1RvRm9vdHByaW50cyhldmVudEluc3RhbmNlcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29uc3RyYWludFZhbCAhPSBudWxsKSB7IC8vIGFuIElEXHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VzID0gdGhpcy5ldmVudE1hbmFnZXIuZ2V0RXZlbnRJbnN0YW5jZXNXaXRoSWQoY29uc3RyYWludFZhbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SW5zdGFuY2VzVG9Gb290cHJpbnRzKGV2ZW50SW5zdGFuY2VzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gcmV0dXJucyBDb21wb25lbnRGb290cHJpbnRbXVxyXG4gICAgLy8gdXNlcyBjdXJyZW50IHZpZXcncyByYW5nZVxyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmJ1aWxkQ3VycmVudEJ1c2luZXNzRm9vdHByaW50cyA9IGZ1bmN0aW9uIChpc0FsbERheSkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fY2FsZW5kYXIudmlldztcclxuICAgICAgICB2YXIgYnVzaW5lc3NIb3VyR2VuZXJhdG9yID0gdmlldy5nZXQoJ2J1c2luZXNzSG91ckdlbmVyYXRvcicpO1xyXG4gICAgICAgIHZhciB1bnpvbmVkUmFuZ2UgPSB2aWV3LmRhdGVQcm9maWxlLmFjdGl2ZVVuem9uZWRSYW5nZTtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3VwID0gYnVzaW5lc3NIb3VyR2VuZXJhdG9yLmJ1aWxkRXZlbnRJbnN0YW5jZUdyb3VwKGlzQWxsRGF5LCB1bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIGlmIChldmVudEluc3RhbmNlR3JvdXApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRJbnN0YW5jZXNUb0Zvb3RwcmludHMoZXZlbnRJbnN0YW5jZUdyb3VwLmV2ZW50SW5zdGFuY2VzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gY29udmVyc2lvbiB1dGlsXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuZXZlbnRJbnN0YW5jZXNUb0Zvb3RwcmludHMgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZXMpIHtcclxuICAgICAgICB2YXIgZXZlbnRSYW5nZXMgPSBldmVudEluc3RhbmNlcy5tYXAodXRpbF8xLmV2ZW50SW5zdGFuY2VUb0V2ZW50UmFuZ2UpO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSB0aGlzLmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMoZXZlbnRSYW5nZXMpO1xyXG4gICAgICAgIHJldHVybiBldmVudEZvb3RwcmludHMubWFwKHV0aWxfMS5ldmVudEZvb3RwcmludFRvQ29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgIH07XHJcbiAgICAvLyBPdmVybGFwXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5jb2xsZWN0T3ZlcmxhcEV2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChwZWVyRXZlbnRGb290cHJpbnRzLCB0YXJnZXRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwZWVyRXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZvb3RwcmludHNJbnRlcnNlY3QodGFyZ2V0Rm9vdHByaW50LCBwZWVyRXZlbnRGb290cHJpbnRzW2ldLmNvbXBvbmVudEZvb3RwcmludCkpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJsYXBFdmVudEZvb3RwcmludHMucHVzaChwZWVyRXZlbnRGb290cHJpbnRzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb3ZlcmxhcEV2ZW50Rm9vdHByaW50cztcclxuICAgIH07XHJcbiAgICAvLyBDb252ZXJzaW9uOiBldmVudERlZnMgLT4gZXZlbnRJbnN0YW5jZXMgLT4gZXZlbnRSYW5nZXMgLT4gZXZlbnRGb290cHJpbnRzIC0+IGNvbXBvbmVudEZvb3RwcmludHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gTk9URTogdGhpcyBtaWdodCBzZWVtIGxpa2UgcmVwZXRpdGl2ZSBjb2RlIHdpdGggdGhlIEdyaWQgY2xhc3MsIGhvd2V2ZXIsIHRoaXMgY29kZSBpcyByZWxhdGVkIHRvXHJcbiAgICAvLyBjb25zdHJhaW50cyB3aGVyZWFzIHRoZSBHcmlkIGNvZGUgaXMgcmVsYXRlZCB0byByZW5kZXJpbmcuIEVhY2ggYXBwcm9hY2ggbWlnaHQgd2FudCB0byBjb252ZXJ0XHJcbiAgICAvLyBldmVudFJhbmdlcyAtPiBldmVudEZvb3RwcmludHMgaW4gYSBkaWZmZXJlbnQgd2F5LiBSZWdhcmRsZXNzLCB0aGVyZSBhcmUgb3Bwb3J0dW5pdGllcyB0byBtYWtlXHJcbiAgICAvLyB0aGlzIG1vcmUgRFJZLlxyXG4gICAgLypcclxuICAgIFJldHVybnMgZmFsc2Ugb24gaW52YWxpZCBpbnB1dC5cclxuICAgICovXHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUucGFyc2VFdmVudERlZlRvSW5zdGFuY2VzID0gZnVuY3Rpb24gKGV2ZW50SW5wdXQpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gRXZlbnREZWZQYXJzZXJfMS5kZWZhdWx0LnBhcnNlKGV2ZW50SW5wdXQsIG5ldyBFdmVudFNvdXJjZV8xLmRlZmF1bHQodGhpcy5fY2FsZW5kYXIpKTtcclxuICAgICAgICBpZiAoIWV2ZW50RGVmKSB7IC8vIGludmFsaWRcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnREZWYuYnVpbGRJbnN0YW5jZXMoZXZlbnRNYW5hZ2VyLmN1cnJlbnRQZXJpb2QudW56b25lZFJhbmdlKTtcclxuICAgIH07XHJcbiAgICBDb25zdHJhaW50cy5wcm90b3R5cGUuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcykge1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciBldmVudEZvb3RwcmludHMgPSBbXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRSYW5nZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRGb290cHJpbnRzLnB1c2guYXBwbHkoLy8gZm9vdHByaW50c1xyXG4gICAgICAgICAgICBldmVudEZvb3RwcmludHMsIHRoaXMuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnRzKGV2ZW50UmFuZ2VzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBldmVudEZvb3RwcmludHM7XHJcbiAgICB9O1xyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudFJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFt1dGlsXzEuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQoZXZlbnRSYW5nZSldO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBQYXJzZXMgZm9vdHByaW50cyBkaXJlY3RseS5cclxuICAgIFZlcnkgc2ltaWxhciB0byBFdmVudERhdGVQcm9maWxlOjpwYXJzZSA6KFxyXG4gICAgKi9cclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5wYXJzZUZvb3RwcmludHMgPSBmdW5jdGlvbiAocmF3SW5wdXQpIHtcclxuICAgICAgICB2YXIgc3RhcnQ7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICBpZiAocmF3SW5wdXQuc3RhcnQpIHtcclxuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLl9jYWxlbmRhci5tb21lbnQocmF3SW5wdXQuc3RhcnQpO1xyXG4gICAgICAgICAgICBpZiAoIXN0YXJ0LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgc3RhcnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdJbnB1dC5lbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5fY2FsZW5kYXIubW9tZW50KHJhd0lucHV0LmVuZCk7XHJcbiAgICAgICAgICAgIGlmICghZW5kLmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgZW5kID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKSwgKHN0YXJ0ICYmICFzdGFydC5oYXNUaW1lKCkpIHx8IChlbmQgJiYgIWVuZC5oYXNUaW1lKCkpIC8vIGlzQWxsRGF5XHJcbiAgICAgICAgICAgIClcclxuICAgICAgICBdO1xyXG4gICAgfTtcclxuICAgIC8vIEZvb3RwcmludCBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ29uc3RyYWludHMucHJvdG90eXBlLmZvb3RwcmludENvbnRhaW5zRm9vdHByaW50ID0gZnVuY3Rpb24gKG91dGVyRm9vdHByaW50LCBpbm5lckZvb3RwcmludCkge1xyXG4gICAgICAgIHJldHVybiBvdXRlckZvb3RwcmludC51bnpvbmVkUmFuZ2UuY29udGFpbnNSYW5nZShpbm5lckZvb3RwcmludC51bnpvbmVkUmFuZ2UpO1xyXG4gICAgfTtcclxuICAgIENvbnN0cmFpbnRzLnByb3RvdHlwZS5mb290cHJpbnRzSW50ZXJzZWN0ID0gZnVuY3Rpb24gKGZvb3RwcmludDAsIGZvb3RwcmludDEpIHtcclxuICAgICAgICByZXR1cm4gZm9vdHByaW50MC51bnpvbmVkUmFuZ2UuaW50ZXJzZWN0c1dpdGgoZm9vdHByaW50MS51bnpvbmVkUmFuZ2UpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDb25zdHJhaW50cztcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ29uc3RyYWludHM7XHJcbi8vIG9wdGlvbmFsIHN1YmplY3RFdmVudEluc3RhbmNlXHJcbmZ1bmN0aW9uIGlzT3ZlcmxhcHNBbGxvd2VkQnlGdW5jKG92ZXJsYXBFdmVudEZvb3RwcmludHMsIG92ZXJsYXBGdW5jLCBzdWJqZWN0RXZlbnRJbnN0YW5jZSkge1xyXG4gICAgdmFyIGk7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmICghb3ZlcmxhcEZ1bmMob3ZlcmxhcEV2ZW50Rm9vdHByaW50c1tpXS5ldmVudEluc3RhbmNlLnRvTGVnYWN5KCksIHN1YmplY3RFdmVudEluc3RhbmNlID8gc3ViamVjdEV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSA6IG51bGwpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBpc092ZXJsYXBFdmVudEluc3RhbmNlc0FsbG93ZWQob3ZlcmxhcEV2ZW50Rm9vdHByaW50cywgc3ViamVjdEV2ZW50SW5zdGFuY2UpIHtcclxuICAgIHZhciBzdWJqZWN0TGVnYWN5SW5zdGFuY2UgPSBzdWJqZWN0RXZlbnRJbnN0YW5jZS50b0xlZ2FjeSgpO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgb3ZlcmxhcEV2ZW50SW5zdGFuY2U7XHJcbiAgICB2YXIgb3ZlcmxhcEV2ZW50RGVmO1xyXG4gICAgdmFyIG92ZXJsYXBWYWw7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgb3ZlcmxhcEV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIG92ZXJsYXBFdmVudEluc3RhbmNlID0gb3ZlcmxhcEV2ZW50Rm9vdHByaW50c1tpXS5ldmVudEluc3RhbmNlO1xyXG4gICAgICAgIG92ZXJsYXBFdmVudERlZiA9IG92ZXJsYXBFdmVudEluc3RhbmNlLmRlZjtcclxuICAgICAgICAvLyBkb24ndCBuZWVkIHRvIHBhc3MgaW4gY2FsZW5kYXIsIGJlY2F1c2UgZG9uJ3Qgd2FudCB0byBjb25zaWRlciBnbG9iYWwgZXZlbnRPdmVybGFwIHByb3BlcnR5LFxyXG4gICAgICAgIC8vIGJlY2F1c2Ugd2UgYWxyZWFkeSBjb25zaWRlcmVkIHRoYXQgZWFybGllciBpbiB0aGUgcHJvY2Vzcy5cclxuICAgICAgICBvdmVybGFwVmFsID0gb3ZlcmxhcEV2ZW50RGVmLmdldE92ZXJsYXAoKTtcclxuICAgICAgICBpZiAob3ZlcmxhcFZhbCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygb3ZlcmxhcFZhbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBpZiAoIW92ZXJsYXBWYWwob3ZlcmxhcEV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSwgc3ViamVjdExlZ2FjeUluc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XHJcbnZhciBFdmVudEluc3RhbmNlR3JvdXBfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xyXG52YXIgUmVjdXJyaW5nRXZlbnREZWZfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTQpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBCVVNJTkVTU19IT1VSX0VWRU5UX0RFRkFVTFRTID0ge1xyXG4gICAgc3RhcnQ6ICcwOTowMCcsXHJcbiAgICBlbmQ6ICcxNzowMCcsXHJcbiAgICBkb3c6IFsxLCAyLCAzLCA0LCA1XSxcclxuICAgIHJlbmRlcmluZzogJ2ludmVyc2UtYmFja2dyb3VuZCdcclxuICAgIC8vIGNsYXNzTmFtZXMgYXJlIGRlZmluZWQgaW4gYnVzaW5lc3NIb3Vyc1NlZ0NsYXNzZXNcclxufTtcclxudmFyIEJ1c2luZXNzSG91ckdlbmVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEJ1c2luZXNzSG91ckdlbmVyYXRvcihyYXdDb21wbGV4RGVmLCBjYWxlbmRhcikge1xyXG4gICAgICAgIHRoaXMucmF3Q29tcGxleERlZiA9IHJhd0NvbXBsZXhEZWY7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgfVxyXG4gICAgQnVzaW5lc3NIb3VyR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZEV2ZW50SW5zdGFuY2VHcm91cCA9IGZ1bmN0aW9uIChpc0FsbERheSwgdW56b25lZFJhbmdlKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmcyA9IHRoaXMuYnVpbGRFdmVudERlZnMoaXNBbGxEYXkpO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgaWYgKGV2ZW50RGVmcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3VwID0gbmV3IEV2ZW50SW5zdGFuY2VHcm91cF8xLmRlZmF1bHQodXRpbF8xLmV2ZW50RGVmc1RvRXZlbnRJbnN0YW5jZXMoZXZlbnREZWZzLCB1bnpvbmVkUmFuZ2UpKTtcclxuICAgICAgICAgICAgLy8gc28gdGhhdCBpbnZlcnNlLWJhY2tncm91bmQgcmVuZGVyaW5nIGNhbiBoYXBwZW4gZXZlbiB3aGVuIG5vIGV2ZW50UmFuZ2VzIGluIHZpZXdcclxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3VwLmV4cGxpY2l0RXZlbnREZWYgPSBldmVudERlZnNbMF07XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEJ1c2luZXNzSG91ckdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRFdmVudERlZnMgPSBmdW5jdGlvbiAoaXNBbGxEYXkpIHtcclxuICAgICAgICB2YXIgcmF3Q29tcGxleERlZiA9IHRoaXMucmF3Q29tcGxleERlZjtcclxuICAgICAgICB2YXIgcmF3RGVmcyA9IFtdO1xyXG4gICAgICAgIHZhciByZXF1aXJlRG93ID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGRlZnMgPSBbXTtcclxuICAgICAgICBpZiAocmF3Q29tcGxleERlZiA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgICByYXdEZWZzID0gW3t9XTsgLy8gd2lsbCBnZXQgQlVTSU5FU1NfSE9VUl9FVkVOVF9ERUZBVUxUUyB2ZXJiYXRpbVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgkLmlzUGxhaW5PYmplY3QocmF3Q29tcGxleERlZikpIHtcclxuICAgICAgICAgICAgcmF3RGVmcyA9IFtyYXdDb21wbGV4RGVmXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc0FycmF5KHJhd0NvbXBsZXhEZWYpKSB7XHJcbiAgICAgICAgICAgIHJhd0RlZnMgPSByYXdDb21wbGV4RGVmO1xyXG4gICAgICAgICAgICByZXF1aXJlRG93ID0gdHJ1ZTsgLy8gZXZlcnkgc3ViLWRlZmluaXRpb24gTkVFRFMgYSBkYXktb2Ytd2Vla1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcmF3RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIXJlcXVpcmVEb3cgfHwgcmF3RGVmc1tpXS5kb3cpIHtcclxuICAgICAgICAgICAgICAgIGRlZnMucHVzaCh0aGlzLmJ1aWxkRXZlbnREZWYoaXNBbGxEYXksIHJhd0RlZnNbaV0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVmcztcclxuICAgIH07XHJcbiAgICBCdXNpbmVzc0hvdXJHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkRXZlbnREZWYgPSBmdW5jdGlvbiAoaXNBbGxEYXksIHJhd0RlZikge1xyXG4gICAgICAgIHZhciBmdWxsUmF3RGVmID0gJC5leHRlbmQoe30sIEJVU0lORVNTX0hPVVJfRVZFTlRfREVGQVVMVFMsIHJhd0RlZik7XHJcbiAgICAgICAgaWYgKGlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGZ1bGxSYXdEZWYuc3RhcnQgPSBudWxsO1xyXG4gICAgICAgICAgICBmdWxsUmF3RGVmLmVuZCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBSZWN1cnJpbmdFdmVudERlZl8xLmRlZmF1bHQucGFyc2UoZnVsbFJhd0RlZiwgbmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdCh0aGlzLmNhbGVuZGFyKSAvLyBkdW1teSBzb3VyY2VcclxuICAgICAgICApO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBCdXNpbmVzc0hvdXJHZW5lcmF0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEJ1c2luZXNzSG91ckdlbmVyYXRvcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIFByb21pc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG52YXIgRW1pdHRlck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbnZhciBFdmVudFBlcmlvZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEV2ZW50UGVyaW9kKHN0YXJ0LCBlbmQsIHRpbWV6b25lKSB7XHJcbiAgICAgICAgdGhpcy5wZW5kaW5nQ250ID0gMDtcclxuICAgICAgICB0aGlzLmZyZWV6ZURlcHRoID0gMDtcclxuICAgICAgICB0aGlzLnN0dW50ZWRSZWxlYXNlQ250ID0gMDtcclxuICAgICAgICB0aGlzLnJlbGVhc2VDbnQgPSAwO1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBzdGFydDtcclxuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgICAgICB0aGlzLnRpbWV6b25lID0gdGltZXpvbmU7XHJcbiAgICAgICAgdGhpcy51bnpvbmVkUmFuZ2UgPSBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydC5jbG9uZSgpLnN0cmlwWm9uZSgpLCBlbmQuY2xvbmUoKS5zdHJpcFpvbmUoKSk7XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0c0J5VWlkID0ge307XHJcbiAgICAgICAgdGhpcy5ldmVudERlZnNCeVVpZCA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzQnlJZCA9IHt9O1xyXG4gICAgICAgIHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQgPSB7fTtcclxuICAgIH1cclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5pc1dpdGhpblJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICAvLyBUT0RPOiB1c2UgYSByYW5nZSB1dGlsIGZ1bmN0aW9uP1xyXG4gICAgICAgIHJldHVybiAhc3RhcnQuaXNCZWZvcmUodGhpcy5zdGFydCkgJiYgIWVuZC5pc0FmdGVyKHRoaXMuZW5kKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXF1ZXN0aW5nIGFuZCBQdXJnaW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnJlcXVlc3RTb3VyY2VzID0gZnVuY3Rpb24gKHNvdXJjZXMpIHtcclxuICAgICAgICB0aGlzLmZyZWV6ZSgpO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3RTb3VyY2Uoc291cmNlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGhhdygpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZXF1ZXN0U291cmNlID0gZnVuY3Rpb24gKHNvdXJjZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHJlcXVlc3QgPSB7IHNvdXJjZTogc291cmNlLCBzdGF0dXM6ICdwZW5kaW5nJywgZXZlbnREZWZzOiBudWxsIH07XHJcbiAgICAgICAgdGhpcy5yZXF1ZXN0c0J5VWlkW3NvdXJjZS51aWRdID0gcmVxdWVzdDtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDbnQgKz0gMTtcclxuICAgICAgICBzb3VyY2UuZmV0Y2godGhpcy5zdGFydCwgdGhpcy5lbmQsIHRoaXMudGltZXpvbmUpLnRoZW4oZnVuY3Rpb24gKGV2ZW50RGVmcykge1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgIT09ICdjYW5jZWxsZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LnN0YXR1cyA9ICdjb21wbGV0ZWQnO1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5ldmVudERlZnMgPSBldmVudERlZnM7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRFdmVudERlZnMoZXZlbnREZWZzKTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdDbnQtLTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAnY2FuY2VsbGVkJykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zdGF0dXMgPSAnZmFpbGVkJztcclxuICAgICAgICAgICAgICAgIF90aGlzLnBlbmRpbmdDbnQtLTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5wdXJnZVNvdXJjZSA9IGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdCA9IHRoaXMucmVxdWVzdHNCeVVpZFtzb3VyY2UudWlkXTtcclxuICAgICAgICBpZiAocmVxdWVzdCkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5yZXF1ZXN0c0J5VWlkW3NvdXJjZS51aWRdO1xyXG4gICAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xyXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zdGF0dXMgPSAnY2FuY2VsbGVkJztcclxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0NudC0tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cnlSZWxlYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICByZXF1ZXN0LmV2ZW50RGVmcy5mb3JFYWNoKHRoaXMucmVtb3ZlRXZlbnREZWYuYmluZCh0aGlzKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnB1cmdlQWxsU291cmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVxdWVzdHNCeVVpZCA9IHRoaXMucmVxdWVzdHNCeVVpZDtcclxuICAgICAgICB2YXIgdWlkO1xyXG4gICAgICAgIHZhciByZXF1ZXN0O1xyXG4gICAgICAgIHZhciBjb21wbGV0ZWRDbnQgPSAwO1xyXG4gICAgICAgIGZvciAodWlkIGluIHJlcXVlc3RzQnlVaWQpIHtcclxuICAgICAgICAgICAgcmVxdWVzdCA9IHJlcXVlc3RzQnlVaWRbdWlkXTtcclxuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAncGVuZGluZycpIHtcclxuICAgICAgICAgICAgICAgIHJlcXVlc3Quc3RhdHVzID0gJ2NhbmNlbGxlZCc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPT09ICdjb21wbGV0ZWQnKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlcXVlc3RzQnlVaWQgPSB7fTtcclxuICAgICAgICB0aGlzLnBlbmRpbmdDbnQgPSAwO1xyXG4gICAgICAgIGlmIChjb21wbGV0ZWRDbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxFdmVudERlZnMoKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBEZWZpbml0aW9uc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudERlZkJ5VWlkID0gZnVuY3Rpb24gKGV2ZW50RGVmVWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnREZWZzQnlVaWRbZXZlbnREZWZVaWRdO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudERlZnNCeUlkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB2YXIgYSA9IHRoaXMuZXZlbnREZWZzQnlJZFtldmVudERlZklkXTtcclxuICAgICAgICBpZiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gYS5zbGljZSgpOyAvLyBjbG9uZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmFkZEV2ZW50RGVmcyA9IGZ1bmN0aW9uIChldmVudERlZnMpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50RGVmcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZEV2ZW50RGVmKGV2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5hZGRFdmVudERlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBldmVudERlZnNCeUlkID0gdGhpcy5ldmVudERlZnNCeUlkO1xyXG4gICAgICAgIHZhciBldmVudERlZklkID0gZXZlbnREZWYuaWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmcyA9IGV2ZW50RGVmc0J5SWRbZXZlbnREZWZJZF0gfHwgKGV2ZW50RGVmc0J5SWRbZXZlbnREZWZJZF0gPSBbXSk7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VzID0gZXZlbnREZWYuYnVpbGRJbnN0YW5jZXModGhpcy51bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGV2ZW50RGVmcy5wdXNoKGV2ZW50RGVmKTtcclxuICAgICAgICB0aGlzLmV2ZW50RGVmc0J5VWlkW2V2ZW50RGVmLnVpZF0gPSBldmVudERlZjtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRJbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFdmVudEluc3RhbmNlKGV2ZW50SW5zdGFuY2VzW2ldLCBldmVudERlZklkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5nZXRFdmVudERlZnNCeUlkKGV2ZW50RGVmSWQpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50RGVmKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbW92ZUV2ZW50RGVmKGV2ZW50RGVmKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnREZWZzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpc0VtcHR5ID0gJC5pc0VtcHR5T2JqZWN0KHRoaXMuZXZlbnREZWZzQnlVaWQpO1xyXG4gICAgICAgIHRoaXMuZXZlbnREZWZzQnlVaWQgPSB7fTtcclxuICAgICAgICB0aGlzLmV2ZW50RGVmc0J5SWQgPSB7fTtcclxuICAgICAgICB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkID0ge307XHJcbiAgICAgICAgaWYgKCFpc0VtcHR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVtb3ZlRXZlbnREZWYgPSBmdW5jdGlvbiAoZXZlbnREZWYpIHtcclxuICAgICAgICB2YXIgZXZlbnREZWZzQnlJZCA9IHRoaXMuZXZlbnREZWZzQnlJZDtcclxuICAgICAgICB2YXIgZXZlbnREZWZzID0gZXZlbnREZWZzQnlJZFtldmVudERlZi5pZF07XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnREZWZzQnlVaWRbZXZlbnREZWYudWlkXTtcclxuICAgICAgICBpZiAoZXZlbnREZWZzKSB7XHJcbiAgICAgICAgICAgIHV0aWxfMS5yZW1vdmVFeGFjdChldmVudERlZnMsIGV2ZW50RGVmKTtcclxuICAgICAgICAgICAgaWYgKCFldmVudERlZnMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZXZlbnREZWZzQnlJZFtldmVudERlZi5pZF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudEluc3RhbmNlc0ZvckRlZihldmVudERlZik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IEluc3RhbmNlc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQgPSB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpZDtcclxuICAgICAgICBmb3IgKGlkIGluIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VzLnB1c2guYXBwbHkoZXZlbnRJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlR3JvdXBzQnlJZFtpZF0uZXZlbnRJbnN0YW5jZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRJbnN0YW5jZXM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmdldEV2ZW50SW5zdGFuY2VzV2l0aElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQpIHtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUdyb3VwID0gdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZFtldmVudERlZklkXTtcclxuICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZUdyb3VwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudEluc3RhbmNlR3JvdXAuZXZlbnRJbnN0YW5jZXMuc2xpY2UoKTsgLy8gY2xvbmVcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlc1dpdGhvdXRJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkID0gdGhpcy5ldmVudEluc3RhbmNlR3JvdXBzQnlJZDtcclxuICAgICAgICB2YXIgbWF0Y2hpbmdJbnN0YW5jZXMgPSBbXTtcclxuICAgICAgICB2YXIgaWQ7XHJcbiAgICAgICAgZm9yIChpZCBpbiBldmVudEluc3RhbmNlR3JvdXBzQnlJZCkge1xyXG4gICAgICAgICAgICBpZiAoaWQgIT09IGV2ZW50RGVmSWQpIHtcclxuICAgICAgICAgICAgICAgIG1hdGNoaW5nSW5zdGFuY2VzLnB1c2guYXBwbHkobWF0Y2hpbmdJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWRbaWRdLmV2ZW50SW5zdGFuY2VzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2hpbmdJbnN0YW5jZXM7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLmFkZEV2ZW50SW5zdGFuY2UgPSBmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSwgZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXBzQnlJZCA9IHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cCA9IGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmSWRdIHx8XHJcbiAgICAgICAgICAgIChldmVudEluc3RhbmNlR3JvdXBzQnlJZFtldmVudERlZklkXSA9IG5ldyBFdmVudEluc3RhbmNlR3JvdXBfMS5kZWZhdWx0KCkpO1xyXG4gICAgICAgIGV2ZW50SW5zdGFuY2VHcm91cC5ldmVudEluc3RhbmNlcy5wdXNoKGV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgIHRoaXMudHJ5UmVsZWFzZSgpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5yZW1vdmVFdmVudEluc3RhbmNlc0ZvckRlZiA9IGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXBzQnlJZCA9IHRoaXMuZXZlbnRJbnN0YW5jZUdyb3Vwc0J5SWQ7XHJcbiAgICAgICAgdmFyIGV2ZW50SW5zdGFuY2VHcm91cCA9IGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmLmlkXTtcclxuICAgICAgICB2YXIgcmVtb3ZlQ250O1xyXG4gICAgICAgIGlmIChldmVudEluc3RhbmNlR3JvdXApIHtcclxuICAgICAgICAgICAgcmVtb3ZlQ250ID0gdXRpbF8xLnJlbW92ZU1hdGNoaW5nKGV2ZW50SW5zdGFuY2VHcm91cC5ldmVudEluc3RhbmNlcywgZnVuY3Rpb24gKGN1cnJlbnRFdmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudEV2ZW50SW5zdGFuY2UuZGVmID09PSBldmVudERlZjtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmICghZXZlbnRJbnN0YW5jZUdyb3VwLmV2ZW50SW5zdGFuY2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50SW5zdGFuY2VHcm91cHNCeUlkW2V2ZW50RGVmLmlkXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocmVtb3ZlQ250KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBSZWxlYXNpbmcgYW5kIEZyZWV6aW5nXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnRyeVJlbGVhc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBlbmRpbmdDbnQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmZyZWV6ZURlcHRoKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGVhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3R1bnRlZFJlbGVhc2VDbnQrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnJlbGVhc2VDbnQrKztcclxuICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlbGVhc2UnLCB0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKTtcclxuICAgIH07XHJcbiAgICBFdmVudFBlcmlvZC5wcm90b3R5cGUud2hlblJlbGVhc2VkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMucmVsZWFzZUNudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZV8xLmRlZmF1bHQucmVzb2x2ZSh0aGlzLmV2ZW50SW5zdGFuY2VHcm91cHNCeUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlXzEuZGVmYXVsdC5jb25zdHJ1Y3QoZnVuY3Rpb24gKG9uUmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMub25lKCdyZWxlYXNlJywgb25SZXNvbHZlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50UGVyaW9kLnByb3RvdHlwZS5mcmVlemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcy5mcmVlemVEZXB0aCsrKSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0dW50ZWRSZWxlYXNlQ250ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRQZXJpb2QucHJvdG90eXBlLnRoYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEoLS10aGlzLmZyZWV6ZURlcHRoKSAmJiB0aGlzLnN0dW50ZWRSZWxlYXNlQ250ICYmICF0aGlzLnBlbmRpbmdDbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWxlYXNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBFdmVudFBlcmlvZDtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRQZXJpb2Q7XHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhFdmVudFBlcmlvZCk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBFdmVudFBlcmlvZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMTkpO1xyXG52YXIgQXJyYXlFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIEV2ZW50U291cmNlUGFyc2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcclxudmFyIFNpbmdsZUV2ZW50RGVmXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG52YXIgRXZlbnRJbnN0YW5jZUdyb3VwXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgRXZlbnRNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRXZlbnRNYW5hZ2VyKGNhbGVuZGFyKSB7XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIHRoaXMuc3RpY2t5U291cmNlID0gbmV3IEFycmF5RXZlbnRTb3VyY2VfMS5kZWZhdWx0KGNhbGVuZGFyKTtcclxuICAgICAgICB0aGlzLm90aGVyU291cmNlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZXF1ZXN0RXZlbnRzID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRpbWV6b25lLCBmb3JjZSkge1xyXG4gICAgICAgIGlmIChmb3JjZSB8fFxyXG4gICAgICAgICAgICAhdGhpcy5jdXJyZW50UGVyaW9kIHx8XHJcbiAgICAgICAgICAgICF0aGlzLmN1cnJlbnRQZXJpb2QuaXNXaXRoaW5SYW5nZShzdGFydCwgZW5kKSB8fFxyXG4gICAgICAgICAgICB0aW1lem9uZSAhPT0gdGhpcy5jdXJyZW50UGVyaW9kLnRpbWV6b25lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0UGVyaW9kKC8vIHdpbGwgY2hhbmdlIHRoaXMuY3VycmVudFBlcmlvZFxyXG4gICAgICAgICAgICBuZXcgRXZlbnRQZXJpb2RfMS5kZWZhdWx0KHN0YXJ0LCBlbmQsIHRpbWV6b25lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQZXJpb2Qud2hlblJlbGVhc2VkKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gU291cmNlIEFkZGluZy9SZW1vdmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuYWRkU291cmNlID0gZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5vdGhlclNvdXJjZXMucHVzaChldmVudFNvdXJjZSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucmVxdWVzdFNvdXJjZShldmVudFNvdXJjZSk7IC8vIG1pZ2h0IHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVTb3VyY2UgPSBmdW5jdGlvbiAoZG9vbWVkU291cmNlKSB7XHJcbiAgICAgICAgdXRpbF8xLnJlbW92ZUV4YWN0KHRoaXMub3RoZXJTb3VyY2VzLCBkb29tZWRTb3VyY2UpO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLnB1cmdlU291cmNlKGRvb21lZFNvdXJjZSk7IC8vIG1pZ2h0IHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5yZW1vdmVBbGxTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMub3RoZXJTb3VyY2VzID0gW107XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucHVyZ2VBbGxTb3VyY2VzKCk7IC8vIG1pZ2h0IHJlbGVhc2VcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gU291cmNlIFJlZmV0Y2hpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlZmV0Y2hTb3VyY2UgPSBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHtcclxuICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IHRoaXMuY3VycmVudFBlcmlvZDtcclxuICAgICAgICBpZiAoY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLnB1cmdlU291cmNlKGV2ZW50U291cmNlKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5yZXF1ZXN0U291cmNlKGV2ZW50U291cmNlKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUucmVmZXRjaEFsbFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRQZXJpb2QgPSB0aGlzLmN1cnJlbnRQZXJpb2Q7XHJcbiAgICAgICAgaWYgKGN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5mcmVlemUoKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5wdXJnZUFsbFNvdXJjZXMoKTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC5yZXF1ZXN0U291cmNlcyh0aGlzLmdldFNvdXJjZXMoKSk7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QudGhhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTb3VyY2UgUXVlcnlpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLnN0aWNreVNvdXJjZV0uY29uY2F0KHRoaXMub3RoZXJTb3VyY2VzKTtcclxuICAgIH07XHJcbiAgICAvLyBsaWtlIHF1ZXJ5U291cmNlcywgYnV0IGFjY2VwdHMgbXVsdHBsZSBtYXRjaCBjcml0ZXJpYSAobGlrZSBtdWx0aXBsZSBJRHMpXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLm11bHRpUXVlcnlTb3VyY2VzID0gZnVuY3Rpb24gKG1hdGNoSW5wdXRzKSB7XHJcbiAgICAgICAgLy8gY29lcmNlIGludG8gYW4gYXJyYXlcclxuICAgICAgICBpZiAoIW1hdGNoSW5wdXRzKSB7XHJcbiAgICAgICAgICAgIG1hdGNoSW5wdXRzID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCEkLmlzQXJyYXkobWF0Y2hJbnB1dHMpKSB7XHJcbiAgICAgICAgICAgIG1hdGNoSW5wdXRzID0gW21hdGNoSW5wdXRzXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG1hdGNoaW5nU291cmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIC8vIHJlc29sdmUgcmF3IGlucHV0cyB0byByZWFsIGV2ZW50IHNvdXJjZSBvYmplY3RzXHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG1hdGNoSW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG1hdGNoaW5nU291cmNlcy5wdXNoLmFwcGx5KC8vIGFwcGVuZFxyXG4gICAgICAgICAgICBtYXRjaGluZ1NvdXJjZXMsIHRoaXMucXVlcnlTb3VyY2VzKG1hdGNoSW5wdXRzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRjaGluZ1NvdXJjZXM7XHJcbiAgICB9O1xyXG4gICAgLy8gbWF0Y2hJbnB1dCBjYW4gZWl0aGVyIGJ5IGEgcmVhbCBldmVudCBzb3VyY2Ugb2JqZWN0LCBhbiBJRCwgb3IgdGhlIGZ1bmN0aW9uL1VSTCBmb3IgdGhlIHNvdXJjZS5cclxuICAgIC8vIHJldHVybnMgYW4gYXJyYXkgb2YgbWF0Y2hpbmcgc291cmNlIG9iamVjdHMuXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnF1ZXJ5U291cmNlcyA9IGZ1bmN0aW9uIChtYXRjaElucHV0KSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZXMgPSB0aGlzLm90aGVyU291cmNlcztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc291cmNlO1xyXG4gICAgICAgIC8vIGdpdmVuIGEgcHJvcGVyIGV2ZW50IHNvdXJjZSBvYmplY3RcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzb3VyY2UgPSBzb3VyY2VzW2ldO1xyXG4gICAgICAgICAgICBpZiAoc291cmNlID09PSBtYXRjaElucHV0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NvdXJjZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYW4gSUQgbWF0Y2hcclxuICAgICAgICBzb3VyY2UgPSB0aGlzLmdldFNvdXJjZUJ5SWQoRXZlbnRTb3VyY2VfMS5kZWZhdWx0Lm5vcm1hbGl6ZUlkKG1hdGNoSW5wdXQpKTtcclxuICAgICAgICBpZiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbc291cmNlXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcGFyc2UgYXMgYW4gZXZlbnQgc291cmNlXHJcbiAgICAgICAgbWF0Y2hJbnB1dCA9IEV2ZW50U291cmNlUGFyc2VyXzEuZGVmYXVsdC5wYXJzZShtYXRjaElucHV0LCB0aGlzLmNhbGVuZGFyKTtcclxuICAgICAgICBpZiAobWF0Y2hJbnB1dCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJC5ncmVwKHNvdXJjZXMsIGZ1bmN0aW9uIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc1NvdXJjZXNFcXVpdmFsZW50KG1hdGNoSW5wdXQsIHNvdXJjZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKlxyXG4gICAgSUQgYXNzdW1lZCB0byBhbHJlYWR5IGJlIG5vcm1hbGl6ZWRcclxuICAgICovXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmdldFNvdXJjZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICByZXR1cm4gJC5ncmVwKHRoaXMub3RoZXJTb3VyY2VzLCBmdW5jdGlvbiAoc291cmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2UuaWQgJiYgc291cmNlLmlkID09PSBpZDtcclxuICAgICAgICB9KVswXTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudC1QZXJpb2RcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnNldFBlcmlvZCA9IGZ1bmN0aW9uIChldmVudFBlcmlvZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy51bmJpbmRQZXJpb2QodGhpcy5jdXJyZW50UGVyaW9kKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kID0gZXZlbnRQZXJpb2Q7XHJcbiAgICAgICAgdGhpcy5iaW5kUGVyaW9kKGV2ZW50UGVyaW9kKTtcclxuICAgICAgICBldmVudFBlcmlvZC5yZXF1ZXN0U291cmNlcyh0aGlzLmdldFNvdXJjZXMoKSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5iaW5kUGVyaW9kID0gZnVuY3Rpb24gKGV2ZW50UGVyaW9kKSB7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5UbyhldmVudFBlcmlvZCwgJ3JlbGVhc2UnLCBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ3JlbGVhc2UnLCBldmVudHNQYXlsb2FkKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnVuYmluZFBlcmlvZCA9IGZ1bmN0aW9uIChldmVudFBlcmlvZCkge1xyXG4gICAgICAgIHRoaXMuc3RvcExpc3RlbmluZ1RvKGV2ZW50UGVyaW9kKTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBHZXR0aW5nL0FkZGluZy9SZW1vdmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnREZWZCeVVpZCA9IGZ1bmN0aW9uICh1aWQpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQZXJpb2QuZ2V0RXZlbnREZWZCeVVpZCh1aWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLmFkZEV2ZW50RGVmID0gZnVuY3Rpb24gKGV2ZW50RGVmLCBpc1N0aWNreSkge1xyXG4gICAgICAgIGlmIChpc1N0aWNreSkge1xyXG4gICAgICAgICAgICB0aGlzLnN0aWNreVNvdXJjZS5hZGRFdmVudERlZihldmVudERlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLmFkZEV2ZW50RGVmKGV2ZW50RGVmKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50RGVmc0J5SWQgPSBmdW5jdGlvbiAoZXZlbnRJZCkge1xyXG4gICAgICAgIHRoaXMuZ2V0U291cmNlcygpLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7XHJcbiAgICAgICAgICAgIGV2ZW50U291cmNlLnJlbW92ZUV2ZW50RGVmc0J5SWQoZXZlbnRJZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QucmVtb3ZlRXZlbnREZWZzQnlJZChldmVudElkKTsgLy8gbWlnaHQgcmVsZWFzZVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnJlbW92ZUFsbEV2ZW50RGVmcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmdldFNvdXJjZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudFNvdXJjZSkge1xyXG4gICAgICAgICAgICBldmVudFNvdXJjZS5yZW1vdmVBbGxFdmVudERlZnMoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGVyaW9kKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBlcmlvZC5yZW1vdmVBbGxFdmVudERlZnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgTXV0YXRpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvKlxyXG4gICAgUmV0dXJucyBhbiB1bmRvIGZ1bmN0aW9uLlxyXG4gICAgKi9cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUubXV0YXRlRXZlbnRzV2l0aElkID0gZnVuY3Rpb24gKGV2ZW50RGVmSWQsIGV2ZW50RGVmTXV0YXRpb24pIHtcclxuICAgICAgICB2YXIgY3VycmVudFBlcmlvZCA9IHRoaXMuY3VycmVudFBlcmlvZDtcclxuICAgICAgICB2YXIgZXZlbnREZWZzO1xyXG4gICAgICAgIHZhciB1bmRvRnVuY3MgPSBbXTtcclxuICAgICAgICBpZiAoY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICBldmVudERlZnMgPSBjdXJyZW50UGVyaW9kLmdldEV2ZW50RGVmc0J5SWQoZXZlbnREZWZJZCk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmcy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgLy8gYWRkL3JlbW92ZSBlc3AgYmVjYXVzZSBpZCBtaWdodCBjaGFuZ2VcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QucmVtb3ZlRXZlbnREZWYoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICAgICAgdW5kb0Z1bmNzLnB1c2goZXZlbnREZWZNdXRhdGlvbi5tdXRhdGVTaW5nbGUoZXZlbnREZWYpKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJpb2QuYWRkRXZlbnREZWYoZXZlbnREZWYpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50UGVyaW9kLnJlbW92ZUV2ZW50RGVmKGV2ZW50RGVmc1tpXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5kb0Z1bmNzW2ldKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFBlcmlvZC5hZGRFdmVudERlZihldmVudERlZnNbaV0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY3VycmVudFBlcmlvZC50aGF3KCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIGNvcGllcyBhbmQgdGhlbiBtdXRhdGVzXHJcbiAgICAqL1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5idWlsZE11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCwgZXZlbnREZWZNdXRhdGlvbikge1xyXG4gICAgICAgIHZhciBldmVudERlZnMgPSB0aGlzLmdldEV2ZW50RGVmc0J5SWQoZXZlbnREZWZJZCk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGRlZkNvcHk7XHJcbiAgICAgICAgdmFyIGFsbEluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudERlZnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZGVmQ29weSA9IGV2ZW50RGVmc1tpXS5jbG9uZSgpO1xyXG4gICAgICAgICAgICBpZiAoZGVmQ29weSBpbnN0YW5jZW9mIFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbi5tdXRhdGVTaW5nbGUoZGVmQ29weSk7XHJcbiAgICAgICAgICAgICAgICBhbGxJbnN0YW5jZXMucHVzaC5hcHBseShhbGxJbnN0YW5jZXMsIC8vIGFwcGVuZFxyXG4gICAgICAgICAgICAgICAgZGVmQ29weS5idWlsZEluc3RhbmNlcygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50SW5zdGFuY2VHcm91cF8xLmRlZmF1bHQoYWxsSW5zdGFuY2VzKTtcclxuICAgIH07XHJcbiAgICAvLyBGcmVlemluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZnJlZXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQZXJpb2QpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50UGVyaW9kLmZyZWV6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudE1hbmFnZXIucHJvdG90eXBlLnRoYXcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudFBlcmlvZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQZXJpb2QudGhhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBtZXRob2RzIHRoYXQgc2ltcGx5IGZvcndhcmQgdG8gRXZlbnRQZXJpb2RcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnREZWZzQnlJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudERlZnNCeUlkKGV2ZW50RGVmSWQpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnRJbnN0YW5jZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudEluc3RhbmNlcygpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50TWFuYWdlci5wcm90b3R5cGUuZ2V0RXZlbnRJbnN0YW5jZXNXaXRoSWQgPSBmdW5jdGlvbiAoZXZlbnREZWZJZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRQZXJpb2QuZ2V0RXZlbnRJbnN0YW5jZXNXaXRoSWQoZXZlbnREZWZJZCk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRNYW5hZ2VyLnByb3RvdHlwZS5nZXRFdmVudEluc3RhbmNlc1dpdGhvdXRJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFBlcmlvZC5nZXRFdmVudEluc3RhbmNlc1dpdGhvdXRJZChldmVudERlZklkKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRNYW5hZ2VyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudE1hbmFnZXI7XHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhFdmVudE1hbmFnZXIpO1xyXG5MaXN0ZW5lck1peGluXzEuZGVmYXVsdC5taXhJbnRvKEV2ZW50TWFuYWdlcik7XHJcbmZ1bmN0aW9uIGlzU291cmNlc0VxdWl2YWxlbnQoc291cmNlMCwgc291cmNlMSkge1xyXG4gICAgcmV0dXJuIHNvdXJjZTAuZ2V0UHJpbWl0aXZlKCkgPT09IHNvdXJjZTEuZ2V0UHJpbWl0aXZlKCk7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG52YXIgU3RhbmRhcmRUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFN0YW5kYXJkVGhlbWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBTdGFuZGFyZFRoZW1lKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBTdGFuZGFyZFRoZW1lO1xyXG59KFRoZW1lXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBTdGFuZGFyZFRoZW1lO1xyXG5TdGFuZGFyZFRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge1xyXG4gICAgd2lkZ2V0OiAnZmMtdW50aGVtZWQnLFxyXG4gICAgd2lkZ2V0SGVhZGVyOiAnZmMtd2lkZ2V0LWhlYWRlcicsXHJcbiAgICB3aWRnZXRDb250ZW50OiAnZmMtd2lkZ2V0LWNvbnRlbnQnLFxyXG4gICAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxyXG4gICAgYnV0dG9uOiAnZmMtYnV0dG9uJyxcclxuICAgIGNvcm5lckxlZnQ6ICdmYy1jb3JuZXItbGVmdCcsXHJcbiAgICBjb3JuZXJSaWdodDogJ2ZjLWNvcm5lci1yaWdodCcsXHJcbiAgICBzdGF0ZURlZmF1bHQ6ICdmYy1zdGF0ZS1kZWZhdWx0JyxcclxuICAgIHN0YXRlQWN0aXZlOiAnZmMtc3RhdGUtYWN0aXZlJyxcclxuICAgIHN0YXRlRGlzYWJsZWQ6ICdmYy1zdGF0ZS1kaXNhYmxlZCcsXHJcbiAgICBzdGF0ZUhvdmVyOiAnZmMtc3RhdGUtaG92ZXInLFxyXG4gICAgc3RhdGVEb3duOiAnZmMtc3RhdGUtZG93bicsXHJcbiAgICBwb3BvdmVySGVhZGVyOiAnZmMtd2lkZ2V0LWhlYWRlcicsXHJcbiAgICBwb3BvdmVyQ29udGVudDogJ2ZjLXdpZGdldC1jb250ZW50JyxcclxuICAgIC8vIGRheSBncmlkXHJcbiAgICBoZWFkZXJSb3c6ICdmYy13aWRnZXQtaGVhZGVyJyxcclxuICAgIGRheVJvdzogJ2ZjLXdpZGdldC1jb250ZW50JyxcclxuICAgIC8vIGxpc3Qgdmlld1xyXG4gICAgbGlzdFZpZXc6ICdmYy13aWRnZXQtY29udGVudCdcclxufTtcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYy1pY29uJztcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XHJcbiAgICBjbG9zZTogJ2ZjLWljb24teCcsXHJcbiAgICBwcmV2OiAnZmMtaWNvbi1sZWZ0LXNpbmdsZS1hcnJvdycsXHJcbiAgICBuZXh0OiAnZmMtaWNvbi1yaWdodC1zaW5nbGUtYXJyb3cnLFxyXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWxlZnQtZG91YmxlLWFycm93JyxcclxuICAgIG5leHRZZWFyOiAnZmMtaWNvbi1yaWdodC1kb3VibGUtYXJyb3cnXHJcbn07XHJcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZU9wdGlvbiA9ICdidXR0b25JY29ucyc7XHJcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICdpY29uJztcclxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZjLWljb24tJztcclxuXG5cbi8qKiovIH0pLFxuLyogMjIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xyXG52YXIgSnF1ZXJ5VWlUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEpxdWVyeVVpVGhlbWUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBKcXVlcnlVaVRoZW1lKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIHJldHVybiBKcXVlcnlVaVRoZW1lO1xyXG59KFRoZW1lXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBKcXVlcnlVaVRoZW1lO1xyXG5KcXVlcnlVaVRoZW1lLnByb3RvdHlwZS5jbGFzc2VzID0ge1xyXG4gICAgd2lkZ2V0OiAndWktd2lkZ2V0JyxcclxuICAgIHdpZGdldEhlYWRlcjogJ3VpLXdpZGdldC1oZWFkZXInLFxyXG4gICAgd2lkZ2V0Q29udGVudDogJ3VpLXdpZGdldC1jb250ZW50JyxcclxuICAgIGJ1dHRvbkdyb3VwOiAnZmMtYnV0dG9uLWdyb3VwJyxcclxuICAgIGJ1dHRvbjogJ3VpLWJ1dHRvbicsXHJcbiAgICBjb3JuZXJMZWZ0OiAndWktY29ybmVyLWxlZnQnLFxyXG4gICAgY29ybmVyUmlnaHQ6ICd1aS1jb3JuZXItcmlnaHQnLFxyXG4gICAgc3RhdGVEZWZhdWx0OiAndWktc3RhdGUtZGVmYXVsdCcsXHJcbiAgICBzdGF0ZUFjdGl2ZTogJ3VpLXN0YXRlLWFjdGl2ZScsXHJcbiAgICBzdGF0ZURpc2FibGVkOiAndWktc3RhdGUtZGlzYWJsZWQnLFxyXG4gICAgc3RhdGVIb3ZlcjogJ3VpLXN0YXRlLWhvdmVyJyxcclxuICAgIHN0YXRlRG93bjogJ3VpLXN0YXRlLWRvd24nLFxyXG4gICAgdG9kYXk6ICd1aS1zdGF0ZS1oaWdobGlnaHQnLFxyXG4gICAgcG9wb3ZlckhlYWRlcjogJ3VpLXdpZGdldC1oZWFkZXInLFxyXG4gICAgcG9wb3ZlckNvbnRlbnQ6ICd1aS13aWRnZXQtY29udGVudCcsXHJcbiAgICAvLyBkYXkgZ3JpZFxyXG4gICAgaGVhZGVyUm93OiAndWktd2lkZ2V0LWhlYWRlcicsXHJcbiAgICBkYXlSb3c6ICd1aS13aWRnZXQtY29udGVudCcsXHJcbiAgICAvLyBsaXN0IHZpZXdcclxuICAgIGxpc3RWaWV3OiAndWktd2lkZ2V0LWNvbnRlbnQnXHJcbn07XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAndWktaWNvbic7XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xyXG4gICAgY2xvc2U6ICd1aS1pY29uLWNsb3NldGhpY2snLFxyXG4gICAgcHJldjogJ3VpLWljb24tY2lyY2xlLXRyaWFuZ2xlLXcnLFxyXG4gICAgbmV4dDogJ3VpLWljb24tY2lyY2xlLXRyaWFuZ2xlLWUnLFxyXG4gICAgcHJldlllYXI6ICd1aS1pY29uLXNlZWstcHJldicsXHJcbiAgICBuZXh0WWVhcjogJ3VpLWljb24tc2Vlay1uZXh0J1xyXG59O1xyXG5KcXVlcnlVaVRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAndGhlbWVCdXR0b25JY29ucyc7XHJcbkpxdWVyeVVpVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICd0aGVtZUljb24nO1xyXG5KcXVlcnlVaVRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAndWktaWNvbi0nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIFByb21pc2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBGdW5jRXZlbnRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhGdW5jRXZlbnRTb3VyY2UsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGdW5jRXZlbnRTb3VyY2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgRnVuY0V2ZW50U291cmNlLnBhcnNlID0gZnVuY3Rpb24gKHJhd0lucHV0LCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciByYXdQcm9wcztcclxuICAgICAgICAvLyBub3JtYWxpemUgcmF3IGlucHV0XHJcbiAgICAgICAgaWYgKCQuaXNGdW5jdGlvbihyYXdJbnB1dC5ldmVudHMpKSB7IC8vIGV4dGVuZGVkIGZvcm1cclxuICAgICAgICAgICAgcmF3UHJvcHMgPSByYXdJbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc0Z1bmN0aW9uKHJhd0lucHV0KSkgeyAvLyBzaG9ydCBmb3JtXHJcbiAgICAgICAgICAgIHJhd1Byb3BzID0geyBldmVudHM6IHJhd0lucHV0IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gRXZlbnRTb3VyY2VfMS5kZWZhdWx0LnBhcnNlLmNhbGwodGhpcywgcmF3UHJvcHMsIGNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEZ1bmNFdmVudFNvdXJjZS5wcm90b3R5cGUuZmV0Y2ggPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCwgdGltZXpvbmUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2FsZW5kYXIucHVzaExvYWRpbmcoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZV8xLmRlZmF1bHQuY29uc3RydWN0KGZ1bmN0aW9uIChvblJlc29sdmUpIHtcclxuICAgICAgICAgICAgX3RoaXMuZnVuYy5jYWxsKF90aGlzLmNhbGVuZGFyLCBzdGFydC5jbG9uZSgpLCBlbmQuY2xvbmUoKSwgdGltZXpvbmUsIGZ1bmN0aW9uIChyYXdFdmVudERlZnMpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNhbGVuZGFyLnBvcExvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgIG9uUmVzb2x2ZShfdGhpcy5wYXJzZUV2ZW50RGVmcyhyYXdFdmVudERlZnMpKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRnVuY0V2ZW50U291cmNlLnByb3RvdHlwZS5nZXRQcmltaXRpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYztcclxuICAgIH07XHJcbiAgICBGdW5jRXZlbnRTb3VyY2UucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHZhciBzdXBlclN1Y2Nlc3MgPSBfc3VwZXIucHJvdG90eXBlLmFwcGx5TWFudWFsU3RhbmRhcmRQcm9wcy5jYWxsKHRoaXMsIHJhd1Byb3BzKTtcclxuICAgICAgICB0aGlzLmZ1bmMgPSByYXdQcm9wcy5ldmVudHM7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyU3VjY2VzcztcclxuICAgIH07XHJcbiAgICByZXR1cm4gRnVuY0V2ZW50U291cmNlO1xyXG59KEV2ZW50U291cmNlXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBGdW5jRXZlbnRTb3VyY2U7XHJcbkZ1bmNFdmVudFNvdXJjZS5kZWZpbmVTdGFuZGFyZFByb3BzKHtcclxuICAgIGV2ZW50czogZmFsc2UgLy8gZG9uJ3QgYXV0b21hdGljYWxseSB0cmFuc2ZlclxyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgUHJvbWlzZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIEpzb25GZWVkRXZlbnRTb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhKc29uRmVlZEV2ZW50U291cmNlLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gSnNvbkZlZWRFdmVudFNvdXJjZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBKc29uRmVlZEV2ZW50U291cmNlLnBhcnNlID0gZnVuY3Rpb24gKHJhd0lucHV0LCBjYWxlbmRhcikge1xyXG4gICAgICAgIHZhciByYXdQcm9wcztcclxuICAgICAgICAvLyBub3JtYWxpemUgcmF3IGlucHV0XHJcbiAgICAgICAgaWYgKHR5cGVvZiByYXdJbnB1dC51cmwgPT09ICdzdHJpbmcnKSB7IC8vIGV4dGVuZGVkIGZvcm1cclxuICAgICAgICAgICAgcmF3UHJvcHMgPSByYXdJbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJhd0lucHV0ID09PSAnc3RyaW5nJykgeyAvLyBzaG9ydCBmb3JtXHJcbiAgICAgICAgICAgIHJhd1Byb3BzID0geyB1cmw6IHJhd0lucHV0IH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYXdQcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gRXZlbnRTb3VyY2VfMS5kZWZhdWx0LnBhcnNlLmNhbGwodGhpcywgcmF3UHJvcHMsIGNhbGVuZGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHRpbWV6b25lKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgYWpheFNldHRpbmdzID0gdGhpcy5hamF4U2V0dGluZ3M7XHJcbiAgICAgICAgdmFyIG9uU3VjY2VzcyA9IGFqYXhTZXR0aW5ncy5zdWNjZXNzO1xyXG4gICAgICAgIHZhciBvbkVycm9yID0gYWpheFNldHRpbmdzLmVycm9yO1xyXG4gICAgICAgIHZhciByZXF1ZXN0UGFyYW1zID0gdGhpcy5idWlsZFJlcXVlc3RQYXJhbXMoc3RhcnQsIGVuZCwgdGltZXpvbmUpO1xyXG4gICAgICAgIC8vIHRvZG86IGV2ZW50dWFsbHkgaGFuZGxlIHRoZSBwcm9taXNlJ3MgdGhlbixcclxuICAgICAgICAvLyBkb24ndCBpbnRlcmNlcHQgc3VjY2Vzcy9lcnJvclxyXG4gICAgICAgIC8vIHRobyB3aWxsIGJlIGEgYnJlYWtpbmcgQVBJIGNoYW5nZVxyXG4gICAgICAgIHRoaXMuY2FsZW5kYXIucHVzaExvYWRpbmcoKTtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZV8xLmRlZmF1bHQuY29uc3RydWN0KGZ1bmN0aW9uIChvblJlc29sdmUsIG9uUmVqZWN0KSB7XHJcbiAgICAgICAgICAgICQuYWpheCgkLmV4dGVuZCh7fSwgLy8gZGVzdGluYXRpb25cclxuICAgICAgICAgICAgSnNvbkZlZWRFdmVudFNvdXJjZS5BSkFYX0RFRkFVTFRTLCBhamF4U2V0dGluZ3MsIHtcclxuICAgICAgICAgICAgICAgIHVybDogX3RoaXMudXJsLFxyXG4gICAgICAgICAgICAgICAgZGF0YTogcmVxdWVzdFBhcmFtcyxcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChyYXdFdmVudERlZnMsIHN0YXR1cywgeGhyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNhbGxiYWNrUmVzO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNhbGVuZGFyLnBvcExvYWRpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocmF3RXZlbnREZWZzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrUmVzID0gdXRpbF8xLmFwcGx5QWxsKG9uU3VjY2VzcywgX3RoaXMsIFtyYXdFdmVudERlZnMsIHN0YXR1cywgeGhyXSk7IC8vIHJlZGlyZWN0IGB0aGlzYFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJC5pc0FycmF5KGNhbGxiYWNrUmVzKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3RXZlbnREZWZzID0gY2FsbGJhY2tSZXM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgb25SZXNvbHZlKF90aGlzLnBhcnNlRXZlbnREZWZzKHJhd0V2ZW50RGVmcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb25SZWplY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICh4aHIsIHN0YXR1c1RleHQsIGVycm9yVGhyb3duKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2FsZW5kYXIucG9wTG9hZGluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5hcHBseUFsbChvbkVycm9yLCBfdGhpcywgW3hociwgc3RhdHVzVGV4dCwgZXJyb3JUaHJvd25dKTsgLy8gcmVkaXJlY3QgYHRoaXNgXHJcbiAgICAgICAgICAgICAgICAgICAgb25SZWplY3QoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEpzb25GZWVkRXZlbnRTb3VyY2UucHJvdG90eXBlLmJ1aWxkUmVxdWVzdFBhcmFtcyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCB0aW1lem9uZSkge1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHRoaXMuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGFqYXhTZXR0aW5ncyA9IHRoaXMuYWpheFNldHRpbmdzO1xyXG4gICAgICAgIHZhciBzdGFydFBhcmFtO1xyXG4gICAgICAgIHZhciBlbmRQYXJhbTtcclxuICAgICAgICB2YXIgdGltZXpvbmVQYXJhbTtcclxuICAgICAgICB2YXIgY3VzdG9tUmVxdWVzdFBhcmFtcztcclxuICAgICAgICB2YXIgcGFyYW1zID0ge307XHJcbiAgICAgICAgc3RhcnRQYXJhbSA9IHRoaXMuc3RhcnRQYXJhbTtcclxuICAgICAgICBpZiAoc3RhcnRQYXJhbSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHN0YXJ0UGFyYW0gPSBjYWxlbmRhci5vcHQoJ3N0YXJ0UGFyYW0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5kUGFyYW0gPSB0aGlzLmVuZFBhcmFtO1xyXG4gICAgICAgIGlmIChlbmRQYXJhbSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVuZFBhcmFtID0gY2FsZW5kYXIub3B0KCdlbmRQYXJhbScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aW1lem9uZVBhcmFtID0gdGhpcy50aW1lem9uZVBhcmFtO1xyXG4gICAgICAgIGlmICh0aW1lem9uZVBhcmFtID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGltZXpvbmVQYXJhbSA9IGNhbGVuZGFyLm9wdCgndGltZXpvbmVQYXJhbScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXRyaWV2ZSBhbnkgb3V0Ym91bmQgR0VUL1BPU1QgJC5hamF4IGRhdGEgZnJvbSB0aGUgb3B0aW9uc1xyXG4gICAgICAgIGlmICgkLmlzRnVuY3Rpb24oYWpheFNldHRpbmdzLmRhdGEpKSB7XHJcbiAgICAgICAgICAgIC8vIHN1cHBsaWVkIGFzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEga2V5L3ZhbHVlIG9iamVjdFxyXG4gICAgICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gYWpheFNldHRpbmdzLmRhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHByb2JhYmx5IHN1cHBsaWVkIGFzIGEgc3RyYWlnaHQga2V5L3ZhbHVlIG9iamVjdFxyXG4gICAgICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gYWpheFNldHRpbmdzLmRhdGEgfHwge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgICQuZXh0ZW5kKHBhcmFtcywgY3VzdG9tUmVxdWVzdFBhcmFtcyk7XHJcbiAgICAgICAgcGFyYW1zW3N0YXJ0UGFyYW1dID0gc3RhcnQuZm9ybWF0KCk7XHJcbiAgICAgICAgcGFyYW1zW2VuZFBhcmFtXSA9IGVuZC5mb3JtYXQoKTtcclxuICAgICAgICBpZiAodGltZXpvbmUgJiYgdGltZXpvbmUgIT09ICdsb2NhbCcpIHtcclxuICAgICAgICAgICAgcGFyYW1zW3RpbWV6b25lUGFyYW1dID0gdGltZXpvbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwYXJhbXM7XHJcbiAgICB9O1xyXG4gICAgSnNvbkZlZWRFdmVudFNvdXJjZS5wcm90b3R5cGUuZ2V0UHJpbWl0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVybDtcclxuICAgIH07XHJcbiAgICBKc29uRmVlZEV2ZW50U291cmNlLnByb3RvdHlwZS5hcHBseU1pc2NQcm9wcyA9IGZ1bmN0aW9uIChyYXdQcm9wcykge1xyXG4gICAgICAgIHRoaXMuYWpheFNldHRpbmdzID0gcmF3UHJvcHM7XHJcbiAgICB9O1xyXG4gICAgSnNvbkZlZWRFdmVudFNvdXJjZS5BSkFYX0RFRkFVTFRTID0ge1xyXG4gICAgICAgIGRhdGFUeXBlOiAnanNvbicsXHJcbiAgICAgICAgY2FjaGU6IGZhbHNlXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEpzb25GZWVkRXZlbnRTb3VyY2U7XHJcbn0oRXZlbnRTb3VyY2VfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEpzb25GZWVkRXZlbnRTb3VyY2U7XHJcbkpzb25GZWVkRXZlbnRTb3VyY2UuZGVmaW5lU3RhbmRhcmRQcm9wcyh7XHJcbiAgICAvLyBhdXRvbWF0aWNhbGx5IHRyYW5zZmVyICh0cnVlKS4uLlxyXG4gICAgdXJsOiB0cnVlLFxyXG4gICAgc3RhcnRQYXJhbTogdHJ1ZSxcclxuICAgIGVuZFBhcmFtOiB0cnVlLFxyXG4gICAgdGltZXpvbmVQYXJhbTogdHJ1ZVxyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEl0ZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gSXRlcmF0b3IoaXRlbXMpIHtcclxuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXMgfHwgW107XHJcbiAgICB9XHJcbiAgICAvKiBDYWxscyBhIG1ldGhvZCBvbiBldmVyeSBpdGVtIHBhc3NpbmcgdGhlIGFyZ3VtZW50cyB0aHJvdWdoICovXHJcbiAgICBJdGVyYXRvci5wcm90b3R5cGUucHJveHlDYWxsID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHRzID0gW107XHJcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtW21ldGhvZE5hbWVdLmFwcGx5KGl0ZW0sIGFyZ3MpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH07XHJcbiAgICByZXR1cm4gSXRlcmF0b3I7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEl0ZXJhdG9yO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMjYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuLyogQ3JlYXRlcyBhIGNsb25lIG9mIGFuIGVsZW1lbnQgYW5kIGxldHMgaXQgdHJhY2sgdGhlIG1vdXNlIGFzIGl0IG1vdmVzXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgTW91c2VGb2xsb3dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIE1vdXNlRm9sbG93ZXIoc291cmNlRWwsIG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmlzRm9sbG93aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pc0hpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSBmYWxzZTsgLy8gZG9pbmcgdGhlIHJldmVydCBhbmltYXRpb24/XHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcbiAgICAgICAgdGhpcy5zb3VyY2VFbCA9IHNvdXJjZUVsO1xyXG4gICAgICAgIHRoaXMucGFyZW50RWwgPSBvcHRpb25zLnBhcmVudEVsID8gJChvcHRpb25zLnBhcmVudEVsKSA6IHNvdXJjZUVsLnBhcmVudCgpOyAvLyBkZWZhdWx0IHRvIHNvdXJjZUVsJ3MgcGFyZW50XHJcbiAgICB9XHJcbiAgICAvLyBDYXVzZXMgdGhlIGVsZW1lbnQgdG8gc3RhcnQgZm9sbG93aW5nIHRoZSBtb3VzZVxyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNGb2xsb3dpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5pc0ZvbGxvd2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMueTAgPSB1dGlsXzEuZ2V0RXZZKGV2KTtcclxuICAgICAgICAgICAgdGhpcy54MCA9IHV0aWxfMS5nZXRFdlgoZXYpO1xyXG4gICAgICAgICAgICB0aGlzLnRvcERlbHRhID0gMDtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0RGVsdGEgPSAwO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodXRpbF8xLmdldEV2SXNUb3VjaChldikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuVG8oJChkb2N1bWVudCksICd0b3VjaG1vdmUnLCB0aGlzLmhhbmRsZU1vdmUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwgJ21vdXNlbW92ZScsIHRoaXMuaGFuZGxlTW92ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2F1c2VzIHRoZSBlbGVtZW50IHRvIHN0b3AgZm9sbG93aW5nIHRoZSBtb3VzZS4gSWYgc2hvdWxkUmV2ZXJ0IGlzIHRydWUsIHdpbGwgYW5pbWF0ZSBiYWNrIHRvIG9yaWdpbmFsIHBvc2l0aW9uLlxyXG4gICAgLy8gYGNhbGxiYWNrYCBnZXRzIGludm9rZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLiBJZiBubyBhbmltYXRpb24sIGl0IGlzIGludm9rZWQgaW1tZWRpYXRlbHkuXHJcbiAgICBNb3VzZUZvbGxvd2VyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKHNob3VsZFJldmVydCwgY2FsbGJhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciByZXZlcnREdXJhdGlvbiA9IHRoaXMub3B0aW9ucy5yZXZlcnREdXJhdGlvbjtcclxuICAgICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIF90aGlzLmlzQW5pbWF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIF90aGlzLnJlbW92ZUVsZW1lbnQoKTtcclxuICAgICAgICAgICAgX3RoaXMudG9wMCA9IF90aGlzLmxlZnQwID0gbnVsbDsgLy8gcmVzZXQgc3RhdGUgZm9yIGZ1dHVyZSB1cGRhdGVQb3NpdGlvbiBjYWxsc1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0aGlzLmlzRm9sbG93aW5nICYmICF0aGlzLmlzQW5pbWF0aW5nKSB7IC8vIGRpc2FsbG93IG1vcmUgdGhhbiBvbmUgc3RvcCBhbmltYXRpb24gYXQgYSB0aW1lXHJcbiAgICAgICAgICAgIHRoaXMuaXNGb2xsb3dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nVG8oJChkb2N1bWVudCkpO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkUmV2ZXJ0ICYmIHJldmVydER1cmF0aW9uICYmICF0aGlzLmlzSGlkZGVuKSB7IC8vIGRvIGEgcmV2ZXJ0IGFuaW1hdGlvbj9cclxuICAgICAgICAgICAgICAgIHRoaXMuaXNBbmltYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbC5hbmltYXRlKHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHRoaXMudG9wMCxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLmxlZnQwXHJcbiAgICAgICAgICAgICAgICB9LCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IHJldmVydER1cmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb21wbGV0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdldHMgdGhlIHRyYWNraW5nIGVsZW1lbnQuIENyZWF0ZSBpdCBpZiBuZWNlc3NhcnlcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLmdldEVsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XHJcbiAgICAgICAgaWYgKCFlbCkge1xyXG4gICAgICAgICAgICBlbCA9IHRoaXMuZWwgPSB0aGlzLnNvdXJjZUVsLmNsb25lKClcclxuICAgICAgICAgICAgICAgIC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWRkaXRpb25hbENsYXNzIHx8ICcnKVxyXG4gICAgICAgICAgICAgICAgLmNzcyh7XHJcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6ICcnLFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogdGhpcy5pc0hpZGRlbiA/ICdub25lJyA6ICcnLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAwLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogJ2F1dG8nLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuc291cmNlRWwud2lkdGgoKSxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5zb3VyY2VFbC5oZWlnaHQoKSxcclxuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMub3B0aW9ucy5vcGFjaXR5IHx8ICcnLFxyXG4gICAgICAgICAgICAgICAgekluZGV4OiB0aGlzLm9wdGlvbnMuekluZGV4XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCB3YW50IGxvbmcgdGFwcyBvciBhbnkgbW91c2UgaW50ZXJhY3Rpb24gY2F1c2luZyBzZWxlY3Rpb24vbWVudXMuXHJcbiAgICAgICAgICAgIC8vIHdvdWxkIHVzZSBwcmV2ZW50U2VsZWN0aW9uKCksIGJ1dCB0aGF0IHByZXZlbnRzIHNlbGVjdHN0YXJ0LCBjYXVzaW5nIHByb2JsZW1zLlxyXG4gICAgICAgICAgICBlbC5hZGRDbGFzcygnZmMtdW5zZWxlY3RhYmxlJyk7XHJcbiAgICAgICAgICAgIGVsLmFwcGVuZFRvKHRoaXMucGFyZW50RWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWw7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVtb3ZlcyB0aGUgdHJhY2tpbmcgZWxlbWVudCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5lbCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFVwZGF0ZSB0aGUgQ1NTIHBvc2l0aW9uIG9mIHRoZSB0cmFja2luZyBlbGVtZW50XHJcbiAgICBNb3VzZUZvbGxvd2VyLnByb3RvdHlwZS51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc291cmNlT2Zmc2V0O1xyXG4gICAgICAgIHZhciBvcmlnaW47XHJcbiAgICAgICAgdGhpcy5nZXRFbCgpOyAvLyBlbnN1cmUgdGhpcy5lbFxyXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBvcmlnaW4gaW5mbyB3YXMgY29tcHV0ZWRcclxuICAgICAgICBpZiAodGhpcy50b3AwID09IG51bGwpIHtcclxuICAgICAgICAgICAgc291cmNlT2Zmc2V0ID0gdGhpcy5zb3VyY2VFbC5vZmZzZXQoKTtcclxuICAgICAgICAgICAgb3JpZ2luID0gdGhpcy5lbC5vZmZzZXRQYXJlbnQoKS5vZmZzZXQoKTtcclxuICAgICAgICAgICAgdGhpcy50b3AwID0gc291cmNlT2Zmc2V0LnRvcCAtIG9yaWdpbi50b3A7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdDAgPSBzb3VyY2VPZmZzZXQubGVmdCAtIG9yaWdpbi5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsLmNzcyh7XHJcbiAgICAgICAgICAgIHRvcDogdGhpcy50b3AwICsgdGhpcy50b3BEZWx0YSxcclxuICAgICAgICAgICAgbGVmdDogdGhpcy5sZWZ0MCArIHRoaXMubGVmdERlbHRhXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyBjYWxsZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgbW91c2VcclxuICAgIE1vdXNlRm9sbG93ZXIucHJvdG90eXBlLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB0aGlzLnRvcERlbHRhID0gdXRpbF8xLmdldEV2WShldikgLSB0aGlzLnkwO1xyXG4gICAgICAgIHRoaXMubGVmdERlbHRhID0gdXRpbF8xLmdldEV2WChldikgLSB0aGlzLngwO1xyXG4gICAgICAgIGlmICghdGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRlbXBvcmFyaWx5IG1ha2VzIHRoZSB0cmFja2luZyBlbGVtZW50IGludmlzaWJsZS4gQ2FuIGJlIGNhbGxlZCBiZWZvcmUgZm9sbG93aW5nIHN0YXJ0c1xyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5pc0hpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVsLmhpZGUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTaG93IHRoZSB0cmFja2luZyBlbGVtZW50IGFmdGVyIGl0IGhhcyBiZWVuIHRlbXBvcmFyaWx5IGhpZGRlblxyXG4gICAgTW91c2VGb2xsb3dlci5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5pc0hpZGRlbikge1xyXG4gICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlUG9zaXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5nZXRFbCgpLnNob3coKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE1vdXNlRm9sbG93ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IE1vdXNlRm9sbG93ZXI7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oTW91c2VGb2xsb3dlcik7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBBIHJlY3Rhbmd1bGFyIHBhbmVsIHRoYXQgaXMgYWJzb2x1dGVseSBwb3NpdGlvbmVkIG92ZXIgb3RoZXIgY29udGVudFxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuT3B0aW9uczpcclxuICAtIGNsYXNzTmFtZSAoc3RyaW5nKVxyXG4gIC0gY29udGVudCAoSFRNTCBzdHJpbmcgb3IgalF1ZXJ5IGVsZW1lbnQgc2V0KVxyXG4gIC0gcGFyZW50RWxcclxuICAtIHRvcFxyXG4gIC0gbGVmdFxyXG4gIC0gcmlnaHQgKHRoZSB4IGNvb3JkIG9mIHdoZXJlIHRoZSByaWdodCBlZGdlIHNob3VsZCBiZS4gbm90IGEgXCJDU1NcIiByaWdodClcclxuICAtIGF1dG9IaWRlIChib29sZWFuKVxyXG4gIC0gc2hvdyAoY2FsbGJhY2spXHJcbiAgLSBoaWRlIChjYWxsYmFjaylcclxuKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxudmFyIFBvcG92ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBQb3BvdmVyKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLm1hcmdpbiA9IDEwOyAvLyB0aGUgc3BhY2UgcmVxdWlyZWQgYmV0d2VlbiB0aGUgcG9wb3ZlciBhbmQgdGhlIGVkZ2VzIG9mIHRoZSBzY3JvbGwgY29udGFpbmVyXHJcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuICAgIH1cclxuICAgIC8vIFNob3dzIHRoZSBwb3BvdmVyIG9uIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uIFJlbmRlcnMgaXQgaWYgbm90IGFscmVhZHlcclxuICAgIFBvcG92ZXIucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZWwuc2hvdygpO1xyXG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaXNIaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdzaG93Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEhpZGVzIHRoZSBwb3BvdmVyLCB0aHJvdWdoIENTUywgYnV0IGRvZXMgbm90IHJlbW92ZSBpdCBmcm9tIHRoZSBET01cclxuICAgIFBvcG92ZXIucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSGlkZGVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuaGlkZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmlzSGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdoaWRlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENyZWF0ZXMgYHRoaXMuZWxgIGFuZCByZW5kZXJzIGNvbnRlbnQgaW5zaWRlIG9mIGl0XHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICB0aGlzLmVsID0gJCgnPGRpdiBjbGFzcz1cImZjLXBvcG92ZXJcIj4nKVxyXG4gICAgICAgICAgICAuYWRkQ2xhc3Mob3B0aW9ucy5jbGFzc05hbWUgfHwgJycpXHJcbiAgICAgICAgICAgIC5jc3Moe1xyXG4gICAgICAgICAgICAvLyBwb3NpdGlvbiBpbml0aWFsbHkgdG8gdGhlIHRvcCBsZWZ0IHRvIGF2b2lkIGNyZWF0aW5nIHNjcm9sbGJhcnNcclxuICAgICAgICAgICAgdG9wOiAwLFxyXG4gICAgICAgICAgICBsZWZ0OiAwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmFwcGVuZChvcHRpb25zLmNvbnRlbnQpXHJcbiAgICAgICAgICAgIC5hcHBlbmRUbyhvcHRpb25zLnBhcmVudEVsKTtcclxuICAgICAgICAvLyB3aGVuIGEgY2xpY2sgaGFwcGVucyBvbiBhbnl0aGluZyBpbnNpZGUgd2l0aCBhICdmYy1jbG9zZScgY2xhc3NOYW1lLCBoaWRlIHRoZSBwb3BvdmVyXHJcbiAgICAgICAgdGhpcy5lbC5vbignY2xpY2snLCAnLmZjLWNsb3NlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0hpZGUpIHtcclxuICAgICAgICAgICAgdGhpcy5saXN0ZW5UbygkKGRvY3VtZW50KSwgJ21vdXNlZG93bicsIHRoaXMuZG9jdW1lbnRNb3VzZWRvd24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBUcmlnZ2VyZWQgd2hlbiB0aGUgdXNlciBjbGlja3MgKmFueXdoZXJlKiBpbiB0aGUgZG9jdW1lbnQsIGZvciB0aGUgYXV0b0hpZGUgZmVhdHVyZVxyXG4gICAgUG9wb3Zlci5wcm90b3R5cGUuZG9jdW1lbnRNb3VzZWRvd24gPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAvLyBvbmx5IGhpZGUgdGhlIHBvcG92ZXIgaWYgdGhlIGNsaWNrIGhhcHBlbmVkIG91dHNpZGUgdGhlIHBvcG92ZXJcclxuICAgICAgICBpZiAodGhpcy5lbCAmJiAhJChldi50YXJnZXQpLmNsb3Nlc3QodGhpcy5lbCkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBIaWRlcyBhbmQgdW5yZWdpc3RlcnMgYW55IGhhbmRsZXJzXHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSwgJ21vdXNlZG93bicpO1xyXG4gICAgfTtcclxuICAgIC8vIFBvc2l0aW9ucyB0aGUgcG9wb3ZlciBvcHRpbWFsbHksIHVzaW5nIHRoZSB0b3AvbGVmdC9yaWdodCBvcHRpb25zXHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS5wb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy5lbC5vZmZzZXRQYXJlbnQoKS5vZmZzZXQoKTtcclxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmVsLm91dGVyV2lkdGgoKTtcclxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5lbC5vdXRlckhlaWdodCgpO1xyXG4gICAgICAgIHZhciB3aW5kb3dFbCA9ICQod2luZG93KTtcclxuICAgICAgICB2YXIgdmlld3BvcnRFbCA9IHV0aWxfMS5nZXRTY3JvbGxQYXJlbnQodGhpcy5lbCk7XHJcbiAgICAgICAgdmFyIHZpZXdwb3J0VG9wO1xyXG4gICAgICAgIHZhciB2aWV3cG9ydExlZnQ7XHJcbiAgICAgICAgdmFyIHZpZXdwb3J0T2Zmc2V0O1xyXG4gICAgICAgIHZhciB0b3A7IC8vIHRoZSBcInBvc2l0aW9uXCIgKG5vdCBcIm9mZnNldFwiKSB2YWx1ZXMgZm9yIHRoZSBwb3BvdmVyXHJcbiAgICAgICAgdmFyIGxlZnQ7IC8vXHJcbiAgICAgICAgLy8gY29tcHV0ZSB0b3AgYW5kIGxlZnRcclxuICAgICAgICB0b3AgPSBvcHRpb25zLnRvcCB8fCAwO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmxlZnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBsZWZ0ID0gb3B0aW9ucy5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnJpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgbGVmdCA9IG9wdGlvbnMucmlnaHQgLSB3aWR0aDsgLy8gZGVyaXZlIHRoZSBsZWZ0IHZhbHVlIGZyb20gdGhlIHJpZ2h0IHZhbHVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWZ0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZpZXdwb3J0RWwuaXMod2luZG93KSB8fCB2aWV3cG9ydEVsLmlzKGRvY3VtZW50KSkgeyAvLyBub3JtYWxpemUgZ2V0U2Nyb2xsUGFyZW50J3MgcmVzdWx0XHJcbiAgICAgICAgICAgIHZpZXdwb3J0RWwgPSB3aW5kb3dFbDtcclxuICAgICAgICAgICAgdmlld3BvcnRUb3AgPSAwOyAvLyB0aGUgd2luZG93IGlzIGFsd2F5cyBhdCB0aGUgdG9wIGxlZnRcclxuICAgICAgICAgICAgdmlld3BvcnRMZWZ0ID0gMDsgLy8gKGFuZCAub2Zmc2V0KCkgd29uJ3Qgd29yayBpZiBjYWxsZWQgaGVyZSlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0T2Zmc2V0ID0gdmlld3BvcnRFbC5vZmZzZXQoKTtcclxuICAgICAgICAgICAgdmlld3BvcnRUb3AgPSB2aWV3cG9ydE9mZnNldC50b3A7XHJcbiAgICAgICAgICAgIHZpZXdwb3J0TGVmdCA9IHZpZXdwb3J0T2Zmc2V0LmxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSB3aW5kb3cgaXMgc2Nyb2xsZWQsIGl0IGNhdXNlcyB0aGUgdmlzaWJsZSBhcmVhIHRvIGJlIGZ1cnRoZXIgZG93blxyXG4gICAgICAgIHZpZXdwb3J0VG9wICs9IHdpbmRvd0VsLnNjcm9sbFRvcCgpO1xyXG4gICAgICAgIHZpZXdwb3J0TGVmdCArPSB3aW5kb3dFbC5zY3JvbGxMZWZ0KCk7XHJcbiAgICAgICAgLy8gY29uc3RyYWluIHRvIHRoZSB2aWV3IHBvcnQuIGlmIGNvbnN0cmFpbmVkIGJ5IHR3byBlZGdlcywgZ2l2ZSBwcmVjZWRlbmNlIHRvIHRvcC9sZWZ0XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudmlld3BvcnRDb25zdHJhaW4gIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWluKHRvcCwgdmlld3BvcnRUb3AgKyB2aWV3cG9ydEVsLm91dGVySGVpZ2h0KCkgLSBoZWlnaHQgLSB0aGlzLm1hcmdpbik7XHJcbiAgICAgICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgdmlld3BvcnRUb3AgKyB0aGlzLm1hcmdpbik7XHJcbiAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCB2aWV3cG9ydExlZnQgKyB2aWV3cG9ydEVsLm91dGVyV2lkdGgoKSAtIHdpZHRoIC0gdGhpcy5tYXJnaW4pO1xyXG4gICAgICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgdmlld3BvcnRMZWZ0ICsgdGhpcy5tYXJnaW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsLmNzcyh7XHJcbiAgICAgICAgICAgIHRvcDogdG9wIC0gb3JpZ2luLnRvcCxcclxuICAgICAgICAgICAgbGVmdDogbGVmdCAtIG9yaWdpbi5sZWZ0XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVHJpZ2dlcnMgYSBjYWxsYmFjay4gQ2FsbHMgYSBmdW5jdGlvbiBpbiB0aGUgb3B0aW9uIGhhc2ggb2YgdGhlIHNhbWUgbmFtZS5cclxuICAgIC8vIEFyZ3VtZW50cyBiZXlvbmQgdGhlIGZpcnN0IGBuYW1lYCBhcmUgZm9yd2FyZGVkIG9uLlxyXG4gICAgLy8gVE9ETzogYmV0dGVyIGNvZGUgcmV1c2UgZm9yIHRoaXMuIFJlcGVhdCBjb2RlXHJcbiAgICBQb3BvdmVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5vcHRpb25zW25hbWVdKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1tuYW1lXS5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFBvcG92ZXI7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFBvcG92ZXI7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oUG9wb3Zlcik7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFbWl0dGVyTWl4aW5fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG52YXIgVGFza1F1ZXVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGFza1F1ZXVlKCkge1xyXG4gICAgICAgIHRoaXMucSA9IFtdO1xyXG4gICAgICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5xLnB1c2guYXBwbHkodGhpcy5xLCBhcmdzKTsgLy8gYXBwZW5kXHJcbiAgICAgICAgdGhpcy50cnlTdGFydCgpO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudHJ5U3RhcnQoKTtcclxuICAgIH07XHJcbiAgICBUYXNrUXVldWUucHJvdG90eXBlLmdldElzSWRsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuaXNSdW5uaW5nICYmICF0aGlzLmlzUGF1c2VkO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUudHJ5U3RhcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzUnVubmluZyAmJiB0aGlzLmNhblJ1bk5leHQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignc3RhcnQnKTtcclxuICAgICAgICAgICAgdGhpcy5ydW5SZW1haW5pbmcoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGFza1F1ZXVlLnByb3RvdHlwZS5jYW5SdW5OZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pc1BhdXNlZCAmJiB0aGlzLnEubGVuZ3RoO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUucnVuUmVtYWluaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRhc2s7XHJcbiAgICAgICAgdmFyIHJlcztcclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIHRhc2sgPSB0aGlzLnEuc2hpZnQoKTsgLy8gYWx3YXlzIGZyZXNobHkgcmVmZXJlbmNlIHEuIG1pZ2h0IGhhdmUgYmVlbiByZWFzc2lnbmVkLlxyXG4gICAgICAgICAgICByZXMgPSB0aGlzLnJ1blRhc2sodGFzayk7XHJcbiAgICAgICAgICAgIGlmIChyZXMgJiYgcmVzLnRoZW4pIHtcclxuICAgICAgICAgICAgICAgIHJlcy50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2FuUnVuTmV4dCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJ1blJlbWFpbmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBwcmV2ZW50IG1hcmtpbmcgYXMgc3RvcHBlZFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSB3aGlsZSAodGhpcy5jYW5SdW5OZXh0KCkpO1xyXG4gICAgICAgIHRoaXMudHJpZ2dlcignc3RvcCcpOyAvLyBub3QgcmVhbGx5IGEgJ3N0b3AnIC4uLiBtb3JlIG9mIGEgJ2RyYWluZWQnXHJcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAvLyBpZiAnc3RvcCcgaGFuZGxlciBhZGRlZCBtb3JlIHRhc2tzLi4uLiBUT0RPOiB3cml0ZSB0ZXN0IGZvciB0aGlzXHJcbiAgICAgICAgdGhpcy50cnlTdGFydCgpO1xyXG4gICAgfTtcclxuICAgIFRhc2tRdWV1ZS5wcm90b3R5cGUucnVuVGFzayA9IGZ1bmN0aW9uICh0YXNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhc2soKTsgLy8gdGFzayAqaXMqIHRoZSBmdW5jdGlvbiwgYnV0IHN1YmNsYXNzZXMgY2FuIGNoYW5nZSB0aGUgZm9ybWF0IG9mIGEgdGFza1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUYXNrUXVldWU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IFRhc2tRdWV1ZTtcclxuRW1pdHRlck1peGluXzEuZGVmYXVsdC5taXhJbnRvKFRhc2tRdWV1ZSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFRhc2tRdWV1ZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjgpO1xyXG52YXIgUmVuZGVyUXVldWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZW5kZXJRdWV1ZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFJlbmRlclF1ZXVlKHdhaXRzQnlOYW1lc3BhY2UpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLndhaXRzQnlOYW1lc3BhY2UgPSB3YWl0c0J5TmFtZXNwYWNlIHx8IHt9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uICh0YXNrRnVuYywgbmFtZXNwYWNlLCB0eXBlKSB7XHJcbiAgICAgICAgdmFyIHRhc2sgPSB7XHJcbiAgICAgICAgICAgIGZ1bmM6IHRhc2tGdW5jLFxyXG4gICAgICAgICAgICBuYW1lc3BhY2U6IG5hbWVzcGFjZSxcclxuICAgICAgICAgICAgdHlwZTogdHlwZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHdhaXRNcztcclxuICAgICAgICBpZiAobmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIHdhaXRNcyA9IHRoaXMud2FpdHNCeU5hbWVzcGFjZVtuYW1lc3BhY2VdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy53YWl0TmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIGlmIChuYW1lc3BhY2UgPT09IHRoaXMud2FpdE5hbWVzcGFjZSAmJiB3YWl0TXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kZWxheVdhaXQod2FpdE1zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJXYWl0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyeVN0YXJ0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcG91bmRUYXNrKHRhc2spKSB7IC8vIGFwcGVuZGVkIHRvIHF1ZXVlP1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMud2FpdE5hbWVzcGFjZSAmJiB3YWl0TXMgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFdhaXQobmFtZXNwYWNlLCB3YWl0TXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy50cnlTdGFydCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5zdGFydFdhaXQgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCB3YWl0TXMpIHtcclxuICAgICAgICB0aGlzLndhaXROYW1lc3BhY2UgPSBuYW1lc3BhY2U7XHJcbiAgICAgICAgdGhpcy5zcGF3bldhaXQod2FpdE1zKTtcclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUuZGVsYXlXYWl0ID0gZnVuY3Rpb24gKHdhaXRNcykge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLndhaXRJZCk7XHJcbiAgICAgICAgdGhpcy5zcGF3bldhaXQod2FpdE1zKTtcclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUuc3Bhd25XYWl0ID0gZnVuY3Rpb24gKHdhaXRNcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy53YWl0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgX3RoaXMud2FpdE5hbWVzcGFjZSA9IG51bGw7XHJcbiAgICAgICAgICAgIF90aGlzLnRyeVN0YXJ0KCk7XHJcbiAgICAgICAgfSwgd2FpdE1zKTtcclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUuY2xlYXJXYWl0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLndhaXROYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2FpdElkKTtcclxuICAgICAgICAgICAgdGhpcy53YWl0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLndhaXROYW1lc3BhY2UgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBSZW5kZXJRdWV1ZS5wcm90b3R5cGUuY2FuUnVuTmV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIV9zdXBlci5wcm90b3R5cGUuY2FuUnVuTmV4dC5jYWxsKHRoaXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gd2FpdGluZyBmb3IgYSBjZXJ0YWluIG5hbWVzcGFjZSB0byBzdG9wIHJlY2VpdmluZyB0YXNrcz9cclxuICAgICAgICBpZiAodGhpcy53YWl0TmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgIHZhciBxID0gdGhpcy5xO1xyXG4gICAgICAgICAgICAvLyBpZiB0aGVyZSB3YXMgYSBkaWZmZXJlbnQgbmFtZXNwYWNlIHRhc2sgaW4gdGhlIG1lYW50aW1lLFxyXG4gICAgICAgICAgICAvLyB0aGF0IGZvcmNlcyBhbGwgcHJldmlvdXNseS13YWl0aW5nIHRhc2tzIHRvIHN1ZGRlbmx5IGV4ZWN1dGUuXHJcbiAgICAgICAgICAgIC8vIFRPRE86IGZpbmQgYSB3YXkgdG8gZG8gdGhpcyBpbiBjb25zdGFudCB0aW1lLlxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmIChxW2ldLm5hbWVzcGFjZSAhPT0gdGhpcy53YWl0TmFtZXNwYWNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIGFsbG93IGV4ZWN1dGlvblxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgUmVuZGVyUXVldWUucHJvdG90eXBlLnJ1blRhc2sgPSBmdW5jdGlvbiAodGFzaykge1xyXG4gICAgICAgIHRhc2suZnVuYygpO1xyXG4gICAgfTtcclxuICAgIFJlbmRlclF1ZXVlLnByb3RvdHlwZS5jb21wb3VuZFRhc2sgPSBmdW5jdGlvbiAobmV3VGFzaykge1xyXG4gICAgICAgIHZhciBxID0gdGhpcy5xO1xyXG4gICAgICAgIHZhciBzaG91bGRBcHBlbmQgPSB0cnVlO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciB0YXNrO1xyXG4gICAgICAgIGlmIChuZXdUYXNrLm5hbWVzcGFjZSAmJiBuZXdUYXNrLnR5cGUgPT09ICdkZXN0cm95Jykge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIGluaXQvYWRkL3JlbW92ZSBvcHMgd2l0aCBzYW1lIG5hbWVzcGFjZSwgcmVnYXJkbGVzcyBvZiBvcmRlclxyXG4gICAgICAgICAgICBmb3IgKGkgPSBxLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgICAgICB0YXNrID0gcVtpXTtcclxuICAgICAgICAgICAgICAgIGlmICh0YXNrLm5hbWVzcGFjZSA9PT0gbmV3VGFzay5uYW1lc3BhY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRhc2sudHlwZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdpbml0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZEFwcGVuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbGF0ZXN0IGRlc3Ryb3kgaXMgY2FuY2VsbGVkIG91dCBieSBub3QgZG9pbmcgdGhlIGluaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhZGQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlbW92ZSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxLnNwbGljZShpLCAxKTsgLy8gcmVtb3ZlIHRhc2tcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNob3VsZEFwcGVuZCkge1xyXG4gICAgICAgICAgICBxLnB1c2gobmV3VGFzayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzaG91bGRBcHBlbmQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlbmRlclF1ZXVlO1xyXG59KFRhc2tRdWV1ZV8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gUmVuZGVyUXVldWU7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIE1vZGVsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKTtcclxudmFyIENvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKENvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvbXBvbmVudCgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnNldEVsZW1lbnQgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICB0aGlzLmVsID0gZWw7XHJcbiAgICAgICAgdGhpcy5iaW5kR2xvYmFsSGFuZGxlcnMoKTtcclxuICAgICAgICB0aGlzLnJlbmRlclNrZWxldG9uKCk7XHJcbiAgICAgICAgdGhpcy5zZXQoJ2lzSW5Eb20nLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnJlbW92ZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnNldCgnaXNJbkRvbScpO1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJTa2VsZXRvbigpO1xyXG4gICAgICAgIHRoaXMudW5iaW5kR2xvYmFsSGFuZGxlcnMoKTtcclxuICAgICAgICB0aGlzLmVsLnJlbW92ZSgpO1xyXG4gICAgICAgIC8vIE5PVEU6IGRvbid0IG51bGwtb3V0IHRoaXMuZWwgaW4gY2FzZSB0aGUgVmlldyB3YXMgZGVzdHJveWVkIHdpdGhpbiBhbiBBUEkgY2FsbGJhY2suXHJcbiAgICAgICAgLy8gV2UgZG9uJ3QgbnVsbC1vdXQgdGhlIFZpZXcncyBvdGhlciBqUXVlcnkgZWxlbWVudCByZWZlcmVuY2VzIHVwb24gZGVzdHJveSxcclxuICAgICAgICAvLyAgc28gd2Ugc2hvdWxkbid0IGtpbGwgdGhpcy5lbCBlaXRoZXIuXHJcbiAgICB9O1xyXG4gICAgQ29tcG9uZW50LnByb3RvdHlwZS5iaW5kR2xvYmFsSGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGVcclxuICAgIH07XHJcbiAgICBDb21wb25lbnQucHJvdG90eXBlLnVuYmluZEdsb2JhbEhhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlXHJcbiAgICB9O1xyXG4gICAgLypcclxuICAgIE5PVEU6IENhbid0IGhhdmUgYSBgcmVuZGVyYCBtZXRob2QuIFJlYWQgdGhlIGRlcHJlY2F0aW9uIG5vdGljZSBpbiBWaWV3OjpleGVjdXRlRGF0ZVJlbmRlclxyXG4gICAgKi9cclxuICAgIC8vIFJlbmRlcnMgdGhlIGJhc2ljIHN0cnVjdHVyZSBvZiB0aGUgdmlldyBiZWZvcmUgYW55IGNvbnRlbnQgaXMgcmVuZGVyZWRcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIHRoZSBiYXNpYyBzdHJ1Y3R1cmUgb2YgdGhlIHZpZXdcclxuICAgIENvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ29tcG9uZW50O1xyXG59KE1vZGVsXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBDb21wb25lbnQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBtb21lbnRfZXh0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIGRhdGVfZm9ybWF0dGluZ18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XHJcbnZhciBDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjMwKTtcclxudmFyIHV0aWxfMiA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG52YXIgRGF0ZUNvbXBvbmVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERhdGVDb21wb25lbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXRlQ29tcG9uZW50KF92aWV3LCBfb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaXNSVEwgPSBmYWxzZTsgLy8gZnJlcXVlbnRseSBhY2Nlc3NlZCBvcHRpb25zXHJcbiAgICAgICAgX3RoaXMuaGl0c05lZWRlZERlcHRoID0gMDsgLy8gbmVjZXNzYXJ5IGJlY2F1c2UgbXVsdGlwbGUgY2FsbGVycyBtaWdodCBuZWVkIHRoZSBzYW1lIGhpdHNcclxuICAgICAgICBfdGhpcy5oYXNBbGxEYXlCdXNpbmVzc0hvdXJzID0gZmFsc2U7IC8vIFRPRE86IHVuaWZ5IHdpdGggbGFyZ2VVbml0IGFuZCBpc1RpbWVTY2FsZT9cclxuICAgICAgICBfdGhpcy5pc0RhdGVzUmVuZGVyZWQgPSBmYWxzZTtcclxuICAgICAgICAvLyBoYWNrIHRvIHNldCBvcHRpb25zIHByaW9yIHRvIHRoZSB0aGlzLm9wdCBjYWxsc1xyXG4gICAgICAgIGlmIChfdmlldykge1xyXG4gICAgICAgICAgICBfdGhpc1sndmlldyddID0gX3ZpZXc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfb3B0aW9ucykge1xyXG4gICAgICAgICAgICBfdGhpc1snb3B0aW9ucyddID0gX29wdGlvbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF90aGlzLnVpZCA9IFN0cmluZyhEYXRlQ29tcG9uZW50Lmd1aWQrKyk7XHJcbiAgICAgICAgX3RoaXMuY2hpbGRyZW5CeVVpZCA9IHt9O1xyXG4gICAgICAgIF90aGlzLm5leHREYXlUaHJlc2hvbGQgPSBtb21lbnQuZHVyYXRpb24oX3RoaXMub3B0KCduZXh0RGF5VGhyZXNob2xkJykpO1xyXG4gICAgICAgIF90aGlzLmlzUlRMID0gX3RoaXMub3B0KCdpc1JUTCcpO1xyXG4gICAgICAgIGlmIChfdGhpcy5maWxsUmVuZGVyZXJDbGFzcykge1xyXG4gICAgICAgICAgICBfdGhpcy5maWxsUmVuZGVyZXIgPSBuZXcgX3RoaXMuZmlsbFJlbmRlcmVyQ2xhc3MoX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoX3RoaXMuZXZlbnRSZW5kZXJlckNsYXNzKSB7IC8vIGZpbGxSZW5kZXJlciBpcyBvcHRpb25hbCAtLS0tLXZcclxuICAgICAgICAgICAgX3RoaXMuZXZlbnRSZW5kZXJlciA9IG5ldyBfdGhpcy5ldmVudFJlbmRlcmVyQ2xhc3MoX3RoaXMsIF90aGlzLmZpbGxSZW5kZXJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5oZWxwZXJSZW5kZXJlckNsYXNzICYmIF90aGlzLmV2ZW50UmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGVscGVyUmVuZGVyZXIgPSBuZXcgX3RoaXMuaGVscGVyUmVuZGVyZXJDbGFzcyhfdGhpcywgX3RoaXMuZXZlbnRSZW5kZXJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfdGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlckNsYXNzICYmIF90aGlzLmZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgICAgICBfdGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlciA9IG5ldyBfdGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlckNsYXNzKF90aGlzLCBfdGhpcy5maWxsUmVuZGVyZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jaGlsZHJlbkJ5VWlkW2NoaWxkLnVpZF0pIHtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbkJ5VWlkW2NoaWxkLnVpZF0gPSBjaGlsZDtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW1vdmVDaGlsZCA9IGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuQnlVaWRbY2hpbGQudWlkXSkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jaGlsZHJlbkJ5VWlkW2NoaWxkLnVpZF07XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLy8gVE9ETzogb25seSBkbyBpZiBpc0luRG9tP1xyXG4gICAgLy8gVE9ETzogbWFrZSBwYXJ0IG9mIENvbXBvbmVudCwgYWxvbmcgd2l0aCBjaGlsZHJlbi9iYXRjaC1yZW5kZXIgc3lzdGVtP1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1cGRhdGVTaXplJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBPcHRpb25zXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUub3B0ID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VmlldygpLm9wdChuYW1lKTsgLy8gZGVmYXVsdCBpbXBsZW1lbnRhdGlvblxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnB1YmxpY2x5VHJpZ2dlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5fZ2V0Q2FsZW5kYXIoKTtcclxuICAgICAgICByZXR1cm4gY2FsZW5kYXIucHVibGljbHlUcmlnZ2VyLmFwcGx5KGNhbGVuZGFyLCBhcmdzKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5oYXNQdWJsaWNIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdGhpcy5fZ2V0Q2FsZW5kYXIoKTtcclxuICAgICAgICByZXR1cm4gY2FsZW5kYXIuaGFzUHVibGljSGFuZGxlcnMuYXBwbHkoY2FsZW5kYXIsIGFyZ3MpO1xyXG4gICAgfTtcclxuICAgIC8vIERhdGVcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5leGVjdXRlRGF0ZVJlbmRlciA9IGZ1bmN0aW9uIChkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHRoaXMuZGF0ZVByb2ZpbGUgPSBkYXRlUHJvZmlsZTsgLy8gZm9yIHJlbmRlcmluZ1xyXG4gICAgICAgIHRoaXMucmVuZGVyRGF0ZXMoZGF0ZVByb2ZpbGUpO1xyXG4gICAgICAgIHRoaXMuaXNEYXRlc1JlbmRlcmVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignZXhlY3V0ZURhdGVSZW5kZXInLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV4ZWN1dGVEYXRlVW5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ2V4ZWN1dGVEYXRlVW5yZW5kZXInLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuZGF0ZVByb2ZpbGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJEYXRlcygpO1xyXG4gICAgICAgIHRoaXMuaXNEYXRlc1JlbmRlcmVkID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLy8gZGF0ZS1jZWxsIGNvbnRlbnQgb25seVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIHNob3VsZCBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvLyBkYXRlLWNlbGwgY29udGVudCBvbmx5XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIHN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlXHJcbiAgICB9O1xyXG4gICAgLy8gTm93LUluZGljYXRvclxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFJldHVybnMgYSBzdHJpbmcgdW5pdCwgbGlrZSAnc2Vjb25kJyBvciAnbWludXRlJyB0aGF0IGRlZmluZWQgaG93IG9mdGVuIHRoZSBjdXJyZW50IHRpbWUgaW5kaWNhdG9yXHJcbiAgICAvLyBzaG91bGQgYmUgcmVmcmVzaGVkLiBJZiBzb21ldGhpbmcgZmFsc3kgaXMgcmV0dXJuZWQsIG5vIHRpbWUgaW5kaWNhdG9yIGlzIHJlbmRlcmVkIGF0IGFsbC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldE5vd0luZGljYXRvclVuaXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gc3ViY2xhc3NlcyBzaG91bGQgaW1wbGVtZW50XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVycyBhIGN1cnJlbnQgdGltZSBpbmRpY2F0b3IgYXQgdGhlIGdpdmVuIGRhdGV0aW1lXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdyZW5kZXJOb3dJbmRpY2F0b3InLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFVuZG9lcyB0aGUgcmVuZGVyaW5nIGFjdGlvbnMgZnJvbSByZW5kZXJOb3dJbmRpY2F0b3JcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyTm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1bnJlbmRlck5vd0luZGljYXRvcicsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVzaW5lc3MgSG91cnNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyQnVzaW5lc3NIb3VycyA9IGZ1bmN0aW9uIChidXNpbmVzc0hvdXJHZW5lcmF0b3IpIHtcclxuICAgICAgICBpZiAodGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyLnJlbmRlcihidXNpbmVzc0hvdXJHZW5lcmF0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigncmVuZGVyQnVzaW5lc3NIb3VycycsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIHByZXZpb3VzbHktcmVuZGVyZWQgYnVzaW5lc3MtaG91cnNcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyQnVzaW5lc3NIb3VycyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndW5yZW5kZXJCdXNpbmVzc0hvdXJzJywgYXJndW1lbnRzKTtcclxuICAgICAgICBpZiAodGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlcikge1xyXG4gICAgICAgICAgICB0aGlzLmJ1c2luZXNzSG91clJlbmRlcmVyLnVucmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEV2ZW50IERpc3BsYXlpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5leGVjdXRlRXZlbnRSZW5kZXIgPSBmdW5jdGlvbiAoZXZlbnRzUGF5bG9hZCkge1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50UmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnJhbmdlVXBkYXRlZCgpOyAvLyBwb29ybHkgbmFtZWQgbm93XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRSZW5kZXJlci5yZW5kZXIoZXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXNbJ3JlbmRlckV2ZW50cyddKSB7IC8vIGxlZ2FjeVxyXG4gICAgICAgICAgICB0aGlzWydyZW5kZXJFdmVudHMnXShjb252ZXJ0RXZlbnRzUGF5bG9hZFRvTGVnYWN5QXJyYXkoZXZlbnRzUGF5bG9hZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignZXhlY3V0ZUV2ZW50UmVuZGVyJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5leGVjdXRlRXZlbnRVbnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignZXhlY3V0ZUV2ZW50VW5yZW5kZXInLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIGlmICh0aGlzLmV2ZW50UmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudFJlbmRlcmVyLnVucmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXNbJ2Rlc3Ryb3lFdmVudHMnXSkgeyAvLyBsZWdhY3lcclxuICAgICAgICAgICAgdGhpc1snZGVzdHJveUV2ZW50cyddKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldEJ1c2luZXNzSG91clNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLmdldE93bkJ1c2luZXNzSG91clNlZ3MoKTtcclxuICAgICAgICB0aGlzLml0ZXJDaGlsZHJlbihmdW5jdGlvbiAoY2hpbGQpIHtcclxuICAgICAgICAgICAgc2Vncy5wdXNoLmFwcGx5KHNlZ3MsIGNoaWxkLmdldEJ1c2luZXNzSG91clNlZ3MoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0T3duQnVzaW5lc3NIb3VyU2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5idXNpbmVzc0hvdXJSZW5kZXJlci5nZXRTZWdzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRFdmVudFNlZ3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLmdldE93bkV2ZW50U2VncygpO1xyXG4gICAgICAgIHRoaXMuaXRlckNoaWxkcmVuKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBzZWdzLnB1c2guYXBwbHkoc2VncywgY2hpbGQuZ2V0RXZlbnRTZWdzKCkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBzZWdzO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldE93bkV2ZW50U2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5ldmVudFJlbmRlcmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50UmVuZGVyZXIuZ2V0U2VncygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQgUmVuZGVyaW5nIFRyaWdnZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyQWZ0ZXJFdmVudHNSZW5kZXJlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnRyaWdnZXJBZnRlckV2ZW50U2Vnc1JlbmRlcmVkKHRoaXMuZ2V0RXZlbnRTZWdzKCkpO1xyXG4gICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdldmVudEFmdGVyQWxsUmVuZGVyJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiB0aGlzLFxyXG4gICAgICAgICAgICBhcmdzOiBbdGhpc11cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS50cmlnZ2VyQWZ0ZXJFdmVudFNlZ3NSZW5kZXJlZCA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBhbiBvcHRpbWl6YXRpb24sIGJlY2F1c2UgZ2V0RXZlbnRMZWdhY3kgaXMgZXhwZW5zaXZlXHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUHVibGljSGFuZGxlcnMoJ2V2ZW50QWZ0ZXJSZW5kZXInKSkge1xyXG4gICAgICAgICAgICBzZWdzLmZvckVhY2goZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGxlZ2FjeTtcclxuICAgICAgICAgICAgICAgIGlmIChzZWcuZWwpIHsgLy8gbmVjZXNzYXJ5P1xyXG4gICAgICAgICAgICAgICAgICAgIGxlZ2FjeSA9IHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50QWZ0ZXJSZW5kZXInLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGxlZ2FjeSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2xlZ2FjeSwgc2VnLmVsLCBfdGhpc11cclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXJCZWZvcmVFdmVudHNEZXN0cm95ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyQmVmb3JlRXZlbnRTZWdzRGVzdHJveWVkKHRoaXMuZ2V0RXZlbnRTZWdzKCkpO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnRyaWdnZXJCZWZvcmVFdmVudFNlZ3NEZXN0cm95ZWQgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzUHVibGljSGFuZGxlcnMoJ2V2ZW50RGVzdHJveScpKSB7XHJcbiAgICAgICAgICAgIHNlZ3MuZm9yRWFjaChmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGVnYWN5O1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlZy5lbCkgeyAvLyBuZWNlc3Nhcnk/XHJcbiAgICAgICAgICAgICAgICAgICAgbGVnYWN5ID0gc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnB1YmxpY2x5VHJpZ2dlcignZXZlbnREZXN0cm95Jywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBsZWdhY3ksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtsZWdhY3ksIHNlZy5lbCwgX3RoaXNdXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBSZW5kZXJpbmcgVXRpbHNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBIaWRlcyBhbGwgcmVuZGVyZWQgZXZlbnQgc2VnbWVudHMgbGlua2VkIHRvIHRoZSBnaXZlbiBldmVudFxyXG4gICAgLy8gUkVDVVJTSVZFIHdpdGggc3ViY29tcG9uZW50c1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuc2hvd0V2ZW50c1dpdGhJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgdGhpcy5nZXRFdmVudFNlZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgaWYgKHNlZy5mb290cHJpbnQuZXZlbnREZWYuaWQgPT09IGV2ZW50RGVmSWQgJiZcclxuICAgICAgICAgICAgICAgIHNlZy5lbCAvLyBuZWNlc3Nhcnk/XHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmVsLmNzcygndmlzaWJpbGl0eScsICcnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdzaG93RXZlbnRzV2l0aElkJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBTaG93cyBhbGwgcmVuZGVyZWQgZXZlbnQgc2VnbWVudHMgbGlua2VkIHRvIHRoZSBnaXZlbiBldmVudFxyXG4gICAgLy8gUkVDVVJTSVZFIHdpdGggc3ViY29tcG9uZW50c1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaGlkZUV2ZW50c1dpdGhJZCA9IGZ1bmN0aW9uIChldmVudERlZklkKSB7XHJcbiAgICAgICAgdGhpcy5nZXRFdmVudFNlZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgaWYgKHNlZy5mb290cHJpbnQuZXZlbnREZWYuaWQgPT09IGV2ZW50RGVmSWQgJiZcclxuICAgICAgICAgICAgICAgIHNlZy5lbCAvLyBuZWNlc3Nhcnk/XHJcbiAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgc2VnLmVsLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdoaWRlRXZlbnRzV2l0aElkJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBEcmFnLW4tRHJvcCBSZW5kZXJpbmcgKGZvciBib3RoIGV2ZW50cyBhbmQgZXh0ZXJuYWwgZWxlbWVudHMpXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIGV2ZW50IG9yIGV4dGVybmFsLWVsZW1lbnQgZHJhZyBvdmVyIHRoZSBnaXZlbiBkcm9wIHpvbmUuXHJcbiAgICAvLyBJZiBhbiBleHRlcm5hbC1lbGVtZW50LCBzZWcgd2lsbCBiZSBgbnVsbGAuXHJcbiAgICAvLyBNdXN0IHJldHVybiBlbGVtZW50cyB1c2VkIGZvciBhbnkgbW9jayBldmVudHMuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXJEcmFnID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVkSGVscGVyID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5pdGVyQ2hpbGRyZW4oZnVuY3Rpb24gKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5yZW5kZXJEcmFnKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSkge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRIZWxwZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlbmRlcmVkSGVscGVyO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IG9yIGV4dGVybmFsLWVsZW1lbnQgYmVpbmcgZHJhZ2dlZC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnVucmVuZGVyRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndW5yZW5kZXJEcmFnJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBFdmVudCBSZXNpemluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZC5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlckV2ZW50UmVzaXplID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdGhpcy5jYWxsQ2hpbGRyZW4oJ3JlbmRlckV2ZW50UmVzaXplJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhbiBldmVudCBiZWluZyByZXNpemVkLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndW5yZW5kZXJFdmVudFJlc2l6ZScsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gU2VsZWN0aW9uXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiB0aGUgc2VsZWN0aW9uXHJcbiAgICAvLyBUT0RPOiByZW5hbWUgdG8gYHJlbmRlclNlbGVjdGlvbmAgYWZ0ZXIgbGVnYWN5IGlzIGdvbmVcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlclNlbGVjdGlvbkZvb3RwcmludCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodChjb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdyZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIHNlbGVjdGlvblxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUudW5yZW5kZXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy51bnJlbmRlckhpZ2hsaWdodCgpO1xyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCd1bnJlbmRlclNlbGVjdGlvbicsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgLy8gSGlnaGxpZ2h0XHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFJlbmRlcnMgYW4gZW1waGFzaXMgb24gdGhlIGdpdmVuIGRhdGUgcmFuZ2UuIEdpdmVuIGEgc3BhbiAodW56b25lZCBzdGFydC9lbmQgYW5kIG90aGVyIG1pc2MgZGF0YSlcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLnJlbmRlckhpZ2hsaWdodCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIucmVuZGVyRm9vdHByaW50KCdoaWdobGlnaHQnLCBjb21wb25lbnRGb290cHJpbnQsIHtcclxuICAgICAgICAgICAgICAgIGdldENsYXNzZXM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWydmYy1oaWdobGlnaHQnXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdyZW5kZXJIaWdobGlnaHQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyB0aGUgZW1waGFzaXMgb24gYSBkYXRlIHJhbmdlXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS51bnJlbmRlckhpZ2hsaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5maWxsUmVuZGVyZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5maWxsUmVuZGVyZXIudW5yZW5kZXIoJ2hpZ2hsaWdodCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbigndW5yZW5kZXJIaWdobGlnaHQnLCBhcmd1bWVudHMpO1xyXG4gICAgfTtcclxuICAgIC8vIEhpdCBBcmVhc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBqdXN0IGJlY2F1c2UgYWxsIERhdGVDb21wb25lbnRzIHN1cHBvcnQgdGhpcyBpbnRlcmZhY2VcclxuICAgIC8vIGRvZXNuJ3QgbWVhbiB0aGV5IG5lZWQgdG8gaGF2ZSB0aGVpciBvd24gaW50ZXJuYWwgY29vcmQgc3lzdGVtLiB0aGV5IGNhbiBkZWZlciB0byBzdWItY29tcG9uZW50cy5cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmhpdHNOZWVkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEodGhpcy5oaXRzTmVlZGVkRGVwdGgrKykpIHtcclxuICAgICAgICAgICAgdGhpcy5wcmVwYXJlSGl0cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNhbGxDaGlsZHJlbignaGl0c05lZWRlZCcsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaGl0c05vdE5lZWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5oaXRzTmVlZGVkRGVwdGggJiYgISgtLXRoaXMuaGl0c05lZWRlZERlcHRoKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbGVhc2VIaXRzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY2FsbENoaWxkcmVuKCdoaXRzTm90TmVlZGVkJywgYXJndW1lbnRzKTtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5wcmVwYXJlSGl0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5yZWxlYXNlSGl0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBzdWJjbGFzc2VzIGNhbiBpbXBsZW1lbnRcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBjb29yZGluYXRlcyBmcm9tIHRoZSB0b3BsZWZ0IG9mIHRoZSBkb2N1bWVudCwgcmV0dXJuIGRhdGEgYWJvdXQgdGhlIGRhdGUtcmVsYXRlZCBhcmVhIHVuZGVybmVhdGguXHJcbiAgICAvLyBDYW4gcmV0dXJuIGFuIG9iamVjdCB3aXRoIGFyYml0cmFyeSBwcm9wZXJ0aWVzIChhbHRob3VnaCB0b3AvcmlnaHQvbGVmdC9ib3R0b20gYXJlIGVuY291cmFnZWQpLlxyXG4gICAgLy8gTXVzdCBoYXZlIGEgYGdyaWRgIHByb3BlcnR5LCBhIHJlZmVyZW5jZSB0byB0aGlzIGN1cnJlbnQgZ3JpZC4gVE9ETzogYXZvaWQgdGhpc1xyXG4gICAgLy8gVGhlIHJldHVybmVkIG9iamVjdCB3aWxsIGJlIHByb2Nlc3NlZCBieSBnZXRIaXRGb290cHJpbnQgYW5kIGdldEhpdEVsLlxyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucXVlcnlIaXQgPSBmdW5jdGlvbiAobGVmdE9mZnNldCwgdG9wT2Zmc2V0KSB7XHJcbiAgICAgICAgdmFyIGNoaWxkcmVuQnlVaWQgPSB0aGlzLmNoaWxkcmVuQnlVaWQ7XHJcbiAgICAgICAgdmFyIHVpZDtcclxuICAgICAgICB2YXIgaGl0O1xyXG4gICAgICAgIGZvciAodWlkIGluIGNoaWxkcmVuQnlVaWQpIHtcclxuICAgICAgICAgICAgaGl0ID0gY2hpbGRyZW5CeVVpZFt1aWRdLnF1ZXJ5SGl0KGxlZnRPZmZzZXQsIHRvcE9mZnNldCk7XHJcbiAgICAgICAgICAgIGlmIChoaXQpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBoaXQ7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0U2FmZUhpdEZvb3RwcmludCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICB2YXIgZm9vdHByaW50ID0gdGhpcy5nZXRIaXRGb290cHJpbnQoaGl0KTtcclxuICAgICAgICBpZiAoIXRoaXMuZGF0ZVByb2ZpbGUuYWN0aXZlVW56b25lZFJhbmdlLmNvbnRhaW5zUmFuZ2UoZm9vdHByaW50LnVuem9uZWRSYW5nZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb290cHJpbnQ7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuZ2V0SGl0Rm9vdHByaW50ID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIC8vIHdoYXQgYWJvdXQgYmVpbmcgYWJzdHJhY3QhP1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHBvc2l0aW9uLWxldmVsIGluZm9ybWF0aW9uIGFib3V0IGEgZGF0ZS1yZWxhdGVkIGFyZWEgd2l0aGluIHRoZSBncmlkLFxyXG4gICAgLy8gc2hvdWxkIHJldHVybiBhIGpRdWVyeSBlbGVtZW50IHRoYXQgYmVzdCByZXByZXNlbnRzIGl0LiBwYXNzZWQgdG8gZGF5Q2xpY2sgY2FsbGJhY2suXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRIaXRFbCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICAvLyB3aGF0IGFib3V0IGJlaW5nIGFic3RyYWN0IT9cclxuICAgIH07XHJcbiAgICAvKiBDb252ZXJ0aW5nIGV2ZW50UmFuZ2UgLT4gZXZlbnRGb290cHJpbnRcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50Rm9vdHByaW50cyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudFJhbmdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBldmVudEZvb3RwcmludHMucHVzaC5hcHBseSgvLyBhcHBlbmRcclxuICAgICAgICAgICAgZXZlbnRGb290cHJpbnRzLCB0aGlzLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50cyhldmVudFJhbmdlc1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZXZlbnRGb290cHJpbnRzO1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV2ZW50UmFuZ2VUb0V2ZW50Rm9vdHByaW50cyA9IGZ1bmN0aW9uIChldmVudFJhbmdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFt1dGlsXzIuZXZlbnRSYW5nZVRvRXZlbnRGb290cHJpbnQoZXZlbnRSYW5nZSldO1xyXG4gICAgfTtcclxuICAgIC8qIENvbnZlcnRpbmcgY29tcG9uZW50Rm9vdHByaW50L2V2ZW50Rm9vdHByaW50IC0+IHNlZ3NcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5ldmVudEZvb3RwcmludHNUb1NlZ3MgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzKSB7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZXZlbnRGb290cHJpbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZ3MucHVzaC5hcHBseShzZWdzLCB0aGlzLmV2ZW50Rm9vdHByaW50VG9TZWdzKGV2ZW50Rm9vdHByaW50c1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBldmVudCdzIHNwYW4gKHVuem9uZWQgc3RhcnQvZW5kIGFuZCBvdGhlciBtaXNjIGRhdGEpLCBhbmQgdGhlIGV2ZW50IGl0c2VsZixcclxuICAgIC8vIHNsaWNlcyBpbnRvIHNlZ21lbnRzIGFuZCBhdHRhY2hlcyBldmVudC1kZXJpdmVkIHByb3BlcnRpZXMgdG8gdGhlbS5cclxuICAgIC8vIGV2ZW50U3BhbiAtIHsgc3RhcnQsIGVuZCwgaXNTdGFydCwgaXNFbmQsIG90aGVydGhpbmdzLi4uIH1cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmV2ZW50Rm9vdHByaW50VG9TZWdzID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgdmFyIHVuem9uZWRSYW5nZSA9IGV2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIHNlZ3M7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICBzZWdzID0gdGhpcy5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MoZXZlbnRGb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBpZiAoIXVuem9uZWRSYW5nZS5pc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuaXNTdGFydCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdW56b25lZFJhbmdlLmlzRW5kKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuaXNFbmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZWcuZm9vdHByaW50ID0gZXZlbnRGb290cHJpbnQ7XHJcbiAgICAgICAgICAgIC8vIFRPRE86IHJlbmFtZSB0byBzZWcuZXZlbnRGb290cHJpbnRcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH07XHJcbiAgICAvLyBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jYWxsQ2hpbGRyZW4gPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgYXJncykge1xyXG4gICAgICAgIHRoaXMuaXRlckNoaWxkcmVuKGZ1bmN0aW9uIChjaGlsZCkge1xyXG4gICAgICAgICAgICBjaGlsZFttZXRob2ROYW1lXS5hcHBseShjaGlsZCwgYXJncyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUuaXRlckNoaWxkcmVuID0gZnVuY3Rpb24gKGZ1bmMpIHtcclxuICAgICAgICB2YXIgY2hpbGRyZW5CeVVpZCA9IHRoaXMuY2hpbGRyZW5CeVVpZDtcclxuICAgICAgICB2YXIgdWlkO1xyXG4gICAgICAgIGZvciAodWlkIGluIGNoaWxkcmVuQnlVaWQpIHtcclxuICAgICAgICAgICAgZnVuYyhjaGlsZHJlbkJ5VWlkW3VpZF0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5fZ2V0Q2FsZW5kYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHQgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0LmNhbGVuZGFyIHx8IHQudmlldy5jYWxlbmRhcjtcclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5fZ2V0VmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3O1xyXG4gICAgfTtcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLl9nZXREYXRlUHJvZmlsZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VmlldygpLmdldCgnZGF0ZVByb2ZpbGUnKTtcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgSFRNTCBmb3IgYW4gYW5jaG9yIHRvIGFub3RoZXIgdmlldyBpbnRvIHRoZSBjYWxlbmRhci5cclxuICAgIC8vIFdpbGwgZWl0aGVyIGdlbmVyYXRlIGFuIDxhPiB0YWcgb3IgYSBub24tY2xpY2thYmxlIDxzcGFuPiB0YWcsIGRlcGVuZGluZyBvbiBlbmFibGVkIHNldHRpbmdzLlxyXG4gICAgLy8gYGdvdG9PcHRpb25zYCBjYW4gZWl0aGVyIGJlIGEgbW9tZW50IGlucHV0LCBvciBhbiBvYmplY3Qgd2l0aCB0aGUgZm9ybTpcclxuICAgIC8vIHsgZGF0ZSwgdHlwZSwgZm9yY2VPZmYgfVxyXG4gICAgLy8gYHR5cGVgIGlzIGEgdmlldy10eXBlIGxpa2UgXCJkYXlcIiBvciBcIndlZWtcIi4gZGVmYXVsdCB2YWx1ZSBpcyBcImRheVwiLlxyXG4gICAgLy8gYGF0dHJzYCBhbmQgYGlubmVySHRtbGAgYXJlIHVzZSB0byBnZW5lcmF0ZSB0aGUgcmVzdCBvZiB0aGUgSFRNTCB0YWcuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5idWlsZEdvdG9BbmNob3JIdG1sID0gZnVuY3Rpb24gKGdvdG9PcHRpb25zLCBhdHRycywgaW5uZXJIdG1sKSB7XHJcbiAgICAgICAgdmFyIGRhdGU7XHJcbiAgICAgICAgdmFyIHR5cGU7XHJcbiAgICAgICAgdmFyIGZvcmNlT2ZmO1xyXG4gICAgICAgIHZhciBmaW5hbE9wdGlvbnM7XHJcbiAgICAgICAgaWYgKCQuaXNQbGFpbk9iamVjdChnb3RvT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgZGF0ZSA9IGdvdG9PcHRpb25zLmRhdGU7XHJcbiAgICAgICAgICAgIHR5cGUgPSBnb3RvT3B0aW9ucy50eXBlO1xyXG4gICAgICAgICAgICBmb3JjZU9mZiA9IGdvdG9PcHRpb25zLmZvcmNlT2ZmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZGF0ZSA9IGdvdG9PcHRpb25zOyAvLyBhIHNpbmdsZSBtb21lbnQgaW5wdXRcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0ZSA9IG1vbWVudF9leHRfMS5kZWZhdWx0KGRhdGUpOyAvLyBpZiBhIHN0cmluZywgcGFyc2UgaXRcclxuICAgICAgICBmaW5hbE9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGRhdGU6IGRhdGUuZm9ybWF0KCdZWVlZLU1NLUREJyksXHJcbiAgICAgICAgICAgIHR5cGU6IHR5cGUgfHwgJ2RheSdcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXR0cnMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlubmVySHRtbCA9IGF0dHJzO1xyXG4gICAgICAgICAgICBhdHRycyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF0dHJzID0gYXR0cnMgPyAnICcgKyB1dGlsXzEuYXR0cnNUb1N0cihhdHRycykgOiAnJzsgLy8gd2lsbCBoYXZlIGEgbGVhZGluZyBzcGFjZVxyXG4gICAgICAgIGlubmVySHRtbCA9IGlubmVySHRtbCB8fCAnJztcclxuICAgICAgICBpZiAoIWZvcmNlT2ZmICYmIHRoaXMub3B0KCduYXZMaW5rcycpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnPGEnICsgYXR0cnMgK1xyXG4gICAgICAgICAgICAgICAgJyBkYXRhLWdvdG89XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoSlNPTi5zdHJpbmdpZnkoZmluYWxPcHRpb25zKSkgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICBpbm5lckh0bWwgK1xyXG4gICAgICAgICAgICAgICAgJzwvYT4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuICc8c3BhbicgKyBhdHRycyArICc+JyArXHJcbiAgICAgICAgICAgICAgICBpbm5lckh0bWwgK1xyXG4gICAgICAgICAgICAgICAgJzwvc3Bhbj4nO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5nZXRBbGxEYXlIdG1sID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnYWxsRGF5SHRtbCcpIHx8IHV0aWxfMS5odG1sRXNjYXBlKHRoaXMub3B0KCdhbGxEYXlUZXh0JykpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIEhUTUwgY2xhc3NOYW1lcyBmb3IgYSBzaW5nbGUtZGF5IGVsZW1lbnRcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmdldERheUNsYXNzZXMgPSBmdW5jdGlvbiAoZGF0ZSwgbm9UaGVtZUhpZ2hsaWdodCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy5fZ2V0VmlldygpO1xyXG4gICAgICAgIHZhciBjbGFzc2VzID0gW107XHJcbiAgICAgICAgdmFyIHRvZGF5O1xyXG4gICAgICAgIGlmICghdGhpcy5kYXRlUHJvZmlsZS5hY3RpdmVVbnpvbmVkUmFuZ2UuY29udGFpbnNEYXRlKGRhdGUpKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtZGlzYWJsZWQtZGF5Jyk7IC8vIFRPRE86IGpRdWVyeSBVSSB0aGVtZT9cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtJyArIHV0aWxfMS5kYXlJRHNbZGF0ZS5kYXkoKV0pO1xyXG4gICAgICAgICAgICBpZiAodmlldy5pc0RhdGVJbk90aGVyTW9udGgoZGF0ZSwgdGhpcy5kYXRlUHJvZmlsZSkpIHsgLy8gVE9ETzogdXNlIERhdGVDb21wb25lbnQgc3ViY2xhc3Mgc29tZWhvd1xyXG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1vdGhlci1tb250aCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRvZGF5ID0gdmlldy5jYWxlbmRhci5nZXROb3coKTtcclxuICAgICAgICAgICAgaWYgKGRhdGUuaXNTYW1lKHRvZGF5LCAnZGF5JykpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtdG9kYXknKTtcclxuICAgICAgICAgICAgICAgIGlmIChub1RoZW1lSGlnaGxpZ2h0ICE9PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3RvZGF5JykpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGUgPCB0b2RheSkge1xyXG4gICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKCdmYy1wYXN0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goJ2ZjLWZ1dHVyZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbGFzc2VzO1xyXG4gICAgfTtcclxuICAgIC8vIFV0aWxpdHkgZm9yIGZvcm1hdHRpbmcgYSByYW5nZS4gQWNjZXB0cyBhIHJhbmdlIG9iamVjdCwgZm9ybWF0dGluZyBzdHJpbmcsIGFuZCBvcHRpb25hbCBzZXBhcmF0b3IuXHJcbiAgICAvLyBEaXNwbGF5cyBhbGwtZGF5IHJhbmdlcyBuYXR1cmFsbHksIHdpdGggYW4gaW5jbHVzaXZlIGVuZC4gVGFrZXMgdGhlIGN1cnJlbnQgaXNSVEwgaW50byBhY2NvdW50LlxyXG4gICAgLy8gVGhlIHRpbWV6b25lcyBvZiB0aGUgZGF0ZXMgd2l0aGluIGByYW5nZWAgd2lsbCBiZSByZXNwZWN0ZWQuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSwgaXNBbGxEYXksIGZvcm1hdFN0ciwgc2VwYXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGVuZCA9IHJhbmdlLmVuZDtcclxuICAgICAgICBpZiAoaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgZW5kID0gZW5kLmNsb25lKCkuc3VidHJhY3QoMSk7IC8vIGNvbnZlcnQgdG8gaW5jbHVzaXZlLiBsYXN0IG1zIG9mIHByZXZpb3VzIGRheVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGF0ZV9mb3JtYXR0aW5nXzEuZm9ybWF0UmFuZ2UocmFuZ2Uuc3RhcnQsIGVuZCwgZm9ybWF0U3RyLCBzZXBhcmF0b3IsIHRoaXMuaXNSVEwpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGUgdGhlIG51bWJlciBvZiB0aGUgZ2l2ZSB1bml0cyBpbiB0aGUgXCJjdXJyZW50XCIgcmFuZ2UuXHJcbiAgICAvLyBXaWxsIHJldHVybiBhIGZsb2F0aW5nLXBvaW50IG51bWJlci4gV29uJ3Qgcm91bmQuXHJcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5jdXJyZW50UmFuZ2VBcyA9IGZ1bmN0aW9uICh1bml0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldERhdGVQcm9maWxlKCkuY3VycmVudFVuem9uZWRSYW5nZS5hcyh1bml0KTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIHRoZSBkYXRlIHJhbmdlIG9mIHRoZSBmdWxsIGRheXMgdGhlIGdpdmVuIHJhbmdlIHZpc3VhbGx5IGFwcGVhcnMgdG8gb2NjdXB5LlxyXG4gICAgLy8gUmV0dXJucyBhIHBsYWluIG9iamVjdCB3aXRoIHN0YXJ0L2VuZCwgTk9UIGFuIFVuem9uZWRSYW5nZSFcclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmNvbXB1dGVEYXlSYW5nZSA9IGZ1bmN0aW9uICh1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLl9nZXRDYWxlbmRhcigpO1xyXG4gICAgICAgIHZhciBzdGFydERheSA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQodW56b25lZFJhbmdlLnN0YXJ0TXMsIHRydWUpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIHN0YXJ0c1xyXG4gICAgICAgIHZhciBlbmQgPSBjYWxlbmRhci5tc1RvVXRjTW9tZW50KHVuem9uZWRSYW5nZS5lbmRNcyk7XHJcbiAgICAgICAgdmFyIGVuZFRpbWVNUyA9ICtlbmQudGltZSgpOyAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXHJcbiAgICAgICAgdmFyIGVuZERheSA9IGVuZC5jbG9uZSgpLnN0cmlwVGltZSgpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIGV4Y2x1c2l2ZWx5IGVuZHNcclxuICAgICAgICAvLyBJZiB0aGUgZW5kIHRpbWUgaXMgYWN0dWFsbHkgaW5jbHVzaXZlbHkgcGFydCBvZiB0aGUgbmV4dCBkYXkgYW5kIGlzIGVxdWFsIHRvIG9yXHJcbiAgICAgICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxyXG4gICAgICAgIC8vIE90aGVyd2lzZSwgbGVhdmluZyBpdCBhcyBpbmNsdXNpdmUgd2lsbCBjYXVzZSBpdCB0byBleGNsdWRlIGBlbmREYXlgLlxyXG4gICAgICAgIGlmIChlbmRUaW1lTVMgJiYgZW5kVGltZU1TID49IHRoaXMubmV4dERheVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICBlbmREYXkuYWRkKDEsICdkYXlzJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGVuZCBpcyB3aXRoaW4gYHN0YXJ0RGF5YCBidXQgbm90IHBhc3QgbmV4dERheVRocmVzaG9sZCwgYXNzaWduIHRoZSBkZWZhdWx0IGR1cmF0aW9uIG9mIG9uZSBkYXkuXHJcbiAgICAgICAgaWYgKGVuZERheSA8PSBzdGFydERheSkge1xyXG4gICAgICAgICAgICBlbmREYXkgPSBzdGFydERheS5jbG9uZSgpLmFkZCgxLCAnZGF5cycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnREYXksIGVuZDogZW5kRGF5IH07XHJcbiAgICB9O1xyXG4gICAgLy8gRG9lcyB0aGUgZ2l2ZW4gcmFuZ2UgdmlzdWFsbHkgYXBwZWFyIHRvIG9jY3VweSBtb3JlIHRoYW4gb25lIGRheT9cclxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmlzTXVsdGlEYXlSYW5nZSA9IGZ1bmN0aW9uICh1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgZGF5UmFuZ2UgPSB0aGlzLmNvbXB1dGVEYXlSYW5nZSh1bnpvbmVkUmFuZ2UpO1xyXG4gICAgICAgIHJldHVybiBkYXlSYW5nZS5lbmQuZGlmZihkYXlSYW5nZS5zdGFydCwgJ2RheXMnKSA+IDE7XHJcbiAgICB9O1xyXG4gICAgRGF0ZUNvbXBvbmVudC5ndWlkID0gMDsgLy8gVE9ETzogYmV0dGVyIHN5c3RlbSBmb3IgdGhpcz9cclxuICAgIHJldHVybiBEYXRlQ29tcG9uZW50O1xyXG59KENvbXBvbmVudF8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0ZUNvbXBvbmVudDtcclxuLy8gbGVnYWN5XHJcbmZ1bmN0aW9uIGNvbnZlcnRFdmVudHNQYXlsb2FkVG9MZWdhY3lBcnJheShldmVudHNQYXlsb2FkKSB7XHJcbiAgICB2YXIgZXZlbnREZWZJZDtcclxuICAgIHZhciBldmVudEluc3RhbmNlcztcclxuICAgIHZhciBsZWdhY3lFdmVudHMgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChldmVudERlZklkIGluIGV2ZW50c1BheWxvYWQpIHtcclxuICAgICAgICBldmVudEluc3RhbmNlcyA9IGV2ZW50c1BheWxvYWRbZXZlbnREZWZJZF0uZXZlbnRJbnN0YW5jZXM7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV2ZW50SW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxlZ2FjeUV2ZW50cy5wdXNoKGV2ZW50SW5zdGFuY2VzW2ldLnRvTGVnYWN5KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBsZWdhY3lFdmVudHM7XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBvcHRpb25zXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcclxudmFyIEl0ZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNSk7XHJcbnZhciBHbG9iYWxFbWl0dGVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxudmFyIEVtaXR0ZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbnZhciBMaXN0ZW5lck1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG52YXIgVG9vbGJhcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTcpO1xyXG52YXIgT3B0aW9uc01hbmFnZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjU4KTtcclxudmFyIFZpZXdTcGVjTWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNTkpO1xyXG52YXIgQ29uc3RyYWludHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjE3KTtcclxudmFyIGxvY2FsZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XHJcbnZhciBtb21lbnRfZXh0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIENvbXBvbmVudEZvb3RwcmludF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XHJcbnZhciBFdmVudERhdGVQcm9maWxlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxudmFyIEV2ZW50TWFuYWdlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjApO1xyXG52YXIgQnVzaW5lc3NIb3VyR2VuZXJhdG9yXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxOCk7XHJcbnZhciBFdmVudFNvdXJjZVBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcbnZhciBFdmVudERlZlBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNik7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxudmFyIEV2ZW50RGVmTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG52YXIgRXZlbnRTb3VyY2VfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbnZhciBUaGVtZVJlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcclxudmFyIENhbGVuZGFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ2FsZW5kYXIoZWwsIG92ZXJyaWRlcykge1xyXG4gICAgICAgIHRoaXMubG9hZGluZ0xldmVsID0gMDsgLy8gbnVtYmVyIG9mIHNpbXVsdGFuZW91cyBsb2FkaW5nIHRhc2tzXHJcbiAgICAgICAgdGhpcy5pZ25vcmVVcGRhdGVWaWV3U2l6ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5mcmVlemVDb250ZW50SGVpZ2h0RGVwdGggPSAwO1xyXG4gICAgICAgIC8vIGRlY2xhcmUgdGhlIGN1cnJlbnQgY2FsZW5kYXIgaW5zdGFuY2UgcmVsaWVzIG9uIEdsb2JhbEVtaXR0ZXIuIG5lZWRlZCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxyXG4gICAgICAgIC8vIHVubmVlZGVkKCkgaXMgY2FsbGVkIGluIGRlc3Ryb3kuXHJcbiAgICAgICAgR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQubmVlZGVkKCk7XHJcbiAgICAgICAgdGhpcy5lbCA9IGVsO1xyXG4gICAgICAgIHRoaXMudmlld3NCeVR5cGUgPSB7fTtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyID0gbmV3IE9wdGlvbnNNYW5hZ2VyXzEuZGVmYXVsdCh0aGlzLCBvdmVycmlkZXMpO1xyXG4gICAgICAgIHRoaXMudmlld1NwZWNNYW5hZ2VyID0gbmV3IFZpZXdTcGVjTWFuYWdlcl8xLmRlZmF1bHQodGhpcy5vcHRpb25zTWFuYWdlciwgdGhpcyk7XHJcbiAgICAgICAgdGhpcy5pbml0TW9tZW50SW50ZXJuYWxzKCk7IC8vIG5lZWRzIHRvIGhhcHBlbiBhZnRlciBvcHRpb25zIGhhc2ggaW5pdGlhbGl6ZWRcclxuICAgICAgICB0aGlzLmluaXRDdXJyZW50RGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuaW5pdEV2ZW50TWFuYWdlcigpO1xyXG4gICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBuZXcgQ29uc3RyYWludHNfMS5kZWZhdWx0KHRoaXMuZXZlbnRNYW5hZ2VyLCB0aGlzKTtcclxuICAgICAgICB0aGlzLmNvbnN0cnVjdGVkKCk7XHJcbiAgICB9XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY29uc3RydWN0ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gdXNlZnVsIGZvciBtb25rZXlwYXRjaGluZy4gdXNlZD9cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0VmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52aWV3O1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wdWJsaWNseVRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSwgdHJpZ2dlckluZm8pIHtcclxuICAgICAgICB2YXIgb3B0SGFuZGxlciA9IHRoaXMub3B0KG5hbWUpO1xyXG4gICAgICAgIHZhciBjb250ZXh0O1xyXG4gICAgICAgIHZhciBhcmdzO1xyXG4gICAgICAgIGlmICgkLmlzUGxhaW5PYmplY3QodHJpZ2dlckluZm8pKSB7XHJcbiAgICAgICAgICAgIGNvbnRleHQgPSB0cmlnZ2VySW5mby5jb250ZXh0O1xyXG4gICAgICAgICAgICBhcmdzID0gdHJpZ2dlckluZm8uYXJncztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJC5pc0FycmF5KHRyaWdnZXJJbmZvKSkge1xyXG4gICAgICAgICAgICBhcmdzID0gdHJpZ2dlckluZm87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb250ZXh0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgY29udGV4dCA9IHRoaXMuZWxbMF07IC8vIGZhbGxiYWNrIGNvbnRleHRcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhcmdzKSB7XHJcbiAgICAgICAgICAgIGFyZ3MgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmlnZ2VyV2l0aChuYW1lLCBjb250ZXh0LCBhcmdzKTsgLy8gRW1pdHRlcidzIG1ldGhvZFxyXG4gICAgICAgIGlmIChvcHRIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBvcHRIYW5kbGVyLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaGFzUHVibGljSGFuZGxlcnMgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhc0hhbmRsZXJzKG5hbWUpIHx8XHJcbiAgICAgICAgICAgIHRoaXMub3B0KG5hbWUpOyAvLyBoYW5kbGVyIHNwZWNpZmllZCBpbiBvcHRpb25zXHJcbiAgICB9O1xyXG4gICAgLy8gT3B0aW9ucyBQdWJsaWMgQVBJXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgLy8gcHVibGljIGdldHRlci9zZXR0ZXJcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5vcHRpb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcclxuICAgICAgICB2YXIgbmV3T3B0aW9uSGFzaDtcclxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7IC8vIGdldHRlclxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc01hbmFnZXIuZ2V0KG5hbWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgeyAvLyBzZXR0ZXIgZm9yIGluZGl2aWR1YWwgb3B0aW9uXHJcbiAgICAgICAgICAgICAgICBuZXdPcHRpb25IYXNoID0ge307XHJcbiAgICAgICAgICAgICAgICBuZXdPcHRpb25IYXNoW25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLmFkZChuZXdPcHRpb25IYXNoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHsgLy8gY29tcG91bmQgc2V0dGVyIHdpdGggb2JqZWN0IGlucHV0XHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIuYWRkKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBwcml2YXRlIGdldHRlclxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm9wdCA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc01hbmFnZXIuZ2V0KG5hbWUpO1xyXG4gICAgfTtcclxuICAgIC8vIFZpZXdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyBHaXZlbiBhIHZpZXcgbmFtZSBmb3IgYSBjdXN0b20gdmlldyBvciBhIHN0YW5kYXJkIHZpZXcsIGNyZWF0ZXMgYSByZWFkeS10by1nbyBWaWV3IG9iamVjdFxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmluc3RhbnRpYXRlVmlldyA9IGZ1bmN0aW9uICh2aWV3VHlwZSkge1xyXG4gICAgICAgIHZhciBzcGVjID0gdGhpcy52aWV3U3BlY01hbmFnZXIuZ2V0Vmlld1NwZWModmlld1R5cGUpO1xyXG4gICAgICAgIGlmICghc3BlYykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWaWV3IHR5cGUgXFxcIlwiICsgdmlld1R5cGUgKyBcIlxcXCIgaXMgbm90IHZhbGlkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IHNwZWNbJ2NsYXNzJ10odGhpcywgc3BlYyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmV0dXJucyBhIGJvb2xlYW4gYWJvdXQgd2hldGhlciB0aGUgdmlldyBpcyBva2F5IHRvIGluc3RhbnRpYXRlIGF0IHNvbWUgcG9pbnRcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pc1ZhbGlkVmlld1R5cGUgPSBmdW5jdGlvbiAodmlld1R5cGUpIHtcclxuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLnZpZXdTcGVjTWFuYWdlci5nZXRWaWV3U3BlYyh2aWV3VHlwZSkpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jaGFuZ2VWaWV3ID0gZnVuY3Rpb24gKHZpZXdOYW1lLCBkYXRlT3JSYW5nZSkge1xyXG4gICAgICAgIGlmIChkYXRlT3JSYW5nZSkge1xyXG4gICAgICAgICAgICBpZiAoZGF0ZU9yUmFuZ2Uuc3RhcnQgJiYgZGF0ZU9yUmFuZ2UuZW5kKSB7IC8vIGEgcmFuZ2VcclxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIucmVjb3JkT3ZlcnJpZGVzKHtcclxuICAgICAgICAgICAgICAgICAgICB2aXNpYmxlUmFuZ2U6IGRhdGVPclJhbmdlXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHsgLy8gYSBkYXRlXHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5tb21lbnQoZGF0ZU9yUmFuZ2UpLnN0cmlwWm9uZSgpOyAvLyBqdXN0IGxpa2UgZ290b0RhdGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcodmlld05hbWUpO1xyXG4gICAgfTtcclxuICAgIC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXHJcbiAgICAvLyBgdmlld1R5cGVgIGNhbiBiZSBhIHNwZWNpZmljIHZpZXcgbmFtZSBvciBhIGdlbmVyaWMgb25lIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIi5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS56b29tVG8gPSBmdW5jdGlvbiAobmV3RGF0ZSwgdmlld1R5cGUpIHtcclxuICAgICAgICB2YXIgc3BlYztcclxuICAgICAgICB2aWV3VHlwZSA9IHZpZXdUeXBlIHx8ICdkYXknOyAvLyBkYXkgaXMgZGVmYXVsdCB6b29tXHJcbiAgICAgICAgc3BlYyA9IHRoaXMudmlld1NwZWNNYW5hZ2VyLmdldFZpZXdTcGVjKHZpZXdUeXBlKSB8fFxyXG4gICAgICAgICAgICB0aGlzLnZpZXdTcGVjTWFuYWdlci5nZXRVbml0Vmlld1NwZWModmlld1R5cGUpO1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUgPSBuZXdEYXRlLmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KHNwZWMgPyBzcGVjLnR5cGUgOiBudWxsKTtcclxuICAgIH07XHJcbiAgICAvLyBDdXJyZW50IERhdGVcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdEN1cnJlbnREYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkZWZhdWx0RGF0ZUlucHV0ID0gdGhpcy5vcHQoJ2RlZmF1bHREYXRlJyk7XHJcbiAgICAgICAgLy8gY29tcHV0ZSB0aGUgaW5pdGlhbCBhbWJpZy10aW1lem9uZSBkYXRlXHJcbiAgICAgICAgaWYgKGRlZmF1bHREYXRlSW5wdXQgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5tb21lbnQoZGVmYXVsdERhdGVJbnB1dCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5nZXROb3coKTsgLy8gZ2V0Tm93IGFscmVhZHkgcmV0dXJucyB1bnpvbmVkXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBwcmV2SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KHZpZXcuZ2V0KCdkYXRlUHJvZmlsZScpKTtcclxuICAgICAgICBpZiAocHJldkluZm8uaXNWYWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gcHJldkluZm8uZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBuZXh0SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGROZXh0KHZpZXcuZ2V0KCdkYXRlUHJvZmlsZScpKTtcclxuICAgICAgICBpZiAobmV4dEluZm8uaXNWYWxpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gbmV4dEluZm8uZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wcmV2WWVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnREYXRlLmFkZCgtMSwgJ3llYXJzJyk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLm5leHRZZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUuYWRkKDEsICd5ZWFycycpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS50b2RheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnREYXRlID0gdGhpcy5nZXROb3coKTsgLy8gc2hvdWxkIGRlbnkgbGlrZSBwcmV2L25leHQ/XHJcbiAgICAgICAgdGhpcy5yZW5kZXJWaWV3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdvdG9EYXRlID0gZnVuY3Rpb24gKHpvbmVkRGF0ZUlucHV0KSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RGF0ZSA9IHRoaXMubW9tZW50KHpvbmVkRGF0ZUlucHV0KS5zdHJpcFpvbmUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5jcmVtZW50RGF0ZSA9IGZ1bmN0aW9uIChkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudERhdGUuYWRkKG1vbWVudC5kdXJhdGlvbihkZWx0YSkpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldygpO1xyXG4gICAgfTtcclxuICAgIC8vIGZvciBleHRlcm5hbCBBUElcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5VGltZXpvbmUodGhpcy5jdXJyZW50RGF0ZSk7IC8vIGluZnVzZSB0aGUgY2FsZW5kYXIncyB0aW1lem9uZVxyXG4gICAgfTtcclxuICAgIC8vIExvYWRpbmcgVHJpZ2dlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFNob3VsZCBiZSBjYWxsZWQgd2hlbiBhbnkgdHlwZSBvZiBhc3luYyBkYXRhIGZldGNoaW5nIGJlZ2luc1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnB1c2hMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKHRoaXMubG9hZGluZ0xldmVsKyspKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdsb2FkaW5nJywgW3RydWUsIHRoaXMudmlld10pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBTaG91bGQgYmUgY2FsbGVkIHdoZW4gYW55IHR5cGUgb2YgYXN5bmMgZGF0YSBmZXRjaGluZyBjb21wbGV0ZXNcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5wb3BMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghKC0tdGhpcy5sb2FkaW5nTGV2ZWwpKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHVibGljbHlUcmlnZ2VyKCdsb2FkaW5nJywgW2ZhbHNlLCB0aGlzLnZpZXddKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gSGlnaC1sZXZlbCBSZW5kZXJpbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RWwpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsUmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZWxlbWVudFZpc2libGUoKSkge1xyXG4gICAgICAgICAgICAvLyBtYWlubHkgZm9yIHRoZSBwdWJsaWMgQVBJXHJcbiAgICAgICAgICAgIHRoaXMuY2FsY1NpemUoKTtcclxuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3U2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdGlhbFJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBlbCA9IHRoaXMuZWw7XHJcbiAgICAgICAgZWwuYWRkQ2xhc3MoJ2ZjJyk7XHJcbiAgICAgICAgLy8gZXZlbnQgZGVsZWdhdGlvbiBmb3IgbmF2IGxpbmtzXHJcbiAgICAgICAgZWwub24oJ2NsaWNrLmZjJywgJ2FbZGF0YS1nb3RvXScsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICB2YXIgYW5jaG9yRWwgPSAkKGV2LmN1cnJlbnRUYXJnZXQpO1xyXG4gICAgICAgICAgICB2YXIgZ290b09wdGlvbnMgPSBhbmNob3JFbC5kYXRhKCdnb3RvJyk7IC8vIHdpbGwgYXV0b21hdGljYWxseSBwYXJzZSBKU09OXHJcbiAgICAgICAgICAgIHZhciBkYXRlID0gX3RoaXMubW9tZW50KGdvdG9PcHRpb25zLmRhdGUpO1xyXG4gICAgICAgICAgICB2YXIgdmlld1R5cGUgPSBnb3RvT3B0aW9ucy50eXBlO1xyXG4gICAgICAgICAgICAvLyBwcm9wZXJ0eSBsaWtlIFwibmF2TGlua0RheUNsaWNrXCIuIG1pZ2h0IGJlIGEgc3RyaW5nIG9yIGEgZnVuY3Rpb25cclxuICAgICAgICAgICAgdmFyIGN1c3RvbUFjdGlvbiA9IF90aGlzLnZpZXcub3B0KCduYXZMaW5rJyArIHV0aWxfMS5jYXBpdGFsaXNlRmlyc3RMZXR0ZXIodmlld1R5cGUpICsgJ0NsaWNrJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3VzdG9tQWN0aW9uID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21BY3Rpb24oZGF0ZSwgZXYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmlld1R5cGUgPSBjdXN0b21BY3Rpb247XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy56b29tVG8oZGF0ZSwgdmlld1R5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY2FsbGVkIGltbWVkaWF0ZWx5LCBhbmQgdXBvbiBvcHRpb24gY2hhbmdlXHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci53YXRjaCgnc2V0dGluZ1RoZW1lJywgWyc/dGhlbWUnLCAnP3RoZW1lU3lzdGVtJ10sIGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAgICAgICAgIHZhciB0aGVtZUNsYXNzID0gVGhlbWVSZWdpc3RyeV8xLmdldFRoZW1lU3lzdGVtQ2xhc3Mob3B0cy50aGVtZVN5c3RlbSB8fCBvcHRzLnRoZW1lKTtcclxuICAgICAgICAgICAgdmFyIHRoZW1lID0gbmV3IHRoZW1lQ2xhc3MoX3RoaXMub3B0aW9uc01hbmFnZXIpO1xyXG4gICAgICAgICAgICB2YXIgd2lkZ2V0Q2xhc3MgPSB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Jyk7XHJcbiAgICAgICAgICAgIF90aGlzLnRoZW1lID0gdGhlbWU7XHJcbiAgICAgICAgICAgIGlmICh3aWRnZXRDbGFzcykge1xyXG4gICAgICAgICAgICAgICAgZWwuYWRkQ2xhc3Mod2lkZ2V0Q2xhc3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgd2lkZ2V0Q2xhc3MgPSBfdGhpcy50aGVtZS5nZXRDbGFzcygnd2lkZ2V0Jyk7XHJcbiAgICAgICAgICAgIF90aGlzLnRoZW1lID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKHdpZGdldENsYXNzKSB7XHJcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVDbGFzcyh3aWRnZXRDbGFzcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLndhdGNoKCdzZXR0aW5nQnVzaW5lc3NIb3VyR2VuZXJhdG9yJywgWyc/YnVzaW5lc3NIb3VycyddLCBmdW5jdGlvbiAoZGVwcykge1xyXG4gICAgICAgICAgICBfdGhpcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IgPSBuZXcgQnVzaW5lc3NIb3VyR2VuZXJhdG9yXzEuZGVmYXVsdChkZXBzLmJ1c2luZXNzSG91cnMsIF90aGlzKTtcclxuICAgICAgICAgICAgaWYgKF90aGlzLnZpZXcpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLnZpZXcuc2V0KCdidXNpbmVzc0hvdXJHZW5lcmF0b3InLCBfdGhpcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IgPSBudWxsO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGNhbGxlZCBpbW1lZGlhdGVseSwgYW5kIHVwb24gb3B0aW9uIGNoYW5nZS5cclxuICAgICAgICAvLyBIQUNLOiBsb2NhbGUgb2Z0ZW4gYWZmZWN0cyBpc1JUTCwgc28gd2UgZXhwbGljaXRseSBsaXN0ZW4gdG8gdGhhdCB0b28uXHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci53YXRjaCgnYXBwbHlpbmdEaXJDbGFzc2VzJywgWyc/aXNSVEwnLCAnP2xvY2FsZSddLCBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgICAgICAgICBlbC50b2dnbGVDbGFzcygnZmMtbHRyJywgIW9wdHMuaXNSVEwpO1xyXG4gICAgICAgICAgICBlbC50b2dnbGVDbGFzcygnZmMtcnRsJywgb3B0cy5pc1JUTCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwgPSAkKFwiPGRpdiBjbGFzcz0nZmMtdmlldy1jb250YWluZXInPlwiKS5wcmVwZW5kVG8oZWwpO1xyXG4gICAgICAgIHRoaXMuaW5pdFRvb2xiYXJzKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJIZWFkZXIoKTtcclxuICAgICAgICB0aGlzLnJlbmRlckZvb3RlcigpO1xyXG4gICAgICAgIHRoaXMucmVuZGVyVmlldyh0aGlzLm9wdCgnZGVmYXVsdFZpZXcnKSk7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCdoYW5kbGVXaW5kb3dSZXNpemUnKSkge1xyXG4gICAgICAgICAgICAkKHdpbmRvdykucmVzaXplKHRoaXMud2luZG93UmVzaXplUHJveHkgPSB1dGlsXzEuZGVib3VuY2UoLy8gcHJldmVudHMgcmFwaWQgY2FsbHNcclxuICAgICAgICAgICAgdGhpcy53aW5kb3dSZXNpemUuYmluZCh0aGlzKSwgdGhpcy5vcHQoJ3dpbmRvd1Jlc2l6ZURlbGF5JykpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmlldykge1xyXG4gICAgICAgICAgICB0aGlzLmNsZWFyVmlldygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwoJ3JlbW92ZUVsZW1lbnQnKTtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5yZW1vdmUoKTtcclxuICAgICAgICB0aGlzLmVsLnJlbW92ZUNsYXNzKCdmYyBmYy1sdHIgZmMtcnRsJyk7XHJcbiAgICAgICAgLy8gcmVtb3ZlcyB0aGVtZS1yZWxhdGVkIHJvb3QgY2xhc3NOYW1lXHJcbiAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci51bndhdGNoKCdzZXR0aW5nVGhlbWUnKTtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLnVud2F0Y2goJ3NldHRpbmdCdXNpbmVzc0hvdXJHZW5lcmF0b3InKTtcclxuICAgICAgICB0aGlzLmVsLm9mZignLmZjJyk7IC8vIHVuYmluZCBuYXYgbGluayBoYW5kbGVyc1xyXG4gICAgICAgIGlmICh0aGlzLndpbmRvd1Jlc2l6ZVByb3h5KSB7XHJcbiAgICAgICAgICAgICQod2luZG93KS51bmJpbmQoJ3Jlc2l6ZScsIHRoaXMud2luZG93UmVzaXplUHJveHkpO1xyXG4gICAgICAgICAgICB0aGlzLndpbmRvd1Jlc2l6ZVByb3h5ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgR2xvYmFsRW1pdHRlcl8xLmRlZmF1bHQudW5uZWVkZWQoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZWxlbWVudFZpc2libGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuaXMoJzp2aXNpYmxlJyk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVuZGVyIFF1ZXVlXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmJpbmRWaWV3SGFuZGxlcnMgPSBmdW5jdGlvbiAodmlldykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmlldy53YXRjaCgndGl0bGVGb3JDYWxlbmRhcicsIFsndGl0bGUnXSwgZnVuY3Rpb24gKGRlcHMpIHtcclxuICAgICAgICAgICAgaWYgKHZpZXcgPT09IF90aGlzLnZpZXcpIHsgLy8gaGFja1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0VG9vbGJhcnNUaXRsZShkZXBzLnRpdGxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHZpZXcud2F0Y2goJ2RhdGVQcm9maWxlRm9yQ2FsZW5kYXInLCBbJ2RhdGVQcm9maWxlJ10sIGZ1bmN0aW9uIChkZXBzKSB7XHJcbiAgICAgICAgICAgIGlmICh2aWV3ID09PSBfdGhpcy52aWV3KSB7IC8vIGhhY2tcclxuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnREYXRlID0gZGVwcy5kYXRlUHJvZmlsZS5kYXRlOyAvLyBtaWdodCBoYXZlIGJlZW4gY29uc3RyYWluZWQgYnkgdmlldyBkYXRlc1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudXBkYXRlVG9vbGJhckJ1dHRvbnMoZGVwcy5kYXRlUHJvZmlsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudW5iaW5kVmlld0hhbmRsZXJzID0gZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICB2aWV3LnVud2F0Y2goJ3RpdGxlRm9yQ2FsZW5kYXInKTtcclxuICAgICAgICB2aWV3LnVud2F0Y2goJ2RhdGVQcm9maWxlRm9yQ2FsZW5kYXInKTtcclxuICAgIH07XHJcbiAgICAvLyBWaWV3IFJlbmRlcmluZ1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIC8vIFJlbmRlcnMgYSB2aWV3IGJlY2F1c2Ugb2YgYSBkYXRlIGNoYW5nZSwgdmlldy10eXBlIGNoYW5nZSwgb3IgZm9yIHRoZSBmaXJzdCB0aW1lLlxyXG4gICAgLy8gSWYgbm90IGdpdmVuIGEgdmlld1R5cGUsIGtlZXAgdGhlIGN1cnJlbnQgdmlldyBidXQgcmVuZGVyIGRpZmZlcmVudCBkYXRlcy5cclxuICAgIC8vIEFjY2VwdHMgYW4gb3B0aW9uYWwgc2Nyb2xsIHN0YXRlIHRvIHJlc3RvcmUgdG8uXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVuZGVyVmlldyA9IGZ1bmN0aW9uICh2aWV3VHlwZSkge1xyXG4gICAgICAgIHZhciBvbGRWaWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBuZXdWaWV3O1xyXG4gICAgICAgIHRoaXMuZnJlZXplQ29udGVudEhlaWdodCgpO1xyXG4gICAgICAgIGlmIChvbGRWaWV3ICYmIHZpZXdUeXBlICYmIG9sZFZpZXcudHlwZSAhPT0gdmlld1R5cGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jbGVhclZpZXcoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdmlld1R5cGUgY2hhbmdlZCwgb3IgdGhlIHZpZXcgd2FzIG5ldmVyIGNyZWF0ZWQsIGNyZWF0ZSBhIGZyZXNoIHZpZXdcclxuICAgICAgICBpZiAoIXRoaXMudmlldyAmJiB2aWV3VHlwZSkge1xyXG4gICAgICAgICAgICBuZXdWaWV3ID0gdGhpcy52aWV3ID1cclxuICAgICAgICAgICAgICAgIHRoaXMudmlld3NCeVR5cGVbdmlld1R5cGVdIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMudmlld3NCeVR5cGVbdmlld1R5cGVdID0gdGhpcy5pbnN0YW50aWF0ZVZpZXcodmlld1R5cGUpKTtcclxuICAgICAgICAgICAgdGhpcy5iaW5kVmlld0hhbmRsZXJzKG5ld1ZpZXcpO1xyXG4gICAgICAgICAgICBuZXdWaWV3LnN0YXJ0QmF0Y2hSZW5kZXIoKTsgLy8gc28gdGhhdCBzZXRFbGVtZW50K3NldERhdGUgcmVuZGVyaW5nIGFyZSBqb2luZWRcclxuICAgICAgICAgICAgbmV3Vmlldy5zZXRFbGVtZW50KCQoXCI8ZGl2IGNsYXNzPSdmYy12aWV3IGZjLVwiICsgdmlld1R5cGUgKyBcIi12aWV3Jz5cIikuYXBwZW5kVG8odGhpcy5jb250ZW50RWwpKTtcclxuICAgICAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKCdhY3RpdmF0ZUJ1dHRvbicsIHZpZXdUeXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudmlldykge1xyXG4gICAgICAgICAgICAvLyBwcmV2ZW50IHVubmVjZXNzYXJ5IGNoYW5nZSBmaXJpbmdcclxuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5nZXQoJ2J1c2luZXNzSG91ckdlbmVyYXRvcicpICE9PSB0aGlzLmJ1c2luZXNzSG91ckdlbmVyYXRvcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy52aWV3LnNldCgnYnVzaW5lc3NIb3VyR2VuZXJhdG9yJywgdGhpcy5idXNpbmVzc0hvdXJHZW5lcmF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMudmlldy5zZXREYXRlKHRoaXMuY3VycmVudERhdGUpO1xyXG4gICAgICAgICAgICBpZiAobmV3Vmlldykge1xyXG4gICAgICAgICAgICAgICAgbmV3Vmlldy5zdG9wQmF0Y2hSZW5kZXIoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRoYXdDb250ZW50SGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIHRoZSBjdXJyZW50IHZpZXcgYW5kIHJlZmxlY3RzIHRoaXMgY2hhbmdlIGluIHRoZSBIZWFkZXIuXHJcbiAgICAvLyBVbnJlZ3NpdGVycyB0aGUgYHZpZXdgLCBidXQgZG9lcyBub3QgcmVtb3ZlIGZyb20gdmlld0J5VHlwZSBoYXNoLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNsZWFyVmlldyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY3VycmVudFZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKCdkZWFjdGl2YXRlQnV0dG9uJywgY3VycmVudFZpZXcudHlwZSk7XHJcbiAgICAgICAgdGhpcy51bmJpbmRWaWV3SGFuZGxlcnMoY3VycmVudFZpZXcpO1xyXG4gICAgICAgIGN1cnJlbnRWaWV3LnJlbW92ZUVsZW1lbnQoKTtcclxuICAgICAgICBjdXJyZW50Vmlldy51bnNldERhdGUoKTsgLy8gc28gYmluZFZpZXdIYW5kbGVycyBkb2Vzbid0IGZpcmUgd2l0aCBvbGQgdmFsdWVzIG5leHQgdGltZVxyXG4gICAgICAgIHRoaXMudmlldyA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgLy8gRGVzdHJveXMgdGhlIHZpZXcsIGluY2x1ZGluZyB0aGUgdmlldyBvYmplY3QuIFRoZW4sIHJlLWluc3RhbnRpYXRlcyBpdCBhbmQgcmVuZGVycyBpdC5cclxuICAgIC8vIE1haW50YWlucyB0aGUgc2FtZSBzY3JvbGwgc3RhdGUuXHJcbiAgICAvLyBUT0RPOiBtYWludGFpbiBhbnkgb3RoZXIgdXNlci1tYW5pcHVsYXRlZCBzdGF0ZS5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZWluaXRWaWV3ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBvbGRWaWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBzY3JvbGwgPSBvbGRWaWV3LnF1ZXJ5U2Nyb2xsKCk7IC8vIHdvdWxkbid0IGJlIHNvIGNvbXBsaWNhdGVkIGlmIENhbGVuZGFyIG93bmVkIHRoZSBzY3JvbGxcclxuICAgICAgICB0aGlzLmZyZWV6ZUNvbnRlbnRIZWlnaHQoKTtcclxuICAgICAgICB0aGlzLmNsZWFyVmlldygpO1xyXG4gICAgICAgIHRoaXMuY2FsY1NpemUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlclZpZXcob2xkVmlldy50eXBlKTsgLy8gbmVlZHMgdGhlIHR5cGUgdG8gZnJlc2hseSByZW5kZXJcclxuICAgICAgICB0aGlzLnZpZXcuYXBwbHlTY3JvbGwoc2Nyb2xsKTtcclxuICAgICAgICB0aGlzLnRoYXdDb250ZW50SGVpZ2h0KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUmVzaXppbmdcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0U3VnZ2VzdGVkVmlld0hlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxjU2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0O1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pc0hlaWdodEF1dG8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdjb250ZW50SGVpZ2h0JykgPT09ICdhdXRvJyB8fCB0aGlzLm9wdCgnaGVpZ2h0JykgPT09ICdhdXRvJztcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudXBkYXRlVmlld1NpemUgPSBmdW5jdGlvbiAoaXNSZXNpemUpIHtcclxuICAgICAgICBpZiAoaXNSZXNpemUgPT09IHZvaWQgMCkgeyBpc1Jlc2l6ZSA9IGZhbHNlOyB9XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIHNjcm9sbDtcclxuICAgICAgICBpZiAoIXRoaXMuaWdub3JlVXBkYXRlVmlld1NpemUgJiYgdmlldykge1xyXG4gICAgICAgICAgICBpZiAoaXNSZXNpemUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FsY1NpemUoKTtcclxuICAgICAgICAgICAgICAgIHNjcm9sbCA9IHZpZXcucXVlcnlTY3JvbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlnbm9yZVVwZGF0ZVZpZXdTaXplKys7XHJcbiAgICAgICAgICAgIHZpZXcudXBkYXRlU2l6ZSh0aGlzLmdldFN1Z2dlc3RlZFZpZXdIZWlnaHQoKSwgdGhpcy5pc0hlaWdodEF1dG8oKSwgaXNSZXNpemUpO1xyXG4gICAgICAgICAgICB0aGlzLmlnbm9yZVVwZGF0ZVZpZXdTaXplLS07XHJcbiAgICAgICAgICAgIGlmIChpc1Jlc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgdmlldy5hcHBseVNjcm9sbChzY3JvbGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlOyAvLyBzaWduYWwgc3VjY2Vzc1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY2FsY1NpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudFZpc2libGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jYWxjU2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuX2NhbGNTaXplID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjb250ZW50SGVpZ2h0SW5wdXQgPSB0aGlzLm9wdCgnY29udGVudEhlaWdodCcpO1xyXG4gICAgICAgIHZhciBoZWlnaHRJbnB1dCA9IHRoaXMub3B0KCdoZWlnaHQnKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnRIZWlnaHRJbnB1dCA9PT0gJ251bWJlcicpIHsgLy8gZXhpc3RzIGFuZCBub3QgJ2F1dG8nXHJcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IGNvbnRlbnRIZWlnaHRJbnB1dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNvbnRlbnRIZWlnaHRJbnB1dCA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBleGlzdHMgYW5kIGlzIGEgZnVuY3Rpb25cclxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gY29udGVudEhlaWdodElucHV0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBoZWlnaHRJbnB1dCA9PT0gJ251bWJlcicpIHsgLy8gZXhpc3RzIGFuZCBub3QgJ2F1dG8nXHJcbiAgICAgICAgICAgIHRoaXMuc3VnZ2VzdGVkVmlld0hlaWdodCA9IGhlaWdodElucHV0IC0gdGhpcy5xdWVyeVRvb2xiYXJzSGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBoZWlnaHRJbnB1dCA9PT0gJ2Z1bmN0aW9uJykgeyAvLyBleGlzdHMgYW5kIGlzIGEgZnVuY3Rpb25cclxuICAgICAgICAgICAgdGhpcy5zdWdnZXN0ZWRWaWV3SGVpZ2h0ID0gaGVpZ2h0SW5wdXQoKSAtIHRoaXMucXVlcnlUb29sYmFyc0hlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChoZWlnaHRJbnB1dCA9PT0gJ3BhcmVudCcpIHsgLy8gc2V0IHRvIGhlaWdodCBvZiBwYXJlbnQgZWxlbWVudFxyXG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSB0aGlzLmVsLnBhcmVudCgpLmhlaWdodCgpIC0gdGhpcy5xdWVyeVRvb2xiYXJzSGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnN1Z2dlc3RlZFZpZXdIZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuY29udGVudEVsLndpZHRoKCkgL1xyXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgodGhpcy5vcHQoJ2FzcGVjdFJhdGlvJyksIC41KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS53aW5kb3dSZXNpemUgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgLy8gdGhlIHB1cnBvc2U6IHNvIHdlIGRvbid0IHByb2Nlc3MganF1aSBcInJlc2l6ZVwiIGV2ZW50cyB0aGF0IGhhdmUgYnViYmxlZCB1cFxyXG4gICAgICAgIC8vIGNhc3QgdG8gYW55IGJlY2F1c2UgLnRhcmdldCwgd2hpY2ggaXMgRWxlbWVudCwgY2FuJ3QgYmUgY29tcGFyZWQgdG8gd2luZG93IGZvciBzb21lIHJlYXNvbi5cclxuICAgICAgICBldi50YXJnZXQgPT09IHdpbmRvdyAmJlxyXG4gICAgICAgICAgICB0aGlzLnZpZXcgJiZcclxuICAgICAgICAgICAgdGhpcy52aWV3LmlzRGF0ZXNSZW5kZXJlZCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy51cGRhdGVWaWV3U2l6ZSh0cnVlKSkgeyAvLyBpc1Jlc2l6ZT10cnVlLCByZXR1cm5zIHRydWUgb24gc3VjY2Vzc1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wdWJsaWNseVRyaWdnZXIoJ3dpbmRvd1Jlc2l6ZScsIFt0aGlzLnZpZXddKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBIZWlnaHQgXCJGcmVlemluZ1wiXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZnJlZXplQ29udGVudEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoISh0aGlzLmZyZWV6ZUNvbnRlbnRIZWlnaHREZXB0aCsrKSkge1xyXG4gICAgICAgICAgICB0aGlzLmZvcmNlRnJlZXplQ29udGVudEhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZm9yY2VGcmVlemVDb250ZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29udGVudEVsLmNzcyh7XHJcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5jb250ZW50RWwuaGVpZ2h0KCksXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS50aGF3Q29udGVudEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmZyZWV6ZUNvbnRlbnRIZWlnaHREZXB0aC0tO1xyXG4gICAgICAgIC8vIGFsd2F5cyBicmluZyBiYWNrIHRvIG5hdHVyYWwgaGVpZ2h0XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwuY3NzKHtcclxuICAgICAgICAgICAgd2lkdGg6ICcnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6ICcnLFxyXG4gICAgICAgICAgICBvdmVyZmxvdzogJydcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBidXQgaWYgdGhlcmUgYXJlIGZ1dHVyZSB0aGF3cywgcmUtZnJlZXplXHJcbiAgICAgICAgaWYgKHRoaXMuZnJlZXplQ29udGVudEhlaWdodERlcHRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZm9yY2VGcmVlemVDb250ZW50SGVpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFRvb2xiYXJcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdFRvb2xiYXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuaGVhZGVyID0gbmV3IFRvb2xiYXJfMS5kZWZhdWx0KHRoaXMsIHRoaXMuY29tcHV0ZUhlYWRlck9wdGlvbnMoKSk7XHJcbiAgICAgICAgdGhpcy5mb290ZXIgPSBuZXcgVG9vbGJhcl8xLmRlZmF1bHQodGhpcywgdGhpcy5jb21wdXRlRm9vdGVyT3B0aW9ucygpKTtcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlciA9IG5ldyBJdGVyYXRvcl8xLmRlZmF1bHQoW3RoaXMuaGVhZGVyLCB0aGlzLmZvb3Rlcl0pO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5jb21wdXRlSGVhZGVyT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBleHRyYUNsYXNzZXM6ICdmYy1oZWFkZXItdG9vbGJhcicsXHJcbiAgICAgICAgICAgIGxheW91dDogdGhpcy5vcHQoJ2hlYWRlcicpXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuY29tcHV0ZUZvb3Rlck9wdGlvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZXh0cmFDbGFzc2VzOiAnZmMtZm9vdGVyLXRvb2xiYXInLFxyXG4gICAgICAgICAgICBsYXlvdXQ6IHRoaXMub3B0KCdmb290ZXInKVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLy8gY2FuIGJlIGNhbGxlZCByZXBlYXRlZGx5IGFuZCBIZWFkZXIgd2lsbCByZXJlbmRlclxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlckhlYWRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaGVhZGVyID0gdGhpcy5oZWFkZXI7XHJcbiAgICAgICAgaGVhZGVyLnNldFRvb2xiYXJPcHRpb25zKHRoaXMuY29tcHV0ZUhlYWRlck9wdGlvbnMoKSk7XHJcbiAgICAgICAgaGVhZGVyLnJlbmRlcigpO1xyXG4gICAgICAgIGlmIChoZWFkZXIuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5wcmVwZW5kKGhlYWRlci5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIGNhbiBiZSBjYWxsZWQgcmVwZWF0ZWRseSBhbmQgRm9vdGVyIHdpbGwgcmVyZW5kZXJcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXJGb290ZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZvb3RlciA9IHRoaXMuZm9vdGVyO1xyXG4gICAgICAgIGZvb3Rlci5zZXRUb29sYmFyT3B0aW9ucyh0aGlzLmNvbXB1dGVGb290ZXJPcHRpb25zKCkpO1xyXG4gICAgICAgIGZvb3Rlci5yZW5kZXIoKTtcclxuICAgICAgICBpZiAoZm9vdGVyLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuYXBwZW5kKGZvb3Rlci5lbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5zZXRUb29sYmFyc1RpdGxlID0gZnVuY3Rpb24gKHRpdGxlKSB7XHJcbiAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKCd1cGRhdGVUaXRsZScsIHRpdGxlKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudXBkYXRlVG9vbGJhckJ1dHRvbnMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgbm93ID0gdGhpcy5nZXROb3coKTtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgdG9kYXlJbmZvID0gdmlldy5kYXRlUHJvZmlsZUdlbmVyYXRvci5idWlsZChub3cpO1xyXG4gICAgICAgIHZhciBwcmV2SW5mbyA9IHZpZXcuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KHZpZXcuZ2V0KCdkYXRlUHJvZmlsZScpKTtcclxuICAgICAgICB2YXIgbmV4dEluZm8gPSB2aWV3LmRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dCh2aWV3LmdldCgnZGF0ZVByb2ZpbGUnKSk7XHJcbiAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKCh0b2RheUluZm8uaXNWYWxpZCAmJiAhZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZS5jb250YWluc0RhdGUobm93KSkgP1xyXG4gICAgICAgICAgICAnZW5hYmxlQnV0dG9uJyA6XHJcbiAgICAgICAgICAgICdkaXNhYmxlQnV0dG9uJywgJ3RvZGF5Jyk7XHJcbiAgICAgICAgdGhpcy50b29sYmFyc01hbmFnZXIucHJveHlDYWxsKHByZXZJbmZvLmlzVmFsaWQgP1xyXG4gICAgICAgICAgICAnZW5hYmxlQnV0dG9uJyA6XHJcbiAgICAgICAgICAgICdkaXNhYmxlQnV0dG9uJywgJ3ByZXYnKTtcclxuICAgICAgICB0aGlzLnRvb2xiYXJzTWFuYWdlci5wcm94eUNhbGwobmV4dEluZm8uaXNWYWxpZCA/XHJcbiAgICAgICAgICAgICdlbmFibGVCdXR0b24nIDpcclxuICAgICAgICAgICAgJ2Rpc2FibGVCdXR0b24nLCAnbmV4dCcpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5xdWVyeVRvb2xiYXJzSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvb2xiYXJzTWFuYWdlci5pdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCB0b29sYmFyKSB7XHJcbiAgICAgICAgICAgIHZhciB0b29sYmFySGVpZ2h0ID0gdG9vbGJhci5lbCA/IHRvb2xiYXIuZWwub3V0ZXJIZWlnaHQodHJ1ZSkgOiAwOyAvLyBpbmNsdWRlcyBtYXJnaW5cclxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yICsgdG9vbGJhckhlaWdodDtcclxuICAgICAgICB9LCAwKTtcclxuICAgIH07XHJcbiAgICAvLyBTZWxlY3Rpb25cclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvLyB0aGlzIHB1YmxpYyBtZXRob2QgcmVjZWl2ZXMgc3RhcnQvZW5kIGRhdGVzIGluIGFueSBmb3JtYXQsIHdpdGggYW55IHRpbWV6b25lXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKHpvbmVkU3RhcnRJbnB1dCwgem9uZWRFbmRJbnB1dCkge1xyXG4gICAgICAgIHRoaXMudmlldy5zZWxlY3QodGhpcy5idWlsZFNlbGVjdEZvb3RwcmludC5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudW5zZWxlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudmlldykge1xyXG4gICAgICAgICAgICB0aGlzLnZpZXcudW5zZWxlY3QoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYXJndW1lbnRzIHRvIHRoZSBzZWxlY3QgbWV0aG9kIGluIHRoZSBBUEksIHJldHVybnMgYSBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCBhbmQgb3RoZXIgaW5mbylcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5idWlsZFNlbGVjdEZvb3RwcmludCA9IGZ1bmN0aW9uICh6b25lZFN0YXJ0SW5wdXQsIHpvbmVkRW5kSW5wdXQpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSB0aGlzLm1vbWVudCh6b25lZFN0YXJ0SW5wdXQpLnN0cmlwWm9uZSgpO1xyXG4gICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgaWYgKHpvbmVkRW5kSW5wdXQpIHtcclxuICAgICAgICAgICAgZW5kID0gdGhpcy5tb21lbnQoem9uZWRFbmRJbnB1dCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHN0YXJ0Lmhhc1RpbWUoKSkge1xyXG4gICAgICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpLmFkZCh0aGlzLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZW5kID0gc3RhcnQuY2xvbmUoKS5hZGQodGhpcy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9uZW50Rm9vdHByaW50XzEuZGVmYXVsdChuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChzdGFydCwgZW5kKSwgIXN0YXJ0Lmhhc1RpbWUoKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gRGF0ZSBVdGlsc1xyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5pbml0TW9tZW50SW50ZXJuYWxzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm9wdCgnZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24nKSk7XHJcbiAgICAgICAgdGhpcy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uID0gbW9tZW50LmR1cmF0aW9uKHRoaXMub3B0KCdkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uJykpO1xyXG4gICAgICAgIC8vIENhbGxlZCBpbW1lZGlhdGVseSwgYW5kIHdoZW4gYW55IG9mIHRoZSBvcHRpb25zIGNoYW5nZS5cclxuICAgICAgICAvLyBIYXBwZW5zIGJlZm9yZSBhbnkgaW50ZXJuYWwgb2JqZWN0cyByZWJ1aWxkIG9yIHJlcmVuZGVyLCBiZWNhdXNlIHRoaXMgaXMgdmVyeSBjb3JlLlxyXG4gICAgICAgIHRoaXMub3B0aW9uc01hbmFnZXIud2F0Y2goJ2J1aWxkaW5nTW9tZW50TG9jYWxlJywgW1xyXG4gICAgICAgICAgICAnP2xvY2FsZScsICc/bW9udGhOYW1lcycsICc/bW9udGhOYW1lc1Nob3J0JywgJz9kYXlOYW1lcycsICc/ZGF5TmFtZXNTaG9ydCcsXHJcbiAgICAgICAgICAgICc/Zmlyc3REYXknLCAnP3dlZWtOdW1iZXJDYWxjdWxhdGlvbidcclxuICAgICAgICBdLCBmdW5jdGlvbiAob3B0cykge1xyXG4gICAgICAgICAgICB2YXIgd2Vla051bWJlckNhbGN1bGF0aW9uID0gb3B0cy53ZWVrTnVtYmVyQ2FsY3VsYXRpb247XHJcbiAgICAgICAgICAgIHZhciBmaXJzdERheSA9IG9wdHMuZmlyc3REYXk7XHJcbiAgICAgICAgICAgIHZhciBfd2VlaztcclxuICAgICAgICAgICAgLy8gbm9ybWFsaXplXHJcbiAgICAgICAgICAgIGlmICh3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdpc28nKSB7XHJcbiAgICAgICAgICAgICAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPSAnSVNPJzsgLy8gbm9ybWFsaXplXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGxvY2FsZURhdGEgPSBPYmplY3QuY3JlYXRlKC8vIG1ha2UgYSBjaGVhcCBjb3B5XHJcbiAgICAgICAgICAgIGxvY2FsZV8xLmdldE1vbWVudExvY2FsZURhdGEob3B0cy5sb2NhbGUpIC8vIHdpbGwgZmFsbCBiYWNrIHRvIGVuXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGlmIChvcHRzLm1vbnRoTmFtZXMpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX21vbnRocyA9IG9wdHMubW9udGhOYW1lcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0cy5tb250aE5hbWVzU2hvcnQpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX21vbnRoc1Nob3J0ID0gb3B0cy5tb250aE5hbWVzU2hvcnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKG9wdHMuZGF5TmFtZXMpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX3dlZWtkYXlzID0gb3B0cy5kYXlOYW1lcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAob3B0cy5kYXlOYW1lc1Nob3J0KSB7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEYXRhLl93ZWVrZGF5c1Nob3J0ID0gb3B0cy5kYXlOYW1lc1Nob3J0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaXJzdERheSA9PSBudWxsICYmIHdlZWtOdW1iZXJDYWxjdWxhdGlvbiA9PT0gJ0lTTycpIHtcclxuICAgICAgICAgICAgICAgIGZpcnN0RGF5ID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmlyc3REYXkgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgX3dlZWsgPSBPYmplY3QuY3JlYXRlKGxvY2FsZURhdGEuX3dlZWspOyAvLyBfd2VlazogeyBkb3c6ICMgfVxyXG4gICAgICAgICAgICAgICAgX3dlZWsuZG93ID0gZmlyc3REYXk7XHJcbiAgICAgICAgICAgICAgICBsb2NhbGVEYXRhLl93ZWVrID0gX3dlZWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCAvLyB3aGl0ZWxpc3QgY2VydGFpbiBraW5kcyBvZiBpbnB1dFxyXG4gICAgICAgICAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdJU08nIHx8XHJcbiAgICAgICAgICAgICAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdsb2NhbCcgfHxcclxuICAgICAgICAgICAgICAgIHR5cGVvZiB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgIGxvY2FsZURhdGEuX2Z1bGxDYWxlbmRhcl93ZWVrQ2FsYyA9IHdlZWtOdW1iZXJDYWxjdWxhdGlvbjsgLy8gbW9tZW50LWV4dCB3aWxsIGtub3cgd2hhdCB0byBkbyB3aXRoIGl0XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMubG9jYWxlRGF0YSA9IGxvY2FsZURhdGE7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBpbnRlcm5hbCBjdXJyZW50IGRhdGUgb2JqZWN0IGFscmVhZHkgZXhpc3RzLCBtb3ZlIHRvIG5ldyBsb2NhbGUuXHJcbiAgICAgICAgICAgIC8vIFdlIGRvIE5PVCBuZWVkIHRvIGRvIHRoaXMgdGVjaG5pcXVlIGZvciBldmVudCBkYXRlcywgYmVjYXVzZSB0aGlzIGhhcHBlbnMgd2hlbiBjb252ZXJ0aW5nIHRvIFwic2VnbWVudHNcIi5cclxuICAgICAgICAgICAgaWYgKF90aGlzLmN1cnJlbnREYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2NhbGl6ZU1vbWVudChfdGhpcy5jdXJyZW50RGF0ZSk7IC8vIHNldHMgdG8gbG9jYWxlRGF0YVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIGEgbW9tZW50IHVzaW5nIHRoZSBzZXR0aW5ncyBvZiB0aGUgY3VycmVudCBjYWxlbmRhcjogdGltZXpvbmUgYW5kIGxvY2FsZS5cclxuICAgIC8vIEFjY2VwdHMgYW55dGhpbmcgdGhlIHZhbmlsbGEgbW9tZW50KCkgY29uc3RydWN0b3IgYWNjZXB0cy5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5tb21lbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBtb207XHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCd0aW1lem9uZScpID09PSAnbG9jYWwnKSB7XHJcbiAgICAgICAgICAgIG1vbSA9IG1vbWVudF9leHRfMS5kZWZhdWx0LmFwcGx5KG51bGwsIGFyZ3MpO1xyXG4gICAgICAgICAgICAvLyBGb3JjZSB0aGUgbW9tZW50IHRvIGJlIGxvY2FsLCBiZWNhdXNlIG1vbWVudEV4dCBkb2Vzbid0IGd1YXJhbnRlZSBpdC5cclxuICAgICAgICAgICAgaWYgKG1vbS5oYXNUaW1lKCkpIHsgLy8gZG9uJ3QgZ2l2ZSBhbWJpZ3VvdXNseS10aW1lZCBtb21lbnRzIGEgbG9jYWwgem9uZVxyXG4gICAgICAgICAgICAgICAgbW9tLmxvY2FsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHQoJ3RpbWV6b25lJykgPT09ICdVVEMnKSB7XHJcbiAgICAgICAgICAgIG1vbSA9IG1vbWVudF9leHRfMS5kZWZhdWx0LnV0Yy5hcHBseShudWxsLCBhcmdzKTsgLy8gcHJvY2VzcyBhcyBVVENcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1vbSA9IG1vbWVudF9leHRfMS5kZWZhdWx0LnBhcnNlWm9uZS5hcHBseShudWxsLCBhcmdzKTsgLy8gbGV0IHRoZSBpbnB1dCBkZWNpZGUgdGhlIHpvbmVcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sb2NhbGl6ZU1vbWVudChtb20pOyAvLyBUT0RPXHJcbiAgICAgICAgcmV0dXJuIG1vbTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUubXNUb01vbWVudCA9IGZ1bmN0aW9uIChtcywgZm9yY2VBbGxEYXkpIHtcclxuICAgICAgICB2YXIgbW9tID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKG1zKTsgLy8gVE9ETzogb3B0aW1pemUgYnkgdXNpbmcgRGF0ZS5VVENcclxuICAgICAgICBpZiAoZm9yY2VBbGxEYXkpIHtcclxuICAgICAgICAgICAgbW9tLnN0cmlwVGltZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbW9tID0gdGhpcy5hcHBseVRpbWV6b25lKG1vbSk7IC8vIG1heSBvciBtYXkgbm90IGFwcGx5IGxvY2FsZVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvY2FsaXplTW9tZW50KG1vbSk7XHJcbiAgICAgICAgcmV0dXJuIG1vbTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUubXNUb1V0Y01vbWVudCA9IGZ1bmN0aW9uIChtcywgZm9yY2VBbGxEYXkpIHtcclxuICAgICAgICB2YXIgbW9tID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKG1zKTsgLy8gVE9ETzogb3B0aW1pemUgYnkgdXNpbmcgRGF0ZS5VVENcclxuICAgICAgICBpZiAoZm9yY2VBbGxEYXkpIHtcclxuICAgICAgICAgICAgbW9tLnN0cmlwVGltZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvY2FsaXplTW9tZW50KG1vbSk7XHJcbiAgICAgICAgcmV0dXJuIG1vbTtcclxuICAgIH07XHJcbiAgICAvLyBVcGRhdGVzIHRoZSBnaXZlbiBtb21lbnQncyBsb2NhbGUgc2V0dGluZ3MgdG8gdGhlIGN1cnJlbnQgY2FsZW5kYXIgbG9jYWxlIHNldHRpbmdzLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmxvY2FsaXplTW9tZW50ID0gZnVuY3Rpb24gKG1vbSkge1xyXG4gICAgICAgIG1vbS5fbG9jYWxlID0gdGhpcy5sb2NhbGVEYXRhO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgYSBib29sZWFuIGFib3V0IHdoZXRoZXIgb3Igbm90IHRoZSBjYWxlbmRhciBrbm93cyBob3cgdG8gY2FsY3VsYXRlXHJcbiAgICAvLyB0aGUgdGltZXpvbmUgb2Zmc2V0IG9mIGFyYml0cmFyeSBkYXRlcyBpbiB0aGUgY3VycmVudCB0aW1lem9uZS5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXRJc0FtYmlnVGltZXpvbmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCd0aW1lem9uZScpICE9PSAnbG9jYWwnICYmIHRoaXMub3B0KCd0aW1lem9uZScpICE9PSAnVVRDJztcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGEgY29weSBvZiB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgY3VycmVudCB0aW1lem9uZS4gSGFzIG5vIGVmZmVjdCBvbiBkYXRlcyB3aXRob3V0IHRpbWVzLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmFwcGx5VGltZXpvbmUgPSBmdW5jdGlvbiAoZGF0ZSkge1xyXG4gICAgICAgIGlmICghZGF0ZS5oYXNUaW1lKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGUuY2xvbmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHpvbmVkRGF0ZSA9IHRoaXMubW9tZW50KGRhdGUudG9BcnJheSgpKTtcclxuICAgICAgICB2YXIgdGltZUFkanVzdCA9IGRhdGUudGltZSgpLmFzTWlsbGlzZWNvbmRzKCkgLSB6b25lZERhdGUudGltZSgpLmFzTWlsbGlzZWNvbmRzKCk7XHJcbiAgICAgICAgdmFyIGFkanVzdGVkWm9uZWREYXRlO1xyXG4gICAgICAgIC8vIFNhZmFyaSBzb21ldGltZXMgaGFzIHByb2JsZW1zIHdpdGggdGhpcyBjb2Vyc2lvbiB3aGVuIG5lYXIgRFNULiBBZGp1c3QgaWYgbmVjZXNzYXJ5LiAoYnVnICMyMzk2KVxyXG4gICAgICAgIGlmICh0aW1lQWRqdXN0KSB7IC8vIGlzIHRoZSB0aW1lIHJlc3VsdCBkaWZmZXJlbnQgdGhhbiBleHBlY3RlZD9cclxuICAgICAgICAgICAgYWRqdXN0ZWRab25lZERhdGUgPSB6b25lZERhdGUuY2xvbmUoKS5hZGQodGltZUFkanVzdCk7IC8vIGFkZCBtaWxsaXNlY29uZHNcclxuICAgICAgICAgICAgaWYgKGRhdGUudGltZSgpLmFzTWlsbGlzZWNvbmRzKCkgLSBhZGp1c3RlZFpvbmVkRGF0ZS50aW1lKCkuYXNNaWxsaXNlY29uZHMoKSA9PT0gMCkgeyAvLyBkb2VzIGl0IG1hdGNoIHBlcmZlY3RseSBub3c/XHJcbiAgICAgICAgICAgICAgICB6b25lZERhdGUgPSBhZGp1c3RlZFpvbmVkRGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gem9uZWREYXRlO1xyXG4gICAgfTtcclxuICAgIC8qXHJcbiAgICBBc3N1bWVzIHRoZSBmb290cHJpbnQgaXMgbm9uLW9wZW4tZW5kZWQuXHJcbiAgICAqL1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmZvb3RwcmludFRvRGF0ZVByb2ZpbGUgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50LCBpZ25vcmVFbmQpIHtcclxuICAgICAgICBpZiAoaWdub3JlRW5kID09PSB2b2lkIDApIHsgaWdub3JlRW5kID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgc3RhcnQgPSBtb21lbnRfZXh0XzEuZGVmYXVsdC51dGMoY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZS5zdGFydE1zKTtcclxuICAgICAgICB2YXIgZW5kO1xyXG4gICAgICAgIGlmICghaWdub3JlRW5kKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IG1vbWVudF9leHRfMS5kZWZhdWx0LnV0Yyhjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlLmVuZE1zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICBzdGFydC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgaWYgKGVuZCkge1xyXG4gICAgICAgICAgICAgICAgZW5kLnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzdGFydCA9IHRoaXMuYXBwbHlUaW1lem9uZShzdGFydCk7XHJcbiAgICAgICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgICAgIGVuZCA9IHRoaXMuYXBwbHlUaW1lem9uZShlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9jYWxpemVNb21lbnQoc3RhcnQpO1xyXG4gICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2NhbGl6ZU1vbWVudChlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEV2ZW50RGF0ZVByb2ZpbGVfMS5kZWZhdWx0KHN0YXJ0LCBlbmQsIHRoaXMpO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgYSBtb21lbnQgZm9yIHRoZSBjdXJyZW50IGRhdGUsIGFzIGRlZmluZWQgYnkgdGhlIGNsaWVudCdzIGNvbXB1dGVyIG9yIGZyb20gdGhlIGBub3dgIG9wdGlvbi5cclxuICAgIC8vIFdpbGwgcmV0dXJuIGFuIG1vbWVudCB3aXRoIGFuIGFtYmlndW91cyB0aW1lem9uZS5cclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5nZXROb3cgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMub3B0KCdub3cnKTtcclxuICAgICAgICBpZiAodHlwZW9mIG5vdyA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBub3cgPSBub3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW9tZW50KG5vdykuc3RyaXBab25lKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gUHJvZHVjZXMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgZm9yIHRoZSBnaXZlbiBkdXJhdGlvbi5cclxuICAgIC8vIFNpZGUtZWZmZWN0OiBjaGFuZ2VzIHRoZSBsb2NhbGUgb2YgdGhlIGdpdmVuIGR1cmF0aW9uLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmh1bWFuaXplRHVyYXRpb24gPSBmdW5jdGlvbiAoZHVyYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gZHVyYXRpb24ubG9jYWxlKHRoaXMub3B0KCdsb2NhbGUnKSkuaHVtYW5pemUoKTtcclxuICAgIH07XHJcbiAgICAvLyB3aWxsIHJldHVybiBgbnVsbGAgaWYgaW52YWxpZCByYW5nZVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnBhcnNlVW56b25lZFJhbmdlID0gZnVuY3Rpb24gKHJhbmdlSW5wdXQpIHtcclxuICAgICAgICB2YXIgc3RhcnQgPSBudWxsO1xyXG4gICAgICAgIHZhciBlbmQgPSBudWxsO1xyXG4gICAgICAgIGlmIChyYW5nZUlucHV0LnN0YXJ0KSB7XHJcbiAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5tb21lbnQocmFuZ2VJbnB1dC5zdGFydCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyYW5nZUlucHV0LmVuZCkge1xyXG4gICAgICAgICAgICBlbmQgPSB0aGlzLm1vbWVudChyYW5nZUlucHV0LmVuZCkuc3RyaXBab25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghc3RhcnQgJiYgIWVuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXJ0ICYmIGVuZCAmJiBlbmQuaXNCZWZvcmUoc3RhcnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoc3RhcnQsIGVuZCk7XHJcbiAgICB9O1xyXG4gICAgLy8gRXZlbnQtRGF0ZSBVdGlsaXRpZXNcclxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuaW5pdEV2ZW50TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBldmVudE1hbmFnZXIgPSBuZXcgRXZlbnRNYW5hZ2VyXzEuZGVmYXVsdCh0aGlzKTtcclxuICAgICAgICB2YXIgcmF3U291cmNlcyA9IHRoaXMub3B0KCdldmVudFNvdXJjZXMnKSB8fCBbXTtcclxuICAgICAgICB2YXIgc2luZ2xlUmF3U291cmNlID0gdGhpcy5vcHQoJ2V2ZW50cycpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyID0gZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIGlmIChzaW5nbGVSYXdTb3VyY2UpIHtcclxuICAgICAgICAgICAgcmF3U291cmNlcy51bnNoaWZ0KHNpbmdsZVJhd1NvdXJjZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50TWFuYWdlci5vbigncmVsZWFzZScsIGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgICAgIF90aGlzLnRyaWdnZXIoJ2V2ZW50c1Jlc2V0JywgZXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgIHJhd1NvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiAocmF3U291cmNlKSB7XHJcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBFdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQucGFyc2UocmF3U291cmNlLCBfdGhpcyk7XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2UpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50TWFuYWdlci5hZGRTb3VyY2Uoc291cmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGV2ZW50TWFuYWdlci50aGF3KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlcXVlc3RFdmVudHMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50TWFuYWdlci5yZXF1ZXN0RXZlbnRzKHN0YXJ0LCBlbmQsIHRoaXMub3B0KCd0aW1lem9uZScpLCAhdGhpcy5vcHQoJ2xhenlGZXRjaGluZycpKTtcclxuICAgIH07XHJcbiAgICAvLyBHZXQgYW4gZXZlbnQncyBub3JtYWxpemVkIGVuZCBkYXRlLiBJZiBub3QgcHJlc2VudCwgY2FsY3VsYXRlIGl0IGZyb20gdGhlIGRlZmF1bHRzLlxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmdldEV2ZW50RW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50LmVuZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXZlbnQuZW5kLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0RXZlbnRFbmQoZXZlbnQuYWxsRGF5LCBldmVudC5zdGFydCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGFuIGV2ZW50J3MgYWxsRGF5IHN0YXR1cyBhbmQgc3RhcnQgZGF0ZSwgcmV0dXJuIHdoYXQgaXRzIGZhbGxiYWNrIGVuZCBkYXRlIHNob3VsZCBiZS5cclxuICAgIC8vIFRPRE86IHJlbmFtZSB0byBjb21wdXRlRGVmYXVsdEV2ZW50RW5kXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RGVmYXVsdEV2ZW50RW5kID0gZnVuY3Rpb24gKGFsbERheSwgem9uZWRTdGFydCkge1xyXG4gICAgICAgIHZhciBlbmQgPSB6b25lZFN0YXJ0LmNsb25lKCk7XHJcbiAgICAgICAgaWYgKGFsbERheSkge1xyXG4gICAgICAgICAgICBlbmQuc3RyaXBUaW1lKCkuYWRkKHRoaXMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZW5kLmFkZCh0aGlzLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5nZXRJc0FtYmlnVGltZXpvbmUoKSkge1xyXG4gICAgICAgICAgICBlbmQuc3RyaXBab25lKCk7IC8vIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgdHpvIHNob3VsZCBiZVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZW5kO1xyXG4gICAgfTtcclxuICAgIC8vIFB1YmxpYyBFdmVudHMgQVBJXHJcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlcmVuZGVyRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudmlldy5mbGFzaCgnZGlzcGxheWluZ0V2ZW50cycpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZWZldGNoRXZlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnJlZmV0Y2hBbGxTb3VyY2VzKCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbmRlckV2ZW50cyA9IGZ1bmN0aW9uIChldmVudElucHV0cywgaXNTdGlja3kpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50SW5wdXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyRXZlbnQoZXZlbnRJbnB1dHNbaV0sIGlzU3RpY2t5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgfTtcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXJFdmVudCA9IGZ1bmN0aW9uIChldmVudElucHV0LCBpc1N0aWNreSkge1xyXG4gICAgICAgIGlmIChpc1N0aWNreSA9PT0gdm9pZCAwKSB7IGlzU3RpY2t5ID0gZmFsc2U7IH1cclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gRXZlbnREZWZQYXJzZXJfMS5kZWZhdWx0LnBhcnNlKGV2ZW50SW5wdXQsIGV2ZW50SW5wdXQuc291cmNlIHx8IGV2ZW50TWFuYWdlci5zdGlja3lTb3VyY2UpO1xyXG4gICAgICAgIGlmIChldmVudERlZikge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIuYWRkRXZlbnREZWYoZXZlbnREZWYsIGlzU3RpY2t5KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gbGVnYWN5UXVlcnkgb3BlcmF0ZXMgb24gbGVnYWN5IGV2ZW50IGluc3RhbmNlIG9iamVjdHNcclxuICAgIENhbGVuZGFyLnByb3RvdHlwZS5yZW1vdmVFdmVudHMgPSBmdW5jdGlvbiAobGVnYWN5UXVlcnkpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIGxlZ2FjeUluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHZhciBpZE1hcCA9IHt9O1xyXG4gICAgICAgIHZhciBldmVudERlZjtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBpZiAobGVnYWN5UXVlcnkgPT0gbnVsbCkgeyAvLyBzaG9ydGN1dCBmb3IgcmVtb3ZpbmcgYWxsXHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5yZW1vdmVBbGxFdmVudERlZnMoKTsgLy8gcGVyc2lzdD10cnVlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIuZ2V0RXZlbnRJbnN0YW5jZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBsZWdhY3lJbnN0YW5jZXMucHVzaChldmVudEluc3RhbmNlLnRvTGVnYWN5KCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGVnYWN5SW5zdGFuY2VzID0gZmlsdGVyTGVnYWN5RXZlbnRJbnN0YW5jZXMobGVnYWN5SW5zdGFuY2VzLCBsZWdhY3lRdWVyeSk7XHJcbiAgICAgICAgICAgIC8vIGNvbXB1dGUgdW5pcXVlIElEc1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVnYWN5SW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudERlZiA9IHRoaXMuZXZlbnRNYW5hZ2VyLmdldEV2ZW50RGVmQnlVaWQobGVnYWN5SW5zdGFuY2VzW2ldLl9pZCk7XHJcbiAgICAgICAgICAgICAgICBpZE1hcFtldmVudERlZi5pZF0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICAgICAgZm9yIChpIGluIGlkTWFwKSB7IC8vIHJldXNlIGBpYCBhcyBhbiBcImlkXCJcclxuICAgICAgICAgICAgICAgIGV2ZW50TWFuYWdlci5yZW1vdmVFdmVudERlZnNCeUlkKGkpOyAvLyBwZXJzaXN0PXRydWVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBsZWdhY3lRdWVyeSBvcGVyYXRlcyBvbiBsZWdhY3kgZXZlbnQgaW5zdGFuY2Ugb2JqZWN0c1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmNsaWVudEV2ZW50cyA9IGZ1bmN0aW9uIChsZWdhY3lRdWVyeSkge1xyXG4gICAgICAgIHZhciBsZWdhY3lFdmVudEluc3RhbmNlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLmdldEV2ZW50SW5zdGFuY2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBsZWdhY3lFdmVudEluc3RhbmNlcy5wdXNoKGV2ZW50SW5zdGFuY2UudG9MZWdhY3koKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlckxlZ2FjeUV2ZW50SW5zdGFuY2VzKGxlZ2FjeUV2ZW50SW5zdGFuY2VzLCBsZWdhY3lRdWVyeSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnVwZGF0ZUV2ZW50cyA9IGZ1bmN0aW9uIChldmVudFByb3BzQXJyYXkpIHtcclxuICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50UHJvcHNBcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUV2ZW50KGV2ZW50UHJvcHNBcnJheVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZXZlbnRNYW5hZ2VyLnRoYXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUudXBkYXRlRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRQcm9wcykge1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IHRoaXMuZXZlbnRNYW5hZ2VyLmdldEV2ZW50RGVmQnlVaWQoZXZlbnRQcm9wcy5faWQpO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlO1xyXG4gICAgICAgIHZhciBldmVudERlZk11dGF0aW9uO1xyXG4gICAgICAgIGlmIChldmVudERlZiBpbnN0YW5jZW9mIFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdCkge1xyXG4gICAgICAgICAgICBldmVudEluc3RhbmNlID0gZXZlbnREZWYuYnVpbGRJbnN0YW5jZSgpO1xyXG4gICAgICAgICAgICBldmVudERlZk11dGF0aW9uID0gRXZlbnREZWZNdXRhdGlvbl8xLmRlZmF1bHQuY3JlYXRlRnJvbVJhd1Byb3BzKGV2ZW50SW5zdGFuY2UsIGV2ZW50UHJvcHMsIC8vIHJhdyBwcm9wc1xyXG4gICAgICAgICAgICBudWxsIC8vIGxhcmdlVW5pdCAtLSB3aG8gdXNlcyBpdD9cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIubXV0YXRlRXZlbnRzV2l0aElkKGV2ZW50RGVmLmlkLCBldmVudERlZk11dGF0aW9uKTsgLy8gd2lsbCByZWxlYXNlXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFB1YmxpYyBFdmVudCBTb3VyY2VzIEFQSVxyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RXZlbnRTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50TWFuYWdlci5vdGhlclNvdXJjZXMuc2xpY2UoKTsgLy8gY2xvbmVcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUuZ2V0RXZlbnRTb3VyY2VCeUlkID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRNYW5hZ2VyLmdldFNvdXJjZUJ5SWQoRXZlbnRTb3VyY2VfMS5kZWZhdWx0Lm5vcm1hbGl6ZUlkKGlkKSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLmFkZEV2ZW50U291cmNlID0gZnVuY3Rpb24gKHNvdXJjZUlucHV0KSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZSA9IEV2ZW50U291cmNlUGFyc2VyXzEuZGVmYXVsdC5wYXJzZShzb3VyY2VJbnB1dCwgdGhpcyk7XHJcbiAgICAgICAgaWYgKHNvdXJjZSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFuYWdlci5hZGRTb3VyY2Uoc291cmNlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsZW5kYXIucHJvdG90eXBlLnJlbW92ZUV2ZW50U291cmNlcyA9IGZ1bmN0aW9uIChzb3VyY2VNdWx0aVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBzb3VyY2VzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGlmIChzb3VyY2VNdWx0aVF1ZXJ5ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudE1hbmFnZXIucmVtb3ZlQWxsU291cmNlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc291cmNlcyA9IGV2ZW50TWFuYWdlci5tdWx0aVF1ZXJ5U291cmNlcyhzb3VyY2VNdWx0aVF1ZXJ5KTtcclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLmZyZWV6ZSgpO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLnJlbW92ZVNvdXJjZShzb3VyY2VzW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIudGhhdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVtb3ZlRXZlbnRTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlUXVlcnkpIHtcclxuICAgICAgICB2YXIgZXZlbnRNYW5hZ2VyID0gdGhpcy5ldmVudE1hbmFnZXI7XHJcbiAgICAgICAgdmFyIHNvdXJjZXMgPSBldmVudE1hbmFnZXIucXVlcnlTb3VyY2VzKHNvdXJjZVF1ZXJ5KTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICBldmVudE1hbmFnZXIuZnJlZXplKCk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZXZlbnRNYW5hZ2VyLnJlbW92ZVNvdXJjZShzb3VyY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLnRoYXcoKTtcclxuICAgIH07XHJcbiAgICBDYWxlbmRhci5wcm90b3R5cGUucmVmZXRjaEV2ZW50U291cmNlcyA9IGZ1bmN0aW9uIChzb3VyY2VNdWx0aVF1ZXJ5KSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IHRoaXMuZXZlbnRNYW5hZ2VyO1xyXG4gICAgICAgIHZhciBzb3VyY2VzID0gZXZlbnRNYW5hZ2VyLm11bHRpUXVlcnlTb3VyY2VzKHNvdXJjZU11bHRpUXVlcnkpO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGV2ZW50TWFuYWdlci5mcmVlemUoKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBldmVudE1hbmFnZXIucmVmZXRjaFNvdXJjZShzb3VyY2VzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnRNYW5hZ2VyLnRoYXcoKTtcclxuICAgIH07XHJcbiAgICAvLyBub3QgZm9yIGludGVybmFsIHVzZS4gdXNlIG9wdGlvbnMgbW9kdWxlIGRpcmVjdGx5IGluc3RlYWQuXHJcbiAgICBDYWxlbmRhci5kZWZhdWx0cyA9IG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cztcclxuICAgIENhbGVuZGFyLmVuZ2xpc2hEZWZhdWx0cyA9IG9wdGlvbnNfMS5lbmdsaXNoRGVmYXVsdHM7XHJcbiAgICBDYWxlbmRhci5ydGxEZWZhdWx0cyA9IG9wdGlvbnNfMS5ydGxEZWZhdWx0cztcclxuICAgIHJldHVybiBDYWxlbmRhcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gQ2FsZW5kYXI7XHJcbkVtaXR0ZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhDYWxlbmRhcik7XHJcbkxpc3RlbmVyTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oQ2FsZW5kYXIpO1xyXG5mdW5jdGlvbiBmaWx0ZXJMZWdhY3lFdmVudEluc3RhbmNlcyhsZWdhY3lFdmVudEluc3RhbmNlcywgbGVnYWN5UXVlcnkpIHtcclxuICAgIGlmIChsZWdhY3lRdWVyeSA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGxlZ2FjeUV2ZW50SW5zdGFuY2VzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoJC5pc0Z1bmN0aW9uKGxlZ2FjeVF1ZXJ5KSkge1xyXG4gICAgICAgIHJldHVybiBsZWdhY3lFdmVudEluc3RhbmNlcy5maWx0ZXIobGVnYWN5UXVlcnkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7IC8vIGFuIGV2ZW50IElEXHJcbiAgICAgICAgbGVnYWN5UXVlcnkgKz0gJyc7IC8vIG5vcm1hbGl6ZSB0byBzdHJpbmdcclxuICAgICAgICByZXR1cm4gbGVnYWN5RXZlbnRJbnN0YW5jZXMuZmlsdGVyKGZ1bmN0aW9uIChsZWdhY3lFdmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIC8vIHNvZnQgY29tcGFyaXNvbiBiZWNhdXNlIGlkIG5vdCBiZSBub3JtYWxpemVkIHRvIHN0cmluZ1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgcmV0dXJuIGxlZ2FjeUV2ZW50SW5zdGFuY2UuaWQgPT0gbGVnYWN5UXVlcnkgfHxcclxuICAgICAgICAgICAgICAgIGxlZ2FjeUV2ZW50SW5zdGFuY2UuX2lkID09PSBsZWdhY3lRdWVyeTsgLy8gY2FuIHNwZWNpZnkgaW50ZXJuYWwgaWQsIGJ1dCBtdXN0IGV4YWN0bHkgbWF0Y2hcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cblxuLyoqKi8gfSksXG4vKiAyMzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciBleHBvcnRIb29rcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIG1vbWVudF9leHRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xyXG52YXIgTGlzdGVuZXJNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxudmFyIEhpdERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbnZhciBTaW5nbGVFdmVudERlZl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxudmFyIEV2ZW50SW5zdGFuY2VHcm91cF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbnZhciBFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxudmFyIEV4dGVybmFsRHJvcHBpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFeHRlcm5hbERyb3BwaW5nLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRXh0ZXJuYWxEcm9wcGluZygpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7IC8vIGpxdWktZHJhZ2dpbmcgYW4gZXh0ZXJuYWwgZWxlbWVudD8gYm9vbGVhblxyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgaW1wZW1lbnRzOlxyXG4gICAgICAtIGV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHNcclxuICAgICAgLSBpc0V2ZW50SW5zdGFuY2VHcm91cEFsbG93ZWRcclxuICAgICAgLSBpc0V4dGVybmFsSW5zdGFuY2VHcm91cEFsbG93ZWRcclxuICAgICAgLSByZW5kZXJEcmFnXHJcbiAgICAgIC0gdW5yZW5kZXJEcmFnXHJcbiAgICAqL1xyXG4gICAgRXh0ZXJuYWxEcm9wcGluZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFeHRlcm5hbERyb3BwaW5nLnByb3RvdHlwZS5iaW5kVG9Eb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmxpc3RlblRvKCQoZG9jdW1lbnQpLCB7XHJcbiAgICAgICAgICAgIGRyYWdzdGFydDogdGhpcy5oYW5kbGVEcmFnU3RhcnQsXHJcbiAgICAgICAgICAgIHNvcnRzdGFydDogdGhpcy5oYW5kbGVEcmFnU3RhcnQgLy8ganF1aVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEV4dGVybmFsRHJvcHBpbmcucHJvdG90eXBlLnVuYmluZEZyb21Eb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnN0b3BMaXN0ZW5pbmdUbygkKGRvY3VtZW50KSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIHdoZW4gYSBqUXVlcnkgVUkgZHJhZyBpcyBpbml0aWF0ZWQgYW55d2hlcmUgaW4gdGhlIERPTVxyXG4gICAgRXh0ZXJuYWxEcm9wcGluZy5wcm90b3R5cGUuaGFuZGxlRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2LCB1aSkge1xyXG4gICAgICAgIHZhciBlbDtcclxuICAgICAgICB2YXIgYWNjZXB0O1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnZHJvcHBhYmxlJykpIHsgLy8gb25seSBsaXN0ZW4gaWYgdGhpcyBzZXR0aW5nIGlzIG9uXHJcbiAgICAgICAgICAgIGVsID0gJCgodWkgPyB1aS5pdGVtIDogbnVsbCkgfHwgZXYudGFyZ2V0KTtcclxuICAgICAgICAgICAgLy8gVGVzdCB0aGF0IHRoZSBkcmFnZ2VkIGVsZW1lbnQgcGFzc2VzIHRoZSBkcm9wQWNjZXB0IHNlbGVjdG9yIG9yIGZpbHRlciBmdW5jdGlvbi5cclxuICAgICAgICAgICAgLy8gRllJLCB0aGUgZGVmYXVsdCBpcyBcIipcIiAobWF0Y2hlcyBhbGwpXHJcbiAgICAgICAgICAgIGFjY2VwdCA9IHRoaXMub3B0KCdkcm9wQWNjZXB0Jyk7XHJcbiAgICAgICAgICAgIGlmICgkLmlzRnVuY3Rpb24oYWNjZXB0KSA/IGFjY2VwdC5jYWxsKGVsWzBdLCBlbCkgOiBlbC5pcyhhY2NlcHQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNEcmFnZ2luZykgeyAvLyBwcmV2ZW50IGRvdWJsZS1saXN0ZW5pbmcgaWYgZmlyZWQgdHdpY2VcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlblRvRXh0ZXJuYWxEcmFnKGVsLCBldiwgdWkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCB3aGVuIGEgalF1ZXJ5IFVJIGRyYWcgc3RhcnRzIGFuZCBpdCBuZWVkcyB0byBiZSBtb25pdG9yZWQgZm9yIGRyb3BwaW5nXHJcbiAgICBFeHRlcm5hbERyb3BwaW5nLnByb3RvdHlwZS5saXN0ZW5Ub0V4dGVybmFsRHJhZyA9IGZ1bmN0aW9uIChlbCwgZXYsIHVpKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIG1ldGEgPSBnZXREcmFnZ2VkRWxNZXRhKGVsKTsgLy8gZXh0cmEgZGF0YSBhYm91dCBldmVudCBkcm9wLCBpbmNsdWRpbmcgcG9zc2libGUgZXZlbnQgdG8gY3JlYXRlXHJcbiAgICAgICAgdmFyIHNpbmdsZUV2ZW50RGVmOyAvLyBhIG51bGwgdmFsdWUgc2lnbmFscyBhbiB1bnN1Y2Nlc3NmdWwgZHJhZ1xyXG4gICAgICAgIC8vIGxpc3RlbmVyIHRoYXQgdHJhY2tzIG1vdXNlIG1vdmVtZW50IG92ZXIgZGF0ZS1hc3NvY2lhdGVkIHBpeGVsIHJlZ2lvbnNcclxuICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5kcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyXzEuZGVmYXVsdChjb21wb25lbnQsIHtcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25TdGFydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE92ZXI6IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIGhpdEZvb3RwcmludCA9IGhpdC5jb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChoaXQpOyAvLyBoaXQgbWlnaHQgbm90IGJlbG9uZyB0byB0aGlzIGdyaWRcclxuICAgICAgICAgICAgICAgIHZhciBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhpdEZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpbmdsZUV2ZW50RGVmID0gX3RoaXMuY29tcHV0ZUV4dGVybmFsRHJvcChoaXRGb290cHJpbnQsIG1ldGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaW5nbGVFdmVudERlZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwID0gbmV3IEV2ZW50SW5zdGFuY2VHcm91cF8xLmRlZmF1bHQoc2luZ2xlRXZlbnREZWYuYnVpbGRJbnN0YW5jZXMoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWxsb3dlZCA9IG1ldGEuZXZlbnRQcm9wcyA/IC8vIGlzRXZlbnQ/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXApIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc0V4dGVybmFsSW5zdGFuY2VHcm91cEFsbG93ZWQobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICghaXNBbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2luZ2xlRXZlbnREZWYgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5kaXNhYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc2luZ2xlRXZlbnREZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQucmVuZGVyRHJhZygvLyBjYWxsZWQgd2l0aG91dCBhIHNlZyBwYXJhbWV0ZXJcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50cyhtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwLnNsaWNlUmVuZGVyUmFuZ2VzKGNvbXBvbmVudC5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2UsIHZpZXcuY2FsZW5kYXIpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE91dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2luZ2xlRXZlbnREZWYgPSBudWxsOyAvLyBzaWduYWwgdW5zdWNjZXNzZnVsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdERvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHV0aWxfMS5lbmFibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC51bnJlbmRlckRyYWcoKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb25FbmQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNpbmdsZUV2ZW50RGVmKSB7IC8vIGVsZW1lbnQgd2FzIGRyb3BwZWQgb24gYSB2YWxpZCBoaXRcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnJlcG9ydEV4dGVybmFsRHJvcChzaW5nbGVFdmVudERlZiwgQm9vbGVhbihtZXRhLmV2ZW50UHJvcHMpLCAvLyBpc0V2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgQm9vbGVhbihtZXRhLnN0aWNrKSwgLy8gaXNTdGlja3lcclxuICAgICAgICAgICAgICAgICAgICBlbCwgZXYsIHVpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIF90aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBkcmFnTGlzdGVuZXIuc3RhcnREcmFnKGV2KTsgLy8gc3RhcnQgbGlzdGVuaW5nIGltbWVkaWF0ZWx5XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSBoaXQgdG8gYmUgZHJvcHBlZCB1cG9uLCBhbmQgbWlzYyBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGUganF1aSBkcmFnIChndWFyYW50ZWVkIHRvIGJlIGEgcGxhaW4gb2JqZWN0KSxcclxuICAgIC8vIHJldHVybnMgdGhlIHpvbmVkIHN0YXJ0L2VuZCBkYXRlcyBmb3IgdGhlIGV2ZW50IHRoYXQgd291bGQgcmVzdWx0IGZyb20gdGhlIGh5cG90aGV0aWNhbCBkcm9wLiBlbmQgbWlnaHQgYmUgbnVsbC5cclxuICAgIC8vIFJldHVybmluZyBhIG51bGwgdmFsdWUgc2lnbmFscyBhbiBpbnZhbGlkIGRyb3AgaGl0LlxyXG4gICAgLy8gRE9FUyBOT1QgY29uc2lkZXIgb3ZlcmxhcC9jb25zdHJhaW50LlxyXG4gICAgLy8gQXNzdW1lcyBib3RoIGZvb3RwcmludHMgYXJlIG5vbi1vcGVuLWVuZGVkLlxyXG4gICAgRXh0ZXJuYWxEcm9wcGluZy5wcm90b3R5cGUuY29tcHV0ZUV4dGVybmFsRHJvcCA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQsIG1ldGEpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLnZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gbW9tZW50X2V4dF8xLmRlZmF1bHQudXRjKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2Uuc3RhcnRNcykuc3RyaXBab25lKCk7XHJcbiAgICAgICAgdmFyIGVuZDtcclxuICAgICAgICB2YXIgZXZlbnREZWY7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICAvLyBpZiBkcm9wcGVkIG9uIGFuIGFsbC1kYXkgc3BhbiwgYW5kIGVsZW1lbnQncyBtZXRhZGF0YSBzcGVjaWZpZWQgYSB0aW1lLCBzZXQgaXRcclxuICAgICAgICAgICAgaWYgKG1ldGEuc3RhcnRUaW1lKSB7XHJcbiAgICAgICAgICAgICAgICBzdGFydC50aW1lKG1ldGEuc3RhcnRUaW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHN0YXJ0LnN0cmlwVGltZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtZXRhLmR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGVuZCA9IHN0YXJ0LmNsb25lKCkuYWRkKG1ldGEuZHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdGFydCA9IGNhbGVuZGFyLmFwcGx5VGltZXpvbmUoc3RhcnQpO1xyXG4gICAgICAgIGlmIChlbmQpIHtcclxuICAgICAgICAgICAgZW5kID0gY2FsZW5kYXIuYXBwbHlUaW1lem9uZShlbmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudERlZiA9IFNpbmdsZUV2ZW50RGVmXzEuZGVmYXVsdC5wYXJzZSgkLmV4dGVuZCh7fSwgbWV0YS5ldmVudFByb3BzLCB7XHJcbiAgICAgICAgICAgIHN0YXJ0OiBzdGFydCxcclxuICAgICAgICAgICAgZW5kOiBlbmRcclxuICAgICAgICB9KSwgbmV3IEV2ZW50U291cmNlXzEuZGVmYXVsdChjYWxlbmRhcikpO1xyXG4gICAgICAgIHJldHVybiBldmVudERlZjtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXh0ZXJuYWxEcm9wcGluZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXh0ZXJuYWxEcm9wcGluZztcclxuTGlzdGVuZXJNaXhpbl8xLmRlZmF1bHQubWl4SW50byhFeHRlcm5hbERyb3BwaW5nKTtcclxuLyogRXh0ZXJuYWwtRHJhZ2dpbmctRWxlbWVudCBEYXRhXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4vLyBSZXF1aXJlIGFsbCBIVE1MNSBkYXRhLSogYXR0cmlidXRlcyB1c2VkIGJ5IEZ1bGxDYWxlbmRhciB0byBoYXZlIHRoaXMgcHJlZml4LlxyXG4vLyBBIHZhbHVlIG9mICcnIHdpbGwgcXVlcnkgYXR0cmlidXRlcyBsaWtlIGRhdGEtZXZlbnQuIEEgdmFsdWUgb2YgJ2ZjJyB3aWxsIHF1ZXJ5IGF0dHJpYnV0ZXMgbGlrZSBkYXRhLWZjLWV2ZW50LlxyXG5leHBvcnRIb29rcy5kYXRhQXR0clByZWZpeCA9ICcnO1xyXG4vLyBHaXZlbiBhIGpRdWVyeSBlbGVtZW50IHRoYXQgbWlnaHQgcmVwcmVzZW50IGEgZHJhZ2dlZCBGdWxsQ2FsZW5kYXIgZXZlbnQsIHJldHVybnMgYW4gaW50ZXJtZWRpYXRlIGRhdGEgc3RydWN0dXJlXHJcbi8vIHRvIGJlIHVzZWQgZm9yIEV2ZW50IE9iamVjdCBjcmVhdGlvbi5cclxuLy8gQSBkZWZpbmVkIGAuZXZlbnRQcm9wc2AsIGV2ZW4gd2hlbiBlbXB0eSwgaW5kaWNhdGVzIHRoYXQgYW4gZXZlbnQgc2hvdWxkIGJlIGNyZWF0ZWQuXHJcbmZ1bmN0aW9uIGdldERyYWdnZWRFbE1ldGEoZWwpIHtcclxuICAgIHZhciBwcmVmaXggPSBleHBvcnRIb29rcy5kYXRhQXR0clByZWZpeDtcclxuICAgIHZhciBldmVudFByb3BzOyAvLyBwcm9wZXJ0aWVzIGZvciBjcmVhdGluZyB0aGUgZXZlbnQsIG5vdCByZWxhdGVkIHRvIGRhdGUvdGltZVxyXG4gICAgdmFyIHN0YXJ0VGltZTsgLy8gYSBEdXJhdGlvblxyXG4gICAgdmFyIGR1cmF0aW9uO1xyXG4gICAgdmFyIHN0aWNrO1xyXG4gICAgaWYgKHByZWZpeCkge1xyXG4gICAgICAgIHByZWZpeCArPSAnLSc7XHJcbiAgICB9XHJcbiAgICBldmVudFByb3BzID0gZWwuZGF0YShwcmVmaXggKyAnZXZlbnQnKSB8fCBudWxsO1xyXG4gICAgaWYgKGV2ZW50UHJvcHMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGV2ZW50UHJvcHMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGV2ZW50UHJvcHMgPSAkLmV4dGVuZCh7fSwgZXZlbnRQcm9wcyk7IC8vIG1ha2UgYSBjb3B5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgeyAvLyBzb21ldGhpbmcgbGlrZSAxIG9yIHRydWUuIHN0aWxsIHNpZ25hbCBldmVudCBjcmVhdGlvblxyXG4gICAgICAgICAgICBldmVudFByb3BzID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBsdWNrIHNwZWNpYWwtY2FzZWQgZGF0ZS90aW1lIHByb3BlcnRpZXNcclxuICAgICAgICBzdGFydFRpbWUgPSBldmVudFByb3BzLnN0YXJ0O1xyXG4gICAgICAgIGlmIChzdGFydFRpbWUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzdGFydFRpbWUgPSBldmVudFByb3BzLnRpbWU7XHJcbiAgICAgICAgfSAvLyBhY2NlcHQgJ3RpbWUnIGFzIHdlbGxcclxuICAgICAgICBkdXJhdGlvbiA9IGV2ZW50UHJvcHMuZHVyYXRpb247XHJcbiAgICAgICAgc3RpY2sgPSBldmVudFByb3BzLnN0aWNrO1xyXG4gICAgICAgIGRlbGV0ZSBldmVudFByb3BzLnN0YXJ0O1xyXG4gICAgICAgIGRlbGV0ZSBldmVudFByb3BzLnRpbWU7XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50UHJvcHMuZHVyYXRpb247XHJcbiAgICAgICAgZGVsZXRlIGV2ZW50UHJvcHMuc3RpY2s7XHJcbiAgICB9XHJcbiAgICAvLyBmYWxsYmFjayB0byBzdGFuZGFsb25lIGF0dHJpYnV0ZSB2YWx1ZXMgZm9yIGVhY2ggb2YgdGhlIGRhdGUvdGltZSBwcm9wZXJ0aWVzXHJcbiAgICBpZiAoc3RhcnRUaW1lID09IG51bGwpIHtcclxuICAgICAgICBzdGFydFRpbWUgPSBlbC5kYXRhKHByZWZpeCArICdzdGFydCcpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0YXJ0VGltZSA9PSBudWxsKSB7XHJcbiAgICAgICAgc3RhcnRUaW1lID0gZWwuZGF0YShwcmVmaXggKyAndGltZScpO1xyXG4gICAgfSAvLyBhY2NlcHQgJ3RpbWUnIGFzIHdlbGxcclxuICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgZHVyYXRpb24gPSBlbC5kYXRhKHByZWZpeCArICdkdXJhdGlvbicpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0aWNrID09IG51bGwpIHtcclxuICAgICAgICBzdGljayA9IGVsLmRhdGEocHJlZml4ICsgJ3N0aWNrJyk7XHJcbiAgICB9XHJcbiAgICAvLyBtYXNzYWdlIGludG8gY29ycmVjdCBkYXRhIHR5cGVzXHJcbiAgICBzdGFydFRpbWUgPSBzdGFydFRpbWUgIT0gbnVsbCA/IG1vbWVudC5kdXJhdGlvbihzdGFydFRpbWUpIDogbnVsbDtcclxuICAgIGR1cmF0aW9uID0gZHVyYXRpb24gIT0gbnVsbCA/IG1vbWVudC5kdXJhdGlvbihkdXJhdGlvbikgOiBudWxsO1xyXG4gICAgc3RpY2sgPSBCb29sZWFuKHN0aWNrKTtcclxuICAgIHJldHVybiB7IGV2ZW50UHJvcHM6IGV2ZW50UHJvcHMsIHN0YXJ0VGltZTogc3RhcnRUaW1lLCBkdXJhdGlvbjogZHVyYXRpb24sIHN0aWNrOiBzdGljayB9O1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDIzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50RGVmTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG52YXIgRXZlbnREZWZEYXRlTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxudmFyIEV2ZW50UmVzaXppbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFdmVudFJlc2l6aW5nLCBfc3VwZXIpO1xyXG4gICAgLypcclxuICAgIGNvbXBvbmVudCBpbXBlbWVudHM6XHJcbiAgICAgIC0gYmluZFNlZ0hhbmRsZXJUb0VsXHJcbiAgICAgIC0gcHVibGljbHlUcmlnZ2VyXHJcbiAgICAgIC0gZGlmZkRhdGVzXHJcbiAgICAgIC0gZXZlbnRSYW5nZXNUb0V2ZW50Rm9vdHByaW50c1xyXG4gICAgICAtIGlzRXZlbnRJbnN0YW5jZUdyb3VwQWxsb3dlZFxyXG4gICAgICAtIGdldFNhZmVIaXRGb290cHJpbnRcclxuICAgICovXHJcbiAgICBmdW5jdGlvbiBFdmVudFJlc2l6aW5nKGNvbXBvbmVudCwgZXZlbnRQb2ludGluZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbXBvbmVudCkgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5pc1Jlc2l6aW5nID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZyA9IGV2ZW50UG9pbnRpbmc7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5iaW5kVG9FbCA9IGZ1bmN0aW9uIChlbCkge1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICBjb21wb25lbnQuYmluZFNlZ0hhbmRsZXJUb0VsKGVsLCAnbW91c2Vkb3duJywgdGhpcy5oYW5kbGVNb3VzZURvd24uYmluZCh0aGlzKSk7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ3RvdWNoc3RhcnQnLCB0aGlzLmhhbmRsZVRvdWNoU3RhcnQuYmluZCh0aGlzKSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuaGFuZGxlTW91c2VEb3duID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQuY2FuU3RhcnRSZXNpemUoc2VnLCBldikpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERyYWdMaXN0ZW5lcihzZWcsICQoZXYudGFyZ2V0KS5pcygnLmZjLXN0YXJ0LXJlc2l6ZXInKSlcclxuICAgICAgICAgICAgICAgIC5zdGFydEludGVyYWN0aW9uKGV2LCB7IGRpc3RhbmNlOiA1IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5oYW5kbGVUb3VjaFN0YXJ0ID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21wb25lbnQuY2FuU3RhcnRSZXNpemUoc2VnLCBldikpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERyYWdMaXN0ZW5lcihzZWcsICQoZXYudGFyZ2V0KS5pcygnLmZjLXN0YXJ0LXJlc2l6ZXInKSlcclxuICAgICAgICAgICAgICAgIC5zdGFydEludGVyYWN0aW9uKGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ3JlYXRlcyBhIGxpc3RlbmVyIHRoYXQgdHJhY2tzIHRoZSB1c2VyIGFzIHRoZXkgcmVzaXplIGFuIGV2ZW50IHNlZ21lbnQuXHJcbiAgICAvLyBHZW5lcmljIGVub3VnaCB0byB3b3JrIHdpdGggYW55IHR5cGUgb2YgR3JpZC5cclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLmJ1aWxkRHJhZ0xpc3RlbmVyID0gZnVuY3Rpb24gKHNlZywgaXNTdGFydCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IGNhbGVuZGFyLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgZWwgPSBzZWcuZWw7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gc2VnLmZvb3RwcmludC5ldmVudERlZjtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IHNlZy5mb290cHJpbnQuZXZlbnRJbnN0YW5jZTtcclxuICAgICAgICB2YXIgaXNEcmFnZ2luZztcclxuICAgICAgICB2YXIgcmVzaXplTXV0YXRpb247IC8vIHpvbmVkIGV2ZW50IGRhdGUgcHJvcGVydGllcy4gZmFsc3kgaWYgaW52YWxpZCByZXNpemVcclxuICAgICAgICAvLyBUcmFja3MgbW91c2UgbW92ZW1lbnQgb3ZlciB0aGUgKmdyaWQncyogY29vcmRpbmF0ZSBtYXBcclxuICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5kcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyXzEuZGVmYXVsdChjb21wb25lbnQsIHtcclxuICAgICAgICAgICAgc2Nyb2xsOiB0aGlzLm9wdCgnZHJhZ1Njcm9sbCcpLFxyXG4gICAgICAgICAgICBzdWJqZWN0RWw6IGVsLFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGRyYWdTdGFydDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIC8vIGVuc3VyZSBhIG1vdXNlb3V0IG9uIHRoZSBtYW5pcHVsYXRlZCBldmVudCBoYXMgYmVlbiByZXBvcnRlZFxyXG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRQb2ludGluZy5oYW5kbGVNb3VzZW91dChzZWcsIGV2KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLnNlZ1Jlc2l6ZVN0YXJ0KHNlZywgZXYpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdmVyOiBmdW5jdGlvbiAoaGl0LCBpc09yaWcsIG9yaWdIaXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpc0FsbG93ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdmFyIG9yaWdIaXRGb290cHJpbnQgPSBjb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChvcmlnSGl0KTtcclxuICAgICAgICAgICAgICAgIHZhciBoaXRGb290cHJpbnQgPSBjb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChoaXQpO1xyXG4gICAgICAgICAgICAgICAgdmFyIG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ0hpdEZvb3RwcmludCAmJiBoaXRGb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNpemVNdXRhdGlvbiA9IGlzU3RhcnQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlRXZlbnRTdGFydFJlc2l6ZU11dGF0aW9uKG9yaWdIaXRGb290cHJpbnQsIGhpdEZvb3RwcmludCwgc2VnLmZvb3RwcmludCkgOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wdXRlRXZlbnRFbmRSZXNpemVNdXRhdGlvbihvcmlnSGl0Rm9vdHByaW50LCBoaXRGb290cHJpbnQsIHNlZy5mb290cHJpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNpemVNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRJbnN0YW5jZUdyb3VwID0gZXZlbnRNYW5hZ2VyLmJ1aWxkTXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cChldmVudERlZi5pZCwgcmVzaXplTXV0YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBjb21wb25lbnQuaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZU11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuZGlzYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzaXplTXV0YXRpb24uaXNFbXB0eSgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gY2hhbmdlLiAoRllJLCBldmVudCBkYXRlcyBtaWdodCBoYXZlIHpvbmVzKVxyXG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZU11dGF0aW9uID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChyZXNpemVNdXRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcuaGlkZUV2ZW50c1dpdGhJZChzZWcuZm9vdHByaW50LmV2ZW50RGVmLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICB2aWV3LnJlbmRlckV2ZW50UmVzaXplKGNvbXBvbmVudC5ldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAuc2xpY2VSZW5kZXJSYW5nZXMoY29tcG9uZW50LmRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZSwgY2FsZW5kYXIpKSwgc2VnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXNpemVNdXRhdGlvbiA9IG51bGw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdERvbmU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcudW5yZW5kZXJFdmVudFJlc2l6ZShzZWcpO1xyXG4gICAgICAgICAgICAgICAgdmlldy5zaG93RXZlbnRzV2l0aElkKHNlZy5mb290cHJpbnQuZXZlbnREZWYuaWQpO1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLmVuYWJsZUN1cnNvcigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNlZ1Jlc2l6ZVN0b3Aoc2VnLCBldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzaXplTXV0YXRpb24pIHsgLy8gdmFsaWQgZGF0ZSB0byByZXNpemUgdG8/XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byByZS1zaG93IG9yaWdpbmFsLCB3aWxsIHJlcmVuZGVyIGFsbCBhbnl3YXlzLiBlc3AgaW1wb3J0YW50IGlmIGV2ZW50UmVuZGVyV2FpdFxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcucmVwb3J0RXZlbnRSZXNpemUoZXZlbnRJbnN0YW5jZSwgcmVzaXplTXV0YXRpb24sIGVsLCBldik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnTGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRyYWdMaXN0ZW5lcjtcclxuICAgIH07XHJcbiAgICAvLyBDYWxsZWQgYmVmb3JlIGV2ZW50IHNlZ21lbnQgcmVzaXppbmcgc3RhcnRzXHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5zZWdSZXNpemVTdGFydCA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5pc1Jlc2l6aW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50UmVzaXplU3RhcnQnLCB7XHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHNlZy5lbFswXSxcclxuICAgICAgICAgICAgYXJnczogW1xyXG4gICAgICAgICAgICAgICAgc2VnLmZvb3RwcmludC5nZXRFdmVudExlZ2FjeSgpLFxyXG4gICAgICAgICAgICAgICAgZXYsXHJcbiAgICAgICAgICAgICAgICB7fSxcclxuICAgICAgICAgICAgICAgIHRoaXMudmlld1xyXG4gICAgICAgICAgICBdXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsbGVkIGFmdGVyIGV2ZW50IHNlZ21lbnQgcmVzaXppbmcgc3RvcHNcclxuICAgIEV2ZW50UmVzaXppbmcucHJvdG90eXBlLnNlZ1Jlc2l6ZVN0b3AgPSBmdW5jdGlvbiAoc2VnLCBldikge1xyXG4gICAgICAgIHRoaXMuaXNSZXNpemluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50LnB1YmxpY2x5VHJpZ2dlcignZXZlbnRSZXNpemVTdG9wJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIFJldHVybnMgbmV3IGRhdGUtaW5mb3JtYXRpb24gZm9yIGFuIGV2ZW50IHNlZ21lbnQgYmVpbmcgcmVzaXplZCBmcm9tIGl0cyBzdGFydFxyXG4gICAgRXZlbnRSZXNpemluZy5wcm90b3R5cGUuY29tcHV0ZUV2ZW50U3RhcnRSZXNpemVNdXRhdGlvbiA9IGZ1bmN0aW9uIChzdGFydEZvb3RwcmludCwgZW5kRm9vdHByaW50LCBvcmlnRXZlbnRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgb3JpZ1JhbmdlID0gb3JpZ0V2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIHN0YXJ0RGVsdGEgPSB0aGlzLmNvbXBvbmVudC5kaWZmRGF0ZXMoZW5kRm9vdHByaW50LnVuem9uZWRSYW5nZS5nZXRTdGFydCgpLCBzdGFydEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKSk7XHJcbiAgICAgICAgdmFyIGRhdGVNdXRhdGlvbjtcclxuICAgICAgICB2YXIgZXZlbnREZWZNdXRhdGlvbjtcclxuICAgICAgICBpZiAob3JpZ1JhbmdlLmdldFN0YXJ0KCkuYWRkKHN0YXJ0RGVsdGEpIDwgb3JpZ1JhbmdlLmdldEVuZCgpKSB7XHJcbiAgICAgICAgICAgIGRhdGVNdXRhdGlvbiA9IG5ldyBFdmVudERlZkRhdGVNdXRhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgZGF0ZU11dGF0aW9uLnNldFN0YXJ0RGVsdGEoc3RhcnREZWx0YSk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBuZXcgRXZlbnREZWZNdXRhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbi5zZXREYXRlTXV0YXRpb24oZGF0ZU11dGF0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIG5ldyBkYXRlLWluZm9ybWF0aW9uIGZvciBhbiBldmVudCBzZWdtZW50IGJlaW5nIHJlc2l6ZWQgZnJvbSBpdHMgZW5kXHJcbiAgICBFdmVudFJlc2l6aW5nLnByb3RvdHlwZS5jb21wdXRlRXZlbnRFbmRSZXNpemVNdXRhdGlvbiA9IGZ1bmN0aW9uIChzdGFydEZvb3RwcmludCwgZW5kRm9vdHByaW50LCBvcmlnRXZlbnRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgb3JpZ1JhbmdlID0gb3JpZ0V2ZW50Rm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2U7XHJcbiAgICAgICAgdmFyIGVuZERlbHRhID0gdGhpcy5jb21wb25lbnQuZGlmZkRhdGVzKGVuZEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZ2V0RW5kKCksIHN0YXJ0Rm9vdHByaW50LnVuem9uZWRSYW5nZS5nZXRFbmQoKSk7XHJcbiAgICAgICAgdmFyIGRhdGVNdXRhdGlvbjtcclxuICAgICAgICB2YXIgZXZlbnREZWZNdXRhdGlvbjtcclxuICAgICAgICBpZiAob3JpZ1JhbmdlLmdldEVuZCgpLmFkZChlbmREZWx0YSkgPiBvcmlnUmFuZ2UuZ2V0U3RhcnQoKSkge1xyXG4gICAgICAgICAgICBkYXRlTXV0YXRpb24gPSBuZXcgRXZlbnREZWZEYXRlTXV0YXRpb25fMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGRhdGVNdXRhdGlvbi5zZXRFbmREZWx0YShlbmREZWx0YSk7XHJcbiAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBuZXcgRXZlbnREZWZNdXRhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICAgICAgZXZlbnREZWZNdXRhdGlvbi5zZXREYXRlTXV0YXRpb24oZGF0ZU11dGF0aW9uKTtcclxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRXZlbnRSZXNpemluZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRXZlbnRSZXNpemluZztcclxuXG5cbi8qKiovIH0pLFxuLyogMjM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50RGVmTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG52YXIgRXZlbnREZWZEYXRlTXV0YXRpb25fMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApO1xyXG52YXIgRHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KTtcclxudmFyIEhpdERyYWdMaXN0ZW5lcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XHJcbnZhciBNb3VzZUZvbGxvd2VyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyNik7XHJcbnZhciBJbnRlcmFjdGlvbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XHJcbnZhciBFdmVudERyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRXZlbnREcmFnZ2luZywgX3N1cGVyKTtcclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgaW1wbGVtZW50czpcclxuICAgICAgLSBiaW5kU2VnSGFuZGxlclRvRWxcclxuICAgICAgLSBwdWJsaWNseVRyaWdnZXJcclxuICAgICAgLSBkaWZmRGF0ZXNcclxuICAgICAgLSBldmVudFJhbmdlc1RvRXZlbnRGb290cHJpbnRzXHJcbiAgICAgIC0gaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkXHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gRXZlbnREcmFnZ2luZyhjb21wb25lbnQsIGV2ZW50UG9pbnRpbmcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIF90aGlzLmV2ZW50UG9pbnRpbmcgPSBldmVudFBvaW50aW5nO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5kcmFnTGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuZ2V0U2VsZWN0aW9uRGVsYXkgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRlbGF5ID0gdGhpcy5vcHQoJ2V2ZW50TG9uZ1ByZXNzRGVsYXknKTtcclxuICAgICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWxheSA9IHRoaXMub3B0KCdsb25nUHJlc3NEZWxheScpOyAvLyBmYWxsYmFja1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVsYXk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuYmluZFRvRWwgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmRTZWdIYW5kbGVyVG9FbChlbCwgJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlTW91c2Vkb3duLmJpbmQodGhpcykpO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kU2VnSGFuZGxlclRvRWwoZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5oYW5kbGVUb3VjaFN0YXJ0LmJpbmQodGhpcykpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmhhbmRsZU1vdXNlZG93biA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBvbmVudC5zaG91bGRJZ25vcmVNb3VzZSgpICYmXHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LmNhblN0YXJ0RHJhZyhzZWcsIGV2KSkge1xyXG4gICAgICAgICAgICB0aGlzLmJ1aWxkRHJhZ0xpc3RlbmVyKHNlZykuc3RhcnRJbnRlcmFjdGlvbihldiwgeyBkaXN0YW5jZTogNSB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuaGFuZGxlVG91Y2hTdGFydCA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgZGVsYXk6IHRoaXMudmlldy5pc0V2ZW50RGVmU2VsZWN0ZWQoc2VnLmZvb3RwcmludC5ldmVudERlZikgPyAvLyBhbHJlYWR5IHNlbGVjdGVkP1xyXG4gICAgICAgICAgICAgICAgMCA6IHRoaXMuZ2V0U2VsZWN0aW9uRGVsYXkoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudC5jYW5TdGFydERyYWcoc2VnLCBldikpIHtcclxuICAgICAgICAgICAgdGhpcy5idWlsZERyYWdMaXN0ZW5lcihzZWcpLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHNldHRpbmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50LmNhblN0YXJ0U2VsZWN0aW9uKHNlZywgZXYpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYnVpbGRTZWxlY3RMaXN0ZW5lcihzZWcpLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHNldHRpbmdzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gc2VnIGlzbid0IGRyYWdnYWJsZSwgYnV0IGxldCdzIHVzZSBhIGdlbmVyaWMgRHJhZ0xpc3RlbmVyXHJcbiAgICAvLyBzaW1wbHkgZm9yIHRoZSBkZWxheSwgc28gaXQgY2FuIGJlIHNlbGVjdGVkLlxyXG4gICAgLy8gSGFzIHNpZGUgZWZmZWN0IG9mIHNldHRpbmcvdW5zZXR0aW5nIGBkcmFnTGlzdGVuZXJgXHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5idWlsZFNlbGVjdExpc3RlbmVyID0gZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gc2VnLmZvb3RwcmludC5ldmVudERlZjtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IHNlZy5mb290cHJpbnQuZXZlbnRJbnN0YW5jZTsgLy8gbnVsbCBmb3IgaW52ZXJzZS1iYWNrZ3JvdW5kIGV2ZW50c1xyXG4gICAgICAgIGlmICh0aGlzLmRyYWdMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kcmFnTGlzdGVuZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLmRyYWdMaXN0ZW5lciA9IG5ldyBEcmFnTGlzdGVuZXJfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkcmFnTGlzdGVuZXIuaXNUb3VjaCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICF2aWV3LmlzRXZlbnREZWZTZWxlY3RlZChldmVudERlZikgJiZcclxuICAgICAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IHByZXZpb3VzbHkgc2VsZWN0ZWQsIHdpbGwgZmlyZSBhZnRlciBhIGRlbGF5LiB0aGVuLCBzZWxlY3QgdGhlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5zZWxlY3RFdmVudEluc3RhbmNlKGV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5kcmFnTGlzdGVuZXIgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGRyYWdMaXN0ZW5lcjtcclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgdHJhY2sgdXNlci1kcmFnZ2luZyBvbiBhbiBldmVudCBzZWdtZW50LlxyXG4gICAgLy8gR2VuZXJpYyBlbm91Z2ggdG8gd29yayB3aXRoIGFueSB0eXBlIG9mIEdyaWQuXHJcbiAgICAvLyBIYXMgc2lkZSBlZmZlY3Qgb2Ygc2V0dGluZy91bnNldHRpbmcgYGRyYWdMaXN0ZW5lcmBcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLmJ1aWxkRHJhZ0xpc3RlbmVyID0gZnVuY3Rpb24gKHNlZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIGV2ZW50TWFuYWdlciA9IGNhbGVuZGFyLmV2ZW50TWFuYWdlcjtcclxuICAgICAgICB2YXIgZWwgPSBzZWcuZWw7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gc2VnLmZvb3RwcmludC5ldmVudERlZjtcclxuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZSA9IHNlZy5mb290cHJpbnQuZXZlbnRJbnN0YW5jZTsgLy8gbnVsbCBmb3IgaW52ZXJzZS1iYWNrZ3JvdW5kIGV2ZW50c1xyXG4gICAgICAgIHZhciBpc0RyYWdnaW5nO1xyXG4gICAgICAgIHZhciBtb3VzZUZvbGxvd2VyOyAvLyBBIGNsb25lIG9mIHRoZSBvcmlnaW5hbCBlbGVtZW50IHRoYXQgd2lsbCBtb3ZlIHdpdGggdGhlIG1vdXNlXHJcbiAgICAgICAgdmFyIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICAgICAgaWYgKHRoaXMuZHJhZ0xpc3RlbmVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyYWdMaXN0ZW5lcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVHJhY2tzIG1vdXNlIG1vdmVtZW50IG92ZXIgdGhlICp2aWV3J3MqIGNvb3JkaW5hdGUgbWFwLiBBbGxvd3MgZHJhZ2dpbmcgYW5kIGRyb3BwaW5nIGJldHdlZW4gc3ViY29tcG9uZW50c1xyXG4gICAgICAgIC8vIG9mIHRoZSB2aWV3LlxyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSB0aGlzLmRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXJfMS5kZWZhdWx0KHZpZXcsIHtcclxuICAgICAgICAgICAgc2Nyb2xsOiB0aGlzLm9wdCgnZHJhZ1Njcm9sbCcpLFxyXG4gICAgICAgICAgICBzdWJqZWN0RWw6IGVsLFxyXG4gICAgICAgICAgICBzdWJqZWN0Q2VudGVyOiB0cnVlLFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5jb21wb25lbnQgPSBjb21wb25lbnQ7IC8vIGZvciByZW5kZXJEcmFnXHJcbiAgICAgICAgICAgICAgICBpc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBtb3VzZUZvbGxvd2VyID0gbmV3IE1vdXNlRm9sbG93ZXJfMS5kZWZhdWx0KHNlZy5lbCwge1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZGl0aW9uYWxDbGFzczogJ2ZjLWRyYWdnaW5nJyxcclxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRFbDogdmlldy5lbCxcclxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiBkcmFnTGlzdGVuZXIuaXNUb3VjaCA/IG51bGwgOiBfdGhpcy5vcHQoJ2RyYWdPcGFjaXR5JyksXHJcbiAgICAgICAgICAgICAgICAgICAgcmV2ZXJ0RHVyYXRpb246IF90aGlzLm9wdCgnZHJhZ1JldmVydER1cmF0aW9uJyksXHJcbiAgICAgICAgICAgICAgICAgICAgekluZGV4OiAyIC8vIG9uZSBhYm92ZSB0aGUgLmZjLXZpZXdcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgbW91c2VGb2xsb3dlci5oaWRlKCk7IC8vIGRvbid0IHNob3cgdW50aWwgd2Uga25vdyB0aGlzIGlzIGEgcmVhbCBkcmFnXHJcbiAgICAgICAgICAgICAgICBtb3VzZUZvbGxvd2VyLnN0YXJ0KGV2KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGlmIChkcmFnTGlzdGVuZXIuaXNUb3VjaCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICF2aWV3LmlzRXZlbnREZWZTZWxlY3RlZChldmVudERlZikgJiZcclxuICAgICAgICAgICAgICAgICAgICBldmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm90IHByZXZpb3VzbHkgc2VsZWN0ZWQsIHdpbGwgZmlyZSBhZnRlciBhIGRlbGF5LiB0aGVuLCBzZWxlY3QgdGhlIGV2ZW50XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5zZWxlY3RFdmVudEluc3RhbmNlKGV2ZW50SW5zdGFuY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgYSBtb3VzZW91dCBvbiB0aGUgbWFuaXB1bGF0ZWQgZXZlbnQgaGFzIGJlZW4gcmVwb3J0ZWRcclxuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50UG9pbnRpbmcuaGFuZGxlTW91c2VvdXQoc2VnLCBldik7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5zZWdEcmFnU3RhcnQoc2VnLCBldik7XHJcbiAgICAgICAgICAgICAgICB2aWV3LmhpZGVFdmVudHNXaXRoSWQoc2VnLmZvb3RwcmludC5ldmVudERlZi5pZCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE92ZXI6IGZ1bmN0aW9uIChoaXQsIGlzT3JpZywgb3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQWxsb3dlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ0Zvb3RwcmludDtcclxuICAgICAgICAgICAgICAgIHZhciBmb290cHJpbnQ7XHJcbiAgICAgICAgICAgICAgICB2YXIgbXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cDtcclxuICAgICAgICAgICAgICAgIC8vIHN0YXJ0aW5nIGhpdCBjb3VsZCBiZSBmb3JjZWQgKERheUdyaWQubGltaXQpXHJcbiAgICAgICAgICAgICAgICBpZiAoc2VnLmhpdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9yaWdIaXQgPSBzZWcuaGl0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gaGl0IG1pZ2h0IG5vdCBiZWxvbmcgdG8gdGhpcyBncmlkLCBzbyBxdWVyeSBvcmlnaW4gZ3JpZFxyXG4gICAgICAgICAgICAgICAgb3JpZ0Zvb3RwcmludCA9IG9yaWdIaXQuY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQob3JpZ0hpdCk7XHJcbiAgICAgICAgICAgICAgICBmb290cHJpbnQgPSBoaXQuY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQoaGl0KTtcclxuICAgICAgICAgICAgICAgIGlmIChvcmlnRm9vdHByaW50ICYmIGZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBfdGhpcy5jb21wdXRlRXZlbnREcm9wTXV0YXRpb24ob3JpZ0Zvb3RwcmludCwgZm9vdHByaW50LCBldmVudERlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50RGVmTXV0YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cCA9IGV2ZW50TWFuYWdlci5idWlsZE11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXAoZXZlbnREZWYuaWQsIGV2ZW50RGVmTXV0YXRpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FsbG93ZWQgPSBjb21wb25lbnQuaXNFdmVudEluc3RhbmNlR3JvdXBBbGxvd2VkKG11dGF0ZWRFdmVudEluc3RhbmNlR3JvdXApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNBbGxvd2VkID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIHV0aWxfMS5kaXNhYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBpZiBhIHZhbGlkIGRyb3AgbG9jYXRpb24sIGhhdmUgdGhlIHN1YmNsYXNzIHJlbmRlciBhIHZpc3VhbCBpbmRpY2F0aW9uXHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnREZWZNdXRhdGlvbiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHZpZXcucmVuZGVyRHJhZygvLyB0cnV0aHkgaWYgcmVuZGVyZWQgc29tZXRoaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50LmV2ZW50UmFuZ2VzVG9FdmVudEZvb3RwcmludHMobXV0YXRlZEV2ZW50SW5zdGFuY2VHcm91cC5zbGljZVJlbmRlclJhbmdlcyhjb21wb25lbnQuZGF0ZVByb2ZpbGUucmVuZGVyVW56b25lZFJhbmdlLCBjYWxlbmRhcikpLCBzZWcsIGRyYWdMaXN0ZW5lci5pc1RvdWNoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuaGlkZSgpOyAvLyBpZiB0aGUgc3ViY2xhc3MgaXMgYWxyZWFkeSB1c2luZyBhIG1vY2sgZXZlbnQgXCJoZWxwZXJcIiwgaGlkZSBvdXIgb3duXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBtb3VzZUZvbGxvd2VyLnNob3coKTsgLy8gb3RoZXJ3aXNlLCBoYXZlIHRoZSBoZWxwZXIgZm9sbG93IHRoZSBtb3VzZSAobm8gc25hcHBpbmcpXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPcmlnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbmVlZHMgdG8gaGF2ZSBtb3ZlZCBoaXRzIHRvIGJlIGEgdmFsaWQgZHJvcFxyXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXRPdXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZpZXcudW5yZW5kZXJEcmFnKHNlZyk7IC8vIHVucmVuZGVyIHdoYXRldmVyIHdhcyBkb25lIGluIHJlbmRlckRyYWdcclxuICAgICAgICAgICAgICAgIG1vdXNlRm9sbG93ZXIuc2hvdygpOyAvLyBzaG93IGluIGNhc2Ugd2UgYXJlIG1vdmluZyBvdXQgb2YgYWxsIGhpdHNcclxuICAgICAgICAgICAgICAgIGV2ZW50RGVmTXV0YXRpb24gPSBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXREb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsXzEuZW5hYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWcuY29tcG9uZW50OyAvLyBwcmV2ZW50IHNpZGUgZWZmZWN0c1xyXG4gICAgICAgICAgICAgICAgLy8gZG8gcmV2ZXJ0IGFuaW1hdGlvbiBpZiBoYXNuJ3QgY2hhbmdlZC4gY2FsbHMgYSBjYWxsYmFjayB3aGVuIGZpbmlzaGVkICh3aGV0aGVyIGFuaW1hdGlvbiBvciBub3QpXHJcbiAgICAgICAgICAgICAgICBtb3VzZUZvbGxvd2VyLnN0b3AoIWV2ZW50RGVmTXV0YXRpb24sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3LnVucmVuZGVyRHJhZyhzZWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZWdEcmFnU3RvcChzZWcsIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdmlldy5zaG93RXZlbnRzV2l0aElkKHNlZy5mb290cHJpbnQuZXZlbnREZWYuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudERlZk11dGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcmUtc2hvdyBvcmlnaW5hbCwgd2lsbCByZXJlbmRlciBhbGwgYW55d2F5cy4gZXNwIGltcG9ydGFudCBpZiBldmVudFJlbmRlcldhaXRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5yZXBvcnRFdmVudERyb3AoZXZlbnRJbnN0YW5jZSwgZXZlbnREZWZNdXRhdGlvbiwgZWwsIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmRyYWdMaXN0ZW5lciA9IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gZHJhZ0xpc3RlbmVyO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCBiZWZvcmUgZXZlbnQgc2VnbWVudCBkcmFnZ2luZyBzdGFydHNcclxuICAgIEV2ZW50RHJhZ2dpbmcucHJvdG90eXBlLnNlZ0RyYWdTdGFydCA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5wdWJsaWNseVRyaWdnZXIoJ2V2ZW50RHJhZ1N0YXJ0Jywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIENhbGxlZCBhZnRlciBldmVudCBzZWdtZW50IGRyYWdnaW5nIHN0b3BzXHJcbiAgICBFdmVudERyYWdnaW5nLnByb3RvdHlwZS5zZWdEcmFnU3RvcCA9IGZ1bmN0aW9uIChzZWcsIGV2KSB7XHJcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnQucHVibGljbHlUcmlnZ2VyKCdldmVudERyYWdTdG9wJywge1xyXG4gICAgICAgICAgICBjb250ZXh0OiBzZWcuZWxbMF0sXHJcbiAgICAgICAgICAgIGFyZ3M6IFtcclxuICAgICAgICAgICAgICAgIHNlZy5mb290cHJpbnQuZ2V0RXZlbnRMZWdhY3koKSxcclxuICAgICAgICAgICAgICAgIGV2LFxyXG4gICAgICAgICAgICAgICAge30sXHJcbiAgICAgICAgICAgICAgICB0aGlzLnZpZXdcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vIERPRVMgTk9UIGNvbnNpZGVyIG92ZXJsYXAvY29uc3RyYWludFxyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuY29tcHV0ZUV2ZW50RHJvcE11dGF0aW9uID0gZnVuY3Rpb24gKHN0YXJ0Rm9vdHByaW50LCBlbmRGb290cHJpbnQsIGV2ZW50RGVmKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmTXV0YXRpb24gPSBuZXcgRXZlbnREZWZNdXRhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICBldmVudERlZk11dGF0aW9uLnNldERhdGVNdXRhdGlvbih0aGlzLmNvbXB1dGVFdmVudERhdGVNdXRhdGlvbihzdGFydEZvb3RwcmludCwgZW5kRm9vdHByaW50KSk7XHJcbiAgICAgICAgcmV0dXJuIGV2ZW50RGVmTXV0YXRpb247XHJcbiAgICB9O1xyXG4gICAgRXZlbnREcmFnZ2luZy5wcm90b3R5cGUuY29tcHV0ZUV2ZW50RGF0ZU11dGF0aW9uID0gZnVuY3Rpb24gKHN0YXJ0Rm9vdHByaW50LCBlbmRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgZGF0ZTAgPSBzdGFydEZvb3RwcmludC51bnpvbmVkUmFuZ2UuZ2V0U3RhcnQoKTtcclxuICAgICAgICB2YXIgZGF0ZTEgPSBlbmRGb290cHJpbnQudW56b25lZFJhbmdlLmdldFN0YXJ0KCk7XHJcbiAgICAgICAgdmFyIGNsZWFyRW5kID0gZmFsc2U7XHJcbiAgICAgICAgdmFyIGZvcmNlVGltZWQgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZm9yY2VBbGxEYXkgPSBmYWxzZTtcclxuICAgICAgICB2YXIgZGF0ZURlbHRhO1xyXG4gICAgICAgIHZhciBkYXRlTXV0YXRpb247XHJcbiAgICAgICAgaWYgKHN0YXJ0Rm9vdHByaW50LmlzQWxsRGF5ICE9PSBlbmRGb290cHJpbnQuaXNBbGxEYXkpIHtcclxuICAgICAgICAgICAgY2xlYXJFbmQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAoZW5kRm9vdHByaW50LmlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgICAgICBmb3JjZUFsbERheSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBkYXRlMC5zdHJpcFRpbWUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGZvcmNlVGltZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGVEZWx0YSA9IHRoaXMuY29tcG9uZW50LmRpZmZEYXRlcyhkYXRlMSwgZGF0ZTApO1xyXG4gICAgICAgIGRhdGVNdXRhdGlvbiA9IG5ldyBFdmVudERlZkRhdGVNdXRhdGlvbl8xLmRlZmF1bHQoKTtcclxuICAgICAgICBkYXRlTXV0YXRpb24uY2xlYXJFbmQgPSBjbGVhckVuZDtcclxuICAgICAgICBkYXRlTXV0YXRpb24uZm9yY2VUaW1lZCA9IGZvcmNlVGltZWQ7XHJcbiAgICAgICAgZGF0ZU11dGF0aW9uLmZvcmNlQWxsRGF5ID0gZm9yY2VBbGxEYXk7XHJcbiAgICAgICAgZGF0ZU11dGF0aW9uLnNldERhdGVEZWx0YShkYXRlRGVsdGEpO1xyXG4gICAgICAgIHJldHVybiBkYXRlTXV0YXRpb247XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50RHJhZ2dpbmc7XHJcbn0oSW50ZXJhY3Rpb25fMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEV2ZW50RHJhZ2dpbmc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDIzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBIaXREcmFnTGlzdGVuZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xyXG52YXIgQ29tcG9uZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxudmFyIERhdGVTZWxlY3RpbmcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEYXRlU2VsZWN0aW5nLCBfc3VwZXIpO1xyXG4gICAgLypcclxuICAgIGNvbXBvbmVudCBtdXN0IGltcGxlbWVudDpcclxuICAgICAgLSBiaW5kRGF0ZUhhbmRsZXJUb0VsXHJcbiAgICAgIC0gZ2V0U2FmZUhpdEZvb3RwcmludFxyXG4gICAgICAtIHJlbmRlckhpZ2hsaWdodFxyXG4gICAgICAtIHVucmVuZGVySGlnaGxpZ2h0XHJcbiAgICAqL1xyXG4gICAgZnVuY3Rpb24gRGF0ZVNlbGVjdGluZyhjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZHJhZ0xpc3RlbmVyID0gX3RoaXMuYnVpbGREcmFnTGlzdGVuZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5kcmFnTGlzdGVuZXIuZW5kSW50ZXJhY3Rpb24oKTtcclxuICAgIH07XHJcbiAgICBEYXRlU2VsZWN0aW5nLnByb3RvdHlwZS5nZXREZWxheSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLm9wdCgnc2VsZWN0TG9uZ1ByZXNzRGVsYXknKTtcclxuICAgICAgICBpZiAoZGVsYXkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBkZWxheSA9IHRoaXMub3B0KCdsb25nUHJlc3NEZWxheScpOyAvLyBmYWxsYmFja1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGVsYXk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuYmluZFRvRWwgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudDtcclxuICAgICAgICB2YXIgZHJhZ0xpc3RlbmVyID0gdGhpcy5kcmFnTGlzdGVuZXI7XHJcbiAgICAgICAgY29tcG9uZW50LmJpbmREYXRlSGFuZGxlclRvRWwoZWwsICdtb3VzZWRvd24nLCBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICAgICAgaWYgKF90aGlzLm9wdCgnc2VsZWN0YWJsZScpICYmICFjb21wb25lbnQuc2hvdWxkSWdub3JlTW91c2UoKSkge1xyXG4gICAgICAgICAgICAgICAgZHJhZ0xpc3RlbmVyLnN0YXJ0SW50ZXJhY3Rpb24oZXYsIHtcclxuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTogX3RoaXMub3B0KCdzZWxlY3RNaW5EaXN0YW5jZScpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kRGF0ZUhhbmRsZXJUb0VsKGVsLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0KCdzZWxlY3RhYmxlJykgJiYgIWNvbXBvbmVudC5zaG91bGRJZ25vcmVUb3VjaCgpKSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnTGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldiwge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGF5OiBfdGhpcy5nZXREZWxheSgpXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHV0aWxfMS5wcmV2ZW50U2VsZWN0aW9uKGVsKTtcclxuICAgIH07XHJcbiAgICAvLyBDcmVhdGVzIGEgbGlzdGVuZXIgdGhhdCB0cmFja3MgdGhlIHVzZXIncyBkcmFnIGFjcm9zcyBkYXkgZWxlbWVudHMsIGZvciBkYXkgc2VsZWN0aW5nLlxyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuYnVpbGREcmFnTGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIHNlbGVjdGlvbkZvb3RwcmludDsgLy8gbnVsbCBpZiBpbnZhbGlkIHNlbGVjdGlvblxyXG4gICAgICAgIHZhciBkcmFnTGlzdGVuZXIgPSBuZXcgSGl0RHJhZ0xpc3RlbmVyXzEuZGVmYXVsdChjb21wb25lbnQsIHtcclxuICAgICAgICAgICAgc2Nyb2xsOiB0aGlzLm9wdCgnZHJhZ1Njcm9sbCcpLFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvblN0YXJ0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Gb290cHJpbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMudmlldy51bnNlbGVjdChldik7IC8vIHNpbmNlIHdlIGNvdWxkIGJlIHJlbmRlcmluZyBhIG5ldyBzZWxlY3Rpb24sIHdlIHdhbnQgdG8gY2xlYXIgYW55IG9sZCBvbmVcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgaGl0T3ZlcjogZnVuY3Rpb24gKGhpdCwgaXNPcmlnLCBvcmlnSGl0KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb3JpZ0hpdEZvb3RwcmludDtcclxuICAgICAgICAgICAgICAgIHZhciBoaXRGb290cHJpbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAob3JpZ0hpdCkgeyAvLyBjbGljayBuZWVkcyB0byBoYXZlIHN0YXJ0ZWQgb24gYSBoaXRcclxuICAgICAgICAgICAgICAgICAgICBvcmlnSGl0Rm9vdHByaW50ID0gY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQob3JpZ0hpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaGl0Rm9vdHByaW50ID0gY29tcG9uZW50LmdldFNhZmVIaXRGb290cHJpbnQoaGl0KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3JpZ0hpdEZvb3RwcmludCAmJiBoaXRGb290cHJpbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRm9vdHByaW50ID0gX3RoaXMuY29tcHV0ZVNlbGVjdGlvbihvcmlnSGl0Rm9vdHByaW50LCBoaXRGb290cHJpbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uRm9vdHByaW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50KHNlbGVjdGlvbkZvb3RwcmludCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNlbGVjdGlvbkZvb3RwcmludCA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXRpbF8xLmRpc2FibGVDdXJzb3IoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE91dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uRm9vdHByaW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudC51bnJlbmRlclNlbGVjdGlvbigpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBoaXREb25lOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB1dGlsXzEuZW5hYmxlQ3Vyc29yKCk7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uRW5kOiBmdW5jdGlvbiAoZXYsIGlzQ2FuY2VsbGVkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ2FuY2VsbGVkICYmIHNlbGVjdGlvbkZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBzZWxlY3Rpb24gd2lsbCBhbHJlYWR5IGhhdmUgYmVlbiByZW5kZXJlZC4ganVzdCByZXBvcnQgaXRcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3LnJlcG9ydFNlbGVjdGlvbihzZWxlY3Rpb25Gb290cHJpbnQsIGV2KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBkcmFnTGlzdGVuZXI7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gdGhlIGZpcnN0IGFuZCBsYXN0IGRhdGUtc3BhbnMgb2YgYSBzZWxlY3Rpb24sIHJldHVybnMgYW5vdGhlciBkYXRlLXNwYW4gb2JqZWN0LlxyXG4gICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgYW5kIHByb3ZpZGUgYWRkaXRpb25hbCBkYXRhIGluIHRoZSBzcGFuIG9iamVjdC4gV2lsbCBiZSBwYXNzZWQgdG8gcmVuZGVyU2VsZWN0aW9uRm9vdHByaW50KCkuXHJcbiAgICAvLyBXaWxsIHJldHVybiBmYWxzZSBpZiB0aGUgc2VsZWN0aW9uIGlzIGludmFsaWQgYW5kIHRoaXMgc2hvdWxkIGJlIGluZGljYXRlZCB0byB0aGUgdXNlci5cclxuICAgIC8vIFdpbGwgcmV0dXJuIG51bGwvdW5kZWZpbmVkIGlmIGEgc2VsZWN0aW9uIGludmFsaWQgYnV0IG5vIGVycm9yIHNob3VsZCBiZSByZXBvcnRlZC5cclxuICAgIERhdGVTZWxlY3RpbmcucHJvdG90eXBlLmNvbXB1dGVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZm9vdHByaW50MCwgZm9vdHByaW50MSkge1xyXG4gICAgICAgIHZhciB3aG9sZUZvb3RwcmludCA9IHRoaXMuY29tcHV0ZVNlbGVjdGlvbkZvb3RwcmludChmb290cHJpbnQwLCBmb290cHJpbnQxKTtcclxuICAgICAgICBpZiAod2hvbGVGb290cHJpbnQgJiYgIXRoaXMuaXNTZWxlY3Rpb25Gb290cHJpbnRBbGxvd2VkKHdob2xlRm9vdHByaW50KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB3aG9sZUZvb3RwcmludDtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiB0d28gc3BhbnMsIG11c3QgcmV0dXJuIHRoZSBjb21iaW5hdGlvbiBvZiB0aGUgdHdvLlxyXG4gICAgLy8gVE9ETzogZG8gdGhpcyBzZXBhcmF0aW9uIG9mIGNvbmNlcm5zIChjb21iaW5pbmcgVlMgdmFsaWRhdGlvbikgZm9yIGV2ZW50IGRuZC9yZXNpemUgdG9vLlxyXG4gICAgLy8gQXNzdW1lcyBib3RoIGZvb3RwcmludHMgYXJlIG5vbi1vcGVuLWVuZGVkLlxyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuY29tcHV0ZVNlbGVjdGlvbkZvb3RwcmludCA9IGZ1bmN0aW9uIChmb290cHJpbnQwLCBmb290cHJpbnQxKSB7XHJcbiAgICAgICAgdmFyIG1zID0gW1xyXG4gICAgICAgICAgICBmb290cHJpbnQwLnVuem9uZWRSYW5nZS5zdGFydE1zLFxyXG4gICAgICAgICAgICBmb290cHJpbnQwLnVuem9uZWRSYW5nZS5lbmRNcyxcclxuICAgICAgICAgICAgZm9vdHByaW50MS51bnpvbmVkUmFuZ2Uuc3RhcnRNcyxcclxuICAgICAgICAgICAgZm9vdHByaW50MS51bnpvbmVkUmFuZ2UuZW5kTXNcclxuICAgICAgICBdO1xyXG4gICAgICAgIG1zLnNvcnQodXRpbF8xLmNvbXBhcmVOdW1iZXJzKTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQobXNbMF0sIG1zWzNdKSwgZm9vdHByaW50MC5pc0FsbERheSk7XHJcbiAgICB9O1xyXG4gICAgRGF0ZVNlbGVjdGluZy5wcm90b3R5cGUuaXNTZWxlY3Rpb25Gb290cHJpbnRBbGxvd2VkID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5kYXRlUHJvZmlsZS52YWxpZFVuem9uZWRSYW5nZS5jb250YWluc1JhbmdlKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpICYmXHJcbiAgICAgICAgICAgIHRoaXMudmlldy5jYWxlbmRhci5jb25zdHJhaW50cy5pc1NlbGVjdGlvbkZvb3RwcmludEFsbG93ZWQoY29tcG9uZW50Rm9vdHByaW50KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGF0ZVNlbGVjdGluZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0ZVNlbGVjdGluZztcclxuXG5cbi8qKiovIH0pLFxuLyogMjM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgSGl0RHJhZ0xpc3RlbmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KTtcclxudmFyIEludGVyYWN0aW9uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxudmFyIERhdGVDbGlja2luZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERhdGVDbGlja2luZywgX3N1cGVyKTtcclxuICAgIC8qXHJcbiAgICBjb21wb25lbnQgbXVzdCBpbXBsZW1lbnQ6XHJcbiAgICAgIC0gYmluZERhdGVIYW5kbGVyVG9FbFxyXG4gICAgICAtIGdldFNhZmVIaXRGb290cHJpbnRcclxuICAgICAgLSBnZXRIaXRFbFxyXG4gICAgKi9cclxuICAgIGZ1bmN0aW9uIERhdGVDbGlja2luZyhjb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjb21wb25lbnQpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZHJhZ0xpc3RlbmVyID0gX3RoaXMuYnVpbGREcmFnTGlzdGVuZXIoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBEYXRlQ2xpY2tpbmcucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmRyYWdMaXN0ZW5lci5lbmRJbnRlcmFjdGlvbigpO1xyXG4gICAgfTtcclxuICAgIERhdGVDbGlja2luZy5wcm90b3R5cGUuYmluZFRvRWwgPSBmdW5jdGlvbiAoZWwpIHtcclxuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQ7XHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IHRoaXMuZHJhZ0xpc3RlbmVyO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kRGF0ZUhhbmRsZXJUb0VsKGVsLCAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgIGlmICghY29tcG9uZW50LnNob3VsZElnbm9yZU1vdXNlKCkpIHtcclxuICAgICAgICAgICAgICAgIGRyYWdMaXN0ZW5lci5zdGFydEludGVyYWN0aW9uKGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbXBvbmVudC5iaW5kRGF0ZUhhbmRsZXJUb0VsKGVsLCAndG91Y2hzdGFydCcsIGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudC5zaG91bGRJZ25vcmVUb3VjaCgpKSB7XHJcbiAgICAgICAgICAgICAgICBkcmFnTGlzdGVuZXIuc3RhcnRJbnRlcmFjdGlvbihldik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLyBDcmVhdGVzIGEgbGlzdGVuZXIgdGhhdCB0cmFja3MgdGhlIHVzZXIncyBkcmFnIGFjcm9zcyBkYXkgZWxlbWVudHMsIGZvciBkYXkgY2xpY2tpbmcuXHJcbiAgICBEYXRlQ2xpY2tpbmcucHJvdG90eXBlLmJ1aWxkRHJhZ0xpc3RlbmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBkYXlDbGlja0hpdDsgLy8gbnVsbCBpZiBpbnZhbGlkIGRheUNsaWNrXHJcbiAgICAgICAgdmFyIGRyYWdMaXN0ZW5lciA9IG5ldyBIaXREcmFnTGlzdGVuZXJfMS5kZWZhdWx0KGNvbXBvbmVudCwge1xyXG4gICAgICAgICAgICBzY3JvbGw6IHRoaXMub3B0KCdkcmFnU2Nyb2xsJyksXHJcbiAgICAgICAgICAgIGludGVyYWN0aW9uU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGRheUNsaWNrSGl0ID0gZHJhZ0xpc3RlbmVyLm9yaWdIaXQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE92ZXI6IGZ1bmN0aW9uIChoaXQsIGlzT3JpZywgb3JpZ0hpdCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdXNlciBkcmFnZ2VkIHRvIGFub3RoZXIgY2VsbCBhdCBhbnkgcG9pbnQsIGl0IGNhbiBubyBsb25nZXIgYmUgYSBkYXlDbGlja1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc09yaWcpIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXlDbGlja0hpdCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGhpdE91dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZGF5Q2xpY2tIaXQgPSBudWxsO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpbnRlcmFjdGlvbkVuZDogZnVuY3Rpb24gKGV2LCBpc0NhbmNlbGxlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNvbXBvbmVudEZvb3RwcmludDtcclxuICAgICAgICAgICAgICAgIGlmICghaXNDYW5jZWxsZWQgJiYgZGF5Q2xpY2tIaXQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGb290cHJpbnQgPSBjb21wb25lbnQuZ2V0U2FmZUhpdEZvb3RwcmludChkYXlDbGlja0hpdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy52aWV3LnRyaWdnZXJEYXlDbGljayhjb21wb25lbnRGb290cHJpbnQsIGNvbXBvbmVudC5nZXRIaXRFbChkYXlDbGlja0hpdCksIGV2KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBiZWNhdXNlIGRyYWdMaXN0ZW5lciB3b24ndCBiZSBjYWxsZWQgd2l0aCBhbnkgdGltZSBkZWxheSwgXCJkcmFnZ2luZ1wiIHdpbGwgYmVnaW4gaW1tZWRpYXRlbHksXHJcbiAgICAgICAgLy8gd2hpY2ggd2lsbCBraWxsIGFueSB0b3VjaG1vdmluZy9zY3JvbGxpbmcuIFByZXZlbnQgdGhpcy5cclxuICAgICAgICBkcmFnTGlzdGVuZXIuc2hvdWxkQ2FuY2VsVG91Y2hTY3JvbGwgPSBmYWxzZTtcclxuICAgICAgICBkcmFnTGlzdGVuZXIuc2Nyb2xsQWx3YXlzS2lsbHMgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBkcmFnTGlzdGVuZXI7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERhdGVDbGlja2luZztcclxufShJbnRlcmFjdGlvbl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0ZUNsaWNraW5nO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgU2Nyb2xsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xyXG52YXIgVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XHJcbnZhciBUaW1lR3JpZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMzkpO1xyXG52YXIgRGF5R3JpZF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nik7XHJcbnZhciBBR0VOREFfQUxMX0RBWV9FVkVOVF9MSU1JVCA9IDU7XHJcbnZhciBhZ2VuZGFUaW1lR3JpZE1ldGhvZHM7XHJcbnZhciBhZ2VuZGFEYXlHcmlkTWV0aG9kcztcclxuLyogQW4gYWJzdHJhY3QgY2xhc3MgZm9yIGFsbCBhZ2VuZGEtcmVsYXRlZCB2aWV3cy4gRGlzcGxheXMgb25lIG1vcmUgY29sdW1ucyB3aXRoIHRpbWUgc2xvdHMgcnVubmluZyB2ZXJ0aWNhbGx5LlxyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gSXMgYSBtYW5hZ2VyIGZvciB0aGUgVGltZUdyaWQgc3ViY29tcG9uZW50IGFuZCBwb3NzaWJseSB0aGUgRGF5R3JpZCBzdWJjb21wb25lbnQgKGlmIGFsbERheVNsb3QgaXMgb24pLlxyXG4vLyBSZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgd2lkdGgvaGVpZ2h0LlxyXG52YXIgQWdlbmRhVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEFnZW5kYVZpZXcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBBZ2VuZGFWaWV3KGNhbGVuZGFyLCB2aWV3U3BlYykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNhbGVuZGFyLCB2aWV3U3BlYykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy51c2VzTWluTWF4VGltZSA9IHRydWU7IC8vIGluZGljYXRlcyB0aGF0IG1pblRpbWUvbWF4VGltZSBhZmZlY3RzIHJlbmRlcmluZ1xyXG4gICAgICAgIF90aGlzLnRpbWVHcmlkID0gX3RoaXMuaW5zdGFudGlhdGVUaW1lR3JpZCgpO1xyXG4gICAgICAgIF90aGlzLmFkZENoaWxkKF90aGlzLnRpbWVHcmlkKTtcclxuICAgICAgICBpZiAoX3RoaXMub3B0KCdhbGxEYXlTbG90JykpIHsgLy8gc2hvdWxkIHdlIGRpc3BsYXkgdGhlIFwiYWxsLWRheVwiIGFyZWE/XHJcbiAgICAgICAgICAgIF90aGlzLmRheUdyaWQgPSBfdGhpcy5pbnN0YW50aWF0ZURheUdyaWQoKTsgLy8gdGhlIGFsbC1kYXkgc3ViY29tcG9uZW50IG9mIHRoaXMgdmlld1xyXG4gICAgICAgICAgICBfdGhpcy5hZGRDaGlsZChfdGhpcy5kYXlHcmlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgX3RoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsZXJfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcclxuICAgICAgICAgICAgb3ZlcmZsb3dZOiAnYXV0bydcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBJbnN0YW50aWF0ZXMgdGhlIFRpbWVHcmlkIG9iamVjdCB0aGlzIHZpZXcgbmVlZHMuIERyYXdzIGZyb20gdGhpcy50aW1lR3JpZENsYXNzXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5pbnN0YW50aWF0ZVRpbWVHcmlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aW1lR3JpZCA9IG5ldyB0aGlzLnRpbWVHcmlkQ2xhc3ModGhpcyk7XHJcbiAgICAgICAgdXRpbF8xLmNvcHlPd25Qcm9wcyhhZ2VuZGFUaW1lR3JpZE1ldGhvZHMsIHRpbWVHcmlkKTtcclxuICAgICAgICByZXR1cm4gdGltZUdyaWQ7XHJcbiAgICB9O1xyXG4gICAgLy8gSW5zdGFudGlhdGVzIHRoZSBEYXlHcmlkIG9iamVjdCB0aGlzIHZpZXcgbWlnaHQgbmVlZC4gRHJhd3MgZnJvbSB0aGlzLmRheUdyaWRDbGFzc1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuaW5zdGFudGlhdGVEYXlHcmlkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBkYXlHcmlkID0gbmV3IHRoaXMuZGF5R3JpZENsYXNzKHRoaXMpO1xyXG4gICAgICAgIHV0aWxfMS5jb3B5T3duUHJvcHMoYWdlbmRhRGF5R3JpZE1ldGhvZHMsIGRheUdyaWQpO1xyXG4gICAgICAgIHJldHVybiBkYXlHcmlkO1xyXG4gICAgfTtcclxuICAgIC8qIFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0aW1lR3JpZFdyYXBFbDtcclxuICAgICAgICB2YXIgdGltZUdyaWRFbDtcclxuICAgICAgICB0aGlzLmVsLmFkZENsYXNzKCdmYy1hZ2VuZGEtdmlldycpLmh0bWwodGhpcy5yZW5kZXJTa2VsZXRvbkh0bWwoKSk7XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5yZW5kZXIoKTtcclxuICAgICAgICB0aW1lR3JpZFdyYXBFbCA9IHRoaXMuc2Nyb2xsZXIuZWwuYWRkQ2xhc3MoJ2ZjLXRpbWUtZ3JpZC1jb250YWluZXInKTtcclxuICAgICAgICB0aW1lR3JpZEVsID0gJCgnPGRpdiBjbGFzcz1cImZjLXRpbWUtZ3JpZFwiPicpLmFwcGVuZFRvKHRpbWVHcmlkV3JhcEVsKTtcclxuICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy1ib2R5ID4gdHIgPiB0ZCcpLmFwcGVuZCh0aW1lR3JpZFdyYXBFbCk7XHJcbiAgICAgICAgdGhpcy50aW1lR3JpZC5oZWFkQ29udGFpbmVyRWwgPSB0aGlzLmVsLmZpbmQoJy5mYy1oZWFkLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMudGltZUdyaWQuc2V0RWxlbWVudCh0aW1lR3JpZEVsKTtcclxuICAgICAgICBpZiAodGhpcy5kYXlHcmlkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5zZXRFbGVtZW50KHRoaXMuZWwuZmluZCgnLmZjLWRheS1ncmlkJykpO1xyXG4gICAgICAgICAgICAvLyBoYXZlIHRoZSBkYXktZ3JpZCBleHRlbmQgaXQncyBjb29yZGluYXRlIGFyZWEgb3ZlciB0aGUgPGhyPiBkaXZpZGluZyB0aGUgdHdvIGdyaWRzXHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5ib3R0b21Db29yZFBhZGRpbmcgPSB0aGlzLmRheUdyaWQuZWwubmV4dCgnaHInKS5vdXRlckhlaWdodCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS51bnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudGltZUdyaWQucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnJlbW92ZUVsZW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5kZXN0cm95KCk7XHJcbiAgICB9O1xyXG4gICAgLy8gQnVpbGRzIHRoZSBIVE1MIHNrZWxldG9uIGZvciB0aGUgdmlldy5cclxuICAgIC8vIFRoZSBkYXktZ3JpZCBhbmQgdGltZS1ncmlkIGNvbXBvbmVudHMgd2lsbCByZW5kZXIgaW5zaWRlIGNvbnRhaW5lcnMgZGVmaW5lZCBieSB0aGlzIEhUTUwuXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbkh0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICByZXR1cm4gJycgK1xyXG4gICAgICAgICAgICAnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMub3B0KCdjb2x1bW5IZWFkZXInKSA/XHJcbiAgICAgICAgICAgICAgICAnPHRoZWFkIGNsYXNzPVwiZmMtaGVhZFwiPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWhlYWQtY29udGFpbmVyICcgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCI+Jm5ic3A7PC90ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90cj4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90aGVhZD4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8dGJvZHkgY2xhc3M9XCJmYy1ib2R5XCI+JyArXHJcbiAgICAgICAgICAgICc8dHI+JyArXHJcbiAgICAgICAgICAgICc8dGQgY2xhc3M9XCInICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMuZGF5R3JpZCA/XHJcbiAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWRheS1ncmlkXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxociBjbGFzcz1cImZjLWRpdmlkZXIgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIj48L2hyPicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzwvdGQ+JyArXHJcbiAgICAgICAgICAgICc8L3RyPicgK1xyXG4gICAgICAgICAgICAnPC90Ym9keT4nICtcclxuICAgICAgICAgICAgJzwvdGFibGU+JztcclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgYW4gSFRNTCBhdHRyaWJ1dGUgc3RyaW5nIGZvciBzZXR0aW5nIHRoZSB3aWR0aCBvZiB0aGUgYXhpcywgaWYgaXQgaXMga25vd25cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmF4aXNTdHlsZUF0dHIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXhpc1dpZHRoICE9IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuICdzdHlsZT1cIndpZHRoOicgKyB0aGlzLmF4aXNXaWR0aCArICdweFwiJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfTtcclxuICAgIC8qIE5vdyBJbmRpY2F0b3JcclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5nZXROb3dJbmRpY2F0b3JVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRpbWVHcmlkLmdldE5vd0luZGljYXRvclVuaXQoKTtcclxuICAgIH07XHJcbiAgICAvKiBEaW1lbnNpb25zXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQWRqdXN0cyB0aGUgdmVydGljYWwgZGltZW5zaW9ucyBvZiB0aGUgdmlldyB0byB0aGUgc3BlY2lmaWVkIHZhbHVlc1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSkge1xyXG4gICAgICAgIHZhciBldmVudExpbWl0O1xyXG4gICAgICAgIHZhciBzY3JvbGxlckhlaWdodDtcclxuICAgICAgICB2YXIgc2Nyb2xsYmFyV2lkdGhzO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlU2l6ZS5jYWxsKHRoaXMsIHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKTtcclxuICAgICAgICAvLyBtYWtlIGFsbCBheGlzIGNlbGxzIGxpbmUgdXAsIGFuZCByZWNvcmQgdGhlIHdpZHRoIHNvIG5ld2x5IGNyZWF0ZWQgYXhpcyBjZWxscyB3aWxsIGhhdmUgaXRcclxuICAgICAgICB0aGlzLmF4aXNXaWR0aCA9IHV0aWxfMS5tYXRjaENlbGxXaWR0aHModGhpcy5lbC5maW5kKCcuZmMtYXhpcycpKTtcclxuICAgICAgICAvLyBoYWNrIHRvIGdpdmUgdGhlIHZpZXcgc29tZSBoZWlnaHQgcHJpb3IgdG8gdGltZUdyaWQncyBjb2x1bW5zIGJlaW5nIHJlbmRlcmVkXHJcbiAgICAgICAgLy8gVE9ETzogc2VwYXJhdGUgc2V0dGluZyBoZWlnaHQgZnJvbSBzY3JvbGxlciBWUyB0aW1lR3JpZC5cclxuICAgICAgICBpZiAoIXRoaXMudGltZUdyaWQuY29sRWxzKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNBdXRvKSB7XHJcbiAgICAgICAgICAgICAgICBzY3JvbGxlckhlaWdodCA9IHRoaXMuY29tcHV0ZVNjcm9sbGVySGVpZ2h0KHRvdGFsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIuc2V0SGVpZ2h0KHNjcm9sbGVySGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNldCBvZiBmYWtlIHJvdyBlbGVtZW50cyB0aGF0IG11c3QgY29tcGVuc2F0ZSB3aGVuIHNjcm9sbGVyIGhhcyBzY3JvbGxiYXJzXHJcbiAgICAgICAgdmFyIG5vU2Nyb2xsUm93RWxzID0gdGhpcy5lbC5maW5kKCcuZmMtcm93Om5vdCguZmMtc2Nyb2xsZXIgKiknKTtcclxuICAgICAgICAvLyByZXNldCBhbGwgZGltZW5zaW9ucyBiYWNrIHRvIHRoZSBvcmlnaW5hbCBzdGF0ZVxyXG4gICAgICAgIHRoaXMudGltZUdyaWQuYm90dG9tUnVsZUVsLmhpZGUoKTsgLy8gLnNob3coKSB3aWxsIGJlIGNhbGxlZCBsYXRlciBpZiB0aGlzIDxocj4gaXMgbmVjZXNzYXJ5XHJcbiAgICAgICAgdGhpcy5zY3JvbGxlci5jbGVhcigpOyAvLyBzZXRzIGhlaWdodCB0byAnYXV0bycgYW5kIGNsZWFycyBvdmVyZmxvd1xyXG4gICAgICAgIHV0aWxfMS51bmNvbXBlbnNhdGVTY3JvbGwobm9TY3JvbGxSb3dFbHMpO1xyXG4gICAgICAgIC8vIGxpbWl0IG51bWJlciBvZiBldmVudHMgaW4gdGhlIGFsbC1kYXkgYXJlYVxyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnJlbW92ZVNlZ1BvcG92ZXIoKTsgLy8ga2lsbCB0aGUgXCJtb3JlXCIgcG9wb3ZlciBpZiBkaXNwbGF5ZWRcclxuICAgICAgICAgICAgZXZlbnRMaW1pdCA9IHRoaXMub3B0KCdldmVudExpbWl0Jyk7XHJcbiAgICAgICAgICAgIGlmIChldmVudExpbWl0ICYmIHR5cGVvZiBldmVudExpbWl0ICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRMaW1pdCA9IEFHRU5EQV9BTExfREFZX0VWRU5UX0xJTUlUOyAvLyBtYWtlIHN1cmUgXCJhdXRvXCIgZ29lcyB0byBhIHJlYWwgbnVtYmVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGV2ZW50TGltaXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5saW1pdFJvd3MoZXZlbnRMaW1pdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc0F1dG8pIHsgLy8gc2hvdWxkIHdlIGZvcmNlIGRpbWVuc2lvbnMgb2YgdGhlIHNjcm9sbCBjb250YWluZXI/XHJcbiAgICAgICAgICAgIHNjcm9sbGVySGVpZ2h0ID0gdGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgIHNjcm9sbGJhcldpZHRocyA9IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsYmFyV2lkdGhzKCk7XHJcbiAgICAgICAgICAgIGlmIChzY3JvbGxiYXJXaWR0aHMubGVmdCB8fCBzY3JvbGxiYXJXaWR0aHMucmlnaHQpIHsgLy8gdXNpbmcgc2Nyb2xsYmFycz9cclxuICAgICAgICAgICAgICAgIC8vIG1ha2UgdGhlIGFsbC1kYXkgYW5kIGhlYWRlciByb3dzIGxpbmVzIHVwXHJcbiAgICAgICAgICAgICAgICB1dGlsXzEuY29tcGVuc2F0ZVNjcm9sbChub1Njcm9sbFJvd0Vscywgc2Nyb2xsYmFyV2lkdGhzKTtcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBzY3JvbGxiYXIgY29tcGVuc2F0aW9uIG1pZ2h0IGhhdmUgY2hhbmdlZCB0ZXh0IGZsb3csIHdoaWNoIG1pZ2h0IGFmZmVjdCBoZWlnaHQsIHNvIHJlY2FsY3VsYXRlXHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgcmVhcHBseSB0aGUgZGVzaXJlZCBoZWlnaHQgdG8gdGhlIHNjcm9sbGVyLlxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJIZWlnaHQgPSB0aGlzLmNvbXB1dGVTY3JvbGxlckhlaWdodCh0b3RhbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldEhlaWdodChzY3JvbGxlckhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gZ3VhcmFudGVlcyB0aGUgc2FtZSBzY3JvbGxiYXIgd2lkdGhzXHJcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsZXIubG9ja092ZXJmbG93KHNjcm9sbGJhcldpZHRocyk7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYW55IHNwYWNlIGJlbG93IHRoZSBzbGF0cywgc2hvdyB0aGUgaG9yaXpvbnRhbCBydWxlLlxyXG4gICAgICAgICAgICAvLyB0aGlzIHdvbid0IGNhdXNlIGFueSBuZXcgb3ZlcmZsb3csIGJlY2F1c2UgbG9ja092ZXJmbG93IGFscmVhZHkgY2FsbGVkLlxyXG4gICAgICAgICAgICBpZiAodGhpcy50aW1lR3JpZC5nZXRUb3RhbFNsYXRIZWlnaHQoKSA8IHNjcm9sbGVySGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVHcmlkLmJvdHRvbVJ1bGVFbC5zaG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gZ2l2ZW4gYSBkZXNpcmVkIHRvdGFsIGhlaWdodCBvZiB0aGUgdmlldywgcmV0dXJucyB3aGF0IHRoZSBoZWlnaHQgb2YgdGhlIHNjcm9sbGVyIHNob3VsZCBiZVxyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUuY29tcHV0ZVNjcm9sbGVySGVpZ2h0ID0gZnVuY3Rpb24gKHRvdGFsSGVpZ2h0KSB7XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsSGVpZ2h0IC1cclxuICAgICAgICAgICAgdXRpbF8xLnN1YnRyYWN0SW5uZXJFbEhlaWdodCh0aGlzLmVsLCB0aGlzLnNjcm9sbGVyLmVsKTsgLy8gZXZlcnl0aGluZyB0aGF0J3MgTk9UIHRoZSBzY3JvbGxlclxyXG4gICAgfTtcclxuICAgIC8qIFNjcm9sbFxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIENvbXB1dGVzIHRoZSBpbml0aWFsIHByZS1jb25maWd1cmVkIHNjcm9sbCBzdGF0ZSBwcmlvciB0byBhbGxvd2luZyB0aGUgdXNlciB0byBjaGFuZ2UgaXRcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmNvbXB1dGVJbml0aWFsRGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2Nyb2xsVGltZSA9IG1vbWVudC5kdXJhdGlvbih0aGlzLm9wdCgnc2Nyb2xsVGltZScpKTtcclxuICAgICAgICB2YXIgdG9wID0gdGhpcy50aW1lR3JpZC5jb21wdXRlVGltZVRvcChzY3JvbGxUaW1lKTtcclxuICAgICAgICAvLyB6b29tIGNhbiBnaXZlIHdlaXJkIGZsb2F0aW5nLXBvaW50IHZhbHVlcy4gcmF0aGVyIHNjcm9sbCBhIGxpdHRsZSBiaXQgZnVydGhlclxyXG4gICAgICAgIHRvcCA9IE1hdGguY2VpbCh0b3ApO1xyXG4gICAgICAgIGlmICh0b3ApIHtcclxuICAgICAgICAgICAgdG9wKys7IC8vIHRvIG92ZXJjb21lIHRvcCBib3JkZXIgdGhhdCBzbG90cyBiZXlvbmQgdGhlIGZpcnN0IGhhdmUuIGxvb2tzIGJldHRlclxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyB0b3A6IHRvcCB9O1xyXG4gICAgfTtcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLnF1ZXJ5RGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4geyB0b3A6IHRoaXMuc2Nyb2xsZXIuZ2V0U2Nyb2xsVG9wKCkgfTtcclxuICAgIH07XHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5hcHBseURhdGVTY3JvbGwgPSBmdW5jdGlvbiAoc2Nyb2xsKSB7XHJcbiAgICAgICAgaWYgKHNjcm9sbC50b3AgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLnNjcm9sbGVyLnNldFNjcm9sbFRvcChzY3JvbGwudG9wKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogSGl0IEFyZWFzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gZm9yd2FyZCBhbGwgaGl0LXJlbGF0ZWQgbWV0aG9kIGNhbGxzIHRvIHRoZSBncmlkcyAoZGF5R3JpZCBtaWdodCBub3QgYmUgZGVmaW5lZClcclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmdldEhpdEZvb3RwcmludCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICAvLyBUT0RPOiBoaXQuY29tcG9uZW50IGlzIHNldCBhcyBhIGhhY2sgdG8gaWRlbnRpZnkgd2hlcmUgdGhlIGhpdCBjYW1lIGZyb21cclxuICAgICAgICByZXR1cm4gaGl0LmNvbXBvbmVudC5nZXRIaXRGb290cHJpbnQoaGl0KTtcclxuICAgIH07XHJcbiAgICBBZ2VuZGFWaWV3LnByb3RvdHlwZS5nZXRIaXRFbCA9IGZ1bmN0aW9uIChoaXQpIHtcclxuICAgICAgICAvLyBUT0RPOiBoaXQuY29tcG9uZW50IGlzIHNldCBhcyBhIGhhY2sgdG8gaWRlbnRpZnkgd2hlcmUgdGhlIGhpdCBjYW1lIGZyb21cclxuICAgICAgICByZXR1cm4gaGl0LmNvbXBvbmVudC5nZXRIaXRFbChoaXQpO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFJlbmRlcmluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIEFnZW5kYVZpZXcucHJvdG90eXBlLmV4ZWN1dGVFdmVudFJlbmRlciA9IGZ1bmN0aW9uIChldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgdmFyIGRheUV2ZW50c1BheWxvYWQgPSB7fTtcclxuICAgICAgICB2YXIgdGltZWRFdmVudHNQYXlsb2FkID0ge307XHJcbiAgICAgICAgdmFyIGlkO1xyXG4gICAgICAgIHZhciBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgLy8gc2VwYXJhdGUgdGhlIGV2ZW50cyBpbnRvIGFsbC1kYXkgYW5kIHRpbWVkXHJcbiAgICAgICAgZm9yIChpZCBpbiBldmVudHNQYXlsb2FkKSB7XHJcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VHcm91cCA9IGV2ZW50c1BheWxvYWRbaWRdO1xyXG4gICAgICAgICAgICBpZiAoZXZlbnRJbnN0YW5jZUdyb3VwLmdldEV2ZW50RGVmKCkuaXNBbGxEYXkoKSkge1xyXG4gICAgICAgICAgICAgICAgZGF5RXZlbnRzUGF5bG9hZFtpZF0gPSBldmVudEluc3RhbmNlR3JvdXA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lZEV2ZW50c1BheWxvYWRbaWRdID0gZXZlbnRJbnN0YW5jZUdyb3VwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudGltZUdyaWQuZXhlY3V0ZUV2ZW50UmVuZGVyKHRpbWVkRXZlbnRzUGF5bG9hZCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQuZXhlY3V0ZUV2ZW50UmVuZGVyKGRheUV2ZW50c1BheWxvYWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiBEcmFnZ2luZy9SZXNpemluZyBSb3V0aW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gQSByZXR1cm5lZCB2YWx1ZSBvZiBgdHJ1ZWAgc2lnbmFscyB0aGF0IGEgbW9jayBcImhlbHBlclwiIGV2ZW50IGhhcyBiZWVuIHJlbmRlcmVkLlxyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUucmVuZGVyRHJhZyA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHZhciBncm91cHMgPSBncm91cEV2ZW50Rm9vdHByaW50c0J5QWxsRGF5KGV2ZW50Rm9vdHByaW50cyk7XHJcbiAgICAgICAgdmFyIHJlbmRlcmVkSGVscGVyID0gZmFsc2U7XHJcbiAgICAgICAgcmVuZGVyZWRIZWxwZXIgPSB0aGlzLnRpbWVHcmlkLnJlbmRlckRyYWcoZ3JvdXBzLnRpbWVkLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgcmVuZGVyZWRIZWxwZXIgPSB0aGlzLmRheUdyaWQucmVuZGVyRHJhZyhncm91cHMuYWxsRGF5LCBzZWcsIGlzVG91Y2gpIHx8IHJlbmRlcmVkSGVscGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVuZGVyZWRIZWxwZXI7XHJcbiAgICB9O1xyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpIHtcclxuICAgICAgICB2YXIgZ3JvdXBzID0gZ3JvdXBFdmVudEZvb3RwcmludHNCeUFsbERheShldmVudEZvb3RwcmludHMpO1xyXG4gICAgICAgIHRoaXMudGltZUdyaWQucmVuZGVyRXZlbnRSZXNpemUoZ3JvdXBzLnRpbWVkLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgICAgIGlmICh0aGlzLmRheUdyaWQpIHtcclxuICAgICAgICAgICAgdGhpcy5kYXlHcmlkLnJlbmRlckV2ZW50UmVzaXplKGdyb3Vwcy5hbGxEYXksIHNlZywgaXNUb3VjaCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIFNlbGVjdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvblxyXG4gICAgQWdlbmRhVmlldy5wcm90b3R5cGUucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudEZvb3RwcmludCkge1xyXG4gICAgICAgIGlmICghY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGltZUdyaWQucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50KGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGF5R3JpZCkge1xyXG4gICAgICAgICAgICB0aGlzLmRheUdyaWQucmVuZGVyU2VsZWN0aW9uRm9vdHByaW50KGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBBZ2VuZGFWaWV3O1xyXG59KFZpZXdfMS5kZWZhdWx0KSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IEFnZW5kYVZpZXc7XHJcbkFnZW5kYVZpZXcucHJvdG90eXBlLnRpbWVHcmlkQ2xhc3MgPSBUaW1lR3JpZF8xLmRlZmF1bHQ7XHJcbkFnZW5kYVZpZXcucHJvdG90eXBlLmRheUdyaWRDbGFzcyA9IERheUdyaWRfMS5kZWZhdWx0O1xyXG4vLyBXaWxsIGN1c3RvbWl6ZSB0aGUgcmVuZGVyaW5nIGJlaGF2aW9yIG9mIHRoZSBBZ2VuZGFWaWV3J3MgdGltZUdyaWRcclxuYWdlbmRhVGltZUdyaWRNZXRob2RzID0ge1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgd2lsbCBnbyBiZWZvcmUgdGhlIGRheS1vZiB3ZWVrIGhlYWRlciBjZWxsc1xyXG4gICAgcmVuZGVySGVhZEludHJvSHRtbDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB2aWV3ID0gdGhpcy52aWV3O1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IHZpZXcuY2FsZW5kYXI7XHJcbiAgICAgICAgdmFyIHdlZWtTdGFydCA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQodGhpcy5kYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2Uuc3RhcnRNcywgdHJ1ZSk7XHJcbiAgICAgICAgdmFyIHdlZWtUZXh0O1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnd2Vla051bWJlcnMnKSkge1xyXG4gICAgICAgICAgICB3ZWVrVGV4dCA9IHdlZWtTdGFydC5mb3JtYXQodGhpcy5vcHQoJ3NtYWxsV2Vla0Zvcm1hdCcpKTtcclxuICAgICAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgICAgICc8dGggY2xhc3M9XCJmYy1heGlzIGZjLXdlZWstbnVtYmVyICcgKyBjYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykgKyAnXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz4nICtcclxuICAgICAgICAgICAgICAgIHZpZXcuYnVpbGRHb3RvQW5jaG9ySHRtbCgvLyBhc2lkZSBmcm9tIGxpbmssIGltcG9ydGFudCBmb3IgbWF0Y2hDZWxsV2lkdGhzXHJcbiAgICAgICAgICAgICAgICB7IGRhdGU6IHdlZWtTdGFydCwgdHlwZTogJ3dlZWsnLCBmb3JjZU9mZjogdGhpcy5jb2xDbnQgPiAxIH0sIHV0aWxfMS5odG1sRXNjYXBlKHdlZWtUZXh0KSAvLyBpbm5lciBIVE1MXHJcbiAgICAgICAgICAgICAgICApICtcclxuICAgICAgICAgICAgICAgICc8L3RoPic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gJzx0aCBjbGFzcz1cImZjLWF4aXMgJyArIGNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd3aWRnZXRIZWFkZXInKSArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGg+JztcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgdGhlIGJnIG9mIHRoZSBUaW1lR3JpZCBzbG90IGFyZWEuIExvbmcgdmVydGljYWwgY29sdW1uLlxyXG4gICAgcmVuZGVyQmdJbnRyb0h0bWw6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICByZXR1cm4gJzx0ZCBjbGFzcz1cImZjLWF4aXMgJyArIHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPjwvdGQ+JztcclxuICAgIH0sXHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSBhbGwgb3RoZXIgdHlwZXMgb2YgY2VsbHMuXHJcbiAgICAvLyBBZmZlY3RzIGNvbnRlbnQtc2tlbGV0b24sIGhlbHBlci1za2VsZXRvbiwgaGlnaGxpZ2h0LXNrZWxldG9uIGZvciBib3RoIHRoZSB0aW1lLWdyaWQgYW5kIGRheS1ncmlkLlxyXG4gICAgcmVuZGVySW50cm9IdG1sOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy1heGlzXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz48L3RkPic7XHJcbiAgICB9XHJcbn07XHJcbi8vIFdpbGwgY3VzdG9taXplIHRoZSByZW5kZXJpbmcgYmVoYXZpb3Igb2YgdGhlIEFnZW5kYVZpZXcncyBkYXlHcmlkXHJcbmFnZW5kYURheUdyaWRNZXRob2RzID0ge1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIHRoYXQgZ29lcyBiZWZvcmUgdGhlIGFsbC1kYXkgY2VsbHNcclxuICAgIHJlbmRlckJnSW50cm9IdG1sOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgcmV0dXJuICcnICtcclxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWF4aXMgJyArIHZpZXcuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPicgK1xyXG4gICAgICAgICAgICAnPHNwYW4+JyArIC8vIG5lZWRlZCBmb3IgbWF0Y2hDZWxsV2lkdGhzXHJcbiAgICAgICAgICAgIHZpZXcuZ2V0QWxsRGF5SHRtbCgpICtcclxuICAgICAgICAgICAgJzwvc3Bhbj4nICtcclxuICAgICAgICAgICAgJzwvdGQ+JztcclxuICAgIH0sXHJcbiAgICAvLyBHZW5lcmF0ZXMgdGhlIEhUTUwgdGhhdCBnb2VzIGJlZm9yZSBhbGwgb3RoZXIgdHlwZXMgb2YgY2VsbHMuXHJcbiAgICAvLyBBZmZlY3RzIGNvbnRlbnQtc2tlbGV0b24sIGhlbHBlci1za2VsZXRvbiwgaGlnaGxpZ2h0LXNrZWxldG9uIGZvciBib3RoIHRoZSB0aW1lLWdyaWQgYW5kIGRheS1ncmlkLlxyXG4gICAgcmVuZGVySW50cm9IdG1sOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgcmV0dXJuICc8dGQgY2xhc3M9XCJmYy1heGlzXCIgJyArIHZpZXcuYXhpc1N0eWxlQXR0cigpICsgJz48L3RkPic7XHJcbiAgICB9XHJcbn07XHJcbmZ1bmN0aW9uIGdyb3VwRXZlbnRGb290cHJpbnRzQnlBbGxEYXkoZXZlbnRGb290cHJpbnRzKSB7XHJcbiAgICB2YXIgYWxsRGF5ID0gW107XHJcbiAgICB2YXIgdGltZWQgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IGV2ZW50Rm9vdHByaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChldmVudEZvb3RwcmludHNbaV0uY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSB7XHJcbiAgICAgICAgICAgIGFsbERheS5wdXNoKGV2ZW50Rm9vdHByaW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aW1lZC5wdXNoKGV2ZW50Rm9vdHByaW50c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgYWxsRGF5OiBhbGxEYXksIHRpbWVkOiB0aW1lZCB9O1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDIzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgbW9tZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBJbnRlcmFjdGl2ZURhdGVDb21wb25lbnRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIpO1xyXG52YXIgQnVzaW5lc3NIb3VyUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xyXG52YXIgU3RhbmRhcmRJbnRlcmFjdGlvbnNNaXhpbl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NSk7XHJcbnZhciBEYXlUYWJsZU1peGluXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwKTtcclxudmFyIENvb3JkQ2FjaGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgQ29tcG9uZW50Rm9vdHByaW50XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcclxudmFyIFRpbWVHcmlkRXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDApO1xyXG52YXIgVGltZUdyaWRIZWxwZXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDEpO1xyXG52YXIgVGltZUdyaWRGaWxsUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQyKTtcclxuLyogQSBjb21wb25lbnQgdGhhdCByZW5kZXJzIG9uZSBvciBtb3JlIGNvbHVtbnMgb2YgdmVydGljYWwgdGltZSBzbG90c1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuLy8gV2UgbWl4aW4gRGF5VGFibGUsIGV2ZW4gdGhvdWdoIHRoZXJlIGlzIG9ubHkgYSBzaW5nbGUgcm93IG9mIGRheXNcclxuLy8gcG90ZW50aWFsIG5pY2UgdmFsdWVzIGZvciB0aGUgc2xvdC1kdXJhdGlvbiBhbmQgaW50ZXJ2YWwtZHVyYXRpb25cclxuLy8gZnJvbSBsYXJnZXN0IHRvIHNtYWxsZXN0XHJcbnZhciBBR0VOREFfU1RPQ0tfU1VCX0RVUkFUSU9OUyA9IFtcclxuICAgIHsgaG91cnM6IDEgfSxcclxuICAgIHsgbWludXRlczogMzAgfSxcclxuICAgIHsgbWludXRlczogMTUgfSxcclxuICAgIHsgc2Vjb25kczogMzAgfSxcclxuICAgIHsgc2Vjb25kczogMTUgfVxyXG5dO1xyXG52YXIgVGltZUdyaWQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUaW1lR3JpZCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbWVHcmlkKHZpZXcpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB2aWV3KSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnByb2Nlc3NPcHRpb25zKCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgLy8gU2xpY2VzIHVwIHRoZSBnaXZlbiBzcGFuICh1bnpvbmVkIHN0YXJ0L2VuZCB3aXRoIG90aGVyIG1pc2MgZGF0YSkgaW50byBhbiBhcnJheSBvZiBzZWdtZW50c1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmNvbXBvbmVudEZvb3RwcmludFRvU2VncyA9IGZ1bmN0aW9uIChjb21wb25lbnRGb290cHJpbnQpIHtcclxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZUJ5VGltZXMoY29tcG9uZW50Rm9vdHByaW50LnVuem9uZWRSYW5nZSk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNSVEwpIHtcclxuICAgICAgICAgICAgICAgIHNlZ3NbaV0uY29sID0gdGhpcy5kYXlzUGVyUm93IC0gMSAtIHNlZ3NbaV0uZGF5SW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZWdzW2ldLmNvbCA9IHNlZ3NbaV0uZGF5SW5kZXg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgLyogRGF0ZSBIYW5kbGluZ1xyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5zbGljZVJhbmdlQnlUaW1lcyA9IGZ1bmN0aW9uICh1bnpvbmVkUmFuZ2UpIHtcclxuICAgICAgICB2YXIgc2VncyA9IFtdO1xyXG4gICAgICAgIHZhciBzZWdSYW5nZTtcclxuICAgICAgICB2YXIgZGF5SW5kZXg7XHJcbiAgICAgICAgZm9yIChkYXlJbmRleCA9IDA7IGRheUluZGV4IDwgdGhpcy5kYXlzUGVyUm93OyBkYXlJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHNlZ1JhbmdlID0gdW56b25lZFJhbmdlLmludGVyc2VjdCh0aGlzLmRheVJhbmdlc1tkYXlJbmRleF0pO1xyXG4gICAgICAgICAgICBpZiAoc2VnUmFuZ2UpIHtcclxuICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRNczogc2VnUmFuZ2Uuc3RhcnRNcyxcclxuICAgICAgICAgICAgICAgICAgICBlbmRNczogc2VnUmFuZ2UuZW5kTXMsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnUmFuZ2UuaXNTdGFydCxcclxuICAgICAgICAgICAgICAgICAgICBpc0VuZDogc2VnUmFuZ2UuaXNFbmQsXHJcbiAgICAgICAgICAgICAgICAgICAgZGF5SW5kZXg6IGRheUluZGV4XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2VncztcclxuICAgIH07XHJcbiAgICAvKiBPcHRpb25zXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUGFyc2VzIHZhcmlvdXMgb3B0aW9ucyBpbnRvIHByb3BlcnRpZXMgb2YgdGhpcyBvYmplY3RcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5wcm9jZXNzT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2xvdER1cmF0aW9uID0gdGhpcy5vcHQoJ3Nsb3REdXJhdGlvbicpO1xyXG4gICAgICAgIHZhciBzbmFwRHVyYXRpb24gPSB0aGlzLm9wdCgnc25hcER1cmF0aW9uJyk7XHJcbiAgICAgICAgdmFyIGlucHV0O1xyXG4gICAgICAgIHNsb3REdXJhdGlvbiA9IG1vbWVudC5kdXJhdGlvbihzbG90RHVyYXRpb24pO1xyXG4gICAgICAgIHNuYXBEdXJhdGlvbiA9IHNuYXBEdXJhdGlvbiA/IG1vbWVudC5kdXJhdGlvbihzbmFwRHVyYXRpb24pIDogc2xvdER1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuc2xvdER1cmF0aW9uID0gc2xvdER1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuc25hcER1cmF0aW9uID0gc25hcER1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuc25hcHNQZXJTbG90ID0gc2xvdER1cmF0aW9uIC8gc25hcER1cmF0aW9uOyAvLyBUT0RPOiBlbnN1cmUgYW4gaW50ZWdlciBtdWx0aXBsZT9cclxuICAgICAgICAvLyBtaWdodCBiZSBhbiBhcnJheSB2YWx1ZSAoZm9yIFRpbWVsaW5lVmlldykuXHJcbiAgICAgICAgLy8gaWYgc28sIGdldHRpbmcgdGhlIG1vc3QgZ3JhbnVsYXIgZW50cnkgKHRoZSBsYXN0IG9uZSBwcm9iYWJseSkuXHJcbiAgICAgICAgaW5wdXQgPSB0aGlzLm9wdCgnc2xvdExhYmVsRm9ybWF0Jyk7XHJcbiAgICAgICAgaWYgKCQuaXNBcnJheShpbnB1dCkpIHtcclxuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dFtpbnB1dC5sZW5ndGggLSAxXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5sYWJlbEZvcm1hdCA9IGlucHV0IHx8XHJcbiAgICAgICAgICAgIHRoaXMub3B0KCdzbWFsbFRpbWVGb3JtYXQnKTsgLy8gdGhlIGNvbXB1dGVkIGRlZmF1bHRcclxuICAgICAgICBpbnB1dCA9IHRoaXMub3B0KCdzbG90TGFiZWxJbnRlcnZhbCcpO1xyXG4gICAgICAgIHRoaXMubGFiZWxJbnRlcnZhbCA9IGlucHV0ID9cclxuICAgICAgICAgICAgbW9tZW50LmR1cmF0aW9uKGlucHV0KSA6XHJcbiAgICAgICAgICAgIHRoaXMuY29tcHV0ZUxhYmVsSW50ZXJ2YWwoc2xvdER1cmF0aW9uKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhbiBhdXRvbWF0aWMgdmFsdWUgZm9yIHNsb3RMYWJlbEludGVydmFsXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuY29tcHV0ZUxhYmVsSW50ZXJ2YWwgPSBmdW5jdGlvbiAoc2xvdER1cmF0aW9uKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIGxhYmVsSW50ZXJ2YWw7XHJcbiAgICAgICAgdmFyIHNsb3RzUGVyTGFiZWw7XHJcbiAgICAgICAgLy8gZmluZCB0aGUgc21hbGxlc3Qgc3RvY2sgbGFiZWwgaW50ZXJ2YWwgdGhhdCByZXN1bHRzIGluIG1vcmUgdGhhbiBvbmUgc2xvdHMtcGVyLWxhYmVsXHJcbiAgICAgICAgZm9yIChpID0gQUdFTkRBX1NUT0NLX1NVQl9EVVJBVElPTlMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICAgICAgbGFiZWxJbnRlcnZhbCA9IG1vbWVudC5kdXJhdGlvbihBR0VOREFfU1RPQ0tfU1VCX0RVUkFUSU9OU1tpXSk7XHJcbiAgICAgICAgICAgIHNsb3RzUGVyTGFiZWwgPSB1dGlsXzEuZGl2aWRlRHVyYXRpb25CeUR1cmF0aW9uKGxhYmVsSW50ZXJ2YWwsIHNsb3REdXJhdGlvbik7XHJcbiAgICAgICAgICAgIGlmICh1dGlsXzEuaXNJbnQoc2xvdHNQZXJMYWJlbCkgJiYgc2xvdHNQZXJMYWJlbCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbEludGVydmFsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtb21lbnQuZHVyYXRpb24oc2xvdER1cmF0aW9uKTsgLy8gZmFsbCBiYWNrLiBjbG9uZVxyXG4gICAgfTtcclxuICAgIC8qIERhdGUgUmVuZGVyaW5nXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlckRhdGVzID0gZnVuY3Rpb24gKGRhdGVQcm9maWxlKSB7XHJcbiAgICAgICAgdGhpcy5kYXRlUHJvZmlsZSA9IGRhdGVQcm9maWxlO1xyXG4gICAgICAgIHRoaXMudXBkYXRlRGF5VGFibGUoKTtcclxuICAgICAgICB0aGlzLnJlbmRlclNsYXRzKCk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJDb2x1bW5zKCk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gdGhpcy51bnJlbmRlclNsYXRzKCk7IC8vIGRvbid0IG5lZWQgdGhpcyBiZWNhdXNlIHJlcGVhdGVkIC5odG1sKCkgY2FsbHMgY2xlYXJcclxuICAgICAgICB0aGlzLnVucmVuZGVyQ29sdW1ucygpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGhlbWUgPSB0aGlzLnZpZXcuY2FsZW5kYXIudGhlbWU7XHJcbiAgICAgICAgdGhpcy5lbC5odG1sKCc8ZGl2IGNsYXNzPVwiZmMtYmdcIj48L2Rpdj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1zbGF0c1wiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAnPGhyIGNsYXNzPVwiZmMtZGl2aWRlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldEhlYWRlcicpICsgJ1wiIHN0eWxlPVwiZGlzcGxheTpub25lXCI+PC9ocj4nKTtcclxuICAgICAgICB0aGlzLmJvdHRvbVJ1bGVFbCA9IHRoaXMuZWwuZmluZCgnaHInKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyU2xhdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHRoZW1lID0gdGhpcy52aWV3LmNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHRoaXMuc2xhdENvbnRhaW5lckVsID0gdGhpcy5lbC5maW5kKCc+IC5mYy1zbGF0cycpXHJcbiAgICAgICAgICAgIC5odG1sKC8vIGF2b2lkcyBuZWVkaW5nIDo6dW5yZW5kZXJTbGF0cygpXHJcbiAgICAgICAgJzx0YWJsZSBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygndGFibGVHcmlkJykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2xhdFJvd0h0bWwoKSArXHJcbiAgICAgICAgICAgICc8L3RhYmxlPicpO1xyXG4gICAgICAgIHRoaXMuc2xhdEVscyA9IHRoaXMuc2xhdENvbnRhaW5lckVsLmZpbmQoJ3RyJyk7XHJcbiAgICAgICAgdGhpcy5zbGF0Q29vcmRDYWNoZSA9IG5ldyBDb29yZENhY2hlXzEuZGVmYXVsdCh7XHJcbiAgICAgICAgICAgIGVsczogdGhpcy5zbGF0RWxzLFxyXG4gICAgICAgICAgICBpc1ZlcnRpY2FsOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2VuZXJhdGVzIHRoZSBIVE1MIGZvciB0aGUgaG9yaXpvbnRhbCBcInNsYXRzXCIgdGhhdCBydW4gd2lkdGgtd2lzZS4gSGFzIGEgdGltZSBheGlzIG9uIGEgc2lkZS4gRGVwZW5kcyBvbiBSVEwuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyU2xhdFJvd0h0bWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgdGhlbWUgPSBjYWxlbmRhci50aGVtZTtcclxuICAgICAgICB2YXIgaXNSVEwgPSB0aGlzLmlzUlRMO1xyXG4gICAgICAgIHZhciBkYXRlUHJvZmlsZSA9IHRoaXMuZGF0ZVByb2ZpbGU7XHJcbiAgICAgICAgdmFyIGh0bWwgPSAnJztcclxuICAgICAgICB2YXIgc2xvdFRpbWUgPSBtb21lbnQuZHVyYXRpb24oK2RhdGVQcm9maWxlLm1pblRpbWUpOyAvLyB3aXNoIHRoZXJlIHdhcyAuY2xvbmUoKSBmb3IgZHVyYXRpb25zXHJcbiAgICAgICAgdmFyIHNsb3RJdGVyYXRvciA9IG1vbWVudC5kdXJhdGlvbigwKTtcclxuICAgICAgICB2YXIgc2xvdERhdGU7IC8vIHdpbGwgYmUgb24gdGhlIHZpZXcncyBmaXJzdCBkYXksIGJ1dCB3ZSBvbmx5IGNhcmUgYWJvdXQgaXRzIHRpbWVcclxuICAgICAgICB2YXIgaXNMYWJlbGVkO1xyXG4gICAgICAgIHZhciBheGlzSHRtbDtcclxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIHRpbWUgZm9yIGVhY2ggc2xvdFxyXG4gICAgICAgIHdoaWxlIChzbG90VGltZSA8IGRhdGVQcm9maWxlLm1heFRpbWUpIHtcclxuICAgICAgICAgICAgc2xvdERhdGUgPSBjYWxlbmRhci5tc1RvVXRjTW9tZW50KGRhdGVQcm9maWxlLnJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zKS50aW1lKHNsb3RUaW1lKTtcclxuICAgICAgICAgICAgaXNMYWJlbGVkID0gdXRpbF8xLmlzSW50KHV0aWxfMS5kaXZpZGVEdXJhdGlvbkJ5RHVyYXRpb24oc2xvdEl0ZXJhdG9yLCB0aGlzLmxhYmVsSW50ZXJ2YWwpKTtcclxuICAgICAgICAgICAgYXhpc0h0bWwgPVxyXG4gICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWF4aXMgZmMtdGltZSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIiAnICsgdmlldy5heGlzU3R5bGVBdHRyKCkgKyAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgIChpc0xhYmVsZWQgP1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnPHNwYW4+JyArIC8vIGZvciBtYXRjaENlbGxXaWR0aHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHV0aWxfMS5odG1sRXNjYXBlKHNsb3REYXRlLmZvcm1hdCh0aGlzLmxhYmVsRm9ybWF0KSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJzwvc3Bhbj4nIDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgICAgICAgICAnPC90ZD4nO1xyXG4gICAgICAgICAgICBodG1sICs9XHJcbiAgICAgICAgICAgICAgICAnPHRyIGRhdGEtdGltZT1cIicgKyBzbG90RGF0ZS5mb3JtYXQoJ0hIOm1tOnNzJykgKyAnXCInICtcclxuICAgICAgICAgICAgICAgICAgICAoaXNMYWJlbGVkID8gJycgOiAnIGNsYXNzPVwiZmMtbWlub3JcIicpICtcclxuICAgICAgICAgICAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgICAgICAgICAgICghaXNSVEwgPyBheGlzSHRtbCA6ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzx0ZCBjbGFzcz1cIicgKyB0aGVtZS5nZXRDbGFzcygnd2lkZ2V0Q29udGVudCcpICsgJ1wiPjwvdGQ+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgKGlzUlRMID8gYXhpc0h0bWwgOiAnJykgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RyPic7XHJcbiAgICAgICAgICAgIHNsb3RUaW1lLmFkZCh0aGlzLnNsb3REdXJhdGlvbik7XHJcbiAgICAgICAgICAgIHNsb3RJdGVyYXRvci5hZGQodGhpcy5zbG90RHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaHRtbDtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyQ29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSB0aGlzLmRhdGVQcm9maWxlO1xyXG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMudmlldy5jYWxlbmRhci50aGVtZTtcclxuICAgICAgICB0aGlzLmRheVJhbmdlcyA9IHRoaXMuZGF5RGF0ZXMubWFwKGZ1bmN0aW9uIChkYXlEYXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVW56b25lZFJhbmdlXzEuZGVmYXVsdChkYXlEYXRlLmNsb25lKCkuYWRkKGRhdGVQcm9maWxlLm1pblRpbWUpLCBkYXlEYXRlLmNsb25lKCkuYWRkKGRhdGVQcm9maWxlLm1heFRpbWUpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGhpcy5oZWFkQ29udGFpbmVyRWwpIHtcclxuICAgICAgICAgICAgdGhpcy5oZWFkQ29udGFpbmVyRWwuaHRtbCh0aGlzLnJlbmRlckhlYWRIdG1sKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVsLmZpbmQoJz4gLmZjLWJnJykuaHRtbCgnPHRhYmxlIGNsYXNzPVwiJyArIHRoZW1lLmdldENsYXNzKCd0YWJsZUdyaWQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgdGhpcy5yZW5kZXJCZ1RySHRtbCgwKSArIC8vIHJvdz0wXHJcbiAgICAgICAgICAgICc8L3RhYmxlPicpO1xyXG4gICAgICAgIHRoaXMuY29sRWxzID0gdGhpcy5lbC5maW5kKCcuZmMtZGF5LCAuZmMtZGlzYWJsZWQtZGF5Jyk7XHJcbiAgICAgICAgdGhpcy5jb2xDb29yZENhY2hlID0gbmV3IENvb3JkQ2FjaGVfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgZWxzOiB0aGlzLmNvbEVscyxcclxuICAgICAgICAgICAgaXNIb3Jpem9udGFsOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJDb250ZW50U2tlbGV0b24oKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJDb2x1bW5zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJDb250ZW50U2tlbGV0b24oKTtcclxuICAgIH07XHJcbiAgICAvKiBDb250ZW50IFNrZWxldG9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyB0aGUgRE9NIHRoYXQgdGhlIHZpZXcncyBjb250ZW50IHdpbGwgbGl2ZSBpblxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnJlbmRlckNvbnRlbnRTa2VsZXRvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2VsbEh0bWwgPSAnJztcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2tlbGV0b25FbDtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5jb2xDbnQ7IGkrKykge1xyXG4gICAgICAgICAgICBjZWxsSHRtbCArPVxyXG4gICAgICAgICAgICAgICAgJzx0ZD4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtY29sXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXIgZmMtaGVscGVyLWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtZXZlbnQtY29udGFpbmVyXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1oaWdobGlnaHQtY29udGFpbmVyXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1iZ2V2ZW50LWNvbnRhaW5lclwiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtYnVzaW5lc3MtY29udGFpbmVyXCI+PC9kaXY+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L3RkPic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNrZWxldG9uRWwgPSB0aGlzLmNvbnRlbnRTa2VsZXRvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnQtc2tlbGV0b25cIj4nICtcclxuICAgICAgICAgICAgJzx0YWJsZT4nICtcclxuICAgICAgICAgICAgJzx0cj4nICsgY2VsbEh0bWwgKyAnPC90cj4nICtcclxuICAgICAgICAgICAgJzwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nKTtcclxuICAgICAgICB0aGlzLmNvbENvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWNvbnRlbnQtY29sJyk7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1oZWxwZXItY29udGFpbmVyJyk7XHJcbiAgICAgICAgdGhpcy5mZ0NvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWV2ZW50LWNvbnRhaW5lcjpub3QoLmZjLWhlbHBlci1jb250YWluZXIpJyk7XHJcbiAgICAgICAgdGhpcy5iZ0NvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWJnZXZlbnQtY29udGFpbmVyJyk7XHJcbiAgICAgICAgdGhpcy5oaWdobGlnaHRDb250YWluZXJFbHMgPSBza2VsZXRvbkVsLmZpbmQoJy5mYy1oaWdobGlnaHQtY29udGFpbmVyJyk7XHJcbiAgICAgICAgdGhpcy5idXNpbmVzc0NvbnRhaW5lckVscyA9IHNrZWxldG9uRWwuZmluZCgnLmZjLWJ1c2luZXNzLWNvbnRhaW5lcicpO1xyXG4gICAgICAgIHRoaXMuYm9va2VuZENlbGxzKHNrZWxldG9uRWwuZmluZCgndHInKSk7IC8vIFRPRE86IGRvIHRoaXMgb24gc3RyaW5nIGxldmVsXHJcbiAgICAgICAgdGhpcy5lbC5hcHBlbmQoc2tlbGV0b25FbCk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyQ29udGVudFNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRTa2VsZXRvbkVsKSB7IC8vIGRlZmVuc2l2ZSA6KFxyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRTa2VsZXRvbkVsLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRTa2VsZXRvbkVsID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jb2xDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmhlbHBlckNvbnRhaW5lckVscyA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuZmdDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmJnQ29udGFpbmVyRWxzID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5oaWdobGlnaHRDb250YWluZXJFbHMgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmJ1c2luZXNzQ29udGFpbmVyRWxzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSBmbGF0IGFycmF5IG9mIHNlZ21lbnRzLCByZXR1cm4gYW4gYXJyYXkgb2Ygc3ViLWFycmF5cywgZ3JvdXBlZCBieSBlYWNoIHNlZ21lbnQncyBjb2xcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5ncm91cFNlZ3NCeUNvbCA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIHNlZ3NCeUNvbCA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmNvbENudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZ3NCeUNvbC5wdXNoKFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2Vnc0J5Q29sW3NlZ3NbaV0uY29sXS5wdXNoKHNlZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2Vnc0J5Q29sO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHNlZ21lbnRzIGdyb3VwZWQgYnkgY29sdW1uLCBpbnNlcnQgdGhlIHNlZ21lbnRzJyBlbGVtZW50cyBpbnRvIGEgcGFyYWxsZWwgYXJyYXkgb2YgY29udGFpbmVyXHJcbiAgICAvLyBlbGVtZW50cywgZWFjaCBsaXZpbmcgd2l0aGluIGEgY29sdW1uLlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmF0dGFjaFNlZ3NCeUNvbCA9IGZ1bmN0aW9uIChzZWdzQnlDb2wsIGNvbnRhaW5lckVscykge1xyXG4gICAgICAgIHZhciBjb2w7XHJcbiAgICAgICAgdmFyIHNlZ3M7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgZm9yIChjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sKyspIHsgLy8gaXRlcmF0ZSBlYWNoIGNvbHVtbiBncm91cGluZ1xyXG4gICAgICAgICAgICBzZWdzID0gc2Vnc0J5Q29sW2NvbF07XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb250YWluZXJFbHMuZXEoY29sKS5hcHBlbmQoc2Vnc1tpXS5lbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyogTm93IEluZGljYXRvclxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5nZXROb3dJbmRpY2F0b3JVbml0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAnbWludXRlJzsgLy8gd2lsbCByZWZyZXNoIG9uIHRoZSBtaW51dGVcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucmVuZGVyTm93SW5kaWNhdG9yID0gZnVuY3Rpb24gKGRhdGUpIHtcclxuICAgICAgICAvLyBIQUNLOiBpZiBkYXRlIGNvbHVtbnMgbm90IHJlYWR5IGZvciBzb21lIHJlYXNvbiAoc2NoZWR1bGVyKVxyXG4gICAgICAgIGlmICghdGhpcy5jb2xDb250YWluZXJFbHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzZWcgc3lzdGVtIG1pZ2h0IGJlIG92ZXJraWxsLCBidXQgaXQgaGFuZGxlcyBzY2VuYXJpbyB3aGVyZSBsaW5lIG5lZWRzIHRvIGJlIHJlbmRlcmVkXHJcbiAgICAgICAgLy8gIG1vcmUgdGhhbiBvbmNlIGJlY2F1c2Ugb2YgY29sdW1ucyB3aXRoIHRoZSBzYW1lIGRhdGUgKHJlc291cmNlcyBjb2x1bW5zIGZvciBleGFtcGxlKVxyXG4gICAgICAgIHZhciBzZWdzID0gdGhpcy5jb21wb25lbnRGb290cHJpbnRUb1NlZ3MobmV3IENvbXBvbmVudEZvb3RwcmludF8xLmRlZmF1bHQobmV3IFVuem9uZWRSYW5nZV8xLmRlZmF1bHQoZGF0ZSwgZGF0ZS52YWx1ZU9mKCkgKyAxKSwgLy8gcHJvdGVjdCBhZ2FpbnN0IG51bGwgcmFuZ2VcclxuICAgICAgICBmYWxzZSAvLyBhbGwtZGF5XHJcbiAgICAgICAgKSk7XHJcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuY29tcHV0ZURhdGVUb3AoZGF0ZSwgZGF0ZSk7XHJcbiAgICAgICAgdmFyIG5vZGVzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgLy8gcmVuZGVyIGxpbmVzIHdpdGhpbiB0aGUgY29sdW1uc1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5vZGVzLnB1c2goJCgnPGRpdiBjbGFzcz1cImZjLW5vdy1pbmRpY2F0b3IgZmMtbm93LWluZGljYXRvci1saW5lXCI+PC9kaXY+JylcclxuICAgICAgICAgICAgICAgIC5jc3MoJ3RvcCcsIHRvcClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh0aGlzLmNvbENvbnRhaW5lckVscy5lcShzZWdzW2ldLmNvbCkpWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVuZGVyIGFuIGFycm93IG92ZXIgdGhlIGF4aXNcclxuICAgICAgICBpZiAoc2Vncy5sZW5ndGggPiAwKSB7IC8vIGlzIHRoZSBjdXJyZW50IHRpbWUgaW4gdmlldz9cclxuICAgICAgICAgICAgbm9kZXMucHVzaCgkKCc8ZGl2IGNsYXNzPVwiZmMtbm93LWluZGljYXRvciBmYy1ub3ctaW5kaWNhdG9yLWFycm93XCI+PC9kaXY+JylcclxuICAgICAgICAgICAgICAgIC5jc3MoJ3RvcCcsIHRvcClcclxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbyh0aGlzLmVsLmZpbmQoJy5mYy1jb250ZW50LXNrZWxldG9uJykpWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ub3dJbmRpY2F0b3JFbHMgPSAkKG5vZGVzKTtcclxuICAgIH07XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJOb3dJbmRpY2F0b3IgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubm93SW5kaWNhdG9yRWxzKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm93SW5kaWNhdG9yRWxzLnJlbW92ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLm5vd0luZGljYXRvckVscyA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qIENvb3JkaW5hdGVzXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAodG90YWxIZWlnaHQsIGlzQXV0bywgaXNSZXNpemUpIHtcclxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVwZGF0ZVNpemUuY2FsbCh0aGlzLCB0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSk7XHJcbiAgICAgICAgdGhpcy5zbGF0Q29vcmRDYWNoZS5idWlsZCgpO1xyXG4gICAgICAgIGlmIChpc1Jlc2l6ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlZ1ZlcnRpY2FscyhbXS5jb25jYXQodGhpcy5ldmVudFJlbmRlcmVyLmdldFNlZ3MoKSwgdGhpcy5idXNpbmVzc1NlZ3MgfHwgW10pKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmdldFRvdGFsU2xhdEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zbGF0Q29udGFpbmVyRWwub3V0ZXJIZWlnaHQoKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiBkYXRlLlxyXG4gICAgLy8gYG1zYCBjYW4gYmUgYSBtaWxsaXNlY29uZCBVVEMgdGltZSBPUiBhIFVUQyBtb21lbnQuXHJcbiAgICAvLyBBIGBzdGFydE9mRGF5RGF0ZWAgbXVzdCBiZSBnaXZlbiBmb3IgYXZvaWRpbmcgYW1iaWd1aXR5IG92ZXIgaG93IHRvIHRyZWF0IG1pZG5pZ2h0LlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmNvbXB1dGVEYXRlVG9wID0gZnVuY3Rpb24gKG1zLCBzdGFydE9mRGF5RGF0ZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVUaW1lVG9wKG1vbWVudC5kdXJhdGlvbihtcyAtIHN0YXJ0T2ZEYXlEYXRlLmNsb25lKCkuc3RyaXBUaW1lKCkpKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgdG9wIGNvb3JkaW5hdGUsIHJlbGF0aXZlIHRvIHRoZSBib3VuZHMgb2YgdGhlIGdyaWQsIG9mIHRoZSBnaXZlbiB0aW1lIChhIER1cmF0aW9uKS5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wdXRlVGltZVRvcCA9IGZ1bmN0aW9uICh0aW1lKSB7XHJcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuc2xhdEVscy5sZW5ndGg7XHJcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlID0gdGhpcy5kYXRlUHJvZmlsZTtcclxuICAgICAgICB2YXIgc2xhdENvdmVyYWdlID0gKHRpbWUgLSBkYXRlUHJvZmlsZS5taW5UaW1lKSAvIHRoaXMuc2xvdER1cmF0aW9uOyAvLyBmbG9hdGluZy1wb2ludCB2YWx1ZSBvZiAjIG9mIHNsb3RzIGNvdmVyZWRcclxuICAgICAgICB2YXIgc2xhdEluZGV4O1xyXG4gICAgICAgIHZhciBzbGF0UmVtYWluZGVyO1xyXG4gICAgICAgIC8vIGNvbXB1dGUgYSBmbG9hdGluZy1wb2ludCBudW1iZXIgZm9yIGhvdyBtYW55IHNsYXRzIHNob3VsZCBiZSBwcm9ncmVzc2VkIHRocm91Z2guXHJcbiAgICAgICAgLy8gZnJvbSAwIHRvIG51bWJlciBvZiBzbGF0cyAoaW5jbHVzaXZlKVxyXG4gICAgICAgIC8vIGNvbnN0cmFpbmVkIGJlY2F1c2UgbWluVGltZS9tYXhUaW1lIG1pZ2h0IGJlIGN1c3RvbWl6ZWQuXHJcbiAgICAgICAgc2xhdENvdmVyYWdlID0gTWF0aC5tYXgoMCwgc2xhdENvdmVyYWdlKTtcclxuICAgICAgICBzbGF0Q292ZXJhZ2UgPSBNYXRoLm1pbihsZW4sIHNsYXRDb3ZlcmFnZSk7XHJcbiAgICAgICAgLy8gYW4gaW50ZWdlciBpbmRleCBvZiB0aGUgZnVydGhlc3Qgd2hvbGUgc2xhdFxyXG4gICAgICAgIC8vIGZyb20gMCB0byBudW1iZXIgc2xhdHMgKCpleGNsdXNpdmUqLCBzbyBsZW4tMSlcclxuICAgICAgICBzbGF0SW5kZXggPSBNYXRoLmZsb29yKHNsYXRDb3ZlcmFnZSk7XHJcbiAgICAgICAgc2xhdEluZGV4ID0gTWF0aC5taW4oc2xhdEluZGV4LCBsZW4gLSAxKTtcclxuICAgICAgICAvLyBob3cgbXVjaCBmdXJ0aGVyIHRocm91Z2ggdGhlIHNsYXRJbmRleCBzbGF0IChmcm9tIDAuMC0xLjApIG11c3QgYmUgY292ZXJlZCBpbiBhZGRpdGlvbi5cclxuICAgICAgICAvLyBjb3VsZCBiZSAxLjAgaWYgc2xhdENvdmVyYWdlIGlzIGNvdmVyaW5nICphbGwqIHRoZSBzbG90c1xyXG4gICAgICAgIHNsYXRSZW1haW5kZXIgPSBzbGF0Q292ZXJhZ2UgLSBzbGF0SW5kZXg7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xhdENvb3JkQ2FjaGUuZ2V0VG9wUG9zaXRpb24oc2xhdEluZGV4KSArXHJcbiAgICAgICAgICAgIHRoaXMuc2xhdENvb3JkQ2FjaGUuZ2V0SGVpZ2h0KHNsYXRJbmRleCkgKiBzbGF0UmVtYWluZGVyO1xyXG4gICAgfTtcclxuICAgIC8vIFJlZnJlc2hlcyB0aGUgQ1NTIHRvcC9ib3R0b20gY29vcmRpbmF0ZXMgZm9yIGVhY2ggc2VnbWVudCBlbGVtZW50LlxyXG4gICAgLy8gV29ya3Mgd2hlbiBjYWxsZWQgYWZ0ZXIgaW5pdGlhbCByZW5kZXIsIGFmdGVyIGEgd2luZG93IHJlc2l6ZS96b29tIGZvciBleGFtcGxlLlxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVwZGF0ZVNlZ1ZlcnRpY2FscyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdGhpcy5jb21wdXRlU2VnVmVydGljYWxzKHNlZ3MpO1xyXG4gICAgICAgIHRoaXMuYXNzaWduU2VnVmVydGljYWxzKHNlZ3MpO1xyXG4gICAgfTtcclxuICAgIC8vIEZvciBlYWNoIHNlZ21lbnQgaW4gYW4gYXJyYXksIGNvbXB1dGVzIGFuZCBhc3NpZ25zIGl0cyB0b3AgYW5kIGJvdHRvbSBwcm9wZXJ0aWVzXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuY29tcHV0ZVNlZ1ZlcnRpY2FscyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50TWluSGVpZ2h0ID0gdGhpcy5vcHQoJ2FnZW5kYUV2ZW50TWluSGVpZ2h0Jyk7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICB2YXIgZGF5RGF0ZTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBkYXlEYXRlID0gdGhpcy5kYXlEYXRlc1tzZWcuZGF5SW5kZXhdO1xyXG4gICAgICAgICAgICBzZWcudG9wID0gdGhpcy5jb21wdXRlRGF0ZVRvcChzZWcuc3RhcnRNcywgZGF5RGF0ZSk7XHJcbiAgICAgICAgICAgIHNlZy5ib3R0b20gPSBNYXRoLm1heChzZWcudG9wICsgZXZlbnRNaW5IZWlnaHQsIHRoaXMuY29tcHV0ZURhdGVUb3Aoc2VnLmVuZE1zLCBkYXlEYXRlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIHNlZ21lbnRzIHRoYXQgYWxyZWFkeSBoYXZlIHRoZWlyIHRvcC9ib3R0b20gcHJvcGVydGllcyBjb21wdXRlZCwgYXBwbGllcyB0aG9zZSB2YWx1ZXMgdG9cclxuICAgIC8vIHRoZSBzZWdtZW50cycgZWxlbWVudHMuXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuYXNzaWduU2VnVmVydGljYWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIHNlZy5lbC5jc3ModGhpcy5nZW5lcmF0ZVNlZ1ZlcnRpY2FsQ3NzKHNlZykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBHZW5lcmF0ZXMgYW4gb2JqZWN0IHdpdGggQ1NTIHByb3BlcnRpZXMgZm9yIHRoZSB0b3AvYm90dG9tIGNvb3JkaW5hdGVzIG9mIGEgc2VnbWVudCBlbGVtZW50XHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUuZ2VuZXJhdGVTZWdWZXJ0aWNhbENzcyA9IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0b3A6IHNlZy50b3AsXHJcbiAgICAgICAgICAgIGJvdHRvbTogLXNlZy5ib3R0b20gLy8gZmxpcHBlZCBiZWNhdXNlIG5lZWRzIHRvIGJlIHNwYWNlIGJleW9uZCBib3R0b20gZWRnZSBvZiBldmVudCBjb250YWluZXJcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIC8qIEhpdCBTeXN0ZW1cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUucHJlcGFyZUhpdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xDb29yZENhY2hlLmJ1aWxkKCk7XHJcbiAgICAgICAgdGhpcy5zbGF0Q29vcmRDYWNoZS5idWlsZCgpO1xyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZWxlYXNlSGl0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbENvb3JkQ2FjaGUuY2xlYXIoKTtcclxuICAgICAgICAvLyBOT1RFOiBkb24ndCBjbGVhciBzbGF0Q29vcmRDYWNoZSBiZWNhdXNlIHdlIHJlbHkgb24gaXQgZm9yIGNvbXB1dGVUaW1lVG9wXHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKGxlZnRPZmZzZXQsIHRvcE9mZnNldCkge1xyXG4gICAgICAgIHZhciBzbmFwc1BlclNsb3QgPSB0aGlzLnNuYXBzUGVyU2xvdDtcclxuICAgICAgICB2YXIgY29sQ29vcmRDYWNoZSA9IHRoaXMuY29sQ29vcmRDYWNoZTtcclxuICAgICAgICB2YXIgc2xhdENvb3JkQ2FjaGUgPSB0aGlzLnNsYXRDb29yZENhY2hlO1xyXG4gICAgICAgIGlmIChjb2xDb29yZENhY2hlLmlzTGVmdEluQm91bmRzKGxlZnRPZmZzZXQpICYmIHNsYXRDb29yZENhY2hlLmlzVG9wSW5Cb3VuZHModG9wT2Zmc2V0KSkge1xyXG4gICAgICAgICAgICB2YXIgY29sSW5kZXggPSBjb2xDb29yZENhY2hlLmdldEhvcml6b250YWxJbmRleChsZWZ0T2Zmc2V0KTtcclxuICAgICAgICAgICAgdmFyIHNsYXRJbmRleCA9IHNsYXRDb29yZENhY2hlLmdldFZlcnRpY2FsSW5kZXgodG9wT2Zmc2V0KTtcclxuICAgICAgICAgICAgaWYgKGNvbEluZGV4ICE9IG51bGwgJiYgc2xhdEluZGV4ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBzbGF0VG9wID0gc2xhdENvb3JkQ2FjaGUuZ2V0VG9wT2Zmc2V0KHNsYXRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2xhdEhlaWdodCA9IHNsYXRDb29yZENhY2hlLmdldEhlaWdodChzbGF0SW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnRpYWwgPSAodG9wT2Zmc2V0IC0gc2xhdFRvcCkgLyBzbGF0SGVpZ2h0OyAvLyBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiAwIGFuZCAxXHJcbiAgICAgICAgICAgICAgICB2YXIgbG9jYWxTbmFwSW5kZXggPSBNYXRoLmZsb29yKHBhcnRpYWwgKiBzbmFwc1BlclNsb3QpOyAvLyB0aGUgc25hcCAjIHJlbGF0aXZlIHRvIHN0YXJ0IG9mIHNsYXRcclxuICAgICAgICAgICAgICAgIHZhciBzbmFwSW5kZXggPSBzbGF0SW5kZXggKiBzbmFwc1BlclNsb3QgKyBsb2NhbFNuYXBJbmRleDtcclxuICAgICAgICAgICAgICAgIHZhciBzbmFwVG9wID0gc2xhdFRvcCArIChsb2NhbFNuYXBJbmRleCAvIHNuYXBzUGVyU2xvdCkgKiBzbGF0SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIHNuYXBCb3R0b20gPSBzbGF0VG9wICsgKChsb2NhbFNuYXBJbmRleCArIDEpIC8gc25hcHNQZXJTbG90KSAqIHNsYXRIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbDogY29sSW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgc25hcDogc25hcEluZGV4LFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudDogdGhpcyxcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBjb2xDb29yZENhY2hlLmdldExlZnRPZmZzZXQoY29sSW5kZXgpLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjb2xDb29yZENhY2hlLmdldFJpZ2h0T2Zmc2V0KGNvbEluZGV4KSxcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IHNuYXBUb3AsXHJcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBzbmFwQm90dG9tXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5nZXRIaXRGb290cHJpbnQgPSBmdW5jdGlvbiAoaGl0KSB7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5nZXRDZWxsRGF0ZSgwLCBoaXQuY29sKTsgLy8gcm93PTBcclxuICAgICAgICB2YXIgdGltZSA9IHRoaXMuY29tcHV0ZVNuYXBUaW1lKGhpdC5zbmFwKTsgLy8gcGFzcyBpbiB0aGUgc25hcC1pbmRleFxyXG4gICAgICAgIHZhciBlbmQ7XHJcbiAgICAgICAgc3RhcnQudGltZSh0aW1lKTtcclxuICAgICAgICBlbmQgPSBzdGFydC5jbG9uZSgpLmFkZCh0aGlzLnNuYXBEdXJhdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb21wb25lbnRGb290cHJpbnRfMS5kZWZhdWx0KG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpLCBmYWxzZSAvLyBhbGwtZGF5P1xyXG4gICAgICAgICk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSByb3cgbnVtYmVyIG9mIHRoZSBncmlkLCByZXByZXNlbnRpbmcgYSBcInNuYXBcIiwgcmV0dXJucyBhIHRpbWUgKER1cmF0aW9uKSBmcm9tIGl0cyBzdGFydC1vZi1kYXlcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5jb21wdXRlU25hcFRpbWUgPSBmdW5jdGlvbiAoc25hcEluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIG1vbWVudC5kdXJhdGlvbih0aGlzLmRhdGVQcm9maWxlLm1pblRpbWUgKyB0aGlzLnNuYXBEdXJhdGlvbiAqIHNuYXBJbmRleCk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLmdldEhpdEVsID0gZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbEVscy5lcShoaXQuY29sKTtcclxuICAgIH07XHJcbiAgICAvKiBFdmVudCBEcmFnIFZpc3VhbGl6YXRpb25cclxuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAvLyBSZW5kZXJzIGEgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoZSBzcGVjaWZpZWQgZGF0ZShzKS5cclxuICAgIC8vIEEgcmV0dXJuZWQgdmFsdWUgb2YgYHRydWVgIHNpZ25hbHMgdGhhdCBhIG1vY2sgXCJoZWxwZXJcIiBldmVudCBoYXMgYmVlbiByZW5kZXJlZC5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJEcmFnID0gZnVuY3Rpb24gKGV2ZW50Rm9vdHByaW50cywgc2VnLCBpc1RvdWNoKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHNlZykgeyAvLyBpZiB0aGVyZSBpcyBldmVudCBpbmZvcm1hdGlvbiBmb3IgdGhpcyBkcmFnLCByZW5kZXIgYSBoZWxwZXIgZXZlbnRcclxuICAgICAgICAgICAgaWYgKGV2ZW50Rm9vdHByaW50cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyRXZlbnREcmFnZ2luZ0Zvb3RwcmludHMoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgICAgICAgICAgICAgLy8gc2lnbmFsIHRoYXQgYSBoZWxwZXIgaGFzIGJlZW4gcmVuZGVyZWRcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgeyAvLyBvdGhlcndpc2UsIGp1c3QgcmVuZGVyIGEgaGlnaGxpZ2h0XHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBldmVudEZvb3RwcmludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVySGlnaGxpZ2h0KGV2ZW50Rm9vdHByaW50c1tpXS5jb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgZHJhZ2dlZFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyRHJhZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnVucmVuZGVySGlnaGxpZ2h0KCk7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIC8qIEV2ZW50IFJlc2l6ZSBWaXN1YWxpemF0aW9uXHJcbiAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG4gICAgLy8gUmVuZGVycyBhIHZpc3VhbCBpbmRpY2F0aW9uIG9mIGFuIGV2ZW50IGJlaW5nIHJlc2l6ZWRcclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJFdmVudFJlc2l6ZSA9IGZ1bmN0aW9uIChldmVudEZvb3RwcmludHMsIHNlZywgaXNUb3VjaCkge1xyXG4gICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyRXZlbnRSZXNpemluZ0Zvb3RwcmludHMoZXZlbnRGb290cHJpbnRzLCBzZWcsIGlzVG91Y2gpO1xyXG4gICAgfTtcclxuICAgIC8vIFVucmVuZGVycyBhbnkgdmlzdWFsIGluZGljYXRpb24gb2YgYW4gZXZlbnQgYmVpbmcgcmVzaXplZFxyXG4gICAgVGltZUdyaWQucHJvdG90eXBlLnVucmVuZGVyRXZlbnRSZXNpemUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgfTtcclxuICAgIC8qIFNlbGVjdGlvblxyXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgIC8vIFJlbmRlcnMgYSB2aXN1YWwgaW5kaWNhdGlvbiBvZiBhIHNlbGVjdGlvbi4gT3ZlcnJpZGVzIHRoZSBkZWZhdWx0LCB3aGljaCB3YXMgdG8gc2ltcGx5IHJlbmRlciBhIGhpZ2hsaWdodC5cclxuICAgIFRpbWVHcmlkLnByb3RvdHlwZS5yZW5kZXJTZWxlY3Rpb25Gb290cHJpbnQgPSBmdW5jdGlvbiAoY29tcG9uZW50Rm9vdHByaW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3B0KCdzZWxlY3RIZWxwZXInKSkgeyAvLyB0aGlzIHNldHRpbmcgc2lnbmFscyB0aGF0IGEgbW9jayBoZWxwZXIgZXZlbnQgc2hvdWxkIGJlIHJlbmRlcmVkXHJcbiAgICAgICAgICAgIHRoaXMuaGVscGVyUmVuZGVyZXIucmVuZGVyQ29tcG9uZW50Rm9vdHByaW50KGNvbXBvbmVudEZvb3RwcmludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodChjb21wb25lbnRGb290cHJpbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBVbnJlbmRlcnMgYW55IHZpc3VhbCBpbmRpY2F0aW9uIG9mIGEgc2VsZWN0aW9uXHJcbiAgICBUaW1lR3JpZC5wcm90b3R5cGUudW5yZW5kZXJTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5oZWxwZXJSZW5kZXJlci51bnJlbmRlcigpO1xyXG4gICAgICAgIHRoaXMudW5yZW5kZXJIaWdobGlnaHQoKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGltZUdyaWQ7XHJcbn0oSW50ZXJhY3RpdmVEYXRlQ29tcG9uZW50XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUaW1lR3JpZDtcclxuVGltZUdyaWQucHJvdG90eXBlLmV2ZW50UmVuZGVyZXJDbGFzcyA9IFRpbWVHcmlkRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcblRpbWVHcmlkLnByb3RvdHlwZS5idXNpbmVzc0hvdXJSZW5kZXJlckNsYXNzID0gQnVzaW5lc3NIb3VyUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5UaW1lR3JpZC5wcm90b3R5cGUuaGVscGVyUmVuZGVyZXJDbGFzcyA9IFRpbWVHcmlkSGVscGVyUmVuZGVyZXJfMS5kZWZhdWx0O1xyXG5UaW1lR3JpZC5wcm90b3R5cGUuZmlsbFJlbmRlcmVyQ2xhc3MgPSBUaW1lR3JpZEZpbGxSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcblN0YW5kYXJkSW50ZXJhY3Rpb25zTWl4aW5fMS5kZWZhdWx0Lm1peEludG8oVGltZUdyaWQpO1xyXG5EYXlUYWJsZU1peGluXzEuZGVmYXVsdC5taXhJbnRvKFRpbWVHcmlkKTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEV2ZW50UmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDQpO1xyXG4vKlxyXG5Pbmx5IGhhbmRsZXMgZm9yZWdyb3VuZCBzZWdzLlxyXG5Eb2VzIG5vdCBvd24gcmVuZGVyaW5nLiBVc2UgZm9yIGxvdy1sZXZlbCB1dGlsIG1ldGhvZHMgYnkgVGltZUdyaWQuXHJcbiovXHJcbnZhciBUaW1lR3JpZEV2ZW50UmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUaW1lR3JpZEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBUaW1lR3JpZEV2ZW50UmVuZGVyZXIodGltZUdyaWQsIGZpbGxSZW5kZXJlcikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHRpbWVHcmlkLCBmaWxsUmVuZGVyZXIpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMudGltZUdyaWQgPSB0aW1lR3JpZDtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdGhpcy5yZW5kZXJGZ1NlZ3NJbnRvQ29udGFpbmVycyhzZWdzLCB0aGlzLnRpbWVHcmlkLmZnQ29udGFpbmVyRWxzKTtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBhcnJheSBvZiBmb3JlZ3JvdW5kIHNlZ21lbnRzLCByZW5kZXIgYSBET00gZWxlbWVudCBmb3IgZWFjaCwgY29tcHV0ZXMgcG9zaXRpb24sXHJcbiAgICAvLyBhbmQgYXR0YWNoZXMgdG8gdGhlIGNvbHVtbiBpbm5lci1jb250YWluZXIgZWxlbWVudHMuXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckZnU2Vnc0ludG9Db250YWluZXJzID0gZnVuY3Rpb24gKHNlZ3MsIGNvbnRhaW5lckVscykge1xyXG4gICAgICAgIHZhciBzZWdzQnlDb2w7XHJcbiAgICAgICAgdmFyIGNvbDtcclxuICAgICAgICBzZWdzQnlDb2wgPSB0aGlzLnRpbWVHcmlkLmdyb3VwU2Vnc0J5Q29sKHNlZ3MpO1xyXG4gICAgICAgIGZvciAoY29sID0gMDsgY29sIDwgdGhpcy50aW1lR3JpZC5jb2xDbnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRmdTZWdDb29yZHMoc2Vnc0J5Q29sW2NvbF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmF0dGFjaFNlZ3NCeUNvbChzZWdzQnlDb2wsIGNvbnRhaW5lckVscyk7XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS51bnJlbmRlckZnU2VncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5mZ1NlZ3MpIHsgLy8gaGFja1xyXG4gICAgICAgICAgICB0aGlzLmZnU2Vncy5mb3JFYWNoKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgICAgIHNlZy5lbC5yZW1vdmUoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIGEgZGVmYXVsdCBldmVudCB0aW1lIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGB0aW1lRm9ybWF0YCBpcyBub3QgZXhwbGljaXRseSBkZWZpbmVkXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVFdmVudFRpbWVGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0KCdub01lcmlkaWVtVGltZUZvcm1hdCcpOyAvLyBsaWtlIFwiNjozMFwiIChubyBBTS9QTSlcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyBhIGRlZmF1bHQgYGRpc3BsYXlFdmVudEVuZGAgdmFsdWUgaWYgb25lIGlzIG5vdCBleHBsaWNsdHkgZGVmaW5lZFxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50RW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfTtcclxuICAgIC8vIFJlbmRlcnMgdGhlIEhUTUwgZm9yIGEgc2luZ2xlIGV2ZW50IHNlZ21lbnQncyBkZWZhdWx0IHJlbmRlcmluZ1xyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5mZ1NlZ0h0bWwgPSBmdW5jdGlvbiAoc2VnLCBkaXNhYmxlUmVzaXppbmcpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB2aWV3LmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRGb290cHJpbnQgPSBzZWcuZm9vdHByaW50LmNvbXBvbmVudEZvb3RwcmludDtcclxuICAgICAgICB2YXIgaXNBbGxEYXkgPSBjb21wb25lbnRGb290cHJpbnQuaXNBbGxEYXk7XHJcbiAgICAgICAgdmFyIGV2ZW50RGVmID0gc2VnLmZvb3RwcmludC5ldmVudERlZjtcclxuICAgICAgICB2YXIgaXNEcmFnZ2FibGUgPSB2aWV3LmlzRXZlbnREZWZEcmFnZ2FibGUoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpc1Jlc2l6YWJsZUZyb21TdGFydCA9ICFkaXNhYmxlUmVzaXppbmcgJiYgc2VnLmlzU3RhcnQgJiYgdmlldy5pc0V2ZW50RGVmUmVzaXphYmxlRnJvbVN0YXJ0KGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgaXNSZXNpemFibGVGcm9tRW5kID0gIWRpc2FibGVSZXNpemluZyAmJiBzZWcuaXNFbmQgJiYgdmlldy5pc0V2ZW50RGVmUmVzaXphYmxlRnJvbUVuZChldmVudERlZik7XHJcbiAgICAgICAgdmFyIGNsYXNzZXMgPSB0aGlzLmdldFNlZ0NsYXNzZXMoc2VnLCBpc0RyYWdnYWJsZSwgaXNSZXNpemFibGVGcm9tU3RhcnQgfHwgaXNSZXNpemFibGVGcm9tRW5kKTtcclxuICAgICAgICB2YXIgc2tpbkNzcyA9IHV0aWxfMS5jc3NUb1N0cih0aGlzLmdldFNraW5Dc3MoZXZlbnREZWYpKTtcclxuICAgICAgICB2YXIgdGltZVRleHQ7XHJcbiAgICAgICAgdmFyIGZ1bGxUaW1lVGV4dDsgLy8gbW9yZSB2ZXJib3NlIHRpbWUgdGV4dC4gZm9yIHRoZSBwcmludCBzdHlsZXNoZWV0XHJcbiAgICAgICAgdmFyIHN0YXJ0VGltZVRleHQ7IC8vIGp1c3QgdGhlIHN0YXJ0IHRpbWUgdGV4dFxyXG4gICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtdGltZS1ncmlkLWV2ZW50JywgJ2ZjLXYtZXZlbnQnKTtcclxuICAgICAgICAvLyBpZiB0aGUgZXZlbnQgYXBwZWFycyB0byBzcGFuIG1vcmUgdGhhbiBvbmUgZGF5Li4uXHJcbiAgICAgICAgaWYgKHZpZXcuaXNNdWx0aURheVJhbmdlKGNvbXBvbmVudEZvb3RwcmludC51bnpvbmVkUmFuZ2UpKSB7XHJcbiAgICAgICAgICAgIC8vIERvbid0IGRpc3BsYXkgdGltZSB0ZXh0IG9uIHNlZ21lbnRzIHRoYXQgcnVuIGVudGlyZWx5IHRocm91Z2ggYSBkYXkuXHJcbiAgICAgICAgICAgIC8vIFRoYXQgd291bGQgYXBwZWFyIGFzIG1pZG5pZ2h0LW1pZG5pZ2h0IGFuZCB3b3VsZCBsb29rIGR1bWIuXHJcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgZGlzcGxheSB0aGUgdGltZSB0ZXh0IGZvciB0aGUgKnNlZ21lbnQncyogdGltZXMgKGxpa2UgNnBtLW1pZG5pZ2h0IG9yIG1pZG5pZ2h0LTEwYW0pXHJcbiAgICAgICAgICAgIGlmIChzZWcuaXNTdGFydCB8fCBzZWcuaXNFbmQpIHtcclxuICAgICAgICAgICAgICAgIHZhciB6b25lZFN0YXJ0ID0gY2FsZW5kYXIubXNUb01vbWVudChzZWcuc3RhcnRNcyk7XHJcbiAgICAgICAgICAgICAgICB2YXIgem9uZWRFbmQgPSBjYWxlbmRhci5tc1RvTW9tZW50KHNlZy5lbmRNcyk7XHJcbiAgICAgICAgICAgICAgICB0aW1lVGV4dCA9IHRoaXMuX2dldFRpbWVUZXh0KHpvbmVkU3RhcnQsIHpvbmVkRW5kLCBpc0FsbERheSk7XHJcbiAgICAgICAgICAgICAgICBmdWxsVGltZVRleHQgPSB0aGlzLl9nZXRUaW1lVGV4dCh6b25lZFN0YXJ0LCB6b25lZEVuZCwgaXNBbGxEYXksICdMVCcpO1xyXG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lVGV4dCA9IHRoaXMuX2dldFRpbWVUZXh0KHpvbmVkU3RhcnQsIHpvbmVkRW5kLCBpc0FsbERheSwgbnVsbCwgZmFsc2UpOyAvLyBkaXNwbGF5RW5kPWZhbHNlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIERpc3BsYXkgdGhlIG5vcm1hbCB0aW1lIHRleHQgZm9yIHRoZSAqZXZlbnQncyogdGltZXNcclxuICAgICAgICAgICAgdGltZVRleHQgPSB0aGlzLmdldFRpbWVUZXh0KHNlZy5mb290cHJpbnQpO1xyXG4gICAgICAgICAgICBmdWxsVGltZVRleHQgPSB0aGlzLmdldFRpbWVUZXh0KHNlZy5mb290cHJpbnQsICdMVCcpO1xyXG4gICAgICAgICAgICBzdGFydFRpbWVUZXh0ID0gdGhpcy5nZXRUaW1lVGV4dChzZWcuZm9vdHByaW50LCBudWxsLCBmYWxzZSk7IC8vIGRpc3BsYXlFbmQ9ZmFsc2VcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICc8YSBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAoZXZlbnREZWYudXJsID9cclxuICAgICAgICAgICAgICAgICcgaHJlZj1cIicgKyB1dGlsXzEuaHRtbEVzY2FwZShldmVudERlZi51cmwpICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAoc2tpbkNzcyA/XHJcbiAgICAgICAgICAgICAgICAnIHN0eWxlPVwiJyArIHNraW5Dc3MgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+JyArXHJcbiAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtY29udGVudFwiPicgK1xyXG4gICAgICAgICAgICAodGltZVRleHQgP1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy10aW1lXCInICtcclxuICAgICAgICAgICAgICAgICAgICAnIGRhdGEtc3RhcnQ9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoc3RhcnRUaW1lVGV4dCkgKyAnXCInICtcclxuICAgICAgICAgICAgICAgICAgICAnIGRhdGEtZnVsbD1cIicgKyB1dGlsXzEuaHRtbEVzY2FwZShmdWxsVGltZVRleHQpICsgJ1wiJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJz4nICtcclxuICAgICAgICAgICAgICAgICAgICAnPHNwYW4+JyArIHV0aWxfMS5odG1sRXNjYXBlKHRpbWVUZXh0KSArICc8L3NwYW4+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvZGl2PicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKGV2ZW50RGVmLnRpdGxlID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtdGl0bGVcIj4nICtcclxuICAgICAgICAgICAgICAgICAgICB1dGlsXzEuaHRtbEVzY2FwZShldmVudERlZi50aXRsZSkgK1xyXG4gICAgICAgICAgICAgICAgICAgICc8L2Rpdj4nIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1iZ1wiPjwvZGl2PicgK1xyXG4gICAgICAgICAgICAvKiBUT0RPOiB3cml0ZSBDU1MgZm9yIHRoaXNcclxuICAgICAgICAgICAgKGlzUmVzaXphYmxlRnJvbVN0YXJ0ID9cclxuICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLXJlc2l6ZXIgZmMtc3RhcnQtcmVzaXplclwiPjwvZGl2PicgOlxyXG4gICAgICAgICAgICAgICcnXHJcbiAgICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIChpc1Jlc2l6YWJsZUZyb21FbmQgP1xyXG4gICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1yZXNpemVyIGZjLWVuZC1yZXNpemVyXCI+PC9kaXY+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC9hPic7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gc2VnbWVudHMgdGhhdCBhcmUgYXNzdW1lZCB0byBhbGwgbGl2ZSBpbiB0aGUgKnNhbWUgY29sdW1uKixcclxuICAgIC8vIGNvbXB1dGUgdGhlaXIgdmVyaWNhbC9ob3Jpem9udGFsIGNvb3JkaW5hdGVzIGFuZCBhc3NpZ24gdG8gdGhlaXIgZWxlbWVudHMuXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVwZGF0ZUZnU2VnQ29vcmRzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB0aGlzLnRpbWVHcmlkLmNvbXB1dGVTZWdWZXJ0aWNhbHMoc2Vncyk7IC8vIGhvcml6b250YWxzIHJlbGllcyBvbiB0aGlzXHJcbiAgICAgICAgdGhpcy5jb21wdXRlRmdTZWdIb3Jpem9udGFscyhzZWdzKTsgLy8gY29tcHV0ZSBob3Jpem9udGFsIGNvb3JkaW5hdGVzLCB6LWluZGV4J3MsIGFuZCByZW9yZGVyIHRoZSBhcnJheVxyXG4gICAgICAgIHRoaXMudGltZUdyaWQuYXNzaWduU2VnVmVydGljYWxzKHNlZ3MpO1xyXG4gICAgICAgIHRoaXMuYXNzaWduRmdTZWdIb3Jpem9udGFscyhzZWdzKTtcclxuICAgIH07XHJcbiAgICAvLyBHaXZlbiBhbiBhcnJheSBvZiBzZWdtZW50cyB0aGF0IGFyZSBhbGwgaW4gdGhlIHNhbWUgY29sdW1uLCBzZXRzIHRoZSBiYWNrd2FyZENvb3JkIGFuZCBmb3J3YXJkQ29vcmQgb24gZWFjaC5cclxuICAgIC8vIE5PVEU6IEFsc28gcmVvcmRlcnMgdGhlIGdpdmVuIGFycmF5IGJ5IGRhdGUhXHJcbiAgICBUaW1lR3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmNvbXB1dGVGZ1NlZ0hvcml6b250YWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgbGV2ZWxzO1xyXG4gICAgICAgIHZhciBsZXZlbDA7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdGhpcy5zb3J0RXZlbnRTZWdzKHNlZ3MpOyAvLyBvcmRlciBieSBjZXJ0YWluIGNyaXRlcmlhXHJcbiAgICAgICAgbGV2ZWxzID0gYnVpbGRTbG90U2VnTGV2ZWxzKHNlZ3MpO1xyXG4gICAgICAgIGNvbXB1dGVGb3J3YXJkU2xvdFNlZ3MobGV2ZWxzKTtcclxuICAgICAgICBpZiAoKGxldmVsMCA9IGxldmVsc1swXSkpIHtcclxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsMC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29tcHV0ZVNsb3RTZWdQcmVzc3VyZXMobGV2ZWwwW2ldKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWwwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGxldmVsMFtpXSwgMCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gQ2FsY3VsYXRlIHNlZy5mb3J3YXJkQ29vcmQgYW5kIHNlZy5iYWNrd2FyZENvb3JkIGZvciB0aGUgc2VnbWVudCwgd2hlcmUgYm90aCB2YWx1ZXMgcmFuZ2VcclxuICAgIC8vIGZyb20gMCB0byAxLiBJZiB0aGUgY2FsZW5kYXIgaXMgbGVmdC10by1yaWdodCwgdGhlIHNlZy5iYWNrd2FyZENvb3JkIG1hcHMgdG8gXCJsZWZ0XCIgYW5kXHJcbiAgICAvLyBzZWcuZm9yd2FyZENvb3JkIG1hcHMgdG8gXCJyaWdodFwiICh2aWEgcGVyY2VudGFnZSkuIFZpY2UtdmVyc2EgaWYgdGhlIGNhbGVuZGFyIGlzIHJpZ2h0LXRvLWxlZnQuXHJcbiAgICAvL1xyXG4gICAgLy8gVGhlIHNlZ21lbnQgbWlnaHQgYmUgcGFydCBvZiBhIFwic2VyaWVzXCIsIHdoaWNoIG1lYW5zIGNvbnNlY3V0aXZlIHNlZ21lbnRzIHdpdGggdGhlIHNhbWUgcHJlc3N1cmVcclxuICAgIC8vIHdobydzIHdpZHRoIGlzIHVua25vd24gdW50aWwgYW4gZWRnZSBoYXMgYmVlbiBoaXQuIGBzZXJpZXNCYWNrd2FyZFByZXNzdXJlYCBpcyB0aGUgbnVtYmVyIG9mXHJcbiAgICAvLyBzZWdtZW50cyBiZWhpbmQgdGhpcyBvbmUgaW4gdGhlIGN1cnJlbnQgc2VyaWVzLCBhbmQgYHNlcmllc0JhY2t3YXJkQ29vcmRgIGlzIHRoZSBzdGFydGluZ1xyXG4gICAgLy8gY29vcmRpbmF0ZSBvZiB0aGUgZmlyc3Qgc2VnbWVudCBpbiB0aGUgc2VyaWVzLlxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRmdTZWdGb3J3YXJkQmFjayA9IGZ1bmN0aW9uIChzZWcsIHNlcmllc0JhY2t3YXJkUHJlc3N1cmUsIHNlcmllc0JhY2t3YXJkQ29vcmQpIHtcclxuICAgICAgICB2YXIgZm9yd2FyZFNlZ3MgPSBzZWcuZm9yd2FyZFNlZ3M7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgaWYgKHNlZy5mb3J3YXJkQ29vcmQgPT09IHVuZGVmaW5lZCkgeyAvLyBub3QgYWxyZWFkeSBjb21wdXRlZFxyXG4gICAgICAgICAgICBpZiAoIWZvcndhcmRTZWdzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGZvcndhcmQgc2VnbWVudHMsIHRoaXMgc2VnbWVudCBzaG91bGQgYnV0dCB1cCBhZ2FpbnN0IHRoZSBlZGdlXHJcbiAgICAgICAgICAgICAgICBzZWcuZm9yd2FyZENvb3JkID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIHNvcnQgaGlnaGVzdCBwcmVzc3VyZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zb3J0Rm9yd2FyZFNlZ3MoZm9yd2FyZFNlZ3MpO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzZWdtZW50J3MgZm9yd2FyZENvb3JkIHdpbGwgYmUgY2FsY3VsYXRlZCBmcm9tIHRoZSBiYWNrd2FyZENvb3JkIG9mIHRoZVxyXG4gICAgICAgICAgICAgICAgLy8gaGlnaGVzdC1wcmVzc3VyZSBmb3J3YXJkIHNlZ21lbnQuXHJcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXB1dGVGZ1NlZ0ZvcndhcmRCYWNrKGZvcndhcmRTZWdzWzBdLCBzZXJpZXNCYWNrd2FyZFByZXNzdXJlICsgMSwgc2VyaWVzQmFja3dhcmRDb29yZCk7XHJcbiAgICAgICAgICAgICAgICBzZWcuZm9yd2FyZENvb3JkID0gZm9yd2FyZFNlZ3NbMF0uYmFja3dhcmRDb29yZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIGJhY2t3YXJkQ29vcmQgZnJvbSB0aGUgZm9yd2FyZENvb3JkLiBjb25zaWRlciB0aGUgc2VyaWVzXHJcbiAgICAgICAgICAgIHNlZy5iYWNrd2FyZENvb3JkID0gc2VnLmZvcndhcmRDb29yZCAtXHJcbiAgICAgICAgICAgICAgICAoc2VnLmZvcndhcmRDb29yZCAtIHNlcmllc0JhY2t3YXJkQ29vcmQpIC8gLy8gYXZhaWxhYmxlIHdpZHRoIGZvciBzZXJpZXNcclxuICAgICAgICAgICAgICAgICAgICAoc2VyaWVzQmFja3dhcmRQcmVzc3VyZSArIDEpOyAvLyAjIG9mIHNlZ21lbnRzIGluIHRoZSBzZXJpZXNcclxuICAgICAgICAgICAgLy8gdXNlIHRoaXMgc2VnbWVudCdzIGNvb3JkaW5hdGVzIHRvIGNvbXB1dGVkIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgbGVzcy1wcmVzc3VyaXplZFxyXG4gICAgICAgICAgICAvLyBmb3J3YXJkIHNlZ21lbnRzXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmb3J3YXJkU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlRmdTZWdGb3J3YXJkQmFjayhmb3J3YXJkU2Vnc1tpXSwgMCwgc2VnLmZvcndhcmRDb29yZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5zb3J0Rm9yd2FyZFNlZ3MgPSBmdW5jdGlvbiAoZm9yd2FyZFNlZ3MpIHtcclxuICAgICAgICBmb3J3YXJkU2Vncy5zb3J0KHV0aWxfMS5wcm94eSh0aGlzLCAnY29tcGFyZUZvcndhcmRTZWdzJykpO1xyXG4gICAgfTtcclxuICAgIC8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB3aGljaCBmb3J3YXJkIHNlZ21lbnQgdG8gcmVseSBvbiBtb3JlIHdoZW4gY29tcHV0aW5nIGNvb3JkaW5hdGVzLlxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wYXJlRm9yd2FyZFNlZ3MgPSBmdW5jdGlvbiAoc2VnMSwgc2VnMikge1xyXG4gICAgICAgIC8vIHB1dCBoaWdoZXItcHJlc3N1cmUgZmlyc3RcclxuICAgICAgICByZXR1cm4gc2VnMi5mb3J3YXJkUHJlc3N1cmUgLSBzZWcxLmZvcndhcmRQcmVzc3VyZSB8fFxyXG4gICAgICAgICAgICAvLyBwdXQgc2VnbWVudHMgdGhhdCBhcmUgY2xvc2VyIHRvIGluaXRpYWwgZWRnZSBmaXJzdCAoYW5kIGZhdm9yIG9uZXMgd2l0aCBubyBjb29yZHMgeWV0KVxyXG4gICAgICAgICAgICAoc2VnMS5iYWNrd2FyZENvb3JkIHx8IDApIC0gKHNlZzIuYmFja3dhcmRDb29yZCB8fCAwKSB8fFxyXG4gICAgICAgICAgICAvLyBkbyBub3JtYWwgc29ydGluZy4uLlxyXG4gICAgICAgICAgICB0aGlzLmNvbXBhcmVFdmVudFNlZ3Moc2VnMSwgc2VnMik7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gZm9yZWdyb3VuZCBldmVudCBzZWdtZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBoYWQgdGhlaXIgcG9zaXRpb24gY29vcmRpbmF0ZXMgY29tcHV0ZWQsXHJcbiAgICAvLyBhc3NpZ25zIHBvc2l0aW9uLXJlbGF0ZWQgQ1NTIHZhbHVlcyB0byB0aGVpciBlbGVtZW50cy5cclxuICAgIFRpbWVHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuYXNzaWduRmdTZWdIb3Jpem9udGFscyA9IGZ1bmN0aW9uIChzZWdzKSB7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICBzZWcuZWwuY3NzKHRoaXMuZ2VuZXJhdGVGZ1NlZ0hvcml6b250YWxDc3Moc2VnKSk7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBldmVudCBpcyBzaG9ydCB0aGF0IHRoZSB0aXRsZSB3aWxsIGJlIGN1dCBvZmYsXHJcbiAgICAgICAgICAgIC8vIGF0dGFjaCBhIGNsYXNzTmFtZSB0aGF0IGNvbmRlbnNlcyB0aGUgdGl0bGUgaW50byB0aGUgdGltZSBhcmVhLlxyXG4gICAgICAgICAgICBpZiAoc2VnLmZvb3RwcmludC5ldmVudERlZi50aXRsZSAmJiBzZWcuYm90dG9tIC0gc2VnLnRvcCA8IDMwKSB7XHJcbiAgICAgICAgICAgICAgICBzZWcuZWwuYWRkQ2xhc3MoJ2ZjLXNob3J0Jyk7IC8vIFRPRE86IFwiY29uZGVuc2VkXCIgaXMgYSBiZXR0ZXIgbmFtZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyBhbiBvYmplY3Qgd2l0aCBDU1MgcHJvcGVydGllcy92YWx1ZXMgdGhhdCBzaG91bGQgYmUgYXBwbGllZCB0byBhbiBldmVudCBzZWdtZW50IGVsZW1lbnQuXHJcbiAgICAvLyBDb250YWlucyBpbXBvcnRhbnQgcG9zaXRpb25pbmctcmVsYXRlZCBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgdG8gYW55IGV2ZW50IGVsZW1lbnQsIGN1c3RvbWl6ZWQgb3Igbm90LlxyXG4gICAgVGltZUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5nZW5lcmF0ZUZnU2VnSG9yaXpvbnRhbENzcyA9IGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICB2YXIgc2hvdWxkT3ZlcmxhcCA9IHRoaXMub3B0KCdzbG90RXZlbnRPdmVybGFwJyk7XHJcbiAgICAgICAgdmFyIGJhY2t3YXJkQ29vcmQgPSBzZWcuYmFja3dhcmRDb29yZDsgLy8gdGhlIGxlZnQgc2lkZSBpZiBMVFIuIHRoZSByaWdodCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcclxuICAgICAgICB2YXIgZm9yd2FyZENvb3JkID0gc2VnLmZvcndhcmRDb29yZDsgLy8gdGhlIHJpZ2h0IHNpZGUgaWYgTFRSLiB0aGUgbGVmdCBzaWRlIGlmIFJUTC4gZmxvYXRpbmctcG9pbnRcclxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnRpbWVHcmlkLmdlbmVyYXRlU2VnVmVydGljYWxDc3Moc2VnKTsgLy8gZ2V0IHRvcC9ib3R0b20gZmlyc3RcclxuICAgICAgICB2YXIgaXNSVEwgPSB0aGlzLnRpbWVHcmlkLmlzUlRMO1xyXG4gICAgICAgIHZhciBsZWZ0OyAvLyBhbW91bnQgb2Ygc3BhY2UgZnJvbSBsZWZ0IGVkZ2UsIGEgZnJhY3Rpb24gb2YgdGhlIHRvdGFsIHdpZHRoXHJcbiAgICAgICAgdmFyIHJpZ2h0OyAvLyBhbW91bnQgb2Ygc3BhY2UgZnJvbSByaWdodCBlZGdlLCBhIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCB3aWR0aFxyXG4gICAgICAgIGlmIChzaG91bGRPdmVybGFwKSB7XHJcbiAgICAgICAgICAgIC8vIGRvdWJsZSB0aGUgd2lkdGgsIGJ1dCBkb24ndCBnbyBiZXlvbmQgdGhlIG1heGltdW0gZm9yd2FyZCBjb29yZGluYXRlICgxLjApXHJcbiAgICAgICAgICAgIGZvcndhcmRDb29yZCA9IE1hdGgubWluKDEsIGJhY2t3YXJkQ29vcmQgKyAoZm9yd2FyZENvb3JkIC0gYmFja3dhcmRDb29yZCkgKiAyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzUlRMKSB7XHJcbiAgICAgICAgICAgIGxlZnQgPSAxIC0gZm9yd2FyZENvb3JkO1xyXG4gICAgICAgICAgICByaWdodCA9IGJhY2t3YXJkQ29vcmQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWZ0ID0gYmFja3dhcmRDb29yZDtcclxuICAgICAgICAgICAgcmlnaHQgPSAxIC0gZm9yd2FyZENvb3JkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcm9wcy56SW5kZXggPSBzZWcubGV2ZWwgKyAxOyAvLyBjb252ZXJ0IGZyb20gMC1iYXNlIHRvIDEtYmFzZWRcclxuICAgICAgICBwcm9wcy5sZWZ0ID0gbGVmdCAqIDEwMCArICclJztcclxuICAgICAgICBwcm9wcy5yaWdodCA9IHJpZ2h0ICogMTAwICsgJyUnO1xyXG4gICAgICAgIGlmIChzaG91bGRPdmVybGFwICYmIHNlZy5mb3J3YXJkUHJlc3N1cmUpIHtcclxuICAgICAgICAgICAgLy8gYWRkIHBhZGRpbmcgdG8gdGhlIGVkZ2Ugc28gdGhhdCBmb3J3YXJkIHN0YWNrZWQgZXZlbnRzIGRvbid0IGNvdmVyIHRoZSByZXNpemVyJ3MgaWNvblxyXG4gICAgICAgICAgICBwcm9wc1tpc1JUTCA/ICdtYXJnaW5MZWZ0JyA6ICdtYXJnaW5SaWdodCddID0gMTAgKiAyOyAvLyAxMCBpcyBhIGd1ZXNzdGltYXRlIG9mIHRoZSBpY29uJ3Mgd2lkdGhcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb3BzO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBUaW1lR3JpZEV2ZW50UmVuZGVyZXI7XHJcbn0oRXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVGltZUdyaWRFdmVudFJlbmRlcmVyO1xyXG4vLyBCdWlsZHMgYW4gYXJyYXkgb2Ygc2VnbWVudHMgXCJsZXZlbHNcIi4gVGhlIGZpcnN0IGxldmVsIHdpbGwgYmUgdGhlIGxlZnRtb3N0IHRpZXIgb2Ygc2VnbWVudHMgaWYgdGhlIGNhbGVuZGFyIGlzXHJcbi8vIGxlZnQtdG8tcmlnaHQsIG9yIHRoZSByaWdodG1vc3QgaWYgdGhlIGNhbGVuZGFyIGlzIHJpZ2h0LXRvLWxlZnQuIEFzc3VtZXMgdGhlIHNlZ21lbnRzIGFyZSBhbHJlYWR5IG9yZGVyZWQgYnkgZGF0ZS5cclxuZnVuY3Rpb24gYnVpbGRTbG90U2VnTGV2ZWxzKHNlZ3MpIHtcclxuICAgIHZhciBsZXZlbHMgPSBbXTtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIHNlZztcclxuICAgIHZhciBqO1xyXG4gICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgIC8vIGdvIHRocm91Z2ggYWxsIHRoZSBsZXZlbHMgYW5kIHN0b3Agb24gdGhlIGZpcnN0IGxldmVsIHdoZXJlIHRoZXJlIGFyZSBubyBjb2xsaXNpb25zXHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICBpZiAoIWNvbXB1dGVTbG90U2VnQ29sbGlzaW9ucyhzZWcsIGxldmVsc1tqXSkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzZWcubGV2ZWwgPSBqO1xyXG4gICAgICAgIChsZXZlbHNbal0gfHwgKGxldmVsc1tqXSA9IFtdKSkucHVzaChzZWcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGxldmVscztcclxufVxyXG4vLyBGb3IgZXZlcnkgc2VnbWVudCwgZmlndXJlIG91dCB0aGUgb3RoZXIgc2VnbWVudHMgdGhhdCBhcmUgaW4gc3Vic2VxdWVudFxyXG4vLyBsZXZlbHMgdGhhdCBhbHNvIG9jY3VweSB0aGUgc2FtZSB2ZXJ0aWNhbCBzcGFjZS4gQWNjdW11bGF0ZSBpbiBzZWcuZm9yd2FyZFNlZ3NcclxuZnVuY3Rpb24gY29tcHV0ZUZvcndhcmRTbG90U2VncyhsZXZlbHMpIHtcclxuICAgIHZhciBpO1xyXG4gICAgdmFyIGxldmVsO1xyXG4gICAgdmFyIGo7XHJcbiAgICB2YXIgc2VnO1xyXG4gICAgdmFyIGs7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGV2ZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgbGV2ZWwgPSBsZXZlbHNbaV07XHJcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVsLmxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IGxldmVsW2pdO1xyXG4gICAgICAgICAgICBzZWcuZm9yd2FyZFNlZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChrID0gaSArIDE7IGsgPCBsZXZlbHMubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbXB1dGVTbG90U2VnQ29sbGlzaW9ucyhzZWcsIGxldmVsc1trXSwgc2VnLmZvcndhcmRTZWdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vLyBGaWd1cmUgb3V0IHdoaWNoIHBhdGggZm9yd2FyZCAodmlhIHNlZy5mb3J3YXJkU2VncykgcmVzdWx0cyBpbiB0aGUgbG9uZ2VzdCBwYXRoIHVudGlsXHJcbi8vIHRoZSBmdXJ0aGVzdCBlZGdlIGlzIHJlYWNoZWQuIFRoZSBudW1iZXIgb2Ygc2VnbWVudHMgaW4gdGhpcyBwYXRoIHdpbGwgYmUgc2VnLmZvcndhcmRQcmVzc3VyZVxyXG5mdW5jdGlvbiBjb21wdXRlU2xvdFNlZ1ByZXNzdXJlcyhzZWcpIHtcclxuICAgIHZhciBmb3J3YXJkU2VncyA9IHNlZy5mb3J3YXJkU2VncztcclxuICAgIHZhciBmb3J3YXJkUHJlc3N1cmUgPSAwO1xyXG4gICAgdmFyIGk7XHJcbiAgICB2YXIgZm9yd2FyZFNlZztcclxuICAgIGlmIChzZWcuZm9yd2FyZFByZXNzdXJlID09PSB1bmRlZmluZWQpIHsgLy8gbm90IGFscmVhZHkgY29tcHV0ZWRcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZm9yd2FyZFNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yd2FyZFNlZyA9IGZvcndhcmRTZWdzW2ldO1xyXG4gICAgICAgICAgICAvLyBmaWd1cmUgb3V0IHRoZSBjaGlsZCdzIG1heGltdW0gZm9yd2FyZCBwYXRoXHJcbiAgICAgICAgICAgIGNvbXB1dGVTbG90U2VnUHJlc3N1cmVzKGZvcndhcmRTZWcpO1xyXG4gICAgICAgICAgICAvLyBlaXRoZXIgdXNlIHRoZSBleGlzdGluZyBtYXhpbXVtLCBvciB1c2UgdGhlIGNoaWxkJ3MgZm9yd2FyZCBwcmVzc3VyZVxyXG4gICAgICAgICAgICAvLyBwbHVzIG9uZSAoZm9yIHRoZSBmb3J3YXJkU2VnIGl0c2VsZilcclxuICAgICAgICAgICAgZm9yd2FyZFByZXNzdXJlID0gTWF0aC5tYXgoZm9yd2FyZFByZXNzdXJlLCAxICsgZm9yd2FyZFNlZy5mb3J3YXJkUHJlc3N1cmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZWcuZm9yd2FyZFByZXNzdXJlID0gZm9yd2FyZFByZXNzdXJlO1xyXG4gICAgfVxyXG59XHJcbi8vIEZpbmQgYWxsIHRoZSBzZWdtZW50cyBpbiBgb3RoZXJTZWdzYCB0aGF0IHZlcnRpY2FsbHkgY29sbGlkZSB3aXRoIGBzZWdgLlxyXG4vLyBBcHBlbmQgaW50byBhbiBvcHRpb25hbGx5LXN1cHBsaWVkIGByZXN1bHRzYCBhcnJheSBhbmQgcmV0dXJuLlxyXG5mdW5jdGlvbiBjb21wdXRlU2xvdFNlZ0NvbGxpc2lvbnMoc2VnLCBvdGhlclNlZ3MsIHJlc3VsdHMpIHtcclxuICAgIGlmIChyZXN1bHRzID09PSB2b2lkIDApIHsgcmVzdWx0cyA9IFtdOyB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG90aGVyU2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChpc1Nsb3RTZWdDb2xsaXNpb24oc2VnLCBvdGhlclNlZ3NbaV0pKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChvdGhlclNlZ3NbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRzO1xyXG59XHJcbi8vIERvIHRoZXNlIHNlZ21lbnRzIG9jY3VweSB0aGUgc2FtZSB2ZXJ0aWNhbCBzcGFjZT9cclxuZnVuY3Rpb24gaXNTbG90U2VnQ29sbGlzaW9uKHNlZzEsIHNlZzIpIHtcclxuICAgIHJldHVybiBzZWcxLmJvdHRvbSA+IHNlZzIudG9wICYmIHNlZzEudG9wIDwgc2VnMi5ib3R0b207XHJcbn1cclxuXG5cbi8qKiovIH0pLFxuLyogMjQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBIZWxwZXJSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Myk7XHJcbnZhciBUaW1lR3JpZEhlbHBlclJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVGltZUdyaWRIZWxwZXJSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbWVHcmlkSGVscGVyUmVuZGVyZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgVGltZUdyaWRIZWxwZXJSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyU2VncyA9IGZ1bmN0aW9uIChzZWdzLCBzb3VyY2VTZWcpIHtcclxuICAgICAgICB2YXIgaGVscGVyTm9kZXMgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciBzb3VyY2VFbDtcclxuICAgICAgICAvLyBUT0RPOiBub3QgZ29vZCB0byBjYWxsIGV2ZW50UmVuZGVyZXIgdGhpcyB3YXlcclxuICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIucmVuZGVyRmdTZWdzSW50b0NvbnRhaW5lcnMoc2VncywgdGhpcy5jb21wb25lbnQuaGVscGVyQ29udGFpbmVyRWxzKTtcclxuICAgICAgICAvLyBUcnkgdG8gbWFrZSB0aGUgc2VnbWVudCB0aGF0IGlzIGluIHRoZSBzYW1lIHJvdyBhcyBzb3VyY2VTZWcgbG9vayB0aGUgc2FtZVxyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VTZWcgJiYgc291cmNlU2VnLmNvbCA9PT0gc2VnLmNvbCkge1xyXG4gICAgICAgICAgICAgICAgc291cmNlRWwgPSBzb3VyY2VTZWcuZWw7XHJcbiAgICAgICAgICAgICAgICBzZWcuZWwuY3NzKHtcclxuICAgICAgICAgICAgICAgICAgICBsZWZ0OiBzb3VyY2VFbC5jc3MoJ2xlZnQnKSxcclxuICAgICAgICAgICAgICAgICAgICByaWdodDogc291cmNlRWwuY3NzKCdyaWdodCcpLFxyXG4gICAgICAgICAgICAgICAgICAgICdtYXJnaW4tbGVmdCc6IHNvdXJjZUVsLmNzcygnbWFyZ2luLWxlZnQnKSxcclxuICAgICAgICAgICAgICAgICAgICAnbWFyZ2luLXJpZ2h0Jzogc291cmNlRWwuY3NzKCdtYXJnaW4tcmlnaHQnKVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaGVscGVyTm9kZXMucHVzaChzZWcuZWxbMF0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJChoZWxwZXJOb2Rlcyk7IC8vIG11c3QgcmV0dXJuIHRoZSBlbGVtZW50cyByZW5kZXJlZFxyXG4gICAgfTtcclxuICAgIHJldHVybiBUaW1lR3JpZEhlbHBlclJlbmRlcmVyO1xyXG59KEhlbHBlclJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUaW1lR3JpZEhlbHBlclJlbmRlcmVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBGaWxsUmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xyXG52YXIgVGltZUdyaWRGaWxsUmVuZGVyZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhUaW1lR3JpZEZpbGxSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFRpbWVHcmlkRmlsbFJlbmRlcmVyKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIFRpbWVHcmlkRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5hdHRhY2hTZWdFbHMgPSBmdW5jdGlvbiAodHlwZSwgc2Vncykge1xyXG4gICAgICAgIHZhciB0aW1lR3JpZCA9IHRoaXMuY29tcG9uZW50O1xyXG4gICAgICAgIHZhciBjb250YWluZXJFbHM7XHJcbiAgICAgICAgLy8gVE9ETzogbW9yZSBlZmZpY2llbnQgbG9va3VwXHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdiZ0V2ZW50Jykge1xyXG4gICAgICAgICAgICBjb250YWluZXJFbHMgPSB0aW1lR3JpZC5iZ0NvbnRhaW5lckVscztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZSA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XHJcbiAgICAgICAgICAgIGNvbnRhaW5lckVscyA9IHRpbWVHcmlkLmJ1c2luZXNzQ29udGFpbmVyRWxzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnaGlnaGxpZ2h0Jykge1xyXG4gICAgICAgICAgICBjb250YWluZXJFbHMgPSB0aW1lR3JpZC5oaWdobGlnaHRDb250YWluZXJFbHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpbWVHcmlkLnVwZGF0ZVNlZ1ZlcnRpY2FscyhzZWdzKTtcclxuICAgICAgICB0aW1lR3JpZC5hdHRhY2hTZWdzQnlDb2wodGltZUdyaWQuZ3JvdXBTZWdzQnlDb2woc2VncyksIGNvbnRhaW5lckVscyk7XHJcbiAgICAgICAgcmV0dXJuIHNlZ3MubWFwKGZ1bmN0aW9uIChzZWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNlZy5lbFswXTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVGltZUdyaWRGaWxsUmVuZGVyZXI7XHJcbn0oRmlsbFJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBUaW1lR3JpZEZpbGxSZW5kZXJlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgRXZlbnRSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NCk7XHJcbi8qIEV2ZW50LXJlbmRlcmluZyBtZXRob2RzIGZvciB0aGUgRGF5R3JpZCBjbGFzc1xyXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cclxudmFyIERheUdyaWRFdmVudFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF5R3JpZEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBEYXlHcmlkRXZlbnRSZW5kZXJlcihkYXlHcmlkLCBmaWxsUmVuZGVyZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkYXlHcmlkLCBmaWxsUmVuZGVyZXIpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZGF5R3JpZCA9IGRheUdyaWQ7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlckJnUmFuZ2VzID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2VzKSB7XHJcbiAgICAgICAgLy8gZG9uJ3QgcmVuZGVyIHRpbWVkIGJhY2tncm91bmQgZXZlbnRzXHJcbiAgICAgICAgZXZlbnRSYW5nZXMgPSAkLmdyZXAoZXZlbnRSYW5nZXMsIGZ1bmN0aW9uIChldmVudFJhbmdlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBldmVudFJhbmdlLmV2ZW50RGVmLmlzQWxsRGF5KCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5yZW5kZXJCZ1Jhbmdlcy5jYWxsKHRoaXMsIGV2ZW50UmFuZ2VzKTtcclxuICAgIH07XHJcbiAgICAvLyBSZW5kZXJzIHRoZSBnaXZlbiBmb3JlZ3JvdW5kIGV2ZW50IHNlZ21lbnRzIG9udG8gdGhlIGdyaWRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGZ1NlZ3MgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3RzID0gdGhpcy5yb3dTdHJ1Y3RzID0gdGhpcy5yZW5kZXJTZWdSb3dzKHNlZ3MpO1xyXG4gICAgICAgIC8vIGFwcGVuZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b25cclxuICAgICAgICB0aGlzLmRheUdyaWQucm93RWxzLmVhY2goZnVuY3Rpb24gKGksIHJvd05vZGUpIHtcclxuICAgICAgICAgICAgJChyb3dOb2RlKS5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiA+IHRhYmxlJykuYXBwZW5kKHJvd1N0cnVjdHNbaV0udGJvZHlFbCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8gVW5yZW5kZXJzIGFsbCBjdXJyZW50bHkgcmVuZGVyZWQgZm9yZWdyb3VuZCBldmVudCBzZWdtZW50c1xyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnVucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3RzID0gdGhpcy5yb3dTdHJ1Y3RzIHx8IFtdO1xyXG4gICAgICAgIHZhciByb3dTdHJ1Y3Q7XHJcbiAgICAgICAgd2hpbGUgKChyb3dTdHJ1Y3QgPSByb3dTdHJ1Y3RzLnBvcCgpKSkge1xyXG4gICAgICAgICAgICByb3dTdHJ1Y3QudGJvZHlFbC5yZW1vdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yb3dTdHJ1Y3RzID0gbnVsbDtcclxuICAgIH07XHJcbiAgICAvLyBVc2VzIHRoZSBnaXZlbiBldmVudHMgYXJyYXkgdG8gZ2VuZXJhdGUgPHRib2R5PiBlbGVtZW50cyB0aGF0IHNob3VsZCBiZSBhcHBlbmRlZCB0byBlYWNoIHJvdydzIGNvbnRlbnQgc2tlbGV0b24uXHJcbiAgICAvLyBSZXR1cm5zIGFuIGFycmF5IG9mIHJvd1N0cnVjdCBvYmplY3RzIChzZWUgdGhlIGJvdHRvbSBvZiBgcmVuZGVyU2VnUm93YCkuXHJcbiAgICAvLyBQUkVDT05ESVRJT046IGVhY2ggc2VnbWVudCBzaG91ZCBhbHJlYWR5IGhhdmUgYSByZW5kZXJlZCBhbmQgYXNzaWduZWQgYC5lbGBcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJTZWdSb3dzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgcm93U3RydWN0cyA9IFtdO1xyXG4gICAgICAgIHZhciBzZWdSb3dzO1xyXG4gICAgICAgIHZhciByb3c7XHJcbiAgICAgICAgc2VnUm93cyA9IHRoaXMuZ3JvdXBTZWdSb3dzKHNlZ3MpOyAvLyBncm91cCBpbnRvIG5lc3RlZCBhcnJheXNcclxuICAgICAgICAvLyBpdGVyYXRlIGVhY2ggcm93IG9mIHNlZ21lbnQgZ3JvdXBpbmdzXHJcbiAgICAgICAgZm9yIChyb3cgPSAwOyByb3cgPCBzZWdSb3dzLmxlbmd0aDsgcm93KyspIHtcclxuICAgICAgICAgICAgcm93U3RydWN0cy5wdXNoKHRoaXMucmVuZGVyU2VnUm93KHJvdywgc2VnUm93c1tyb3ddKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByb3dTdHJ1Y3RzO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgcm93ICMgYW5kIGFuIGFycmF5IG9mIHNlZ21lbnRzIGFsbCBpbiB0aGUgc2FtZSByb3csIHJlbmRlciBhIDx0Ym9keT4gZWxlbWVudCwgYSBza2VsZXRvbiB0aGF0IGNvbnRhaW5zXHJcbiAgICAvLyB0aGUgc2VnbWVudHMuIFJldHVybnMgb2JqZWN0IHdpdGggYSBidW5jaCBvZiBpbnRlcm5hbCBkYXRhIGFib3V0IGhvdyB0aGUgcmVuZGVyIHdhcyBjYWxjdWxhdGVkLlxyXG4gICAgLy8gTk9URTogbW9kaWZpZXMgcm93U2Vnc1xyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ1JvdyA9IGZ1bmN0aW9uIChyb3csIHJvd1NlZ3MpIHtcclxuICAgICAgICB2YXIgY29sQ250ID0gdGhpcy5kYXlHcmlkLmNvbENudDtcclxuICAgICAgICB2YXIgc2VnTGV2ZWxzID0gdGhpcy5idWlsZFNlZ0xldmVscyhyb3dTZWdzKTsgLy8gZ3JvdXAgaW50byBzdWItYXJyYXlzIG9mIGxldmVsc1xyXG4gICAgICAgIHZhciBsZXZlbENudCA9IE1hdGgubWF4KDEsIHNlZ0xldmVscy5sZW5ndGgpOyAvLyBlbnN1cmUgYXQgbGVhc3Qgb25lIGxldmVsXHJcbiAgICAgICAgdmFyIHRib2R5ID0gJCgnPHRib2R5PicpO1xyXG4gICAgICAgIHZhciBzZWdNYXRyaXggPSBbXTsgLy8gbG9va3VwIGZvciB3aGljaCBzZWdtZW50cyBhcmUgcmVuZGVyZWQgaW50byB3aGljaCBsZXZlbCtjb2wgY2VsbHNcclxuICAgICAgICB2YXIgY2VsbE1hdHJpeCA9IFtdOyAvLyBsb29rdXAgZm9yIGFsbCA8dGQ+IGVsZW1lbnRzIG9mIHRoZSBsZXZlbCtjb2wgbWF0cml4XHJcbiAgICAgICAgdmFyIGxvbmVDZWxsTWF0cml4ID0gW107IC8vIGxvb2t1cCBmb3IgPHRkPiBlbGVtZW50cyB0aGF0IG9ubHkgdGFrZSB1cCBhIHNpbmdsZSBjb2x1bW5cclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgbGV2ZWxTZWdzO1xyXG4gICAgICAgIHZhciBjb2w7XHJcbiAgICAgICAgdmFyIHRyO1xyXG4gICAgICAgIHZhciBqO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgdmFyIHRkO1xyXG4gICAgICAgIC8vIHBvcHVsYXRlcyBlbXB0eSBjZWxscyBmcm9tIHRoZSBjdXJyZW50IGNvbHVtbiAoYGNvbGApIHRvIGBlbmRDb2xgXHJcbiAgICAgICAgZnVuY3Rpb24gZW1wdHlDZWxsc1VudGlsKGVuZENvbCkge1xyXG4gICAgICAgICAgICB3aGlsZSAoY29sIDwgZW5kQ29sKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0cnkgdG8gZ3JhYiBhIGNlbGwgZnJvbSB0aGUgbGV2ZWwgYWJvdmUgYW5kIGV4dGVuZCBpdHMgcm93c3Bhbi4gb3RoZXJ3aXNlLCBjcmVhdGUgYSBmcmVzaCBjZWxsXHJcbiAgICAgICAgICAgICAgICB0ZCA9IChsb25lQ2VsbE1hdHJpeFtpIC0gMV0gfHwgW10pW2NvbF07XHJcbiAgICAgICAgICAgICAgICBpZiAodGQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0ZC5hdHRyKCdyb3dzcGFuJywgcGFyc2VJbnQodGQuYXR0cigncm93c3BhbicpIHx8IDEsIDEwKSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGQgPSAkKCc8dGQ+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuYXBwZW5kKHRkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNlbGxNYXRyaXhbaV1bY29sXSA9IHRkO1xyXG4gICAgICAgICAgICAgICAgbG9uZUNlbGxNYXRyaXhbaV1bY29sXSA9IHRkO1xyXG4gICAgICAgICAgICAgICAgY29sKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxldmVsQ250OyBpKyspIHsgLy8gaXRlcmF0ZSB0aHJvdWdoIGFsbCBsZXZlbHNcclxuICAgICAgICAgICAgbGV2ZWxTZWdzID0gc2VnTGV2ZWxzW2ldO1xyXG4gICAgICAgICAgICBjb2wgPSAwO1xyXG4gICAgICAgICAgICB0ciA9ICQoJzx0cj4nKTtcclxuICAgICAgICAgICAgc2VnTWF0cml4LnB1c2goW10pO1xyXG4gICAgICAgICAgICBjZWxsTWF0cml4LnB1c2goW10pO1xyXG4gICAgICAgICAgICBsb25lQ2VsbE1hdHJpeC5wdXNoKFtdKTtcclxuICAgICAgICAgICAgLy8gbGV2ZWxDbnQgbWlnaHQgYmUgMSBldmVuIHRob3VnaCB0aGVyZSBhcmUgbm8gYWN0dWFsIGxldmVscy4gcHJvdGVjdCBhZ2FpbnN0IHRoaXMuXHJcbiAgICAgICAgICAgIC8vIHRoaXMgc2luZ2xlIGVtcHR5IHJvdyBpcyB1c2VmdWwgZm9yIHN0eWxpbmcuXHJcbiAgICAgICAgICAgIGlmIChsZXZlbFNlZ3MpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbFNlZ3MubGVuZ3RoOyBqKyspIHsgLy8gaXRlcmF0ZSB0aHJvdWdoIHNlZ21lbnRzIGluIGxldmVsXHJcbiAgICAgICAgICAgICAgICAgICAgc2VnID0gbGV2ZWxTZWdzW2pdO1xyXG4gICAgICAgICAgICAgICAgICAgIGVtcHR5Q2VsbHNVbnRpbChzZWcubGVmdENvbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgY29udGFpbmVyIHRoYXQgb2NjdXBpZXMgb3IgbW9yZSBjb2x1bW5zLiBhcHBlbmQgdGhlIGV2ZW50IGVsZW1lbnQuXHJcbiAgICAgICAgICAgICAgICAgICAgdGQgPSAkKCc8dGQgY2xhc3M9XCJmYy1ldmVudC1jb250YWluZXJcIj4nKS5hcHBlbmQoc2VnLmVsKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VnLmxlZnRDb2wgIT09IHNlZy5yaWdodENvbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZC5hdHRyKCdjb2xzcGFuJywgc2VnLnJpZ2h0Q29sIC0gc2VnLmxlZnRDb2wgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIGEgc2luZ2xlLWNvbHVtbiBzZWdtZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvbmVDZWxsTWF0cml4W2ldW2NvbF0gPSB0ZDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGNvbCA8PSBzZWcucmlnaHRDb2wpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbE1hdHJpeFtpXVtjb2xdID0gdGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZ01hdHJpeFtpXVtjb2xdID0gc2VnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2wrKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdHIuYXBwZW5kKHRkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbXB0eUNlbGxzVW50aWwoY29sQ250KTsgLy8gZmluaXNoIG9mZiB0aGUgcm93XHJcbiAgICAgICAgICAgIHRoaXMuZGF5R3JpZC5ib29rZW5kQ2VsbHModHIpO1xyXG4gICAgICAgICAgICB0Ym9keS5hcHBlbmQodHIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICByb3c6IHJvdyxcclxuICAgICAgICAgICAgdGJvZHlFbDogdGJvZHksXHJcbiAgICAgICAgICAgIGNlbGxNYXRyaXg6IGNlbGxNYXRyaXgsXHJcbiAgICAgICAgICAgIHNlZ01hdHJpeDogc2VnTWF0cml4LFxyXG4gICAgICAgICAgICBzZWdMZXZlbHM6IHNlZ0xldmVscyxcclxuICAgICAgICAgICAgc2Vnczogcm93U2Vnc1xyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLy8gU3RhY2tzIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgd2hpY2ggYXJlIGFsbCBhc3N1bWVkIHRvIGJlIGluIHRoZSBzYW1lIHJvdywgaW50byBzdWJhcnJheXMgb2YgdmVydGljYWwgbGV2ZWxzLlxyXG4gICAgLy8gTk9URTogbW9kaWZpZXMgc2Vnc1xyXG4gICAgRGF5R3JpZEV2ZW50UmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkU2VnTGV2ZWxzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgbGV2ZWxzID0gW107XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICB2YXIgajtcclxuICAgICAgICAvLyBHaXZlIHByZWZlcmVuY2UgdG8gZWxlbWVudHMgd2l0aCBjZXJ0YWluIGNyaXRlcmlhLCBzbyB0aGV5IGhhdmVcclxuICAgICAgICAvLyBhIGNoYW5jZSB0byBiZSBjbG9zZXIgdG8gdGhlIHRvcC5cclxuICAgICAgICB0aGlzLnNvcnRFdmVudFNlZ3Moc2Vncyk7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnID0gc2Vnc1tpXTtcclxuICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGxldmVscywgc3RhcnRpbmcgd2l0aCB0aGUgdG9wbW9zdCwgdW50aWwgdGhlIHNlZ21lbnQgZG9lc24ndCBjb2xsaWRlIHdpdGggb3RoZXIgc2VnbWVudHNcclxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxldmVscy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpc0RheVNlZ0NvbGxpc2lvbihzZWcsIGxldmVsc1tqXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBgamAgbm93IGhvbGRzIHRoZSBkZXNpcmVkIHN1YnJvdyBpbmRleFxyXG4gICAgICAgICAgICBzZWcubGV2ZWwgPSBqO1xyXG4gICAgICAgICAgICAvLyBjcmVhdGUgbmV3IGxldmVsIGFycmF5IGlmIG5lZWRlZCBhbmQgYXBwZW5kIHNlZ21lbnRcclxuICAgICAgICAgICAgKGxldmVsc1tqXSB8fCAobGV2ZWxzW2pdID0gW10pKS5wdXNoKHNlZyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG9yZGVyIHNlZ21lbnRzIGxlZnQtdG8tcmlnaHQuIHZlcnkgaW1wb3J0YW50IGlmIGNhbGVuZGFyIGlzIFJUTFxyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsZXZlbHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgbGV2ZWxzW2pdLnNvcnQoY29tcGFyZURheVNlZ0NvbHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbGV2ZWxzO1xyXG4gICAgfTtcclxuICAgIC8vIEdpdmVuIGEgZmxhdCBhcnJheSBvZiBzZWdtZW50cywgcmV0dXJuIGFuIGFycmF5IG9mIHN1Yi1hcnJheXMsIGdyb3VwZWQgYnkgZWFjaCBzZWdtZW50J3Mgcm93XHJcbiAgICBEYXlHcmlkRXZlbnRSZW5kZXJlci5wcm90b3R5cGUuZ3JvdXBTZWdSb3dzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICB2YXIgc2VnUm93cyA9IFtdO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmRheUdyaWQucm93Q250OyBpKyspIHtcclxuICAgICAgICAgICAgc2VnUm93cy5wdXNoKFtdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2VnUm93c1tzZWdzW2ldLnJvd10ucHVzaChzZWdzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ1Jvd3M7XHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGV2ZW50IHRpbWUgZm9ybWF0dGluZyBzdHJpbmcgaWYgYHRpbWVGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRXZlbnRUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnZXh0cmFTbWFsbFRpbWVGb3JtYXQnKTsgLy8gbGlrZSBcIjZwXCIgb3IgXCI2OjMwcFwiXHJcbiAgICB9O1xyXG4gICAgLy8gQ29tcHV0ZXMgYSBkZWZhdWx0IGBkaXNwbGF5RXZlbnRFbmRgIHZhbHVlIGlmIG9uZSBpcyBub3QgZXhwbGljbHR5IGRlZmluZWRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRGlzcGxheUV2ZW50RW5kID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRheUdyaWQuY29sQ250ID09PSAxOyAvLyB3ZSdsbCBsaWtlbHkgaGF2ZSBzcGFjZSBpZiB0aGVyZSdzIG9ubHkgb25lIGRheVxyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyB0aGUgSFRNTCB0byBiZSB1c2VkIGZvciB0aGUgZGVmYXVsdCBlbGVtZW50IGZvciBhbiBpbmRpdmlkdWFsIHNlZ21lbnRcclxuICAgIERheUdyaWRFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5mZ1NlZ0h0bWwgPSBmdW5jdGlvbiAoc2VnLCBkaXNhYmxlUmVzaXppbmcpIHtcclxuICAgICAgICB2YXIgdmlldyA9IHRoaXMudmlldztcclxuICAgICAgICB2YXIgZXZlbnREZWYgPSBzZWcuZm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBpc0FsbERheSA9IHNlZy5mb290cHJpbnQuY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5O1xyXG4gICAgICAgIHZhciBpc0RyYWdnYWJsZSA9IHZpZXcuaXNFdmVudERlZkRyYWdnYWJsZShldmVudERlZik7XHJcbiAgICAgICAgdmFyIGlzUmVzaXphYmxlRnJvbVN0YXJ0ID0gIWRpc2FibGVSZXNpemluZyAmJiBpc0FsbERheSAmJlxyXG4gICAgICAgICAgICBzZWcuaXNTdGFydCAmJiB2aWV3LmlzRXZlbnREZWZSZXNpemFibGVGcm9tU3RhcnQoZXZlbnREZWYpO1xyXG4gICAgICAgIHZhciBpc1Jlc2l6YWJsZUZyb21FbmQgPSAhZGlzYWJsZVJlc2l6aW5nICYmIGlzQWxsRGF5ICYmXHJcbiAgICAgICAgICAgIHNlZy5pc0VuZCAmJiB2aWV3LmlzRXZlbnREZWZSZXNpemFibGVGcm9tRW5kKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IHRoaXMuZ2V0U2VnQ2xhc3NlcyhzZWcsIGlzRHJhZ2dhYmxlLCBpc1Jlc2l6YWJsZUZyb21TdGFydCB8fCBpc1Jlc2l6YWJsZUZyb21FbmQpO1xyXG4gICAgICAgIHZhciBza2luQ3NzID0gdXRpbF8xLmNzc1RvU3RyKHRoaXMuZ2V0U2tpbkNzcyhldmVudERlZikpO1xyXG4gICAgICAgIHZhciB0aW1lSHRtbCA9ICcnO1xyXG4gICAgICAgIHZhciB0aW1lVGV4dDtcclxuICAgICAgICB2YXIgdGl0bGVIdG1sO1xyXG4gICAgICAgIGNsYXNzZXMudW5zaGlmdCgnZmMtZGF5LWdyaWQtZXZlbnQnLCAnZmMtaC1ldmVudCcpO1xyXG4gICAgICAgIC8vIE9ubHkgZGlzcGxheSBhIHRpbWVkIGV2ZW50cyB0aW1lIGlmIGl0IGlzIHRoZSBzdGFydGluZyBzZWdtZW50XHJcbiAgICAgICAgaWYgKHNlZy5pc1N0YXJ0KSB7XHJcbiAgICAgICAgICAgIHRpbWVUZXh0ID0gdGhpcy5nZXRUaW1lVGV4dChzZWcuZm9vdHByaW50KTtcclxuICAgICAgICAgICAgaWYgKHRpbWVUZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lSHRtbCA9ICc8c3BhbiBjbGFzcz1cImZjLXRpbWVcIj4nICsgdXRpbF8xLmh0bWxFc2NhcGUodGltZVRleHQpICsgJzwvc3Bhbj4nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRpdGxlSHRtbCA9XHJcbiAgICAgICAgICAgICc8c3BhbiBjbGFzcz1cImZjLXRpdGxlXCI+JyArXHJcbiAgICAgICAgICAgICAgICAodXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudGl0bGUgfHwgJycpIHx8ICcmbmJzcDsnKSArIC8vIHdlIGFsd2F5cyB3YW50IG9uZSBsaW5lIG9mIGhlaWdodFxyXG4gICAgICAgICAgICAgICAgJzwvc3Bhbj4nO1xyXG4gICAgICAgIHJldHVybiAnPGEgY2xhc3M9XCInICsgY2xhc3Nlcy5qb2luKCcgJykgKyAnXCInICtcclxuICAgICAgICAgICAgKGV2ZW50RGVmLnVybCA/XHJcbiAgICAgICAgICAgICAgICAnIGhyZWY9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUoZXZlbnREZWYudXJsKSArICdcIicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKHNraW5Dc3MgP1xyXG4gICAgICAgICAgICAgICAgJyBzdHlsZT1cIicgKyBza2luQ3NzICsgJ1wiJyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPicgK1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWNvbnRlbnRcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMuZGF5R3JpZC5pc1JUTCA/XHJcbiAgICAgICAgICAgICAgICB0aXRsZUh0bWwgKyAnICcgKyB0aW1lSHRtbCA6IC8vIHB1dCBhIG5hdHVyYWwgc3BhY2UgaW4gYmV0d2VlblxyXG4gICAgICAgICAgICAgICAgdGltZUh0bWwgKyAnICcgKyB0aXRsZUh0bWwgLy9cclxuICAgICAgICAgICAgKSArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgKGlzUmVzaXphYmxlRnJvbVN0YXJ0ID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1zdGFydC1yZXNpemVyXCI+PC9kaXY+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAoaXNSZXNpemFibGVGcm9tRW5kID9cclxuICAgICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwiZmMtcmVzaXplciBmYy1lbmQtcmVzaXplclwiPjwvZGl2PicgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgJzwvYT4nO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBEYXlHcmlkRXZlbnRSZW5kZXJlcjtcclxufShFdmVudFJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXlHcmlkRXZlbnRSZW5kZXJlcjtcclxuLy8gQ29tcHV0ZXMgd2hldGhlciB0d28gc2VnbWVudHMnIGNvbHVtbnMgY29sbGlkZS4gVGhleSBhcmUgYXNzdW1lZCB0byBiZSBpbiB0aGUgc2FtZSByb3cuXHJcbmZ1bmN0aW9uIGlzRGF5U2VnQ29sbGlzaW9uKHNlZywgb3RoZXJTZWdzKSB7XHJcbiAgICB2YXIgaTtcclxuICAgIHZhciBvdGhlclNlZztcclxuICAgIGZvciAoaSA9IDA7IGkgPCBvdGhlclNlZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBvdGhlclNlZyA9IG90aGVyU2Vnc1tpXTtcclxuICAgICAgICBpZiAob3RoZXJTZWcubGVmdENvbCA8PSBzZWcucmlnaHRDb2wgJiZcclxuICAgICAgICAgICAgb3RoZXJTZWcucmlnaHRDb2wgPj0gc2VnLmxlZnRDb2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59XHJcbi8vIEEgY21wIGZ1bmN0aW9uIGZvciBkZXRlcm1pbmluZyB0aGUgbGVmdG1vc3QgZXZlbnRcclxuZnVuY3Rpb24gY29tcGFyZURheVNlZ0NvbHMoYSwgYikge1xyXG4gICAgcmV0dXJuIGEubGVmdENvbCAtIGIubGVmdENvbDtcclxufVxyXG5cblxuLyoqKi8gfSksXG4vKiAyNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIEhlbHBlclJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcclxudmFyIERheUdyaWRIZWxwZXJSZW5kZXJlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKERheUdyaWRIZWxwZXJSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERheUdyaWRIZWxwZXJSZW5kZXJlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBSZW5kZXJzIGEgbW9jayBcImhlbHBlclwiIGV2ZW50LiBgc291cmNlU2VnYCBpcyB0aGUgYXNzb2NpYXRlZCBpbnRlcm5hbCBzZWdtZW50IG9iamVjdC4gSXQgY2FuIGJlIG51bGwuXHJcbiAgICBEYXlHcmlkSGVscGVyUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclNlZ3MgPSBmdW5jdGlvbiAoc2Vncywgc291cmNlU2VnKSB7XHJcbiAgICAgICAgdmFyIGhlbHBlck5vZGVzID0gW107XHJcbiAgICAgICAgdmFyIHJvd1N0cnVjdHM7XHJcbiAgICAgICAgLy8gVE9ETzogbm90IGdvb2QgdG8gY2FsbCBldmVudFJlbmRlcmVyIHRoaXMgd2F5XHJcbiAgICAgICAgcm93U3RydWN0cyA9IHRoaXMuZXZlbnRSZW5kZXJlci5yZW5kZXJTZWdSb3dzKHNlZ3MpO1xyXG4gICAgICAgIC8vIGluamVjdCBlYWNoIG5ldyBldmVudCBza2VsZXRvbiBpbnRvIGVhY2ggYXNzb2NpYXRlZCByb3dcclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5yb3dFbHMuZWFjaChmdW5jdGlvbiAocm93LCByb3dOb2RlKSB7XHJcbiAgICAgICAgICAgIHZhciByb3dFbCA9ICQocm93Tm9kZSk7IC8vIHRoZSAuZmMtcm93XHJcbiAgICAgICAgICAgIHZhciBza2VsZXRvbkVsID0gJCgnPGRpdiBjbGFzcz1cImZjLWhlbHBlci1za2VsZXRvblwiPjx0YWJsZT48L3RhYmxlPjwvZGl2PicpOyAvLyB3aWxsIGJlIGFic29sdXRlbHkgcG9zaXRpb25lZFxyXG4gICAgICAgICAgICB2YXIgc2tlbGV0b25Ub3BFbDtcclxuICAgICAgICAgICAgdmFyIHNrZWxldG9uVG9wO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhbiBvcmlnaW5hbCBzZWdtZW50LCBtYXRjaCB0aGUgdG9wIHBvc2l0aW9uLiBPdGhlcndpc2UsIHB1dCBpdCBhdCB0aGUgcm93J3MgdG9wIGxldmVsXHJcbiAgICAgICAgICAgIGlmIChzb3VyY2VTZWcgJiYgc291cmNlU2VnLnJvdyA9PT0gcm93KSB7XHJcbiAgICAgICAgICAgICAgICBza2VsZXRvblRvcCA9IHNvdXJjZVNlZy5lbC5wb3NpdGlvbigpLnRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNrZWxldG9uVG9wRWwgPSByb3dFbC5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiB0Ym9keScpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFza2VsZXRvblRvcEVsLmxlbmd0aCkgeyAvLyB3aGVuIG5vIGV2ZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIHNrZWxldG9uVG9wRWwgPSByb3dFbC5maW5kKCcuZmMtY29udGVudC1za2VsZXRvbiB0YWJsZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgc2tlbGV0b25Ub3AgPSBza2VsZXRvblRvcEVsLnBvc2l0aW9uKCkudG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNrZWxldG9uRWwuY3NzKCd0b3AnLCBza2VsZXRvblRvcClcclxuICAgICAgICAgICAgICAgIC5maW5kKCd0YWJsZScpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHJvd1N0cnVjdHNbcm93XS50Ym9keUVsKTtcclxuICAgICAgICAgICAgcm93RWwuYXBwZW5kKHNrZWxldG9uRWwpO1xyXG4gICAgICAgICAgICBoZWxwZXJOb2Rlcy5wdXNoKHNrZWxldG9uRWxbMF0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiAkKGhlbHBlck5vZGVzKTsgLy8gbXVzdCByZXR1cm4gdGhlIGVsZW1lbnRzIHJlbmRlcmVkXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERheUdyaWRIZWxwZXJSZW5kZXJlcjtcclxufShIZWxwZXJSZW5kZXJlcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGF5R3JpZEhlbHBlclJlbmRlcmVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIEZpbGxSZW5kZXJlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Mik7XHJcbnZhciBEYXlHcmlkRmlsbFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGF5R3JpZEZpbGxSZW5kZXJlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERheUdyaWRGaWxsUmVuZGVyZXIoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuZmlsbFNlZ1RhZyA9ICd0ZCc7IC8vIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHRhZyBuYW1lXHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGF5R3JpZEZpbGxSZW5kZXJlci5wcm90b3R5cGUuYXR0YWNoU2VnRWxzID0gZnVuY3Rpb24gKHR5cGUsIHNlZ3MpIHtcclxuICAgICAgICB2YXIgbm9kZXMgPSBbXTtcclxuICAgICAgICB2YXIgaTtcclxuICAgICAgICB2YXIgc2VnO1xyXG4gICAgICAgIHZhciBza2VsZXRvbkVsO1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHNlZyA9IHNlZ3NbaV07XHJcbiAgICAgICAgICAgIHNrZWxldG9uRWwgPSB0aGlzLnJlbmRlckZpbGxSb3codHlwZSwgc2VnKTtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucm93RWxzLmVxKHNlZy5yb3cpLmFwcGVuZChza2VsZXRvbkVsKTtcclxuICAgICAgICAgICAgbm9kZXMucHVzaChza2VsZXRvbkVsWzBdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xyXG4gICAgfTtcclxuICAgIC8vIEdlbmVyYXRlcyB0aGUgSFRNTCBuZWVkZWQgZm9yIG9uZSByb3cgb2YgYSBmaWxsLiBSZXF1aXJlcyB0aGUgc2VnJ3MgZWwgdG8gYmUgcmVuZGVyZWQuXHJcbiAgICBEYXlHcmlkRmlsbFJlbmRlcmVyLnByb3RvdHlwZS5yZW5kZXJGaWxsUm93ID0gZnVuY3Rpb24gKHR5cGUsIHNlZykge1xyXG4gICAgICAgIHZhciBjb2xDbnQgPSB0aGlzLmNvbXBvbmVudC5jb2xDbnQ7XHJcbiAgICAgICAgdmFyIHN0YXJ0Q29sID0gc2VnLmxlZnRDb2w7XHJcbiAgICAgICAgdmFyIGVuZENvbCA9IHNlZy5yaWdodENvbCArIDE7XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZTtcclxuICAgICAgICB2YXIgc2tlbGV0b25FbDtcclxuICAgICAgICB2YXIgdHJFbDtcclxuICAgICAgICBpZiAodHlwZSA9PT0gJ2J1c2luZXNzSG91cnMnKSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9ICdiZ2V2ZW50JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2tlbGV0b25FbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy0nICsgY2xhc3NOYW1lICsgJy1za2VsZXRvblwiPicgK1xyXG4gICAgICAgICAgICAnPHRhYmxlPjx0cj48L3RyPjwvdGFibGU+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nKTtcclxuICAgICAgICB0ckVsID0gc2tlbGV0b25FbC5maW5kKCd0cicpO1xyXG4gICAgICAgIGlmIChzdGFydENvbCA+IDApIHtcclxuICAgICAgICAgICAgdHJFbC5hcHBlbmQoXHJcbiAgICAgICAgICAgIC8vIHdpbGwgY3JlYXRlIChzdGFydENvbCArIDEpIHRkJ3NcclxuICAgICAgICAgICAgbmV3IEFycmF5KHN0YXJ0Q29sICsgMSkuam9pbignPHRkPjwvdGQ+JykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0ckVsLmFwcGVuZChzZWcuZWwuYXR0cignY29sc3BhbicsIGVuZENvbCAtIHN0YXJ0Q29sKSk7XHJcbiAgICAgICAgaWYgKGVuZENvbCA8IGNvbENudCkge1xyXG4gICAgICAgICAgICB0ckVsLmFwcGVuZChcclxuICAgICAgICAgICAgLy8gd2lsbCBjcmVhdGUgKGNvbENudCAtIGVuZENvbCkgdGQnc1xyXG4gICAgICAgICAgICBuZXcgQXJyYXkoY29sQ250IC0gZW5kQ29sICsgMSkuam9pbignPHRkPjwvdGQ+JykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbXBvbmVudC5ib29rZW5kQ2VsbHModHJFbCk7XHJcbiAgICAgICAgcmV0dXJuIHNrZWxldG9uRWw7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERheUdyaWRGaWxsUmVuZGVyZXI7XHJcbn0oRmlsbFJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBEYXlHcmlkRmlsbFJlbmRlcmVyO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbnZhciBtb21lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIEJhc2ljVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2Nyk7XHJcbnZhciBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDcpO1xyXG4vKiBBIG1vbnRoIHZpZXcgd2l0aCBkYXkgY2VsbHMgcnVubmluZyBpbiByb3dzIChvbmUtcGVyLXdlZWspIGFuZCBjb2x1bW5zXHJcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xyXG52YXIgTW9udGhWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTW9udGhWaWV3LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTW9udGhWaWV3KCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBCYXNpY1ZpZXcgYmVoYXZpb3IgdG8gaGF2ZSBzcGVjaWFsIG11bHRpLXdlZWsgYXV0by1oZWlnaHQgbG9naWNcclxuICAgIE1vbnRoVmlldy5wcm90b3R5cGUuc2V0R3JpZEhlaWdodCA9IGZ1bmN0aW9uIChoZWlnaHQsIGlzQXV0bykge1xyXG4gICAgICAgIC8vIGlmIGF1dG8sIG1ha2UgdGhlIGhlaWdodCBvZiBlYWNoIHJvdyB0aGUgaGVpZ2h0IHRoYXQgaXQgd291bGQgYmUgaWYgdGhlcmUgd2VyZSA2IHdlZWtzXHJcbiAgICAgICAgaWYgKGlzQXV0bykge1xyXG4gICAgICAgICAgICBoZWlnaHQgKj0gdGhpcy5kYXlHcmlkLnJvd0NudCAvIDY7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHV0aWxfMS5kaXN0cmlidXRlSGVpZ2h0KHRoaXMuZGF5R3JpZC5yb3dFbHMsIGhlaWdodCwgIWlzQXV0byk7IC8vIGlmIGF1dG8sIGRvbid0IGNvbXBlbnNhdGUgZm9yIGhlaWdodC1ob2dnaW5nIHJvd3NcclxuICAgIH07XHJcbiAgICBNb250aFZpZXcucHJvdG90eXBlLmlzRGF0ZUluT3RoZXJNb250aCA9IGZ1bmN0aW9uIChkYXRlLCBkYXRlUHJvZmlsZSkge1xyXG4gICAgICAgIHJldHVybiBkYXRlLm1vbnRoKCkgIT09IG1vbWVudC51dGMoZGF0ZVByb2ZpbGUuY3VycmVudFVuem9uZWRSYW5nZS5zdGFydE1zKS5tb250aCgpOyAvLyBUT0RPOiBvcHRpbWl6ZVxyXG4gICAgfTtcclxuICAgIHJldHVybiBNb250aFZpZXc7XHJcbn0oQmFzaWNWaWV3XzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBNb250aFZpZXc7XHJcbk1vbnRoVmlldy5wcm90b3R5cGUuZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyA9IE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yXzEuZGVmYXVsdDtcclxuXG5cbi8qKiovIH0pLFxuLyogMjQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgQmFzaWNWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3JfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNjgpO1xyXG52YXIgVW56b25lZFJhbmdlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG52YXIgTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIC8vIENvbXB1dGVzIHRoZSBkYXRlIHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZC5cclxuICAgIE1vbnRoVmlld0RhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlID0gZnVuY3Rpb24gKGN1cnJlbnRVbnpvbmVkUmFuZ2UsIGN1cnJlbnRSYW5nZVVuaXQsIGlzUmFuZ2VBbGxEYXkpIHtcclxuICAgICAgICB2YXIgcmVuZGVyVW56b25lZFJhbmdlID0gX3N1cGVyLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlLmNhbGwodGhpcywgY3VycmVudFVuem9uZWRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5tc1RvVXRjTW9tZW50KHJlbmRlclVuem9uZWRSYW5nZS5zdGFydE1zLCBpc1JhbmdlQWxsRGF5KTtcclxuICAgICAgICB2YXIgZW5kID0gdGhpcy5tc1RvVXRjTW9tZW50KHJlbmRlclVuem9uZWRSYW5nZS5lbmRNcywgaXNSYW5nZUFsbERheSk7XHJcbiAgICAgICAgdmFyIHJvd0NudDtcclxuICAgICAgICAvLyBlbnN1cmUgNiB3ZWVrc1xyXG4gICAgICAgIGlmICh0aGlzLm9wdCgnZml4ZWRXZWVrQ291bnQnKSkge1xyXG4gICAgICAgICAgICByb3dDbnQgPSBNYXRoLmNlaWwoLy8gY291bGQgYmUgcGFydGlhbCB3ZWVrcyBkdWUgdG8gaGlkZGVuRGF5c1xyXG4gICAgICAgICAgICBlbmQuZGlmZihzdGFydCwgJ3dlZWtzJywgdHJ1ZSkgLy8gZG9udFJvdW5kPXRydWVcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgZW5kLmFkZCg2IC0gcm93Q250LCAnd2Vla3MnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KHN0YXJ0LCBlbmQpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNb250aFZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcjtcclxufShCYXNpY1ZpZXdEYXRlUHJvZmlsZUdlbmVyYXRvcl8xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTW9udGhWaWV3RGF0ZVByb2ZpbGVHZW5lcmF0b3I7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIFVuem9uZWRSYW5nZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxudmFyIFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xyXG52YXIgU2Nyb2xsZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xyXG52YXIgTGlzdEV2ZW50UmVuZGVyZXJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ5KTtcclxudmFyIExpc3RFdmVudFBvaW50aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1MCk7XHJcbi8qXHJcblJlc3BvbnNpYmxlIGZvciB0aGUgc2Nyb2xsZXIsIGFuZCBmb3J3YXJkaW5nIGV2ZW50LXJlbGF0ZWQgYWN0aW9ucyBpbnRvIHRoZSBcImdyaWRcIi5cclxuKi9cclxudmFyIExpc3RWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGlzdFZpZXcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMaXN0VmlldyhjYWxlbmRhciwgdmlld1NwZWMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBjYWxlbmRhciwgdmlld1NwZWMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuc2VnU2VsZWN0b3IgPSAnLmZjLWxpc3QtaXRlbSc7IC8vIHdoaWNoIGVsZW1lbnRzIGFjY2VwdCBldmVudCBhY3Rpb25zXHJcbiAgICAgICAgX3RoaXMuc2Nyb2xsZXIgPSBuZXcgU2Nyb2xsZXJfMS5kZWZhdWx0KHtcclxuICAgICAgICAgICAgb3ZlcmZsb3dYOiAnaGlkZGVuJyxcclxuICAgICAgICAgICAgb3ZlcmZsb3dZOiAnYXV0bydcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUucmVuZGVyU2tlbGV0b24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5lbC5hZGRDbGFzcygnZmMtbGlzdC12aWV3ICcgK1xyXG4gICAgICAgICAgICB0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCdsaXN0VmlldycpKTtcclxuICAgICAgICB0aGlzLnNjcm9sbGVyLnJlbmRlcigpO1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuZWwuYXBwZW5kVG8odGhpcy5lbCk7XHJcbiAgICAgICAgdGhpcy5jb250ZW50RWwgPSB0aGlzLnNjcm9sbGVyLnNjcm9sbEVsOyAvLyBzaG9ydGN1dFxyXG4gICAgfTtcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS51bnJlbmRlclNrZWxldG9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2Nyb2xsZXIuZGVzdHJveSgpOyAvLyB3aWxsIHJlbW92ZSB0aGUgR3JpZCB0b29cclxuICAgIH07XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCwgaXNBdXRvLCBpc1Jlc2l6ZSkge1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUudXBkYXRlU2l6ZS5jYWxsKHRoaXMsIHRvdGFsSGVpZ2h0LCBpc0F1dG8sIGlzUmVzaXplKTtcclxuICAgICAgICB0aGlzLnNjcm9sbGVyLmNsZWFyKCk7IC8vIHNldHMgaGVpZ2h0IHRvICdhdXRvJyBhbmQgY2xlYXJzIG92ZXJmbG93XHJcbiAgICAgICAgaWYgKCFpc0F1dG8pIHtcclxuICAgICAgICAgICAgdGhpcy5zY3JvbGxlci5zZXRIZWlnaHQodGhpcy5jb21wdXRlU2Nyb2xsZXJIZWlnaHQodG90YWxIZWlnaHQpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLmNvbXB1dGVTY3JvbGxlckhlaWdodCA9IGZ1bmN0aW9uICh0b3RhbEhlaWdodCkge1xyXG4gICAgICAgIHJldHVybiB0b3RhbEhlaWdodCAtXHJcbiAgICAgICAgICAgIHV0aWxfMS5zdWJ0cmFjdElubmVyRWxIZWlnaHQodGhpcy5lbCwgdGhpcy5zY3JvbGxlci5lbCk7IC8vIGV2ZXJ5dGhpbmcgdGhhdCdzIE5PVCB0aGUgc2Nyb2xsZXJcclxuICAgIH07XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUucmVuZGVyRGF0ZXMgPSBmdW5jdGlvbiAoZGF0ZVByb2ZpbGUpIHtcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciBkYXlTdGFydCA9IGNhbGVuZGFyLm1zVG9VdGNNb21lbnQoZGF0ZVByb2ZpbGUucmVuZGVyVW56b25lZFJhbmdlLnN0YXJ0TXMsIHRydWUpO1xyXG4gICAgICAgIHZhciB2aWV3RW5kID0gY2FsZW5kYXIubXNUb1V0Y01vbWVudChkYXRlUHJvZmlsZS5yZW5kZXJVbnpvbmVkUmFuZ2UuZW5kTXMsIHRydWUpO1xyXG4gICAgICAgIHZhciBkYXlEYXRlcyA9IFtdO1xyXG4gICAgICAgIHZhciBkYXlSYW5nZXMgPSBbXTtcclxuICAgICAgICB3aGlsZSAoZGF5U3RhcnQgPCB2aWV3RW5kKSB7XHJcbiAgICAgICAgICAgIGRheURhdGVzLnB1c2goZGF5U3RhcnQuY2xvbmUoKSk7XHJcbiAgICAgICAgICAgIGRheVJhbmdlcy5wdXNoKG5ldyBVbnpvbmVkUmFuZ2VfMS5kZWZhdWx0KGRheVN0YXJ0LCBkYXlTdGFydC5jbG9uZSgpLmFkZCgxLCAnZGF5JykpKTtcclxuICAgICAgICAgICAgZGF5U3RhcnQuYWRkKDEsICdkYXknKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kYXlEYXRlcyA9IGRheURhdGVzO1xyXG4gICAgICAgIHRoaXMuZGF5UmFuZ2VzID0gZGF5UmFuZ2VzO1xyXG4gICAgICAgIC8vIGFsbCByZWFsIHJlbmRlcmluZyBoYXBwZW5zIGluIEV2ZW50UmVuZGVyZXJcclxuICAgIH07XHJcbiAgICAvLyBzbGljZXMgYnkgZGF5XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUuY29tcG9uZW50Rm9vdHByaW50VG9TZWdzID0gZnVuY3Rpb24gKGZvb3RwcmludCkge1xyXG4gICAgICAgIHZhciBkYXlSYW5nZXMgPSB0aGlzLmRheVJhbmdlcztcclxuICAgICAgICB2YXIgZGF5SW5kZXg7XHJcbiAgICAgICAgdmFyIHNlZ1JhbmdlO1xyXG4gICAgICAgIHZhciBzZWc7XHJcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcclxuICAgICAgICBmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBkYXlSYW5nZXMubGVuZ3RoOyBkYXlJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHNlZ1JhbmdlID0gZm9vdHByaW50LnVuem9uZWRSYW5nZS5pbnRlcnNlY3QoZGF5UmFuZ2VzW2RheUluZGV4XSk7XHJcbiAgICAgICAgICAgIGlmIChzZWdSYW5nZSkge1xyXG4gICAgICAgICAgICAgICAgc2VnID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0TXM6IHNlZ1JhbmdlLnN0YXJ0TXMsXHJcbiAgICAgICAgICAgICAgICAgICAgZW5kTXM6IHNlZ1JhbmdlLmVuZE1zLFxyXG4gICAgICAgICAgICAgICAgICAgIGlzU3RhcnQ6IHNlZ1JhbmdlLmlzU3RhcnQsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IHNlZ1JhbmdlLmlzRW5kLFxyXG4gICAgICAgICAgICAgICAgICAgIGRheUluZGV4OiBkYXlJbmRleFxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHNlZ3MucHVzaChzZWcpO1xyXG4gICAgICAgICAgICAgICAgLy8gZGV0ZWN0IHdoZW4gZm9vdHByaW50IHdvbid0IGdvIGZ1bGx5IGludG8gdGhlIG5leHQgZGF5LFxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIG11dGF0ZSB0aGUgbGF0ZXN0IHNlZyB0byB0aGUgYmUgdGhlIGVuZC5cclxuICAgICAgICAgICAgICAgIGlmICghc2VnLmlzRW5kICYmICFmb290cHJpbnQuaXNBbGxEYXkgJiZcclxuICAgICAgICAgICAgICAgICAgICBkYXlJbmRleCArIDEgPCBkYXlSYW5nZXMubGVuZ3RoICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZm9vdHByaW50LnVuem9uZWRSYW5nZS5lbmRNcyA8IGRheVJhbmdlc1tkYXlJbmRleCArIDFdLnN0YXJ0TXMgKyB0aGlzLm5leHREYXlUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWcuZW5kTXMgPSBmb290cHJpbnQudW56b25lZFJhbmdlLmVuZE1zO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlZy5pc0VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3M7XHJcbiAgICB9O1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLnJlbmRlckVtcHR5TWVzc2FnZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5odG1sKCc8ZGl2IGNsYXNzPVwiZmMtbGlzdC1lbXB0eS13cmFwMlwiPicgKyAvLyBUT0RPOiB0cnkgbGVzcyB3cmFwc1xyXG4gICAgICAgICAgICAnPGRpdiBjbGFzcz1cImZjLWxpc3QtZW1wdHktd3JhcDFcIj4nICtcclxuICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJmYy1saXN0LWVtcHR5XCI+JyArXHJcbiAgICAgICAgICAgIHV0aWxfMS5odG1sRXNjYXBlKHRoaXMub3B0KCdub0V2ZW50c01lc3NhZ2UnKSkgK1xyXG4gICAgICAgICAgICAnPC9kaXY+JyArXHJcbiAgICAgICAgICAgICc8L2Rpdj4nICtcclxuICAgICAgICAgICAgJzwvZGl2PicpO1xyXG4gICAgfTtcclxuICAgIC8vIHJlbmRlciB0aGUgZXZlbnQgc2VnbWVudHMgaW4gdGhlIHZpZXdcclxuICAgIExpc3RWaWV3LnByb3RvdHlwZS5yZW5kZXJTZWdMaXN0ID0gZnVuY3Rpb24gKGFsbFNlZ3MpIHtcclxuICAgICAgICB2YXIgc2Vnc0J5RGF5ID0gdGhpcy5ncm91cFNlZ3NCeURheShhbGxTZWdzKTsgLy8gc3BhcnNlIGFycmF5XHJcbiAgICAgICAgdmFyIGRheUluZGV4O1xyXG4gICAgICAgIHZhciBkYXlTZWdzO1xyXG4gICAgICAgIHZhciBpO1xyXG4gICAgICAgIHZhciB0YWJsZUVsID0gJCgnPHRhYmxlIGNsYXNzPVwiZmMtbGlzdC10YWJsZSAnICsgdGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygndGFibGVMaXN0JykgKyAnXCI+PHRib2R5PjwvdGJvZHk+PC90YWJsZT4nKTtcclxuICAgICAgICB2YXIgdGJvZHlFbCA9IHRhYmxlRWwuZmluZCgndGJvZHknKTtcclxuICAgICAgICBmb3IgKGRheUluZGV4ID0gMDsgZGF5SW5kZXggPCBzZWdzQnlEYXkubGVuZ3RoOyBkYXlJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIGRheVNlZ3MgPSBzZWdzQnlEYXlbZGF5SW5kZXhdO1xyXG4gICAgICAgICAgICBpZiAoZGF5U2VncykgeyAvLyBzcGFyc2UgYXJyYXksIHNvIG1pZ2h0IGJlIHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kIGEgZGF5IGhlYWRlclxyXG4gICAgICAgICAgICAgICAgdGJvZHlFbC5hcHBlbmQodGhpcy5kYXlIZWFkZXJIdG1sKHRoaXMuZGF5RGF0ZXNbZGF5SW5kZXhdKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50UmVuZGVyZXIuc29ydEV2ZW50U2VncyhkYXlTZWdzKTtcclxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkYXlTZWdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGJvZHlFbC5hcHBlbmQoZGF5U2Vnc1tpXS5lbCk7IC8vIGFwcGVuZCBldmVudCByb3dcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbnRlbnRFbC5lbXB0eSgpLmFwcGVuZCh0YWJsZUVsKTtcclxuICAgIH07XHJcbiAgICAvLyBSZXR1cm5zIGEgc3BhcnNlIGFycmF5IG9mIGFycmF5cywgc2VncyBncm91cGVkIGJ5IHRoZWlyIGRheUluZGV4XHJcbiAgICBMaXN0Vmlldy5wcm90b3R5cGUuZ3JvdXBTZWdzQnlEYXkgPSBmdW5jdGlvbiAoc2Vncykge1xyXG4gICAgICAgIHZhciBzZWdzQnlEYXkgPSBbXTsgLy8gc3BhcnNlIGFycmF5XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNlZztcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZWcgPSBzZWdzW2ldO1xyXG4gICAgICAgICAgICAoc2Vnc0J5RGF5W3NlZy5kYXlJbmRleF0gfHwgKHNlZ3NCeURheVtzZWcuZGF5SW5kZXhdID0gW10pKVxyXG4gICAgICAgICAgICAgICAgLnB1c2goc2VnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNlZ3NCeURheTtcclxuICAgIH07XHJcbiAgICAvLyBnZW5lcmF0ZXMgdGhlIEhUTUwgZm9yIHRoZSBkYXkgaGVhZGVycyB0aGF0IGxpdmUgYW1vbmdzdCB0aGUgZXZlbnQgcm93c1xyXG4gICAgTGlzdFZpZXcucHJvdG90eXBlLmRheUhlYWRlckh0bWwgPSBmdW5jdGlvbiAoZGF5RGF0ZSkge1xyXG4gICAgICAgIHZhciBtYWluRm9ybWF0ID0gdGhpcy5vcHQoJ2xpc3REYXlGb3JtYXQnKTtcclxuICAgICAgICB2YXIgYWx0Rm9ybWF0ID0gdGhpcy5vcHQoJ2xpc3REYXlBbHRGb3JtYXQnKTtcclxuICAgICAgICByZXR1cm4gJzx0ciBjbGFzcz1cImZjLWxpc3QtaGVhZGluZ1wiIGRhdGEtZGF0ZT1cIicgKyBkYXlEYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpICsgJ1wiPicgK1xyXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiJyArICh0aGlzLmNhbGVuZGFyLnRoZW1lLmdldENsYXNzKCd0YWJsZUxpc3RIZWFkaW5nJykgfHxcclxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnd2lkZ2V0SGVhZGVyJykpICsgJ1wiIGNvbHNwYW49XCIzXCI+JyArXHJcbiAgICAgICAgICAgIChtYWluRm9ybWF0ID9cclxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRHb3RvQW5jaG9ySHRtbChkYXlEYXRlLCB7ICdjbGFzcyc6ICdmYy1saXN0LWhlYWRpbmctbWFpbicgfSwgdXRpbF8xLmh0bWxFc2NhcGUoZGF5RGF0ZS5mb3JtYXQobWFpbkZvcm1hdCkpIC8vIGlubmVyIEhUTUxcclxuICAgICAgICAgICAgICAgICkgOlxyXG4gICAgICAgICAgICAgICAgJycpICtcclxuICAgICAgICAgICAgKGFsdEZvcm1hdCA/XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkR290b0FuY2hvckh0bWwoZGF5RGF0ZSwgeyAnY2xhc3MnOiAnZmMtbGlzdC1oZWFkaW5nLWFsdCcgfSwgdXRpbF8xLmh0bWxFc2NhcGUoZGF5RGF0ZS5mb3JtYXQoYWx0Rm9ybWF0KSkgLy8gaW5uZXIgSFRNTFxyXG4gICAgICAgICAgICAgICAgKSA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPC90ZD4nICtcclxuICAgICAgICAgICAgJzwvdHI+JztcclxuICAgIH07XHJcbiAgICByZXR1cm4gTGlzdFZpZXc7XHJcbn0oVmlld18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTGlzdFZpZXc7XHJcbkxpc3RWaWV3LnByb3RvdHlwZS5ldmVudFJlbmRlcmVyQ2xhc3MgPSBMaXN0RXZlbnRSZW5kZXJlcl8xLmRlZmF1bHQ7XHJcbkxpc3RWaWV3LnByb3RvdHlwZS5ldmVudFBvaW50aW5nQ2xhc3MgPSBMaXN0RXZlbnRQb2ludGluZ18xLmRlZmF1bHQ7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIHV0aWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbnZhciBFdmVudFJlbmRlcmVyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcclxudmFyIExpc3RFdmVudFJlbmRlcmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGlzdEV2ZW50UmVuZGVyZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMaXN0RXZlbnRSZW5kZXJlcigpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBMaXN0RXZlbnRSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRmdTZWdzID0gZnVuY3Rpb24gKHNlZ3MpIHtcclxuICAgICAgICBpZiAoIXNlZ3MubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50LnJlbmRlckVtcHR5TWVzc2FnZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQucmVuZGVyU2VnTGlzdChzZWdzKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gZ2VuZXJhdGVzIHRoZSBIVE1MIGZvciBhIHNpbmdsZSBldmVudCByb3dcclxuICAgIExpc3RFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5mZ1NlZ0h0bWwgPSBmdW5jdGlvbiAoc2VnKSB7XHJcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnZpZXc7XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyID0gdmlldy5jYWxlbmRhcjtcclxuICAgICAgICB2YXIgdGhlbWUgPSBjYWxlbmRhci50aGVtZTtcclxuICAgICAgICB2YXIgZXZlbnRGb290cHJpbnQgPSBzZWcuZm9vdHByaW50O1xyXG4gICAgICAgIHZhciBldmVudERlZiA9IGV2ZW50Rm9vdHByaW50LmV2ZW50RGVmO1xyXG4gICAgICAgIHZhciBjb21wb25lbnRGb290cHJpbnQgPSBldmVudEZvb3RwcmludC5jb21wb25lbnRGb290cHJpbnQ7XHJcbiAgICAgICAgdmFyIHVybCA9IGV2ZW50RGVmLnVybDtcclxuICAgICAgICB2YXIgY2xhc3NlcyA9IFsnZmMtbGlzdC1pdGVtJ10uY29uY2F0KHRoaXMuZ2V0Q2xhc3NlcyhldmVudERlZikpO1xyXG4gICAgICAgIHZhciBiZ0NvbG9yID0gdGhpcy5nZXRCZ0NvbG9yKGV2ZW50RGVmKTtcclxuICAgICAgICB2YXIgdGltZUh0bWw7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudEZvb3RwcmludC5pc0FsbERheSkge1xyXG4gICAgICAgICAgICB0aW1lSHRtbCA9IHZpZXcuZ2V0QWxsRGF5SHRtbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2aWV3LmlzTXVsdGlEYXlSYW5nZShjb21wb25lbnRGb290cHJpbnQudW56b25lZFJhbmdlKSkge1xyXG4gICAgICAgICAgICBpZiAoc2VnLmlzU3RhcnQgfHwgc2VnLmlzRW5kKSB7IC8vIG91dGVyIHNlZ21lbnQgdGhhdCBwcm9iYWJseSBsYXN0cyBwYXJ0IG9mIHRoZSBkYXlcclxuICAgICAgICAgICAgICAgIHRpbWVIdG1sID0gdXRpbF8xLmh0bWxFc2NhcGUodGhpcy5fZ2V0VGltZVRleHQoY2FsZW5kYXIubXNUb01vbWVudChzZWcuc3RhcnRNcyksIGNhbGVuZGFyLm1zVG9Nb21lbnQoc2VnLmVuZE1zKSwgY29tcG9uZW50Rm9vdHByaW50LmlzQWxsRGF5KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7IC8vIGlubmVyIHNlZ21lbnQgdGhhdCBsYXN0cyB0aGUgd2hvbGUgZGF5XHJcbiAgICAgICAgICAgICAgICB0aW1lSHRtbCA9IHZpZXcuZ2V0QWxsRGF5SHRtbCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBEaXNwbGF5IHRoZSBub3JtYWwgdGltZSB0ZXh0IGZvciB0aGUgKmV2ZW50J3MqIHRpbWVzXHJcbiAgICAgICAgICAgIHRpbWVIdG1sID0gdXRpbF8xLmh0bWxFc2NhcGUodGhpcy5nZXRUaW1lVGV4dChldmVudEZvb3RwcmludCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodXJsKSB7XHJcbiAgICAgICAgICAgIGNsYXNzZXMucHVzaCgnZmMtaGFzLXVybCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJzx0ciBjbGFzcz1cIicgKyBjbGFzc2VzLmpvaW4oJyAnKSArICdcIj4nICtcclxuICAgICAgICAgICAgKHRoaXMuZGlzcGxheUV2ZW50VGltZSA/XHJcbiAgICAgICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtbGlzdC1pdGVtLXRpbWUgJyArIHRoZW1lLmdldENsYXNzKCd3aWRnZXRDb250ZW50JykgKyAnXCI+JyArXHJcbiAgICAgICAgICAgICAgICAgICAgKHRpbWVIdG1sIHx8ICcnKSArXHJcbiAgICAgICAgICAgICAgICAgICAgJzwvdGQ+JyA6XHJcbiAgICAgICAgICAgICAgICAnJykgK1xyXG4gICAgICAgICAgICAnPHRkIGNsYXNzPVwiZmMtbGlzdC1pdGVtLW1hcmtlciAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzxzcGFuIGNsYXNzPVwiZmMtZXZlbnQtZG90XCInICtcclxuICAgICAgICAgICAgKGJnQ29sb3IgP1xyXG4gICAgICAgICAgICAgICAgJyBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6JyArIGJnQ29sb3IgKyAnXCInIDpcclxuICAgICAgICAgICAgICAgICcnKSArXHJcbiAgICAgICAgICAgICc+PC9zcGFuPicgK1xyXG4gICAgICAgICAgICAnPC90ZD4nICtcclxuICAgICAgICAgICAgJzx0ZCBjbGFzcz1cImZjLWxpc3QtaXRlbS10aXRsZSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3dpZGdldENvbnRlbnQnKSArICdcIj4nICtcclxuICAgICAgICAgICAgJzxhJyArICh1cmwgPyAnIGhyZWY9XCInICsgdXRpbF8xLmh0bWxFc2NhcGUodXJsKSArICdcIicgOiAnJykgKyAnPicgK1xyXG4gICAgICAgICAgICB1dGlsXzEuaHRtbEVzY2FwZShldmVudERlZi50aXRsZSB8fCAnJykgK1xyXG4gICAgICAgICAgICAnPC9hPicgK1xyXG4gICAgICAgICAgICAnPC90ZD4nICtcclxuICAgICAgICAgICAgJzwvdHI+JztcclxuICAgIH07XHJcbiAgICAvLyBsaWtlIFwiNDowMGFtXCJcclxuICAgIExpc3RFdmVudFJlbmRlcmVyLnByb3RvdHlwZS5jb21wdXRlRXZlbnRUaW1lRm9ybWF0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9wdCgnbWVkaXVtVGltZUZvcm1hdCcpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBMaXN0RXZlbnRSZW5kZXJlcjtcclxufShFdmVudFJlbmRlcmVyXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBMaXN0RXZlbnRSZW5kZXJlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBFdmVudFBvaW50aW5nXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0KTtcclxudmFyIExpc3RFdmVudFBvaW50aW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGlzdEV2ZW50UG9pbnRpbmcsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMaXN0RXZlbnRQb2ludGluZygpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyBmb3IgZXZlbnRzIHdpdGggYSB1cmwsIHRoZSB3aG9sZSA8dHI+IHNob3VsZCBiZSBjbGlja2FibGUsXHJcbiAgICAvLyBidXQgaXQncyBpbXBvc3NpYmxlIHRvIHdyYXAgd2l0aCBhbiA8YT4gdGFnLiBzaW11bGF0ZSB0aGlzLlxyXG4gICAgTGlzdEV2ZW50UG9pbnRpbmcucHJvdG90eXBlLmhhbmRsZUNsaWNrID0gZnVuY3Rpb24gKHNlZywgZXYpIHtcclxuICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuaGFuZGxlQ2xpY2suY2FsbCh0aGlzLCBzZWcsIGV2KTsgLy8gbWlnaHQgcHJldmVudCB0aGUgZGVmYXVsdCBhY3Rpb25cclxuICAgICAgICAvLyBub3QgY2xpY2tpbmcgb24gb3Igd2l0aGluIGFuIDxhPiB3aXRoIGFuIGhyZWZcclxuICAgICAgICBpZiAoISQoZXYudGFyZ2V0KS5jbG9zZXN0KCdhW2hyZWZdJykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHVybCA9IHNlZy5mb290cHJpbnQuZXZlbnREZWYudXJsO1xyXG4gICAgICAgICAgICBpZiAodXJsICYmICFldi5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgeyAvLyBqc0V2ZW50IG5vdCBjYW5jZWxsZWQgaW4gaGFuZGxlclxyXG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB1cmw7IC8vIHNpbXVsYXRlIGxpbmsgY2xpY2tcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gTGlzdEV2ZW50UG9pbnRpbmc7XHJcbn0oRXZlbnRQb2ludGluZ18xLmRlZmF1bHQpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gTGlzdEV2ZW50UG9pbnRpbmc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI1MSAqLyxcbi8qIDI1MiAqLyxcbi8qIDI1MyAqLyxcbi8qIDI1NCAqLyxcbi8qIDI1NSAqLyxcbi8qIDI1NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciBleHBvcnRIb29rcyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG52YXIgdXRpbF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxudmFyIENhbGVuZGFyXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzMik7XHJcbi8vIGZvciBpbnRlbnRpb25hbCBzaWRlLWVmZmVjdHNcclxuX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oNDkpO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI2MCk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oMjYxKTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXygyNjQpO1xyXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDI2NSk7XHJcbl9fd2VicGFja19yZXF1aXJlX18oMjY2KTtcclxuX193ZWJwYWNrX3JlcXVpcmVfXygyNjcpO1xyXG4kLmZ1bGxDYWxlbmRhciA9IGV4cG9ydEhvb2tzO1xyXG4kLmZuLmZ1bGxDYWxlbmRhciA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vIGZvciBhIHBvc3NpYmxlIG1ldGhvZCBjYWxsXHJcbiAgICB2YXIgcmVzID0gdGhpczsgLy8gd2hhdCB0aGlzIGZ1bmN0aW9uIHdpbGwgcmV0dXJuICh0aGlzIGpRdWVyeSBvYmplY3QgYnkgZGVmYXVsdClcclxuICAgIHRoaXMuZWFjaChmdW5jdGlvbiAoaSwgX2VsZW1lbnQpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9ICQoX2VsZW1lbnQpO1xyXG4gICAgICAgIHZhciBjYWxlbmRhciA9IGVsZW1lbnQuZGF0YSgnZnVsbENhbGVuZGFyJyk7IC8vIGdldCB0aGUgZXhpc3RpbmcgY2FsZW5kYXIgb2JqZWN0IChpZiBhbnkpXHJcbiAgICAgICAgdmFyIHNpbmdsZVJlczsgLy8gdGhlIHJldHVybmVkIHZhbHVlIG9mIHRoaXMgc2luZ2xlIG1ldGhvZCBjYWxsXHJcbiAgICAgICAgLy8gYSBtZXRob2QgY2FsbFxyXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09ICdnZXRDYWxlbmRhcicpIHtcclxuICAgICAgICAgICAgICAgIGlmICghaSkgeyAvLyBmaXJzdCBlbGVtZW50IG9ubHlcclxuICAgICAgICAgICAgICAgICAgICByZXMgPSBjYWxlbmRhcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zID09PSAnZGVzdHJveScpIHsgLy8gZG9uJ3Qgd2FybiBpZiBubyBjYWxlbmRhciBvYmplY3RcclxuICAgICAgICAgICAgICAgIGlmIChjYWxlbmRhcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZURhdGEoJ2Z1bGxDYWxlbmRhcicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCFjYWxlbmRhcikge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLndhcm4oJ0F0dGVtcHRpbmcgdG8gY2FsbCBhIEZ1bGxDYWxlbmRhciBtZXRob2Qgb24gYW4gZWxlbWVudCB3aXRoIG5vIGNhbGVuZGFyLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKCQuaXNGdW5jdGlvbihjYWxlbmRhcltvcHRpb25zXSkpIHtcclxuICAgICAgICAgICAgICAgIHNpbmdsZVJlcyA9IGNhbGVuZGFyW29wdGlvbnNdLmFwcGx5KGNhbGVuZGFyLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIGlmICghaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHNpbmdsZVJlczsgLy8gcmVjb3JkIHRoZSBmaXJzdCBtZXRob2QgY2FsbCByZXN1bHRcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSAnZGVzdHJveScpIHsgLy8gZm9yIHRoZSBkZXN0cm95IG1ldGhvZCwgbXVzdCByZW1vdmUgQ2FsZW5kYXIgb2JqZWN0IGRhdGFcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZURhdGEoJ2Z1bGxDYWxlbmRhcicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdXRpbF8xLndhcm4oXCInXCIgKyBvcHRpb25zICsgXCInIGlzIGFuIHVua25vd24gRnVsbENhbGVuZGFyIG1ldGhvZC5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWNhbGVuZGFyKSB7IC8vIGRvbid0IGluaXRpYWxpemUgdHdpY2VcclxuICAgICAgICAgICAgY2FsZW5kYXIgPSBuZXcgQ2FsZW5kYXJfMS5kZWZhdWx0KGVsZW1lbnQsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICBlbGVtZW50LmRhdGEoJ2Z1bGxDYWxlbmRhcicsIGNhbGVuZGFyKTtcclxuICAgICAgICAgICAgY2FsZW5kYXIucmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzO1xyXG59O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydEhvb2tzO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG4vKiBUb29sYmFyIHdpdGggYnV0dG9ucyBhbmQgdGl0bGVcclxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXHJcbnZhciBUb29sYmFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVG9vbGJhcihjYWxlbmRhciwgdG9vbGJhck9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmVsID0gbnVsbDsgLy8gbWlycm9ycyBsb2NhbCBgZWxgXHJcbiAgICAgICAgdGhpcy52aWV3c1dpdGhCdXR0b25zID0gW107XHJcbiAgICAgICAgdGhpcy5jYWxlbmRhciA9IGNhbGVuZGFyO1xyXG4gICAgICAgIHRoaXMudG9vbGJhck9wdGlvbnMgPSB0b29sYmFyT3B0aW9ucztcclxuICAgIH1cclxuICAgIC8vIG1ldGhvZCB0byB1cGRhdGUgdG9vbGJhci1zcGVjaWZpYyBvcHRpb25zLCBub3QgY2FsZW5kYXItd2lkZSBvcHRpb25zXHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5zZXRUb29sYmFyT3B0aW9ucyA9IGZ1bmN0aW9uIChuZXdUb29sYmFyT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMudG9vbGJhck9wdGlvbnMgPSBuZXdUb29sYmFyT3B0aW9ucztcclxuICAgIH07XHJcbiAgICAvLyBjYW4gYmUgY2FsbGVkIHJlcGVhdGVkbHkgYW5kIHdpbGwgcmVyZW5kZXJcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc2VjdGlvbnMgPSB0aGlzLnRvb2xiYXJPcHRpb25zLmxheW91dDtcclxuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xyXG4gICAgICAgIGlmIChzZWN0aW9ucykge1xyXG4gICAgICAgICAgICBpZiAoIWVsKSB7XHJcbiAgICAgICAgICAgICAgICBlbCA9IHRoaXMuZWwgPSAkKFwiPGRpdiBjbGFzcz0nZmMtdG9vbGJhciBcIiArIHRoaXMudG9vbGJhck9wdGlvbnMuZXh0cmFDbGFzc2VzICsgXCInPlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVsLmVtcHR5KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWwuYXBwZW5kKHRoaXMucmVuZGVyU2VjdGlvbignbGVmdCcpKVxyXG4gICAgICAgICAgICAgICAgLmFwcGVuZCh0aGlzLnJlbmRlclNlY3Rpb24oJ3JpZ2h0JykpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKHRoaXMucmVuZGVyU2VjdGlvbignY2VudGVyJykpXHJcbiAgICAgICAgICAgICAgICAuYXBwZW5kKCc8ZGl2IGNsYXNzPVwiZmMtY2xlYXJcIj48L2Rpdj4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRWxlbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5yZW1vdmVFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwucmVtb3ZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuZWwgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5yZW5kZXJTZWN0aW9uID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgY2FsZW5kYXIgPSB0aGlzLmNhbGVuZGFyO1xyXG4gICAgICAgIHZhciB0aGVtZSA9IGNhbGVuZGFyLnRoZW1lO1xyXG4gICAgICAgIHZhciBvcHRpb25zTWFuYWdlciA9IGNhbGVuZGFyLm9wdGlvbnNNYW5hZ2VyO1xyXG4gICAgICAgIHZhciB2aWV3U3BlY01hbmFnZXIgPSBjYWxlbmRhci52aWV3U3BlY01hbmFnZXI7XHJcbiAgICAgICAgdmFyIHNlY3Rpb25FbCA9ICQoJzxkaXYgY2xhc3M9XCJmYy0nICsgcG9zaXRpb24gKyAnXCI+Jyk7XHJcbiAgICAgICAgdmFyIGJ1dHRvblN0ciA9IHRoaXMudG9vbGJhck9wdGlvbnMubGF5b3V0W3Bvc2l0aW9uXTtcclxuICAgICAgICB2YXIgY2FsZW5kYXJDdXN0b21CdXR0b25zID0gb3B0aW9uc01hbmFnZXIuZ2V0KCdjdXN0b21CdXR0b25zJykgfHwge307XHJcbiAgICAgICAgdmFyIGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyA9IG9wdGlvbnNNYW5hZ2VyLm92ZXJyaWRlcy5idXR0b25UZXh0IHx8IHt9O1xyXG4gICAgICAgIHZhciBjYWxlbmRhckJ1dHRvblRleHQgPSBvcHRpb25zTWFuYWdlci5nZXQoJ2J1dHRvblRleHQnKSB8fCB7fTtcclxuICAgICAgICBpZiAoYnV0dG9uU3RyKSB7XHJcbiAgICAgICAgICAgICQuZWFjaChidXR0b25TdHIuc3BsaXQoJyAnKSwgZnVuY3Rpb24gKGksIGJ1dHRvbkdyb3VwU3RyKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ3JvdXBDaGlsZHJlbiA9ICQoKTtcclxuICAgICAgICAgICAgICAgIHZhciBpc09ubHlCdXR0b25zID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIHZhciBncm91cEVsO1xyXG4gICAgICAgICAgICAgICAgJC5lYWNoKGJ1dHRvbkdyb3VwU3RyLnNwbGl0KCcsJyksIGZ1bmN0aW9uIChqLCBidXR0b25OYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1c3RvbUJ1dHRvblByb3BzO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2aWV3U3BlYztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xpY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkljb247IC8vIG9ubHkgb25lIG9mIHRoZXNlIHdpbGwgYmUgc2V0XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvblRleHQ7IC8vIFwiXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbklubmVySHRtbDtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uQ2xhc3NlcztcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uRWw7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkFyaWFBdHRyO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25OYW1lID09PSAndGl0bGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW4gPSBncm91cENoaWxkcmVuLmFkZCgkKCc8aDI+Jm5ic3A7PC9oMj4nKSk7IC8vIHdlIGFsd2F5cyB3YW50IGl0IHRvIHRha2UgdXAgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzT25seUJ1dHRvbnMgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoY3VzdG9tQnV0dG9uUHJvcHMgPSBjYWxlbmRhckN1c3RvbUJ1dHRvbnNbYnV0dG9uTmFtZV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25DbGljayA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXN0b21CdXR0b25Qcm9wcy5jbGljaykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21CdXR0b25Qcm9wcy5jbGljay5jYWxsKGJ1dHRvbkVsWzBdLCBldik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzKGN1c3RvbUJ1dHRvblByb3BzKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uSWNvbiA9IHRoZW1lLmdldEljb25DbGFzcyhidXR0b25OYW1lKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGN1c3RvbUJ1dHRvblByb3BzLnRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCh2aWV3U3BlYyA9IHZpZXdTcGVjTWFuYWdlci5nZXRWaWV3U3BlYyhidXR0b25OYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZpZXdzV2l0aEJ1dHRvbnMucHVzaChidXR0b25OYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyLmNoYW5nZVZpZXcoYnV0dG9uTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2FsZW5kYXJbYnV0dG9uTmFtZV0pIHsgLy8gYSBjYWxlbmRhciBtZXRob2RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyW2J1dHRvbk5hbWVdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXNbYnV0dG9uTmFtZV0pIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICAgICAgICAgICBeIGV2ZXJ5dGhpbmcgZWxzZSBpcyBjb25zaWRlcmVkIGRlZmF1bHRcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnV0dG9uQ2xpY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsYXNzZXMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCdidXR0b24nKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGVtZS5nZXRDbGFzcygnc3RhdGVEZWZhdWx0JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnV0dG9uVGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbklubmVySHRtbCA9IHV0aWxfMS5odG1sRXNjYXBlKGJ1dHRvblRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkFyaWFBdHRyID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChidXR0b25JY29uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uSW5uZXJIdG1sID0gXCI8c3BhbiBjbGFzcz0nXCIgKyBidXR0b25JY29uICsgXCInPjwvc3Bhbj5cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25BcmlhQXR0ciA9ICcgYXJpYS1sYWJlbD1cIicgKyBidXR0b25OYW1lICsgJ1wiJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsID0gJCgvLyB0eXBlPVwiYnV0dG9uXCIgc28gdGhhdCBpdCBkb2Vzbid0IHN1Ym1pdCBhIGZvcm1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICc8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cIicgKyBidXR0b25DbGFzc2VzLmpvaW4oJyAnKSArICdcIicgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkFyaWFBdHRyICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPicgKyBidXR0b25Jbm5lckh0bWwgKyAnPC9idXR0b24+JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY2xpY2soZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgcHJvY2VzcyBjbGlja3MgZm9yIGRpc2FibGVkIGJ1dHRvbnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1dHRvbkVsLmhhc0NsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZURpc2FibGVkJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsaWNrKGV2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWZ0ZXIgdGhlIGNsaWNrIGFjdGlvbiwgaWYgdGhlIGJ1dHRvbiBiZWNvbWVzIHRoZSBcImFjdGl2ZVwiIHRhYiwgb3IgZGlzYWJsZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBuZXZlciBoYXZlIGEgaG92ZXIgY2xhc3MsIHNvIHJlbW92ZSBpdCBub3cuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChidXR0b25FbC5oYXNDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVBY3RpdmUnKSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsLmhhc0NsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZURpc2FibGVkJykpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbC5yZW1vdmVDbGFzcyh0aGVtZS5nZXRDbGFzcygnc3RhdGVIb3ZlcicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1vdXNlZG93bihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlICpkb3duKiBlZmZlY3QgKG1vdXNlIHByZXNzZWQgaW4pLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgb24gYnV0dG9ucyB0aGF0IGFyZSBub3QgdGhlIFwiYWN0aXZlXCIgdGFiLCBvciBkaXNhYmxlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ub3QoJy4nICsgdGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlQWN0aXZlJykpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5ub3QoJy4nICsgdGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGlzYWJsZWQnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZENsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZURvd24nKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tb3VzZXVwKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1bmRvIHRoZSAqZG93biogZWZmZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWwucmVtb3ZlQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRG93bicpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmhvdmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgKmhvdmVyKiBlZmZlY3QuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBvbiBidXR0b25zIHRoYXQgYXJlIG5vdCB0aGUgXCJhY3RpdmVcIiB0YWIsIG9yIGRpc2FibGVkXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5vdCgnLicgKyB0aGVtZS5nZXRDbGFzcygnc3RhdGVBY3RpdmUnKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm5vdCgnLicgKyB0aGVtZS5nZXRDbGFzcygnc3RhdGVEaXNhYmxlZCcpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlSG92ZXInKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdW5kbyB0aGUgKmhvdmVyKiBlZmZlY3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25FbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVtb3ZlQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlSG92ZXInKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoZW1lLmdldENsYXNzKCdzdGF0ZURvd24nKSk7IC8vIGlmIG1vdXNlbGVhdmUgaGFwcGVucyBiZWZvcmUgbW91c2V1cFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cENoaWxkcmVuID0gZ3JvdXBDaGlsZHJlbi5hZGQoYnV0dG9uRWwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNPbmx5QnV0dG9ucykge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwQ2hpbGRyZW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpcnN0KCkuYWRkQ2xhc3ModGhlbWUuZ2V0Q2xhc3MoJ2Nvcm5lckxlZnQnKSkuZW5kKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmxhc3QoKS5hZGRDbGFzcyh0aGVtZS5nZXRDbGFzcygnY29ybmVyUmlnaHQnKSkuZW5kKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBDaGlsZHJlbi5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBFbCA9ICQoJzxkaXY+Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzT25seUJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBFbC5hZGRDbGFzcyh0aGVtZS5nZXRDbGFzcygnYnV0dG9uR3JvdXAnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGdyb3VwRWwuYXBwZW5kKGdyb3VwQ2hpbGRyZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNlY3Rpb25FbC5hcHBlbmQoZ3JvdXBFbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uRWwuYXBwZW5kKGdyb3VwQ2hpbGRyZW4pOyAvLyAxIG9yIDAgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZWN0aW9uRWw7XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUudXBkYXRlVGl0bGUgPSBmdW5jdGlvbiAodGV4dCkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuZmluZCgnaDInKS50ZXh0KHRleHQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5hY3RpdmF0ZUJ1dHRvbiA9IGZ1bmN0aW9uIChidXR0b25OYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZWwpIHtcclxuICAgICAgICAgICAgdGhpcy5lbC5maW5kKCcuZmMtJyArIGJ1dHRvbk5hbWUgKyAnLWJ1dHRvbicpXHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnc3RhdGVBY3RpdmUnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLmRlYWN0aXZhdGVCdXR0b24gPSBmdW5jdGlvbiAoYnV0dG9uTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZWwuZmluZCgnLmZjLScgKyBidXR0b25OYW1lICsgJy1idXR0b24nKVxyXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlQWN0aXZlJykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBUb29sYmFyLnByb3RvdHlwZS5kaXNhYmxlQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJylcclxuICAgICAgICAgICAgICAgIC5wcm9wKCdkaXNhYmxlZCcsIHRydWUpXHJcbiAgICAgICAgICAgICAgICAuYWRkQ2xhc3ModGhpcy5jYWxlbmRhci50aGVtZS5nZXRDbGFzcygnc3RhdGVEaXNhYmxlZCcpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgVG9vbGJhci5wcm90b3R5cGUuZW5hYmxlQnV0dG9uID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5lbCkge1xyXG4gICAgICAgICAgICB0aGlzLmVsLmZpbmQoJy5mYy0nICsgYnV0dG9uTmFtZSArICctYnV0dG9uJylcclxuICAgICAgICAgICAgICAgIC5wcm9wKCdkaXNhYmxlZCcsIGZhbHNlKVxyXG4gICAgICAgICAgICAgICAgLnJlbW92ZUNsYXNzKHRoaXMuY2FsZW5kYXIudGhlbWUuZ2V0Q2xhc3MoJ3N0YXRlRGlzYWJsZWQnKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFRvb2xiYXIucHJvdG90eXBlLmdldFZpZXdzV2l0aEJ1dHRvbnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmlld3NXaXRoQnV0dG9ucztcclxuICAgIH07XHJcbiAgICByZXR1cm4gVG9vbGJhcjtcclxufSgpKTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gVG9vbGJhcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgb3B0aW9uc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XHJcbnZhciBsb2NhbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xyXG52YXIgTW9kZWxfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNTEpO1xyXG52YXIgT3B0aW9uc01hbmFnZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhPcHRpb25zTWFuYWdlciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE9wdGlvbnNNYW5hZ2VyKF9jYWxlbmRhciwgb3ZlcnJpZGVzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fY2FsZW5kYXIgPSBfY2FsZW5kYXI7XHJcbiAgICAgICAgX3RoaXMub3ZlcnJpZGVzID0gJC5leHRlbmQoe30sIG92ZXJyaWRlcyk7IC8vIG1ha2UgYSBjb3B5XHJcbiAgICAgICAgX3RoaXMuZHluYW1pY092ZXJyaWRlcyA9IHt9O1xyXG4gICAgICAgIF90aGlzLmNvbXB1dGUoKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBPcHRpb25zTWFuYWdlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG5ld09wdGlvbkhhc2gpIHtcclxuICAgICAgICB2YXIgb3B0aW9uQ250ID0gMDtcclxuICAgICAgICB2YXIgb3B0aW9uTmFtZTtcclxuICAgICAgICB0aGlzLnJlY29yZE92ZXJyaWRlcyhuZXdPcHRpb25IYXNoKTsgLy8gd2lsbCB0cmlnZ2VyIHRoaXMgbW9kZWwncyB3YXRjaGVyc1xyXG4gICAgICAgIGZvciAob3B0aW9uTmFtZSBpbiBuZXdPcHRpb25IYXNoKSB7XHJcbiAgICAgICAgICAgIG9wdGlvbkNudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBzcGVjaWFsLWNhc2UgaGFuZGxpbmcgb2Ygc2luZ2xlIG9wdGlvbiBjaGFuZ2UuXHJcbiAgICAgICAgLy8gaWYgb25seSBvbmUgb3B0aW9uIGNoYW5nZSwgYG9wdGlvbk5hbWVgIHdpbGwgYmUgaXRzIG5hbWUuXHJcbiAgICAgICAgaWYgKG9wdGlvbkNudCA9PT0gMSkge1xyXG4gICAgICAgICAgICBpZiAob3B0aW9uTmFtZSA9PT0gJ2hlaWdodCcgfHwgb3B0aW9uTmFtZSA9PT0gJ2NvbnRlbnRIZWlnaHQnIHx8IG9wdGlvbk5hbWUgPT09ICdhc3BlY3RSYXRpbycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGVuZGFyLnVwZGF0ZVZpZXdTaXplKHRydWUpOyAvLyBpc1Jlc2l6ZT10cnVlXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9uTmFtZSA9PT0gJ2RlZmF1bHREYXRlJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBjYW4ndCBjaGFuZ2UgZGF0ZSB0aGlzIHdheS4gdXNlIGdvdG9EYXRlIGluc3RlYWRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25OYW1lID09PSAnYnVzaW5lc3NIb3VycycpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gdGhpcyBtb2RlbCBhbHJlYWR5IHJlYWN0cyB0byB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoL14oZXZlbnR8c2VsZWN0KShPdmVybGFwfENvbnN0cmFpbnR8QWxsb3cpJC8udGVzdChvcHRpb25OYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBkb2Vzbid0IGFmZmVjdCByZW5kZXJpbmcuIG9ubHkgaW50ZXJhY3Rpb25zLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbk5hbWUgPT09ICd0aW1lem9uZScpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGVuZGFyLnZpZXcuZmxhc2goJ2luaXRpYWxFdmVudHMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYXRjaC1hbGwuIHJlcmVuZGVyIHRoZSBoZWFkZXIgYW5kIGZvb3RlciBhbmQgcmVidWlsZC9yZXJlbmRlciB0aGUgY3VycmVudCB2aWV3XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIucmVuZGVySGVhZGVyKCk7XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIucmVuZGVyRm9vdGVyKCk7XHJcbiAgICAgICAgLy8gZXZlbiBub24tY3VycmVudCB2aWV3cyB3aWxsIGJlIGFmZmVjdGVkIGJ5IHRoaXMgb3B0aW9uIGNoYW5nZS4gZG8gYmVmb3JlIHJlcmVuZGVyXHJcbiAgICAgICAgLy8gVE9ETzogZGV0YW5nbGVcclxuICAgICAgICB0aGlzLl9jYWxlbmRhci52aWV3c0J5VHlwZSA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2NhbGVuZGFyLnJlaW5pdFZpZXcoKTtcclxuICAgIH07XHJcbiAgICAvLyBDb21wdXRlcyB0aGUgZmxhdHRlbmVkIG9wdGlvbnMgaGFzaCBmb3IgdGhlIGNhbGVuZGFyIGFuZCBhc3NpZ25zIHRvIGB0aGlzLm9wdGlvbnNgLlxyXG4gICAgLy8gQXNzdW1lcyB0aGlzLm92ZXJyaWRlcyBhbmQgdGhpcy5keW5hbWljT3ZlcnJpZGVzIGhhdmUgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLlxyXG4gICAgT3B0aW9uc01hbmFnZXIucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxvY2FsZTtcclxuICAgICAgICB2YXIgbG9jYWxlRGVmYXVsdHM7XHJcbiAgICAgICAgdmFyIGlzUlRMO1xyXG4gICAgICAgIHZhciBkaXJEZWZhdWx0cztcclxuICAgICAgICB2YXIgcmF3T3B0aW9ucztcclxuICAgICAgICBsb2NhbGUgPSB1dGlsXzEuZmlyc3REZWZpbmVkKC8vIGV4cGxpY2l0IGxvY2FsZSBvcHRpb24gZ2l2ZW4/XHJcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcnJpZGVzLmxvY2FsZSwgdGhpcy5vdmVycmlkZXMubG9jYWxlKTtcclxuICAgICAgICBsb2NhbGVEZWZhdWx0cyA9IGxvY2FsZV8xLmxvY2FsZU9wdGlvbkhhc2hbbG9jYWxlXTtcclxuICAgICAgICBpZiAoIWxvY2FsZURlZmF1bHRzKSB7IC8vIGV4cGxpY2l0IGxvY2FsZSBvcHRpb24gbm90IGdpdmVuIG9yIGludmFsaWQ/XHJcbiAgICAgICAgICAgIGxvY2FsZSA9IG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cy5sb2NhbGU7XHJcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzID0gbG9jYWxlXzEubG9jYWxlT3B0aW9uSGFzaFtsb2NhbGVdIHx8IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpc1JUTCA9IHV0aWxfMS5maXJzdERlZmluZWQoLy8gYmFzZWQgb24gb3B0aW9ucyBjb21wdXRlZCBzbyBmYXIsIGlzIGRpcmVjdGlvbiBSVEw/XHJcbiAgICAgICAgdGhpcy5keW5hbWljT3ZlcnJpZGVzLmlzUlRMLCB0aGlzLm92ZXJyaWRlcy5pc1JUTCwgbG9jYWxlRGVmYXVsdHMuaXNSVEwsIG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cy5pc1JUTCk7XHJcbiAgICAgICAgZGlyRGVmYXVsdHMgPSBpc1JUTCA/IG9wdGlvbnNfMS5ydGxEZWZhdWx0cyA6IHt9O1xyXG4gICAgICAgIHRoaXMuZGlyRGVmYXVsdHMgPSBkaXJEZWZhdWx0cztcclxuICAgICAgICB0aGlzLmxvY2FsZURlZmF1bHRzID0gbG9jYWxlRGVmYXVsdHM7XHJcbiAgICAgICAgcmF3T3B0aW9ucyA9IG9wdGlvbnNfMS5tZXJnZU9wdGlvbnMoW1xyXG4gICAgICAgICAgICBvcHRpb25zXzEuZ2xvYmFsRGVmYXVsdHMsXHJcbiAgICAgICAgICAgIGRpckRlZmF1bHRzLFxyXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcclxuICAgICAgICAgICAgdGhpcy5vdmVycmlkZXMsXHJcbiAgICAgICAgICAgIHRoaXMuZHluYW1pY092ZXJyaWRlc1xyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGxvY2FsZV8xLnBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyhyYXdPcHRpb25zKTsgLy8gZmlsbCBpbiBnYXBzIHdpdGggY29tcHV0ZWQgb3B0aW9uc1xyXG4gICAgICAgIHRoaXMucmVzZXQocmF3T3B0aW9ucyk7XHJcbiAgICB9O1xyXG4gICAgLy8gc3RvcmVzIHRoZSBuZXcgb3B0aW9ucyBpbnRlcm5hbGx5LCBidXQgZG9lcyBub3QgcmVyZW5kZXIgYW55dGhpbmcuXHJcbiAgICBPcHRpb25zTWFuYWdlci5wcm90b3R5cGUucmVjb3JkT3ZlcnJpZGVzID0gZnVuY3Rpb24gKG5ld09wdGlvbkhhc2gpIHtcclxuICAgICAgICB2YXIgb3B0aW9uTmFtZTtcclxuICAgICAgICBmb3IgKG9wdGlvbk5hbWUgaW4gbmV3T3B0aW9uSGFzaCkge1xyXG4gICAgICAgICAgICB0aGlzLmR5bmFtaWNPdmVycmlkZXNbb3B0aW9uTmFtZV0gPSBuZXdPcHRpb25IYXNoW29wdGlvbk5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jYWxlbmRhci52aWV3U3BlY01hbmFnZXIuY2xlYXJDYWNoZSgpOyAvLyB0aGUgZHluYW1pYyBvdmVycmlkZSBpbnZhbGlkYXRlcyB0aGUgb3B0aW9ucyBpbiB0aGlzIGNhY2hlLCBzbyBqdXN0IGNsZWFyIGl0XHJcbiAgICAgICAgdGhpcy5jb21wdXRlKCk7IC8vIHRoaXMub3B0aW9ucyBuZWVkcyB0byBiZSByZWNvbXB1dGVkIGFmdGVyIHRoZSBkeW5hbWljIG92ZXJyaWRlXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9wdGlvbnNNYW5hZ2VyO1xyXG59KE1vZGVsXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBPcHRpb25zTWFuYWdlcjtcclxuXG5cbi8qKiovIH0pLFxuLyogMjU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIG1vbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxudmFyIFZpZXdSZWdpc3RyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XHJcbnZhciB1dGlsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG52YXIgb3B0aW9uc18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XHJcbnZhciBsb2NhbGVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xyXG52YXIgVmlld1NwZWNNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVmlld1NwZWNNYW5hZ2VyKG9wdGlvbnNNYW5hZ2VyLCBfY2FsZW5kYXIpIHtcclxuICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyID0gb3B0aW9uc01hbmFnZXI7XHJcbiAgICAgICAgdGhpcy5fY2FsZW5kYXIgPSBfY2FsZW5kYXI7XHJcbiAgICAgICAgdGhpcy5jbGVhckNhY2hlKCk7XHJcbiAgICB9XHJcbiAgICBWaWV3U3BlY01hbmFnZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy52aWV3U3BlY0NhY2hlID0ge307XHJcbiAgICB9O1xyXG4gICAgLy8gR2V0cyBpbmZvcm1hdGlvbiBhYm91dCBob3cgdG8gY3JlYXRlIGEgdmlldy4gV2lsbCB1c2UgYSBjYWNoZS5cclxuICAgIFZpZXdTcGVjTWFuYWdlci5wcm90b3R5cGUuZ2V0Vmlld1NwZWMgPSBmdW5jdGlvbiAodmlld1R5cGUpIHtcclxuICAgICAgICB2YXIgY2FjaGUgPSB0aGlzLnZpZXdTcGVjQ2FjaGU7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlW3ZpZXdUeXBlXSB8fCAoY2FjaGVbdmlld1R5cGVdID0gdGhpcy5idWlsZFZpZXdTcGVjKHZpZXdUeXBlKSk7XHJcbiAgICB9O1xyXG4gICAgLy8gR2l2ZW4gYSBkdXJhdGlvbiBzaW5ndWxhciB1bml0LCBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIsIGZpbmRzIGEgbWF0Y2hpbmcgdmlldyBzcGVjLlxyXG4gICAgLy8gUHJlZmVyZW5jZSBpcyBnaXZlbiB0byB2aWV3cyB0aGF0IGhhdmUgY29ycmVzcG9uZGluZyBidXR0b25zLlxyXG4gICAgVmlld1NwZWNNYW5hZ2VyLnByb3RvdHlwZS5nZXRVbml0Vmlld1NwZWMgPSBmdW5jdGlvbiAodW5pdCkge1xyXG4gICAgICAgIHZhciB2aWV3VHlwZXM7XHJcbiAgICAgICAgdmFyIGk7XHJcbiAgICAgICAgdmFyIHNwZWM7XHJcbiAgICAgICAgaWYgKCQuaW5BcnJheSh1bml0LCB1dGlsXzEudW5pdHNEZXNjKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgLy8gcHV0IHZpZXdzIHRoYXQgaGF2ZSBidXR0b25zIGZpcnN0LiB0aGVyZSB3aWxsIGJlIGR1cGxpY2F0ZXMsIGJ1dCBvaCB3ZWxsXHJcbiAgICAgICAgICAgIHZpZXdUeXBlcyA9IHRoaXMuX2NhbGVuZGFyLmhlYWRlci5nZXRWaWV3c1dpdGhCdXR0b25zKCk7IC8vIFRPRE86IGluY2x1ZGUgZm9vdGVyIGFzIHdlbGw/XHJcbiAgICAgICAgICAgICQuZWFjaChWaWV3UmVnaXN0cnlfMS52aWV3SGFzaCwgZnVuY3Rpb24gKHZpZXdUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICB2aWV3VHlwZXMucHVzaCh2aWV3VHlwZSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmlld1R5cGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzcGVjID0gdGhpcy5nZXRWaWV3U3BlYyh2aWV3VHlwZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNwZWMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3BlYy5zaW5nbGVVbml0ID09PSB1bml0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBCdWlsZHMgYW4gb2JqZWN0IHdpdGggaW5mb3JtYXRpb24gb24gaG93IHRvIGNyZWF0ZSBhIGdpdmVuIHZpZXdcclxuICAgIFZpZXdTcGVjTWFuYWdlci5wcm90b3R5cGUuYnVpbGRWaWV3U3BlYyA9IGZ1bmN0aW9uIChyZXF1ZXN0ZWRWaWV3VHlwZSkge1xyXG4gICAgICAgIHZhciB2aWV3T3ZlcnJpZGVzID0gdGhpcy5vcHRpb25zTWFuYWdlci5vdmVycmlkZXMudmlld3MgfHwge307XHJcbiAgICAgICAgdmFyIHNwZWNDaGFpbiA9IFtdOyAvLyBmb3IgdGhlIHZpZXcuIGxvd2VzdCB0byBoaWdoZXN0IHByaW9yaXR5XHJcbiAgICAgICAgdmFyIGRlZmF1bHRzQ2hhaW4gPSBbXTsgLy8gZm9yIHRoZSB2aWV3LiBsb3dlc3QgdG8gaGlnaGVzdCBwcmlvcml0eVxyXG4gICAgICAgIHZhciBvdmVycmlkZXNDaGFpbiA9IFtdOyAvLyBmb3IgdGhlIHZpZXcuIGxvd2VzdCB0byBoaWdoZXN0IHByaW9yaXR5XHJcbiAgICAgICAgdmFyIHZpZXdUeXBlID0gcmVxdWVzdGVkVmlld1R5cGU7XHJcbiAgICAgICAgdmFyIHNwZWM7IC8vIGZvciB0aGUgdmlld1xyXG4gICAgICAgIHZhciBvdmVycmlkZXM7IC8vIGZvciB0aGUgdmlld1xyXG4gICAgICAgIHZhciBkdXJhdGlvbklucHV0O1xyXG4gICAgICAgIHZhciBkdXJhdGlvbjtcclxuICAgICAgICB2YXIgdW5pdDtcclxuICAgICAgICAvLyBpdGVyYXRlIGZyb20gdGhlIHNwZWNpZmljIHZpZXcgZGVmaW5pdGlvbiB0byBhIG1vcmUgZ2VuZXJhbCBvbmUgdW50aWwgd2UgaGl0IGFuIGFjdHVhbCBWaWV3IGNsYXNzXHJcbiAgICAgICAgd2hpbGUgKHZpZXdUeXBlKSB7XHJcbiAgICAgICAgICAgIHNwZWMgPSBWaWV3UmVnaXN0cnlfMS52aWV3SGFzaFt2aWV3VHlwZV07XHJcbiAgICAgICAgICAgIG92ZXJyaWRlcyA9IHZpZXdPdmVycmlkZXNbdmlld1R5cGVdO1xyXG4gICAgICAgICAgICB2aWV3VHlwZSA9IG51bGw7IC8vIGNsZWFyLiBtaWdodCByZXBvcHVsYXRlIGZvciBhbm90aGVyIGl0ZXJhdGlvblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNwZWMgPT09ICdmdW5jdGlvbicpIHsgLy8gVE9ETzogZGVwcmVjYXRlXHJcbiAgICAgICAgICAgICAgICBzcGVjID0geyAnY2xhc3MnOiBzcGVjIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHNwZWMpIHtcclxuICAgICAgICAgICAgICAgIHNwZWNDaGFpbi51bnNoaWZ0KHNwZWMpO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdHNDaGFpbi51bnNoaWZ0KHNwZWMuZGVmYXVsdHMgfHwge30pO1xyXG4gICAgICAgICAgICAgICAgZHVyYXRpb25JbnB1dCA9IGR1cmF0aW9uSW5wdXQgfHwgc3BlYy5kdXJhdGlvbjtcclxuICAgICAgICAgICAgICAgIHZpZXdUeXBlID0gdmlld1R5cGUgfHwgc3BlYy50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcclxuICAgICAgICAgICAgICAgIG92ZXJyaWRlc0NoYWluLnVuc2hpZnQob3ZlcnJpZGVzKTsgLy8gdmlldy1zcGVjaWZpYyBvcHRpb24gaGFzaGVzIGhhdmUgb3B0aW9ucyBhdCB6ZXJvLWxldmVsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbklucHV0ID0gZHVyYXRpb25JbnB1dCB8fCBvdmVycmlkZXMuZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICB2aWV3VHlwZSA9IHZpZXdUeXBlIHx8IG92ZXJyaWRlcy50eXBlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNwZWMgPSB1dGlsXzEubWVyZ2VQcm9wcyhzcGVjQ2hhaW4pO1xyXG4gICAgICAgIHNwZWMudHlwZSA9IHJlcXVlc3RlZFZpZXdUeXBlO1xyXG4gICAgICAgIGlmICghc3BlY1snY2xhc3MnXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZhbGwgYmFjayB0byB0b3AtbGV2ZWwgYGR1cmF0aW9uYCBvcHRpb25cclxuICAgICAgICBkdXJhdGlvbklucHV0ID0gZHVyYXRpb25JbnB1dCB8fFxyXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnNNYW5hZ2VyLmR5bmFtaWNPdmVycmlkZXMuZHVyYXRpb24gfHxcclxuICAgICAgICAgICAgdGhpcy5vcHRpb25zTWFuYWdlci5vdmVycmlkZXMuZHVyYXRpb247XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uSW5wdXQpIHtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSBtb21lbnQuZHVyYXRpb24oZHVyYXRpb25JbnB1dCk7XHJcbiAgICAgICAgICAgIGlmIChkdXJhdGlvbi52YWx1ZU9mKCkpIHsgLy8gdmFsaWQ/XHJcbiAgICAgICAgICAgICAgICB1bml0ID0gdXRpbF8xLmNvbXB1dGVEdXJhdGlvbkdyZWF0ZXN0VW5pdChkdXJhdGlvbiwgZHVyYXRpb25JbnB1dCk7XHJcbiAgICAgICAgICAgICAgICBzcGVjLmR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgICAgICAgICBzcGVjLmR1cmF0aW9uVW5pdCA9IHVuaXQ7XHJcbiAgICAgICAgICAgICAgICAvLyB2aWV3IGlzIGEgc2luZ2xlLXVuaXQgZHVyYXRpb24sIGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIlxyXG4gICAgICAgICAgICAgICAgLy8gaW5jb3Jwb3JhdGUgb3B0aW9ucyBmb3IgdGhpcy4gbG93ZXN0IHByaW9yaXR5XHJcbiAgICAgICAgICAgICAgICBpZiAoZHVyYXRpb24uYXModW5pdCkgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzcGVjLnNpbmdsZVVuaXQgPSB1bml0O1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJyaWRlc0NoYWluLnVuc2hpZnQodmlld092ZXJyaWRlc1t1bml0XSB8fCB7fSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3BlYy5kZWZhdWx0cyA9IG9wdGlvbnNfMS5tZXJnZU9wdGlvbnMoZGVmYXVsdHNDaGFpbik7XHJcbiAgICAgICAgc3BlYy5vdmVycmlkZXMgPSBvcHRpb25zXzEubWVyZ2VPcHRpb25zKG92ZXJyaWRlc0NoYWluKTtcclxuICAgICAgICB0aGlzLmJ1aWxkVmlld1NwZWNPcHRpb25zKHNwZWMpO1xyXG4gICAgICAgIHRoaXMuYnVpbGRWaWV3U3BlY0J1dHRvblRleHQoc3BlYywgcmVxdWVzdGVkVmlld1R5cGUpO1xyXG4gICAgICAgIHJldHVybiBzcGVjO1xyXG4gICAgfTtcclxuICAgIC8vIEJ1aWxkcyBhbmQgYXNzaWducyBhIHZpZXcgc3BlYydzIG9wdGlvbnMgb2JqZWN0IGZyb20gaXRzIGFscmVhZHktYXNzaWduZWQgZGVmYXVsdHMgYW5kIG92ZXJyaWRlc1xyXG4gICAgVmlld1NwZWNNYW5hZ2VyLnByb3RvdHlwZS5idWlsZFZpZXdTcGVjT3B0aW9ucyA9IGZ1bmN0aW9uIChzcGVjKSB7XHJcbiAgICAgICAgdmFyIG9wdGlvbnNNYW5hZ2VyID0gdGhpcy5vcHRpb25zTWFuYWdlcjtcclxuICAgICAgICBzcGVjLm9wdGlvbnMgPSBvcHRpb25zXzEubWVyZ2VPcHRpb25zKFtcclxuICAgICAgICAgICAgb3B0aW9uc18xLmdsb2JhbERlZmF1bHRzLFxyXG4gICAgICAgICAgICBzcGVjLmRlZmF1bHRzLFxyXG4gICAgICAgICAgICBvcHRpb25zTWFuYWdlci5kaXJEZWZhdWx0cyxcclxuICAgICAgICAgICAgb3B0aW9uc01hbmFnZXIubG9jYWxlRGVmYXVsdHMsXHJcbiAgICAgICAgICAgIG9wdGlvbnNNYW5hZ2VyLm92ZXJyaWRlcyxcclxuICAgICAgICAgICAgc3BlYy5vdmVycmlkZXMsXHJcbiAgICAgICAgICAgIG9wdGlvbnNNYW5hZ2VyLmR5bmFtaWNPdmVycmlkZXMgLy8gZHluYW1pY2FsbHkgc2V0IHZpYSBzZXR0ZXIuIGhpZ2hlc3QgcHJlY2VkZW5jZVxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGxvY2FsZV8xLnBvcHVsYXRlSW5zdGFuY2VDb21wdXRhYmxlT3B0aW9ucyhzcGVjLm9wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIC8vIENvbXB1dGVzIGFuZCBhc3NpZ25zIGEgdmlldyBzcGVjJ3MgYnV0dG9uVGV4dC1yZWxhdGVkIG9wdGlvbnNcclxuICAgIFZpZXdTcGVjTWFuYWdlci5wcm90b3R5cGUuYnVpbGRWaWV3U3BlY0J1dHRvblRleHQgPSBmdW5jdGlvbiAoc3BlYywgcmVxdWVzdGVkVmlld1R5cGUpIHtcclxuICAgICAgICB2YXIgb3B0aW9uc01hbmFnZXIgPSB0aGlzLm9wdGlvbnNNYW5hZ2VyO1xyXG4gICAgICAgIC8vIGdpdmVuIGFuIG9wdGlvbnMgb2JqZWN0IHdpdGggYSBwb3NzaWJsZSBgYnV0dG9uVGV4dGAgaGFzaCwgbG9va3VwIHRoZSBidXR0b25UZXh0IGZvciB0aGVcclxuICAgICAgICAvLyByZXF1ZXN0ZWQgdmlldywgZmFsbGluZyBiYWNrIHRvIGEgZ2VuZXJpYyB1bml0IGVudHJ5IGxpa2UgXCJ3ZWVrXCIgb3IgXCJkYXlcIlxyXG4gICAgICAgIGZ1bmN0aW9uIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHZhciBidXR0b25UZXh0ID0gb3B0aW9ucy5idXR0b25UZXh0IHx8IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dFtyZXF1ZXN0ZWRWaWV3VHlwZV0gfHxcclxuICAgICAgICAgICAgICAgIC8vIHZpZXcgY2FuIGRlY2lkZSB0byBsb29rIHVwIGEgY2VydGFpbiBrZXlcclxuICAgICAgICAgICAgICAgIChzcGVjLmJ1dHRvblRleHRLZXkgPyBidXR0b25UZXh0W3NwZWMuYnV0dG9uVGV4dEtleV0gOiBudWxsKSB8fFxyXG4gICAgICAgICAgICAgICAgLy8gYSBrZXkgbGlrZSBcIm1vbnRoXCJcclxuICAgICAgICAgICAgICAgIChzcGVjLnNpbmdsZVVuaXQgPyBidXR0b25UZXh0W3NwZWMuc2luZ2xlVW5pdF0gOiBudWxsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaGlnaGVzdCB0byBsb3dlc3QgcHJpb3JpdHlcclxuICAgICAgICBzcGVjLmJ1dHRvblRleHRPdmVycmlkZSA9XHJcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGV4dChvcHRpb25zTWFuYWdlci5keW5hbWljT3ZlcnJpZGVzKSB8fFxyXG4gICAgICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbnNNYW5hZ2VyLm92ZXJyaWRlcykgfHwgLy8gY29uc3RydWN0b3Itc3BlY2lmaWVkIGJ1dHRvblRleHQgbG9va3VwIGhhc2ggdGFrZXMgcHJlY2VkZW5jZVxyXG4gICAgICAgICAgICAgICAgc3BlYy5vdmVycmlkZXMuYnV0dG9uVGV4dDsgLy8gYGJ1dHRvblRleHRgIGZvciB2aWV3LXNwZWNpZmljIG9wdGlvbnMgaXMgYSBzdHJpbmdcclxuICAgICAgICAvLyBoaWdoZXN0IHRvIGxvd2VzdCBwcmlvcml0eS4gbWlycm9ycyBidWlsZFZpZXdTcGVjT3B0aW9uc1xyXG4gICAgICAgIHNwZWMuYnV0dG9uVGV4dERlZmF1bHQgPVxyXG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uc01hbmFnZXIubG9jYWxlRGVmYXVsdHMpIHx8XHJcbiAgICAgICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uc01hbmFnZXIuZGlyRGVmYXVsdHMpIHx8XHJcbiAgICAgICAgICAgICAgICBzcGVjLmRlZmF1bHRzLmJ1dHRvblRleHQgfHwgLy8gYSBzaW5nbGUgc3RyaW5nLiBmcm9tIFZpZXdTdWJjbGFzcy5kZWZhdWx0c1xyXG4gICAgICAgICAgICAgICAgcXVlcnlCdXR0b25UZXh0KG9wdGlvbnNfMS5nbG9iYWxEZWZhdWx0cykgfHxcclxuICAgICAgICAgICAgICAgIChzcGVjLmR1cmF0aW9uID8gdGhpcy5fY2FsZW5kYXIuaHVtYW5pemVEdXJhdGlvbihzcGVjLmR1cmF0aW9uKSA6IG51bGwpIHx8IC8vIGxpa2UgXCIzIGRheXNcIlxyXG4gICAgICAgICAgICAgICAgcmVxdWVzdGVkVmlld1R5cGU7IC8vIGZhbGwgYmFjayB0byBnaXZlbiB2aWV3IG5hbWVcclxuICAgIH07XHJcbiAgICByZXR1cm4gVmlld1NwZWNNYW5hZ2VyO1xyXG59KCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBWaWV3U3BlY01hbmFnZXI7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBFdmVudFNvdXJjZVBhcnNlcl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XHJcbnZhciBBcnJheUV2ZW50U291cmNlXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcclxudmFyIEZ1bmNFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjMpO1xyXG52YXIgSnNvbkZlZWRFdmVudFNvdXJjZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMjQpO1xyXG5FdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQucmVnaXN0ZXJDbGFzcyhBcnJheUV2ZW50U291cmNlXzEuZGVmYXVsdCk7XHJcbkV2ZW50U291cmNlUGFyc2VyXzEuZGVmYXVsdC5yZWdpc3RlckNsYXNzKEZ1bmNFdmVudFNvdXJjZV8xLmRlZmF1bHQpO1xyXG5FdmVudFNvdXJjZVBhcnNlcl8xLmRlZmF1bHQucmVnaXN0ZXJDbGFzcyhKc29uRmVlZEV2ZW50U291cmNlXzEuZGVmYXVsdCk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBUaGVtZVJlZ2lzdHJ5XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KTtcclxudmFyIFN0YW5kYXJkVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIxKTtcclxudmFyIEpxdWVyeVVpVGhlbWVfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjIyKTtcclxudmFyIEJvb3RzdHJhcDNUaGVtZV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjIpO1xyXG52YXIgQm9vdHN0cmFwNFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2Myk7XHJcblRoZW1lUmVnaXN0cnlfMS5kZWZpbmVUaGVtZVN5c3RlbSgnc3RhbmRhcmQnLCBTdGFuZGFyZFRoZW1lXzEuZGVmYXVsdCk7XHJcblRoZW1lUmVnaXN0cnlfMS5kZWZpbmVUaGVtZVN5c3RlbSgnanF1ZXJ5LXVpJywgSnF1ZXJ5VWlUaGVtZV8xLmRlZmF1bHQpO1xyXG5UaGVtZVJlZ2lzdHJ5XzEuZGVmaW5lVGhlbWVTeXN0ZW0oJ2Jvb3RzdHJhcDMnLCBCb290c3RyYXAzVGhlbWVfMS5kZWZhdWx0KTtcclxuVGhlbWVSZWdpc3RyeV8xLmRlZmluZVRoZW1lU3lzdGVtKCdib290c3RyYXA0JywgQm9vdHN0cmFwNFRoZW1lXzEuZGVmYXVsdCk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxudmFyIEJvb3RzdHJhcDNUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEJvb3RzdHJhcDNUaGVtZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJvb3RzdHJhcDNUaGVtZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQm9vdHN0cmFwM1RoZW1lO1xyXG59KFRoZW1lXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCb290c3RyYXAzVGhlbWU7XHJcbkJvb3RzdHJhcDNUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcclxuICAgIHdpZGdldDogJ2ZjLWJvb3RzdHJhcDMnLFxyXG4gICAgdGFibGVHcmlkOiAndGFibGUtYm9yZGVyZWQnLFxyXG4gICAgdGFibGVMaXN0OiAndGFibGUnLFxyXG4gICAgdGFibGVMaXN0SGVhZGluZzogJ2FjdGl2ZScsXHJcbiAgICBidXR0b25Hcm91cDogJ2J0bi1ncm91cCcsXHJcbiAgICBidXR0b246ICdidG4gYnRuLWRlZmF1bHQnLFxyXG4gICAgc3RhdGVBY3RpdmU6ICdhY3RpdmUnLFxyXG4gICAgc3RhdGVEaXNhYmxlZDogJ2Rpc2FibGVkJyxcclxuICAgIHRvZGF5OiAnYWxlcnQgYWxlcnQtaW5mbycsXHJcbiAgICBwb3BvdmVyOiAncGFuZWwgcGFuZWwtZGVmYXVsdCcsXHJcbiAgICBwb3BvdmVySGVhZGVyOiAncGFuZWwtaGVhZGluZycsXHJcbiAgICBwb3BvdmVyQ29udGVudDogJ3BhbmVsLWJvZHknLFxyXG4gICAgLy8gZGF5IGdyaWRcclxuICAgIC8vIGZvciBsZWZ0L3JpZ2h0IGJvcmRlciBjb2xvciB3aGVuIGJvcmRlciBpcyBpbnNldCBmcm9tIGVkZ2VzIChhbGwtZGF5IGluIGFnZW5kYSB2aWV3KVxyXG4gICAgLy8gYXZvaWQgYHBhbmVsYCBjbGFzcyBiL2MgZG9uJ3Qgd2FudCBtYXJnaW5zL3JhZGl1cy4gb25seSBib3JkZXIgY29sb3IuXHJcbiAgICBoZWFkZXJSb3c6ICdwYW5lbC1kZWZhdWx0JyxcclxuICAgIGRheVJvdzogJ3BhbmVsLWRlZmF1bHQnLFxyXG4gICAgLy8gbGlzdCB2aWV3XHJcbiAgICBsaXN0VmlldzogJ3BhbmVsIHBhbmVsLWRlZmF1bHQnXHJcbn07XHJcbkJvb3RzdHJhcDNUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdnbHlwaGljb24nO1xyXG5Cb290c3RyYXAzVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xyXG4gICAgY2xvc2U6ICdnbHlwaGljb24tcmVtb3ZlJyxcclxuICAgIHByZXY6ICdnbHlwaGljb24tY2hldnJvbi1sZWZ0JyxcclxuICAgIG5leHQ6ICdnbHlwaGljb24tY2hldnJvbi1yaWdodCcsXHJcbiAgICBwcmV2WWVhcjogJ2dseXBoaWNvbi1iYWNrd2FyZCcsXHJcbiAgICBuZXh0WWVhcjogJ2dseXBoaWNvbi1mb3J3YXJkJ1xyXG59O1xyXG5Cb290c3RyYXAzVGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZU9wdGlvbiA9ICdib290c3RyYXBHbHlwaGljb25zJztcclxuQm9vdHN0cmFwM1RoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb24gPSAnYm9vdHN0cmFwR2x5cGhpY29uJztcclxuQm9vdHN0cmFwM1RoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnZ2x5cGhpY29uLSc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI2MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxudmFyIFRoZW1lXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxudmFyIEJvb3RzdHJhcDRUaGVtZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEJvb3RzdHJhcDRUaGVtZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJvb3RzdHJhcDRUaGVtZSgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQm9vdHN0cmFwNFRoZW1lO1xyXG59KFRoZW1lXzEuZGVmYXVsdCkpO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBCb290c3RyYXA0VGhlbWU7XHJcbkJvb3RzdHJhcDRUaGVtZS5wcm90b3R5cGUuY2xhc3NlcyA9IHtcclxuICAgIHdpZGdldDogJ2ZjLWJvb3RzdHJhcDQnLFxyXG4gICAgdGFibGVHcmlkOiAndGFibGUtYm9yZGVyZWQnLFxyXG4gICAgdGFibGVMaXN0OiAndGFibGUnLFxyXG4gICAgdGFibGVMaXN0SGVhZGluZzogJ3RhYmxlLWFjdGl2ZScsXHJcbiAgICBidXR0b25Hcm91cDogJ2J0bi1ncm91cCcsXHJcbiAgICBidXR0b246ICdidG4gYnRuLXByaW1hcnknLFxyXG4gICAgc3RhdGVBY3RpdmU6ICdhY3RpdmUnLFxyXG4gICAgc3RhdGVEaXNhYmxlZDogJ2Rpc2FibGVkJyxcclxuICAgIHRvZGF5OiAnYWxlcnQgYWxlcnQtaW5mbycsXHJcbiAgICBwb3BvdmVyOiAnY2FyZCBjYXJkLXByaW1hcnknLFxyXG4gICAgcG9wb3ZlckhlYWRlcjogJ2NhcmQtaGVhZGVyJyxcclxuICAgIHBvcG92ZXJDb250ZW50OiAnY2FyZC1ib2R5JyxcclxuICAgIC8vIGRheSBncmlkXHJcbiAgICAvLyBmb3IgbGVmdC9yaWdodCBib3JkZXIgY29sb3Igd2hlbiBib3JkZXIgaXMgaW5zZXQgZnJvbSBlZGdlcyAoYWxsLWRheSBpbiBhZ2VuZGEgdmlldylcclxuICAgIC8vIGF2b2lkIGB0YWJsZWAgY2xhc3MgYi9jIGRvbid0IHdhbnQgbWFyZ2lucy9wYWRkaW5nL3N0cnVjdHVyZS4gb25seSBib3JkZXIgY29sb3IuXHJcbiAgICBoZWFkZXJSb3c6ICd0YWJsZS1ib3JkZXJlZCcsXHJcbiAgICBkYXlSb3c6ICd0YWJsZS1ib3JkZXJlZCcsXHJcbiAgICAvLyBsaXN0IHZpZXdcclxuICAgIGxpc3RWaWV3OiAnY2FyZCBjYXJkLXByaW1hcnknXHJcbn07XHJcbkJvb3RzdHJhcDRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYSc7XHJcbkJvb3RzdHJhcDRUaGVtZS5wcm90b3R5cGUuaWNvbkNsYXNzZXMgPSB7XHJcbiAgICBjbG9zZTogJ2ZhLXRpbWVzJyxcclxuICAgIHByZXY6ICdmYS1jaGV2cm9uLWxlZnQnLFxyXG4gICAgbmV4dDogJ2ZhLWNoZXZyb24tcmlnaHQnLFxyXG4gICAgcHJldlllYXI6ICdmYS1hbmdsZS1kb3VibGUtbGVmdCcsXHJcbiAgICBuZXh0WWVhcjogJ2ZhLWFuZ2xlLWRvdWJsZS1yaWdodCdcclxufTtcclxuQm9vdHN0cmFwNFRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVPcHRpb24gPSAnYm9vdHN0cmFwRm9udEF3ZXNvbWUnO1xyXG5Cb290c3RyYXA0VGhlbWUucHJvdG90eXBlLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiA9ICdib290c3RyYXBGb250QXdlc29tZSc7XHJcbkJvb3RzdHJhcDRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZhLSc7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBWaWV3UmVnaXN0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xyXG52YXIgQmFzaWNWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcclxudmFyIE1vbnRoVmlld18xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNDYpO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdiYXNpYycsIHtcclxuICAgICdjbGFzcyc6IEJhc2ljVmlld18xLmRlZmF1bHRcclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2Jhc2ljRGF5Jywge1xyXG4gICAgdHlwZTogJ2Jhc2ljJyxcclxuICAgIGR1cmF0aW9uOiB7IGRheXM6IDEgfVxyXG59KTtcclxuVmlld1JlZ2lzdHJ5XzEuZGVmaW5lVmlldygnYmFzaWNXZWVrJywge1xyXG4gICAgdHlwZTogJ2Jhc2ljJyxcclxuICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ21vbnRoJywge1xyXG4gICAgJ2NsYXNzJzogTW9udGhWaWV3XzEuZGVmYXVsdCxcclxuICAgIGR1cmF0aW9uOiB7IG1vbnRoczogMSB9LFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBmaXhlZFdlZWtDb3VudDogdHJ1ZVxyXG4gICAgfVxyXG59KTtcclxuXG5cbi8qKiovIH0pLFxuLyogMjY1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFZpZXdSZWdpc3RyeV8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XHJcbnZhciBBZ2VuZGFWaWV3XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzOCk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2FnZW5kYScsIHtcclxuICAgICdjbGFzcyc6IEFnZW5kYVZpZXdfMS5kZWZhdWx0LFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBhbGxEYXlTbG90OiB0cnVlLFxyXG4gICAgICAgIHNsb3REdXJhdGlvbjogJzAwOjMwOjAwJyxcclxuICAgICAgICBzbG90RXZlbnRPdmVybGFwOiB0cnVlIC8vIGEgYmFkIG5hbWUuIGNvbmZ1c2VkIHdpdGggb3ZlcmxhcC9jb25zdHJhaW50IHN5c3RlbVxyXG4gICAgfVxyXG59KTtcclxuVmlld1JlZ2lzdHJ5XzEuZGVmaW5lVmlldygnYWdlbmRhRGF5Jywge1xyXG4gICAgdHlwZTogJ2FnZW5kYScsXHJcbiAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2FnZW5kYVdlZWsnLCB7XHJcbiAgICB0eXBlOiAnYWdlbmRhJyxcclxuICAgIGR1cmF0aW9uOiB7IHdlZWtzOiAxIH1cclxufSk7XHJcblxuXG4vKioqLyB9KSxcbi8qIDI2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBWaWV3UmVnaXN0cnlfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xyXG52YXIgTGlzdFZpZXdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjQ4KTtcclxuVmlld1JlZ2lzdHJ5XzEuZGVmaW5lVmlldygnbGlzdCcsIHtcclxuICAgICdjbGFzcyc6IExpc3RWaWV3XzEuZGVmYXVsdCxcclxuICAgIGJ1dHRvblRleHRLZXk6ICdsaXN0JyxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgYnV0dG9uVGV4dDogJ2xpc3QnLFxyXG4gICAgICAgIGxpc3REYXlGb3JtYXQ6ICdMTCcsXHJcbiAgICAgICAgbm9FdmVudHNNZXNzYWdlOiAnTm8gZXZlbnRzIHRvIGRpc3BsYXknXHJcbiAgICB9XHJcbn0pO1xyXG5WaWV3UmVnaXN0cnlfMS5kZWZpbmVWaWV3KCdsaXN0RGF5Jywge1xyXG4gICAgdHlwZTogJ2xpc3QnLFxyXG4gICAgZHVyYXRpb246IHsgZGF5czogMSB9LFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBsaXN0RGF5Rm9ybWF0OiAnZGRkZCcgLy8gZGF5LW9mLXdlZWsgaXMgYWxsIHdlIG5lZWQuIGZ1bGwgZGF0ZSBpcyBwcm9iYWJseSBpbiBoZWFkZXJcclxuICAgIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2xpc3RXZWVrJywge1xyXG4gICAgdHlwZTogJ2xpc3QnLFxyXG4gICAgZHVyYXRpb246IHsgd2Vla3M6IDEgfSxcclxuICAgIGRlZmF1bHRzOiB7XHJcbiAgICAgICAgbGlzdERheUZvcm1hdDogJ2RkZGQnLFxyXG4gICAgICAgIGxpc3REYXlBbHRGb3JtYXQ6ICdMTCdcclxuICAgIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2xpc3RNb250aCcsIHtcclxuICAgIHR5cGU6ICdsaXN0JyxcclxuICAgIGR1cmF0aW9uOiB7IG1vbnRoOiAxIH0sXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICAgIGxpc3REYXlBbHRGb3JtYXQ6ICdkZGRkJyAvLyBkYXktb2Ytd2VlayBpcyBuaWNlLXRvLWhhdmVcclxuICAgIH1cclxufSk7XHJcblZpZXdSZWdpc3RyeV8xLmRlZmluZVZpZXcoJ2xpc3RZZWFyJywge1xyXG4gICAgdHlwZTogJ2xpc3QnLFxyXG4gICAgZHVyYXRpb246IHsgeWVhcjogMSB9LFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgICBsaXN0RGF5QWx0Rm9ybWF0OiAnZGRkZCcgLy8gZGF5LW9mLXdlZWsgaXMgbmljZS10by1oYXZlXHJcbiAgICB9XHJcbn0pO1xyXG5cblxuLyoqKi8gfSksXG4vKiAyNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7IiwiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIiwiLyohXG4gKiBGdWxsQ2FsZW5kYXIgdjMuMTAuMlxuICogRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL1xuICogKGMpIDIwMTkgQWRhbSBTaGF3XG4gKi9cbiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQocmVxdWlyZShcImZ1bGxjYWxlbmRhclwiKSxyZXF1aXJlKFwianF1ZXJ5XCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImZ1bGxjYWxlbmRhclwiLFwianF1ZXJ5XCJdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP3QocmVxdWlyZShcImZ1bGxjYWxlbmRhclwiKSxyZXF1aXJlKFwianF1ZXJ5XCIpKTp0KGUuRnVsbENhbGVuZGFyLGUualF1ZXJ5KX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobyl7aWYocltvXSlyZXR1cm4gcltvXS5leHBvcnRzO3ZhciBuPXJbb109e2k6byxsOiExLGV4cG9ydHM6e319O3JldHVybiBlW29dLmNhbGwobi5leHBvcnRzLG4sbi5leHBvcnRzLHQpLG4ubD0hMCxuLmV4cG9ydHN9dmFyIHI9e307cmV0dXJuIHQubT1lLHQuYz1yLHQuZD1mdW5jdGlvbihlLHIsbyl7dC5vKGUscil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpvfSl9LHQubj1mdW5jdGlvbihlKXt2YXIgcj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKHIsXCJhXCIscikscn0sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9XCJcIix0KHQucz0yNzApfSh7MTpmdW5jdGlvbih0LHIpe3QuZXhwb3J0cz1lfSwyOmZ1bmN0aW9uKGUsdCl7dmFyIHI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHx7X19wcm90b19fOltdfWluc3RhbmNlb2YgQXJyYXkmJmZ1bmN0aW9uKGUsdCl7ZS5fX3Byb3RvX189dH18fGZ1bmN0aW9uKGUsdCl7Zm9yKHZhciByIGluIHQpdC5oYXNPd25Qcm9wZXJ0eShyKSYmKGVbcl09dFtyXSl9O3QuX19leHRlbmRzPWZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbygpe3RoaXMuY29uc3RydWN0b3I9ZX1yKGUsdCksZS5wcm90b3R5cGU9bnVsbD09PXQ/T2JqZWN0LmNyZWF0ZSh0KTooby5wcm90b3R5cGU9dC5wcm90b3R5cGUsbmV3IG8pfX0sMjcwOmZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgbz1yKDEpLG49cigyNzEpO28uRXZlbnRTb3VyY2VQYXJzZXIucmVnaXN0ZXJDbGFzcyhuLmRlZmF1bHQpLG8uR2NhbEV2ZW50U291cmNlPW4uZGVmYXVsdH0sMjcxOmZ1bmN0aW9uKGUsdCxyKXtmdW5jdGlvbiBvKGUpe3ZhciB0O3JldHVybi9eW15cXC9dK0AoW15cXC9cXC5dK1xcLikqKGdvb2dsZXxnb29nbGVtYWlsfGdtYWlsKVxcLmNvbSQvLnRlc3QoZSk/ZToodD0vXmh0dHBzOlxcL1xcL3d3dy5nb29nbGVhcGlzLmNvbVxcL2NhbGVuZGFyXFwvdjNcXC9jYWxlbmRhcnNcXC8oW15cXC9dKikvLmV4ZWMoZSkpfHwodD0vXmh0dHBzPzpcXC9cXC93d3cuZ29vZ2xlLmNvbVxcL2NhbGVuZGFyXFwvZmVlZHNcXC8oW15cXC9dKikvLmV4ZWMoZSkpP2RlY29kZVVSSUNvbXBvbmVudCh0WzFdKTp2b2lkIDB9ZnVuY3Rpb24gbihlLHQpe3JldHVybiBlLnJlcGxhY2UoLyhcXD8uKj8pPygjfCQpLyxmdW5jdGlvbihlLHIsbyl7cmV0dXJuKHI/citcIiZcIjpcIj9cIikrdCtvfSl9T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIGE9cigyKSxsPXIoMyksaT1yKDEpLHU9ZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdCgpe3JldHVybiBudWxsIT09ZSYmZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl8fHRoaXN9cmV0dXJuIGEuX19leHRlbmRzKHQsZSksdC5wYXJzZT1mdW5jdGlvbihlLHQpe3ZhciByO3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBlP3I9ZTpcInN0cmluZ1wiPT10eXBlb2YgZSYmKHI9e3VybDplfSksISFyJiZpLkV2ZW50U291cmNlLnBhcnNlLmNhbGwodGhpcyxyLHQpfSx0LnByb3RvdHlwZS5mZXRjaD1mdW5jdGlvbihlLHQscil7dmFyIG89dGhpcyxuPXRoaXMuYnVpbGRVcmwoKSxhPXRoaXMuYnVpbGRSZXF1ZXN0UGFyYW1zKGUsdCxyKSx1PXRoaXMuYWpheFNldHRpbmdzfHx7fSxzPXUuc3VjY2VzcztyZXR1cm4gYT8odGhpcy5jYWxlbmRhci5wdXNoTG9hZGluZygpLGkuUHJvbWlzZS5jb25zdHJ1Y3QoZnVuY3Rpb24oZSx0KXtsLmFqYXgobC5leHRlbmQoe30saS5Kc29uRmVlZEV2ZW50U291cmNlLkFKQVhfREVGQVVMVFMsdSx7dXJsOm4sZGF0YTphLHN1Y2Nlc3M6ZnVuY3Rpb24ocixuLHUpe3ZhciBjLHA7by5jYWxlbmRhci5wb3BMb2FkaW5nKCksci5lcnJvcj8oby5yZXBvcnRFcnJvcihcIkdvb2dsZSBDYWxlbmRhciBBUEk6IFwiK3IuZXJyb3IubWVzc2FnZSxyLmVycm9yLmVycm9ycyksdCgpKTpyLml0ZW1zJiYoYz1vLmdjYWxJdGVtc1RvUmF3RXZlbnREZWZzKHIuaXRlbXMsYS50aW1lWm9uZSkscD1pLmFwcGx5QWxsKHMsbyxbcixuLHVdKSxsLmlzQXJyYXkocCkmJihjPXApLGUoby5wYXJzZUV2ZW50RGVmcyhjKSkpfSxlcnJvcjpmdW5jdGlvbihlLHIsbil7by5yZXBvcnRFcnJvcihcIkdvb2dsZSBDYWxlbmRhciBuZXR3b3JrIGZhaWx1cmU6IFwiK3IsW2Usbl0pLG8uY2FsZW5kYXIucG9wTG9hZGluZygpLHQoKX19KSl9KSk6aS5Qcm9taXNlLnJlamVjdCgpfSx0LnByb3RvdHlwZS5nY2FsSXRlbXNUb1Jhd0V2ZW50RGVmcz1mdW5jdGlvbihlLHQpe3ZhciByPXRoaXM7cmV0dXJuIGUubWFwKGZ1bmN0aW9uKGUpe3JldHVybiByLmdjYWxJdGVtVG9SYXdFdmVudERlZihlLHQpfSl9LHQucHJvdG90eXBlLmdjYWxJdGVtVG9SYXdFdmVudERlZj1mdW5jdGlvbihlLHQpe3ZhciByPWUuaHRtbExpbmt8fG51bGw7ciYmdCYmKHI9bihyLFwiY3R6PVwiK3QpKTt2YXIgbz17fTtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgZS5leHRlbmRlZFByb3BlcnRpZXMmJlwib2JqZWN0XCI9PXR5cGVvZiBlLmV4dGVuZGVkUHJvcGVydGllcy5zaGFyZWQmJihvPWUuZXh0ZW5kZWRQcm9wZXJ0aWVzLnNoYXJlZCkse2lkOmUuaWQsdGl0bGU6ZS5zdW1tYXJ5LHN0YXJ0OmUuc3RhcnQuZGF0ZVRpbWV8fGUuc3RhcnQuZGF0ZSxlbmQ6ZS5lbmQuZGF0ZVRpbWV8fGUuZW5kLmRhdGUsdXJsOnIsbG9jYXRpb246ZS5sb2NhdGlvbixkZXNjcmlwdGlvbjplLmRlc2NyaXB0aW9uLGV4dGVuZGVkUHJvcGVydGllczpvfX0sdC5wcm90b3R5cGUuYnVpbGRVcmw9ZnVuY3Rpb24oKXtyZXR1cm4gdC5BUElfQkFTRStcIi9cIitlbmNvZGVVUklDb21wb25lbnQodGhpcy5nb29nbGVDYWxlbmRhcklkKStcIi9ldmVudHM/Y2FsbGJhY2s9P1wifSx0LnByb3RvdHlwZS5idWlsZFJlcXVlc3RQYXJhbXM9ZnVuY3Rpb24oZSx0LHIpe3ZhciBvLG49dGhpcy5nb29nbGVDYWxlbmRhckFwaUtleXx8dGhpcy5jYWxlbmRhci5vcHQoXCJnb29nbGVDYWxlbmRhckFwaUtleVwiKTtyZXR1cm4gbj8oZS5oYXNab25lKCl8fChlPWUuY2xvbmUoKS51dGMoKS5hZGQoLTEsXCJkYXlcIikpLHQuaGFzWm9uZSgpfHwodD10LmNsb25lKCkudXRjKCkuYWRkKDEsXCJkYXlcIikpLG89bC5leHRlbmQodGhpcy5hamF4U2V0dGluZ3MuZGF0YXx8e30se2tleTpuLHRpbWVNaW46ZS5mb3JtYXQoKSx0aW1lTWF4OnQuZm9ybWF0KCksc2luZ2xlRXZlbnRzOiEwLG1heFJlc3VsdHM6OTk5OX0pLHImJlwibG9jYWxcIiE9PXImJihvLnRpbWVab25lPXIucmVwbGFjZShcIiBcIixcIl9cIikpLG8pOih0aGlzLnJlcG9ydEVycm9yKFwiU3BlY2lmeSBhIGdvb2dsZUNhbGVuZGFyQXBpS2V5LiBTZWUgaHR0cDovL2Z1bGxjYWxlbmRhci5pby9kb2NzL2dvb2dsZV9jYWxlbmRhci9cIiksbnVsbCl9LHQucHJvdG90eXBlLnJlcG9ydEVycm9yPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dGhpcy5jYWxlbmRhcixvPXIub3B0KFwiZ29vZ2xlQ2FsZW5kYXJFcnJvclwiKSxuPXR8fFt7bWVzc2FnZTplfV07dGhpcy5nb29nbGVDYWxlbmRhckVycm9yJiZ0aGlzLmdvb2dsZUNhbGVuZGFyRXJyb3IuYXBwbHkocixuKSxvJiZvLmFwcGx5KHIsbiksaS53YXJuLmFwcGx5KG51bGwsW2VdLmNvbmNhdCh0fHxbXSkpfSx0LnByb3RvdHlwZS5nZXRQcmltaXRpdmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nb29nbGVDYWxlbmRhcklkfSx0LnByb3RvdHlwZS5hcHBseU1hbnVhbFN0YW5kYXJkUHJvcHM9ZnVuY3Rpb24oZSl7dmFyIHQ9aS5FdmVudFNvdXJjZS5wcm90b3R5cGUuYXBwbHlNYW51YWxTdGFuZGFyZFByb3BzLmFwcGx5KHRoaXMsYXJndW1lbnRzKSxyPWUuZ29vZ2xlQ2FsZW5kYXJJZDtyZXR1cm4gbnVsbD09ciYmZS51cmwmJihyPW8oZS51cmwpKSxudWxsIT1yJiYodGhpcy5nb29nbGVDYWxlbmRhcklkPXIsdCl9LHQucHJvdG90eXBlLmFwcGx5TWlzY1Byb3BzPWZ1bmN0aW9uKGUpe3RoaXMuYWpheFNldHRpbmdzfHwodGhpcy5hamF4U2V0dGluZ3M9e30pLGwuZXh0ZW5kKHRoaXMuYWpheFNldHRpbmdzLGUpfSx0LkFQSV9CQVNFPVwiaHR0cHM6Ly93d3cuZ29vZ2xlYXBpcy5jb20vY2FsZW5kYXIvdjMvY2FsZW5kYXJzXCIsdH0oaS5FdmVudFNvdXJjZSk7dC5kZWZhdWx0PXUsdS5kZWZpbmVTdGFuZGFyZFByb3BzKHt1cmw6ITEsZ29vZ2xlQ2FsZW5kYXJJZDohMSxnb29nbGVDYWxlbmRhckFwaUtleTohMCxnb29nbGVDYWxlbmRhckVycm9yOiEwfSl9LDM6ZnVuY3Rpb24oZSxyKXtlLmV4cG9ydHM9dH19KX0pOyIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIm1vbWVudFwiLFwiZnVsbGNhbGVuZGFyXCJdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP3QocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTp0KGUubW9tZW50LGUuRnVsbENhbGVuZGFyKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7aWYocltuXSlyZXR1cm4gcltuXS5leHBvcnRzO3ZhciBvPXJbbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW25dLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLHQpLG8ubD0hMCxvLmV4cG9ydHN9dmFyIHI9e307cmV0dXJuIHQubT1lLHQuYz1yLHQuZD1mdW5jdGlvbihlLHIsbil7dC5vKGUscil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpufSl9LHQubj1mdW5jdGlvbihlKXt2YXIgcj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKHIsXCJhXCIscikscn0sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9XCJcIix0KHQucz04NSl9KHswOmZ1bmN0aW9uKHQscil7dC5leHBvcnRzPWV9LDE6ZnVuY3Rpb24oZSxyKXtlLmV4cG9ydHM9dH0sODU6ZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIoODYpO3ZhciBuPXIoMSk7bi5kYXRlcGlja2VyTG9jYWxlKFwiYXJcIixcImFyXCIse2Nsb3NlVGV4dDpcItil2LrZhNin2YJcIixwcmV2VGV4dDpcIiYjeDNDO9in2YTYs9in2KjZglwiLG5leHRUZXh0Olwi2KfZhNiq2KfZhNmKJiN4M0U7XCIsY3VycmVudFRleHQ6XCLYp9mE2YrZiNmFXCIsbW9udGhOYW1lczpbXCLZitmG2KfZitixXCIsXCLZgdio2LHYp9mK2LFcIixcItmF2KfYsdizXCIsXCLYo9io2LHZitmEXCIsXCLZhdin2YrZiFwiLFwi2YrZiNmG2YrZiFwiLFwi2YrZiNmE2YrZiFwiLFwi2KPYutiz2LfYs1wiLFwi2LPYqNiq2YXYqNixXCIsXCLYo9mD2KrZiNio2LFcIixcItmG2YjZgdmF2KjYsVwiLFwi2K/Zitiz2YXYqNixXCJdLG1vbnRoTmFtZXNTaG9ydDpbXCIxXCIsXCIyXCIsXCIzXCIsXCI0XCIsXCI1XCIsXCI2XCIsXCI3XCIsXCI4XCIsXCI5XCIsXCIxMFwiLFwiMTFcIixcIjEyXCJdLGRheU5hbWVzOltcItin2YTYo9it2K9cIixcItin2YTYp9ir2YbZitmGXCIsXCLYp9mE2KvZhNin2KvYp9ihXCIsXCLYp9mE2KPYsdio2LnYp9ihXCIsXCLYp9mE2K7ZhdmK2LNcIixcItin2YTYrNmF2LnYqVwiLFwi2KfZhNiz2KjYqlwiXSxkYXlOYW1lc1Nob3J0OltcItij2K3Yr1wiLFwi2KfYq9mG2YrZhlwiLFwi2KvZhNin2KvYp9ihXCIsXCLYo9ix2KjYudin2KFcIixcItiu2YXZitizXCIsXCLYrNmF2LnYqVwiLFwi2LPYqNiqXCJdLGRheU5hbWVzTWluOltcItitXCIsXCLZhlwiLFwi2KtcIixcItixXCIsXCLYrlwiLFwi2KxcIixcItizXCJdLHdlZWtIZWFkZXI6XCLYo9iz2KjZiNi5XCIsZGF0ZUZvcm1hdDpcImRkL21tL3l5XCIsZmlyc3REYXk6MCxpc1JUTDohMCxzaG93TW9udGhBZnRlclllYXI6ITEseWVhclN1ZmZpeDpcIlwifSksbi5sb2NhbGUoXCJhclwiLHtidXR0b25UZXh0Onttb250aDpcIti02YfYsVwiLHdlZWs6XCLYo9iz2KjZiNi5XCIsZGF5Olwi2YrZiNmFXCIsbGlzdDpcItij2KzZhtiv2KlcIn0sYWxsRGF5VGV4dDpcItin2YTZitmI2YUg2YPZhNmHXCIsZXZlbnRMaW1pdFRleHQ6XCLYo9iu2LHZiVwiLG5vRXZlbnRzTWVzc2FnZTpcItij2Yog2KPYrdiv2KfYqyDZhNi52LHYtlwifSl9LDg2OmZ1bmN0aW9uKGUsdCxyKXshZnVuY3Rpb24oZSx0KXt0KHIoMCkpfSgwLGZ1bmN0aW9uKGUpe3ZhciB0PXsxOlwi2aFcIiwyOlwi2aJcIiwzOlwi2aNcIiw0Olwi2aRcIiw1Olwi2aVcIiw2Olwi2aZcIiw3Olwi2adcIiw4Olwi2ahcIiw5Olwi2alcIiwwOlwi2aBcIn0scj17XCLZoVwiOlwiMVwiLFwi2aJcIjpcIjJcIixcItmjXCI6XCIzXCIsXCLZpFwiOlwiNFwiLFwi2aVcIjpcIjVcIixcItmmXCI6XCI2XCIsXCLZp1wiOlwiN1wiLFwi2ahcIjpcIjhcIixcItmpXCI6XCI5XCIsXCLZoFwiOlwiMFwifSxuPWZ1bmN0aW9uKGUpe3JldHVybiAwPT09ZT8wOjE9PT1lPzE6Mj09PWU/MjplJTEwMD49MyYmZSUxMDA8PTEwPzM6ZSUxMDA+PTExPzQ6NX0sbz17czpbXCLYo9mC2YQg2YXZhiDYq9in2YbZitipXCIsXCLYq9in2YbZitipINmI2KfYrdiv2KlcIixbXCLYq9in2YbZitiq2KfZhlwiLFwi2KvYp9mG2YrYqtmK2YZcIl0sXCIlZCDYq9mI2KfZhlwiLFwiJWQg2KvYp9mG2YrYqVwiLFwiJWQg2KvYp9mG2YrYqVwiXSxtOltcItij2YLZhCDZhdmGINiv2YLZitmC2KlcIixcItiv2YLZitmC2Kkg2YjYp9it2K/YqVwiLFtcItiv2YLZitmC2KrYp9mGXCIsXCLYr9mC2YrZgtiq2YrZhlwiXSxcIiVkINiv2YLYp9im2YJcIixcIiVkINiv2YLZitmC2KlcIixcIiVkINiv2YLZitmC2KlcIl0saDpbXCLYo9mC2YQg2YXZhiDYs9in2LnYqVwiLFwi2LPYp9i52Kkg2YjYp9it2K/YqVwiLFtcItiz2KfYudiq2KfZhlwiLFwi2LPYp9i52KrZitmGXCJdLFwiJWQg2LPYp9i52KfYqlwiLFwiJWQg2LPYp9i52KlcIixcIiVkINiz2KfYudipXCJdLGQ6W1wi2KPZgtmEINmF2YYg2YrZiNmFXCIsXCLZitmI2YUg2YjYp9it2K9cIixbXCLZitmI2YXYp9mGXCIsXCLZitmI2YXZitmGXCJdLFwiJWQg2KPZitin2YVcIixcIiVkINmK2YjZhdmL2KdcIixcIiVkINmK2YjZhVwiXSxNOltcItij2YLZhCDZhdmGINi02YfYsVwiLFwi2LTZh9ixINmI2KfYrdivXCIsW1wi2LTZh9ix2KfZhlwiLFwi2LTZh9ix2YrZhlwiXSxcIiVkINij2LTZh9ixXCIsXCIlZCDYtNmH2LHYp1wiLFwiJWQg2LTZh9ixXCJdLHk6W1wi2KPZgtmEINmF2YYg2LnYp9mFXCIsXCLYudin2YUg2YjYp9it2K9cIixbXCLYudin2YXYp9mGXCIsXCLYudin2YXZitmGXCJdLFwiJWQg2KPYudmI2KfZhVwiLFwiJWQg2LnYp9mF2YvYp1wiLFwiJWQg2LnYp9mFXCJdfSxhPWZ1bmN0aW9uKGUpe3JldHVybiBmdW5jdGlvbih0LHIsYSxkKXt2YXIgdT1uKHQpLGk9b1tlXVtuKHQpXTtyZXR1cm4gMj09PXUmJihpPWlbcj8wOjFdKSxpLnJlcGxhY2UoLyVkL2ksdCl9fSxkPVtcItmK2YbYp9mK2LFcIixcItmB2KjYsdin2YrYsVwiLFwi2YXYp9ix2LNcIixcItij2KjYsdmK2YRcIixcItmF2KfZitmIXCIsXCLZitmI2YbZitmIXCIsXCLZitmI2YTZitmIXCIsXCLYo9i62LPYt9izXCIsXCLYs9io2KrZhdio2LFcIixcItij2YPYqtmI2KjYsVwiLFwi2YbZiNmB2YXYqNixXCIsXCLYr9mK2LPZhdio2LFcIl07cmV0dXJuIGUuZGVmaW5lTG9jYWxlKFwiYXJcIix7bW9udGhzOmQsbW9udGhzU2hvcnQ6ZCx3ZWVrZGF5czpcItin2YTYo9it2K9f2KfZhNil2KvZhtmK2YZf2KfZhNir2YTYp9ir2KfYoV/Yp9mE2KPYsdio2LnYp9ihX9in2YTYrtmF2YrYs1/Yp9mE2KzZhdi52Klf2KfZhNiz2KjYqlwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c1Nob3J0Olwi2KPYrdivX9il2KvZhtmK2YZf2KvZhNin2KvYp9ihX9ij2LHYqNi52KfYoV/YrtmF2YrYs1/YrNmF2LnYqV/Ys9io2KpcIi5zcGxpdChcIl9cIiksd2Vla2RheXNNaW46XCLYrV/Zhl/Yq1/YsV/Yrl/YrF/Ys1wiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c1BhcnNlRXhhY3Q6ITAsbG9uZ0RhdGVGb3JtYXQ6e0xUOlwiSEg6bW1cIixMVFM6XCJISDptbTpzc1wiLEw6XCJEL+KAj00v4oCPWVlZWVwiLExMOlwiRCBNTU1NIFlZWVlcIixMTEw6XCJEIE1NTU0gWVlZWSBISDptbVwiLExMTEw6XCJkZGRkIEQgTU1NTSBZWVlZIEhIOm1tXCJ9LG1lcmlkaWVtUGFyc2U6L9i1fNmFLyxpc1BNOmZ1bmN0aW9uKGUpe3JldHVyblwi2YVcIj09PWV9LG1lcmlkaWVtOmZ1bmN0aW9uKGUsdCxyKXtyZXR1cm4gZTwxMj9cIti1XCI6XCLZhVwifSxjYWxlbmRhcjp7c2FtZURheTpcIlvYp9mE2YrZiNmFINi52YbYryDYp9mE2LPYp9i52KldIExUXCIsbmV4dERheTpcIlvYutiv2YvYpyDYudmG2K8g2KfZhNiz2KfYudipXSBMVFwiLG5leHRXZWVrOlwiZGRkZCBb2LnZhtivINin2YTYs9in2LnYqV0gTFRcIixsYXN0RGF5OlwiW9ij2YXYsyDYudmG2K8g2KfZhNiz2KfYudipXSBMVFwiLGxhc3RXZWVrOlwiZGRkZCBb2LnZhtivINin2YTYs9in2LnYqV0gTFRcIixzYW1lRWxzZTpcIkxcIn0scmVsYXRpdmVUaW1lOntmdXR1cmU6XCLYqNi52K8gJXNcIixwYXN0Olwi2YXZhtiwICVzXCIsczphKFwic1wiKSxzczphKFwic1wiKSxtOmEoXCJtXCIpLG1tOmEoXCJtXCIpLGg6YShcImhcIiksaGg6YShcImhcIiksZDphKFwiZFwiKSxkZDphKFwiZFwiKSxNOmEoXCJNXCIpLE1NOmEoXCJNXCIpLHk6YShcInlcIikseXk6YShcInlcIil9LHByZXBhcnNlOmZ1bmN0aW9uKGUpe3JldHVybiBlLnJlcGxhY2UoL1vZodmi2aPZpNml2abZp9mo2anZoF0vZyxmdW5jdGlvbihlKXtyZXR1cm4gcltlXX0pLnJlcGxhY2UoL9iML2csXCIsXCIpfSxwb3N0Zm9ybWF0OmZ1bmN0aW9uKGUpe3JldHVybiBlLnJlcGxhY2UoL1xcZC9nLGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfSkucmVwbGFjZSgvLC9nLFwi2IxcIil9LHdlZWs6e2Rvdzo2LGRveToxMn19KX0pfX0pfSk7IiwiIWZ1bmN0aW9uKGUsbil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9bihyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wibW9tZW50XCIsXCJmdWxsY2FsZW5kYXJcIl0sbik6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/bihyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOm4oZS5tb21lbnQsZS5GdWxsQ2FsZW5kYXIpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24oZSxuKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gbihyKXtpZih0W3JdKXJldHVybiB0W3JdLmV4cG9ydHM7dmFyIHM9dFtyXT17aTpyLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbcl0uY2FsbChzLmV4cG9ydHMscyxzLmV4cG9ydHMsbikscy5sPSEwLHMuZXhwb3J0c312YXIgdD17fTtyZXR1cm4gbi5tPWUsbi5jPXQsbi5kPWZ1bmN0aW9uKGUsdCxyKXtuLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0OnJ9KX0sbi5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiBuLmQodCxcImFcIix0KSx0fSxuLm89ZnVuY3Rpb24oZSxuKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsbil9LG4ucD1cIlwiLG4obi5zPTk1KX0oezA6ZnVuY3Rpb24obix0KXtuLmV4cG9ydHM9ZX0sMTpmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz1ufSw5NTpmdW5jdGlvbihlLG4sdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdCg5Nik7dmFyIHI9dCgxKTtyLmRhdGVwaWNrZXJMb2NhbGUoXCJjc1wiLFwiY3NcIix7Y2xvc2VUZXh0OlwiWmF2xZnDrXRcIixwcmV2VGV4dDpcIiYjeDNDO0TFmcOtdmVcIixuZXh0VGV4dDpcIlBvemTEm2ppJiN4M0U7XCIsY3VycmVudFRleHQ6XCJOeW7DrVwiLG1vbnRoTmFtZXM6W1wibGVkZW5cIixcIsO6bm9yXCIsXCJixZllemVuXCIsXCJkdWJlblwiLFwia3bEm3RlblwiLFwixI1lcnZlblwiLFwixI1lcnZlbmVjXCIsXCJzcnBlblwiLFwiesOhxZnDrVwiLFwixZnDrWplblwiLFwibGlzdG9wYWRcIixcInByb3NpbmVjXCJdLG1vbnRoTmFtZXNTaG9ydDpbXCJsZWRcIixcIsO6bm9cIixcImLFmWVcIixcImR1YlwiLFwia3bEm1wiLFwixI1lclwiLFwixI12Y1wiLFwic3JwXCIsXCJ6w6HFmVwiLFwixZnDrWpcIixcImxpc1wiLFwicHJvXCJdLGRheU5hbWVzOltcIm5lZMSbbGVcIixcInBvbmTEm2zDrVwiLFwiw7p0ZXLDvVwiLFwic3TFmWVkYVwiLFwixI10dnJ0ZWtcIixcInDDoXRla1wiLFwic29ib3RhXCJdLGRheU5hbWVzU2hvcnQ6W1wibmVcIixcInBvXCIsXCLDunRcIixcInN0XCIsXCLEjXRcIixcInDDoVwiLFwic29cIl0sZGF5TmFtZXNNaW46W1wibmVcIixcInBvXCIsXCLDunRcIixcInN0XCIsXCLEjXRcIixcInDDoVwiLFwic29cIl0sd2Vla0hlYWRlcjpcIlTDvWRcIixkYXRlRm9ybWF0OlwiZGQubW0ueXlcIixmaXJzdERheToxLGlzUlRMOiExLHNob3dNb250aEFmdGVyWWVhcjohMSx5ZWFyU3VmZml4OlwiXCJ9KSxyLmxvY2FsZShcImNzXCIse2J1dHRvblRleHQ6e21vbnRoOlwiTcSbc8OtY1wiLHdlZWs6XCJUw71kZW5cIixkYXk6XCJEZW5cIixsaXN0OlwiQWdlbmRhXCJ9LGFsbERheVRleHQ6XCJDZWzDvSBkZW5cIixldmVudExpbWl0VGV4dDpmdW5jdGlvbihlKXtyZXR1cm5cIitkYWzFocOtOiBcIitlfSxub0V2ZW50c01lc3NhZ2U6XCLFvcOhZG7DqSBha2NlIGsgem9icmF6ZW7DrVwifSl9LDk2OmZ1bmN0aW9uKGUsbix0KXshZnVuY3Rpb24oZSxuKXtuKHQoMCkpfSgwLGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGU+MSYmZTw1JiYxIT1+fihlLzEwKX1mdW5jdGlvbiB0KGUsdCxyLHMpe3ZhciBvPWUrXCIgXCI7c3dpdGNoKHIpe2Nhc2VcInNcIjpyZXR1cm4gdHx8cz9cInDDoXIgc2VrdW5kXCI6XCJww6FyIHNla3VuZGFtaVwiO2Nhc2VcInNzXCI6cmV0dXJuIHR8fHM/bysobihlKT9cInNla3VuZHlcIjpcInNla3VuZFwiKTpvK1wic2VrdW5kYW1pXCI7Y2FzZVwibVwiOnJldHVybiB0P1wibWludXRhXCI6cz9cIm1pbnV0dVwiOlwibWludXRvdVwiO2Nhc2VcIm1tXCI6cmV0dXJuIHR8fHM/bysobihlKT9cIm1pbnV0eVwiOlwibWludXRcIik6bytcIm1pbnV0YW1pXCI7Y2FzZVwiaFwiOnJldHVybiB0P1wiaG9kaW5hXCI6cz9cImhvZGludVwiOlwiaG9kaW5vdVwiO2Nhc2VcImhoXCI6cmV0dXJuIHR8fHM/bysobihlKT9cImhvZGlueVwiOlwiaG9kaW5cIik6bytcImhvZGluYW1pXCI7Y2FzZVwiZFwiOnJldHVybiB0fHxzP1wiZGVuXCI6XCJkbmVtXCI7Y2FzZVwiZGRcIjpyZXR1cm4gdHx8cz9vKyhuKGUpP1wiZG55XCI6XCJkbsOtXCIpOm8rXCJkbnlcIjtjYXNlXCJNXCI6cmV0dXJuIHR8fHM/XCJtxJtzw61jXCI6XCJtxJtzw61jZW1cIjtjYXNlXCJNTVwiOnJldHVybiB0fHxzP28rKG4oZSk/XCJtxJtzw61jZVwiOlwibcSbc8OtY8WvXCIpOm8rXCJtxJtzw61jaVwiO2Nhc2VcInlcIjpyZXR1cm4gdHx8cz9cInJva1wiOlwicm9rZW1cIjtjYXNlXCJ5eVwiOnJldHVybiB0fHxzP28rKG4oZSk/XCJyb2t5XCI6XCJsZXRcIik6bytcImxldHlcIn19dmFyIHI9XCJsZWRlbl/Dum5vcl9ixZllemVuX2R1YmVuX2t2xJt0ZW5fxI1lcnZlbl/EjWVydmVuZWNfc3JwZW5fesOhxZnDrV/FmcOtamVuX2xpc3RvcGFkX3Byb3NpbmVjXCIuc3BsaXQoXCJfXCIpLHM9XCJsZWRfw7pub19ixZllX2R1Yl9rdsSbX8SNdm5fxI12Y19zcnBfesOhxZlfxZnDrWpfbGlzX3Byb1wiLnNwbGl0KFwiX1wiKSxvPVsvXmxlZC9pLC9ew7puby9pLC9eYsWZZS9pLC9eZHViL2ksL15rdsSbL2ksL14oxI12bnzEjWVydmVuJHzEjWVydm5hKS9pLC9eKMSNdmN8xI1lcnZlbmVjfMSNZXJ2ZW5jZSkvaSwvXnNycC9pLC9eesOhxZkvaSwvXsWZw61qL2ksL15saXMvaSwvXnByby9pXSxhPS9eKGxlZGVufMO6bm9yfGLFmWV6ZW58ZHViZW58a3bEm3RlbnzEjWVydmVuZWN8xI1lcnZlbmNlfMSNZXJ2ZW58xI1lcnZuYXxzcnBlbnx6w6HFmcOtfMWZw61qZW58bGlzdG9wYWR8cHJvc2luZWN8bGVkfMO6bm98YsWZZXxkdWJ8a3bEm3zEjXZufMSNdmN8c3JwfHrDocWZfMWZw61qfGxpc3xwcm8pL2k7cmV0dXJuIGUuZGVmaW5lTG9jYWxlKFwiY3NcIix7bW9udGhzOnIsbW9udGhzU2hvcnQ6cyxtb250aHNSZWdleDphLG1vbnRoc1Nob3J0UmVnZXg6YSxtb250aHNTdHJpY3RSZWdleDovXihsZWRlbnxsZWRuYXzDum5vcmF8w7pub3J8YsWZZXplbnxixZllem5hfGR1YmVufGR1Ym5hfGt2xJt0ZW58a3bEm3RuYXzEjWVydmVuZWN8xI1lcnZlbmNlfMSNZXJ2ZW58xI1lcnZuYXxzcnBlbnxzcnBuYXx6w6HFmcOtfMWZw61qZW58xZnDrWpuYXxsaXN0b3BhZHV8bGlzdG9wYWR8cHJvc2luZWN8cHJvc2luY2UpL2ksbW9udGhzU2hvcnRTdHJpY3RSZWdleDovXihsZWR8w7pub3xixZllfGR1YnxrdsSbfMSNdm58xI12Y3xzcnB8esOhxZl8xZnDrWp8bGlzfHBybykvaSxtb250aHNQYXJzZTpvLGxvbmdNb250aHNQYXJzZTpvLHNob3J0TW9udGhzUGFyc2U6byx3ZWVrZGF5czpcIm5lZMSbbGVfcG9uZMSbbMOtX8O6dGVyw71fc3TFmWVkYV/EjXR2cnRla19ww6F0ZWtfc29ib3RhXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzU2hvcnQ6XCJuZV9wb1/DunRfc3RfxI10X3DDoV9zb1wiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcIm5lX3BvX8O6dF9zdF/EjXRfcMOhX3NvXCIuc3BsaXQoXCJfXCIpLGxvbmdEYXRlRm9ybWF0OntMVDpcIkg6bW1cIixMVFM6XCJIOm1tOnNzXCIsTDpcIkRELk1NLllZWVlcIixMTDpcIkQuIE1NTU0gWVlZWVwiLExMTDpcIkQuIE1NTU0gWVlZWSBIOm1tXCIsTExMTDpcImRkZGQgRC4gTU1NTSBZWVlZIEg6bW1cIixsOlwiRC4gTS4gWVlZWVwifSxjYWxlbmRhcjp7c2FtZURheTpcIltkbmVzIHZdIExUXCIsbmV4dERheTpcIlt6w610cmEgdl0gTFRcIixuZXh0V2VlazpmdW5jdGlvbigpe3N3aXRjaCh0aGlzLmRheSgpKXtjYXNlIDA6cmV0dXJuXCJbdiBuZWTEm2xpIHZdIExUXCI7Y2FzZSAxOmNhc2UgMjpyZXR1cm5cIlt2XSBkZGRkIFt2XSBMVFwiO2Nhc2UgMzpyZXR1cm5cIlt2ZSBzdMWZZWR1IHZdIExUXCI7Y2FzZSA0OnJldHVyblwiW3ZlIMSNdHZydGVrIHZdIExUXCI7Y2FzZSA1OnJldHVyblwiW3YgcMOhdGVrIHZdIExUXCI7Y2FzZSA2OnJldHVyblwiW3Ygc29ib3R1IHZdIExUXCJ9fSxsYXN0RGF5OlwiW3bEjWVyYSB2XSBMVFwiLGxhc3RXZWVrOmZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuZGF5KCkpe2Nhc2UgMDpyZXR1cm5cIlttaW51bG91IG5lZMSbbGkgdl0gTFRcIjtjYXNlIDE6Y2FzZSAyOnJldHVyblwiW21pbnVsw6ldIGRkZGQgW3ZdIExUXCI7Y2FzZSAzOnJldHVyblwiW21pbnVsb3Ugc3TFmWVkdSB2XSBMVFwiO2Nhc2UgNDpjYXNlIDU6cmV0dXJuXCJbbWludWzDvV0gZGRkZCBbdl0gTFRcIjtjYXNlIDY6cmV0dXJuXCJbbWludWxvdSBzb2JvdHUgdl0gTFRcIn19LHNhbWVFbHNlOlwiTFwifSxyZWxhdGl2ZVRpbWU6e2Z1dHVyZTpcInphICVzXCIscGFzdDpcInDFmWVkICVzXCIsczp0LHNzOnQsbTp0LG1tOnQsaDp0LGhoOnQsZDp0LGRkOnQsTTp0LE1NOnQseTp0LHl5OnR9LGRheU9mTW9udGhPcmRpbmFsUGFyc2U6L1xcZHsxLDJ9XFwuLyxvcmRpbmFsOlwiJWQuXCIsd2Vlazp7ZG93OjEsZG95OjR9fSl9KX19KX0pOyIsIiFmdW5jdGlvbihlLHIpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXIocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIm1vbWVudFwiLFwiZnVsbGNhbGVuZGFyXCJdLHIpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP3IocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpyKGUubW9tZW50LGUuRnVsbENhbGVuZGFyKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUscil7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIobil7aWYodFtuXSlyZXR1cm4gdFtuXS5leHBvcnRzO3ZhciBhPXRbbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW25dLmNhbGwoYS5leHBvcnRzLGEsYS5leHBvcnRzLHIpLGEubD0hMCxhLmV4cG9ydHN9dmFyIHQ9e307cmV0dXJuIHIubT1lLHIuYz10LHIuZD1mdW5jdGlvbihlLHQsbil7ci5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpufSl9LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsXCJhXCIsdCksdH0sci5vPWZ1bmN0aW9uKGUscil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpfSxyLnA9XCJcIixyKHIucz05Nyl9KHswOmZ1bmN0aW9uKHIsdCl7ci5leHBvcnRzPWV9LDE6ZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9cn0sOTc6ZnVuY3Rpb24oZSxyLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShyLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQoOTgpO3ZhciBuPXQoMSk7bi5kYXRlcGlja2VyTG9jYWxlKFwiZGFcIixcImRhXCIse2Nsb3NlVGV4dDpcIkx1a1wiLHByZXZUZXh0OlwiJiN4M0M7Rm9ycmlnZVwiLG5leHRUZXh0OlwiTsOmc3RlJiN4M0U7XCIsY3VycmVudFRleHQ6XCJJZGFnXCIsbW9udGhOYW1lczpbXCJKYW51YXJcIixcIkZlYnJ1YXJcIixcIk1hcnRzXCIsXCJBcHJpbFwiLFwiTWFqXCIsXCJKdW5pXCIsXCJKdWxpXCIsXCJBdWd1c3RcIixcIlNlcHRlbWJlclwiLFwiT2t0b2JlclwiLFwiTm92ZW1iZXJcIixcIkRlY2VtYmVyXCJdLG1vbnRoTmFtZXNTaG9ydDpbXCJKYW5cIixcIkZlYlwiLFwiTWFyXCIsXCJBcHJcIixcIk1halwiLFwiSnVuXCIsXCJKdWxcIixcIkF1Z1wiLFwiU2VwXCIsXCJPa3RcIixcIk5vdlwiLFwiRGVjXCJdLGRheU5hbWVzOltcIlPDuG5kYWdcIixcIk1hbmRhZ1wiLFwiVGlyc2RhZ1wiLFwiT25zZGFnXCIsXCJUb3JzZGFnXCIsXCJGcmVkYWdcIixcIkzDuHJkYWdcIl0sZGF5TmFtZXNTaG9ydDpbXCJTw7huXCIsXCJNYW5cIixcIlRpclwiLFwiT25zXCIsXCJUb3JcIixcIkZyZVwiLFwiTMO4clwiXSxkYXlOYW1lc01pbjpbXCJTw7hcIixcIk1hXCIsXCJUaVwiLFwiT25cIixcIlRvXCIsXCJGclwiLFwiTMO4XCJdLHdlZWtIZWFkZXI6XCJVZ2VcIixkYXRlRm9ybWF0OlwiZGQtbW0teXlcIixmaXJzdERheToxLGlzUlRMOiExLHNob3dNb250aEFmdGVyWWVhcjohMSx5ZWFyU3VmZml4OlwiXCJ9KSxuLmxvY2FsZShcImRhXCIse2J1dHRvblRleHQ6e21vbnRoOlwiTcOlbmVkXCIsd2VlazpcIlVnZVwiLGRheTpcIkRhZ1wiLGxpc3Q6XCJBZ2VuZGFcIn0sYWxsRGF5VGV4dDpcIkhlbGUgZGFnZW5cIixldmVudExpbWl0VGV4dDpcImZsZXJlXCIsbm9FdmVudHNNZXNzYWdlOlwiSW5nZW4gYXJyYW5nZW1lbnRlciBhdCB2aXNlXCJ9KX0sOTg6ZnVuY3Rpb24oZSxyLHQpeyFmdW5jdGlvbihlLHIpe3IodCgwKSl9KDAsZnVuY3Rpb24oZSl7cmV0dXJuIGUuZGVmaW5lTG9jYWxlKFwiZGFcIix7bW9udGhzOlwiamFudWFyX2ZlYnJ1YXJfbWFydHNfYXByaWxfbWFqX2p1bmlfanVsaV9hdWd1c3Rfc2VwdGVtYmVyX29rdG9iZXJfbm92ZW1iZXJfZGVjZW1iZXJcIi5zcGxpdChcIl9cIiksbW9udGhzU2hvcnQ6XCJqYW5fZmViX21hcl9hcHJfbWFqX2p1bl9qdWxfYXVnX3NlcF9va3Rfbm92X2RlY1wiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5czpcInPDuG5kYWdfbWFuZGFnX3RpcnNkYWdfb25zZGFnX3RvcnNkYWdfZnJlZGFnX2zDuHJkYWdcIi5zcGxpdChcIl9cIiksd2Vla2RheXNTaG9ydDpcInPDuG5fbWFuX3Rpcl9vbnNfdG9yX2ZyZV9sw7hyXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzTWluOlwic8O4X21hX3RpX29uX3RvX2ZyX2zDuFwiLnNwbGl0KFwiX1wiKSxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJISDptbVwiLExUUzpcIkhIOm1tOnNzXCIsTDpcIkRELk1NLllZWVlcIixMTDpcIkQuIE1NTU0gWVlZWVwiLExMTDpcIkQuIE1NTU0gWVlZWSBISDptbVwiLExMTEw6XCJkZGRkIFtkLl0gRC4gTU1NTSBZWVlZIFtrbC5dIEhIOm1tXCJ9LGNhbGVuZGFyOntzYW1lRGF5OlwiW2kgZGFnIGtsLl0gTFRcIixuZXh0RGF5OlwiW2kgbW9yZ2VuIGtsLl0gTFRcIixuZXh0V2VlazpcInDDpSBkZGRkIFtrbC5dIExUXCIsbGFzdERheTpcIltpIGfDpXIga2wuXSBMVFwiLGxhc3RXZWVrOlwiW2ldIGRkZGRbcyBrbC5dIExUXCIsc2FtZUVsc2U6XCJMXCJ9LHJlbGF0aXZlVGltZTp7ZnV0dXJlOlwib20gJXNcIixwYXN0OlwiJXMgc2lkZW5cIixzOlwiZsOlIHNla3VuZGVyXCIsc3M6XCIlZCBzZWt1bmRlclwiLG06XCJldCBtaW51dFwiLG1tOlwiJWQgbWludXR0ZXJcIixoOlwiZW4gdGltZVwiLGhoOlwiJWQgdGltZXJcIixkOlwiZW4gZGFnXCIsZGQ6XCIlZCBkYWdlXCIsTTpcImVuIG3DpW5lZFwiLE1NOlwiJWQgbcOlbmVkZXJcIix5OlwiZXQgw6VyXCIseXk6XCIlZCDDpXJcIn0sZGF5T2ZNb250aE9yZGluYWxQYXJzZTovXFxkezEsMn1cXC4vLG9yZGluYWw6XCIlZC5cIix3ZWVrOntkb3c6MSxkb3k6NH19KX0pfX0pfSk7IiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dChyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wibW9tZW50XCIsXCJmdWxsY2FsZW5kYXJcIl0sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/dChyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOnQoZS5tb21lbnQsZS5GdWxsQ2FsZW5kYXIpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChyKXtpZihuW3JdKXJldHVybiBuW3JdLmV4cG9ydHM7dmFyIGE9bltyXT17aTpyLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbcl0uY2FsbChhLmV4cG9ydHMsYSxhLmV4cG9ydHMsdCksYS5sPSEwLGEuZXhwb3J0c312YXIgbj17fTtyZXR1cm4gdC5tPWUsdC5jPW4sdC5kPWZ1bmN0aW9uKGUsbixyKXt0Lm8oZSxuKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0OnJ9KX0sdC5uPWZ1bmN0aW9uKGUpe3ZhciBuPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiB0LmQobixcImFcIixuKSxufSx0Lm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHQucD1cIlwiLHQodC5zPTk5KX0oezA6ZnVuY3Rpb24odCxuKXt0LmV4cG9ydHM9ZX0sMTpmdW5jdGlvbihlLG4pe2UuZXhwb3J0cz10fSwxMDA6ZnVuY3Rpb24oZSx0LG4peyFmdW5jdGlvbihlLHQpe3QobigwKSl9KDAsZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlLHQsbixyKXt2YXIgYT17bTpbXCJlaW5lIE1pbnV0ZVwiLFwiZWluZXIgTWludXRlXCJdLGg6W1wiZWluZSBTdHVuZGVcIixcImVpbmVyIFN0dW5kZVwiXSxkOltcImVpbiBUYWdcIixcImVpbmVtIFRhZ1wiXSxkZDpbZStcIiBUYWdlXCIsZStcIiBUYWdlblwiXSxNOltcImVpbiBNb25hdFwiLFwiZWluZW0gTW9uYXRcIl0sTU06W2UrXCIgTW9uYXRlXCIsZStcIiBNb25hdGVuXCJdLHk6W1wiZWluIEphaHJcIixcImVpbmVtIEphaHJcIl0seXk6W2UrXCIgSmFocmVcIixlK1wiIEphaHJlblwiXX07cmV0dXJuIHQ/YVtuXVswXTphW25dWzFdfXJldHVybiBlLmRlZmluZUxvY2FsZShcImRlLWF0XCIse21vbnRoczpcIkrDpG5uZXJfRmVicnVhcl9Nw6Ryel9BcHJpbF9NYWlfSnVuaV9KdWxpX0F1Z3VzdF9TZXB0ZW1iZXJfT2t0b2Jlcl9Ob3ZlbWJlcl9EZXplbWJlclwiLnNwbGl0KFwiX1wiKSxtb250aHNTaG9ydDpcIkrDpG4uX0ZlYi5fTcOkcnpfQXByLl9NYWlfSnVuaV9KdWxpX0F1Zy5fU2VwLl9Pa3QuX05vdi5fRGV6LlwiLnNwbGl0KFwiX1wiKSxtb250aHNQYXJzZUV4YWN0OiEwLHdlZWtkYXlzOlwiU29ubnRhZ19Nb250YWdfRGllbnN0YWdfTWl0dHdvY2hfRG9ubmVyc3RhZ19GcmVpdGFnX1NhbXN0YWdcIi5zcGxpdChcIl9cIiksd2Vla2RheXNTaG9ydDpcIlNvLl9Nby5fRGkuX01pLl9Eby5fRnIuX1NhLlwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcIlNvX01vX0RpX01pX0RvX0ZyX1NhXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzUGFyc2VFeGFjdDohMCxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJISDptbVwiLExUUzpcIkhIOm1tOnNzXCIsTDpcIkRELk1NLllZWVlcIixMTDpcIkQuIE1NTU0gWVlZWVwiLExMTDpcIkQuIE1NTU0gWVlZWSBISDptbVwiLExMTEw6XCJkZGRkLCBELiBNTU1NIFlZWVkgSEg6bW1cIn0sY2FsZW5kYXI6e3NhbWVEYXk6XCJbaGV1dGUgdW1dIExUIFtVaHJdXCIsc2FtZUVsc2U6XCJMXCIsbmV4dERheTpcIlttb3JnZW4gdW1dIExUIFtVaHJdXCIsbmV4dFdlZWs6XCJkZGRkIFt1bV0gTFQgW1Vocl1cIixsYXN0RGF5OlwiW2dlc3Rlcm4gdW1dIExUIFtVaHJdXCIsbGFzdFdlZWs6XCJbbGV0enRlbl0gZGRkZCBbdW1dIExUIFtVaHJdXCJ9LHJlbGF0aXZlVGltZTp7ZnV0dXJlOlwiaW4gJXNcIixwYXN0Olwidm9yICVzXCIsczpcImVpbiBwYWFyIFNla3VuZGVuXCIsc3M6XCIlZCBTZWt1bmRlblwiLG06dCxtbTpcIiVkIE1pbnV0ZW5cIixoOnQsaGg6XCIlZCBTdHVuZGVuXCIsZDp0LGRkOnQsTTp0LE1NOnQseTp0LHl5OnR9LGRheU9mTW9udGhPcmRpbmFsUGFyc2U6L1xcZHsxLDJ9XFwuLyxvcmRpbmFsOlwiJWQuXCIsd2Vlazp7ZG93OjEsZG95OjR9fSl9KX0sOTk6ZnVuY3Rpb24oZSx0LG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4oMTAwKTt2YXIgcj1uKDEpO3IuZGF0ZXBpY2tlckxvY2FsZShcImRlLWF0XCIsXCJkZVwiLHtjbG9zZVRleHQ6XCJTY2hsaWXDn2VuXCIscHJldlRleHQ6XCImI3gzQztadXLDvGNrXCIsbmV4dFRleHQ6XCJWb3ImI3gzRTtcIixjdXJyZW50VGV4dDpcIkhldXRlXCIsbW9udGhOYW1lczpbXCJKYW51YXJcIixcIkZlYnJ1YXJcIixcIk3DpHJ6XCIsXCJBcHJpbFwiLFwiTWFpXCIsXCJKdW5pXCIsXCJKdWxpXCIsXCJBdWd1c3RcIixcIlNlcHRlbWJlclwiLFwiT2t0b2JlclwiLFwiTm92ZW1iZXJcIixcIkRlemVtYmVyXCJdLG1vbnRoTmFtZXNTaG9ydDpbXCJKYW5cIixcIkZlYlwiLFwiTcOkclwiLFwiQXByXCIsXCJNYWlcIixcIkp1blwiLFwiSnVsXCIsXCJBdWdcIixcIlNlcFwiLFwiT2t0XCIsXCJOb3ZcIixcIkRlelwiXSxkYXlOYW1lczpbXCJTb25udGFnXCIsXCJNb250YWdcIixcIkRpZW5zdGFnXCIsXCJNaXR0d29jaFwiLFwiRG9ubmVyc3RhZ1wiLFwiRnJlaXRhZ1wiLFwiU2Ftc3RhZ1wiXSxkYXlOYW1lc1Nob3J0OltcIlNvXCIsXCJNb1wiLFwiRGlcIixcIk1pXCIsXCJEb1wiLFwiRnJcIixcIlNhXCJdLGRheU5hbWVzTWluOltcIlNvXCIsXCJNb1wiLFwiRGlcIixcIk1pXCIsXCJEb1wiLFwiRnJcIixcIlNhXCJdLHdlZWtIZWFkZXI6XCJLV1wiLGRhdGVGb3JtYXQ6XCJkZC5tbS55eVwiLGZpcnN0RGF5OjEsaXNSVEw6ITEsc2hvd01vbnRoQWZ0ZXJZZWFyOiExLHllYXJTdWZmaXg6XCJcIn0pLHIubG9jYWxlKFwiZGUtYXRcIix7YnV0dG9uVGV4dDp7eWVhcjpcIkphaHJcIixtb250aDpcIk1vbmF0XCIsd2VlazpcIldvY2hlXCIsZGF5OlwiVGFnXCIsbGlzdDpcIlRlcm1pbsO8YmVyc2ljaHRcIn0sYWxsRGF5VGV4dDpcIkdhbnp0w6RnaWdcIixldmVudExpbWl0VGV4dDpmdW5jdGlvbihlKXtyZXR1cm5cIisgd2VpdGVyZSBcIitlfSxub0V2ZW50c01lc3NhZ2U6XCJLZWluZSBFcmVpZ25pc3NlIGFuenV6ZWlnZW5cIn0pfX0pfSk7IiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dChyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wibW9tZW50XCIsXCJmdWxsY2FsZW5kYXJcIl0sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/dChyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOnQoZS5tb21lbnQsZS5GdWxsQ2FsZW5kYXIpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChyKXtpZihuW3JdKXJldHVybiBuW3JdLmV4cG9ydHM7dmFyIGE9bltyXT17aTpyLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbcl0uY2FsbChhLmV4cG9ydHMsYSxhLmV4cG9ydHMsdCksYS5sPSEwLGEuZXhwb3J0c312YXIgbj17fTtyZXR1cm4gdC5tPWUsdC5jPW4sdC5kPWZ1bmN0aW9uKGUsbixyKXt0Lm8oZSxuKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0OnJ9KX0sdC5uPWZ1bmN0aW9uKGUpe3ZhciBuPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiB0LmQobixcImFcIixuKSxufSx0Lm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHQucD1cIlwiLHQodC5zPTEwMSl9KHswOmZ1bmN0aW9uKHQsbil7dC5leHBvcnRzPWV9LDE6ZnVuY3Rpb24oZSxuKXtlLmV4cG9ydHM9dH0sMTAxOmZ1bmN0aW9uKGUsdCxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuKDEwMik7dmFyIHI9bigxKTtyLmRhdGVwaWNrZXJMb2NhbGUoXCJkZS1jaFwiLFwiZGVcIix7Y2xvc2VUZXh0OlwiU2NobGllw59lblwiLHByZXZUZXh0OlwiJiN4M0M7WnVyw7xja1wiLG5leHRUZXh0OlwiVm9yJiN4M0U7XCIsY3VycmVudFRleHQ6XCJIZXV0ZVwiLG1vbnRoTmFtZXM6W1wiSmFudWFyXCIsXCJGZWJydWFyXCIsXCJNw6RyelwiLFwiQXByaWxcIixcIk1haVwiLFwiSnVuaVwiLFwiSnVsaVwiLFwiQXVndXN0XCIsXCJTZXB0ZW1iZXJcIixcIk9rdG9iZXJcIixcIk5vdmVtYmVyXCIsXCJEZXplbWJlclwiXSxtb250aE5hbWVzU2hvcnQ6W1wiSmFuXCIsXCJGZWJcIixcIk3DpHJcIixcIkFwclwiLFwiTWFpXCIsXCJKdW5cIixcIkp1bFwiLFwiQXVnXCIsXCJTZXBcIixcIk9rdFwiLFwiTm92XCIsXCJEZXpcIl0sZGF5TmFtZXM6W1wiU29ubnRhZ1wiLFwiTW9udGFnXCIsXCJEaWVuc3RhZ1wiLFwiTWl0dHdvY2hcIixcIkRvbm5lcnN0YWdcIixcIkZyZWl0YWdcIixcIlNhbXN0YWdcIl0sZGF5TmFtZXNTaG9ydDpbXCJTb1wiLFwiTW9cIixcIkRpXCIsXCJNaVwiLFwiRG9cIixcIkZyXCIsXCJTYVwiXSxkYXlOYW1lc01pbjpbXCJTb1wiLFwiTW9cIixcIkRpXCIsXCJNaVwiLFwiRG9cIixcIkZyXCIsXCJTYVwiXSx3ZWVrSGVhZGVyOlwiS1dcIixkYXRlRm9ybWF0OlwiZGQubW0ueXlcIixmaXJzdERheToxLGlzUlRMOiExLHNob3dNb250aEFmdGVyWWVhcjohMSx5ZWFyU3VmZml4OlwiXCJ9KSxyLmxvY2FsZShcImRlLWNoXCIse2J1dHRvblRleHQ6e3llYXI6XCJKYWhyXCIsbW9udGg6XCJNb25hdFwiLHdlZWs6XCJXb2NoZVwiLGRheTpcIlRhZ1wiLGxpc3Q6XCJUZXJtaW7DvGJlcnNpY2h0XCJ9LGFsbERheVRleHQ6XCJHYW56dMOkZ2lnXCIsZXZlbnRMaW1pdFRleHQ6ZnVuY3Rpb24oZSl7cmV0dXJuXCIrIHdlaXRlcmUgXCIrZX0sbm9FdmVudHNNZXNzYWdlOlwiS2VpbmUgRXJlaWduaXNzZSBhbnp1emVpZ2VuXCJ9KX0sMTAyOmZ1bmN0aW9uKGUsdCxuKXshZnVuY3Rpb24oZSx0KXt0KG4oMCkpfSgwLGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSx0LG4scil7dmFyIGE9e206W1wiZWluZSBNaW51dGVcIixcImVpbmVyIE1pbnV0ZVwiXSxoOltcImVpbmUgU3R1bmRlXCIsXCJlaW5lciBTdHVuZGVcIl0sZDpbXCJlaW4gVGFnXCIsXCJlaW5lbSBUYWdcIl0sZGQ6W2UrXCIgVGFnZVwiLGUrXCIgVGFnZW5cIl0sTTpbXCJlaW4gTW9uYXRcIixcImVpbmVtIE1vbmF0XCJdLE1NOltlK1wiIE1vbmF0ZVwiLGUrXCIgTW9uYXRlblwiXSx5OltcImVpbiBKYWhyXCIsXCJlaW5lbSBKYWhyXCJdLHl5OltlK1wiIEphaHJlXCIsZStcIiBKYWhyZW5cIl19O3JldHVybiB0P2Fbbl1bMF06YVtuXVsxXX1yZXR1cm4gZS5kZWZpbmVMb2NhbGUoXCJkZS1jaFwiLHttb250aHM6XCJKYW51YXJfRmVicnVhcl9Nw6Ryel9BcHJpbF9NYWlfSnVuaV9KdWxpX0F1Z3VzdF9TZXB0ZW1iZXJfT2t0b2Jlcl9Ob3ZlbWJlcl9EZXplbWJlclwiLnNwbGl0KFwiX1wiKSxtb250aHNTaG9ydDpcIkphbi5fRmViLl9Nw6Ryel9BcHIuX01haV9KdW5pX0p1bGlfQXVnLl9TZXAuX09rdC5fTm92Ll9EZXouXCIuc3BsaXQoXCJfXCIpLG1vbnRoc1BhcnNlRXhhY3Q6ITAsd2Vla2RheXM6XCJTb25udGFnX01vbnRhZ19EaWVuc3RhZ19NaXR0d29jaF9Eb25uZXJzdGFnX0ZyZWl0YWdfU2Ftc3RhZ1wiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c1Nob3J0OlwiU29fTW9fRGlfTWlfRG9fRnJfU2FcIi5zcGxpdChcIl9cIiksd2Vla2RheXNNaW46XCJTb19Nb19EaV9NaV9Eb19Gcl9TYVwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c1BhcnNlRXhhY3Q6ITAsbG9uZ0RhdGVGb3JtYXQ6e0xUOlwiSEg6bW1cIixMVFM6XCJISDptbTpzc1wiLEw6XCJERC5NTS5ZWVlZXCIsTEw6XCJELiBNTU1NIFlZWVlcIixMTEw6XCJELiBNTU1NIFlZWVkgSEg6bW1cIixMTExMOlwiZGRkZCwgRC4gTU1NTSBZWVlZIEhIOm1tXCJ9LGNhbGVuZGFyOntzYW1lRGF5OlwiW2hldXRlIHVtXSBMVCBbVWhyXVwiLHNhbWVFbHNlOlwiTFwiLG5leHREYXk6XCJbbW9yZ2VuIHVtXSBMVCBbVWhyXVwiLG5leHRXZWVrOlwiZGRkZCBbdW1dIExUIFtVaHJdXCIsbGFzdERheTpcIltnZXN0ZXJuIHVtXSBMVCBbVWhyXVwiLGxhc3RXZWVrOlwiW2xldHp0ZW5dIGRkZGQgW3VtXSBMVCBbVWhyXVwifSxyZWxhdGl2ZVRpbWU6e2Z1dHVyZTpcImluICVzXCIscGFzdDpcInZvciAlc1wiLHM6XCJlaW4gcGFhciBTZWt1bmRlblwiLHNzOlwiJWQgU2VrdW5kZW5cIixtOnQsbW06XCIlZCBNaW51dGVuXCIsaDp0LGhoOlwiJWQgU3R1bmRlblwiLGQ6dCxkZDp0LE06dCxNTTp0LHk6dCx5eTp0fSxkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOi9cXGR7MSwyfVxcLi8sb3JkaW5hbDpcIiVkLlwiLHdlZWs6e2RvdzoxLGRveTo0fX0pfSl9fSl9KTsiLCIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KHJlcXVpcmUoXCJtb21lbnRcIikscmVxdWlyZShcImZ1bGxjYWxlbmRhclwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJtb21lbnRcIixcImZ1bGxjYWxlbmRhclwiXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz90KHJlcXVpcmUoXCJtb21lbnRcIikscmVxdWlyZShcImZ1bGxjYWxlbmRhclwiKSk6dChlLm1vbWVudCxlLkZ1bGxDYWxlbmRhcil9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyxmdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiB0KHIpe2lmKG5bcl0pcmV0dXJuIG5bcl0uZXhwb3J0czt2YXIgYT1uW3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtyXS5jYWxsKGEuZXhwb3J0cyxhLGEuZXhwb3J0cyx0KSxhLmw9ITAsYS5leHBvcnRzfXZhciBuPXt9O3JldHVybiB0Lm09ZSx0LmM9bix0LmQ9ZnVuY3Rpb24oZSxuLHIpe3QubyhlLG4pfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6cn0pfSx0Lm49ZnVuY3Rpb24oZSl7dmFyIG49ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIHQuZChuLFwiYVwiLG4pLG59LHQubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sdC5wPVwiXCIsdCh0LnM9MTAzKX0oezA6ZnVuY3Rpb24odCxuKXt0LmV4cG9ydHM9ZX0sMTpmdW5jdGlvbihlLG4pe2UuZXhwb3J0cz10fSwxMDM6ZnVuY3Rpb24oZSx0LG4pe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLG4oMTA0KTt2YXIgcj1uKDEpO3IuZGF0ZXBpY2tlckxvY2FsZShcImRlXCIsXCJkZVwiLHtjbG9zZVRleHQ6XCJTY2hsaWXDn2VuXCIscHJldlRleHQ6XCImI3gzQztadXLDvGNrXCIsbmV4dFRleHQ6XCJWb3ImI3gzRTtcIixjdXJyZW50VGV4dDpcIkhldXRlXCIsbW9udGhOYW1lczpbXCJKYW51YXJcIixcIkZlYnJ1YXJcIixcIk3DpHJ6XCIsXCJBcHJpbFwiLFwiTWFpXCIsXCJKdW5pXCIsXCJKdWxpXCIsXCJBdWd1c3RcIixcIlNlcHRlbWJlclwiLFwiT2t0b2JlclwiLFwiTm92ZW1iZXJcIixcIkRlemVtYmVyXCJdLG1vbnRoTmFtZXNTaG9ydDpbXCJKYW5cIixcIkZlYlwiLFwiTcOkclwiLFwiQXByXCIsXCJNYWlcIixcIkp1blwiLFwiSnVsXCIsXCJBdWdcIixcIlNlcFwiLFwiT2t0XCIsXCJOb3ZcIixcIkRlelwiXSxkYXlOYW1lczpbXCJTb25udGFnXCIsXCJNb250YWdcIixcIkRpZW5zdGFnXCIsXCJNaXR0d29jaFwiLFwiRG9ubmVyc3RhZ1wiLFwiRnJlaXRhZ1wiLFwiU2Ftc3RhZ1wiXSxkYXlOYW1lc1Nob3J0OltcIlNvXCIsXCJNb1wiLFwiRGlcIixcIk1pXCIsXCJEb1wiLFwiRnJcIixcIlNhXCJdLGRheU5hbWVzTWluOltcIlNvXCIsXCJNb1wiLFwiRGlcIixcIk1pXCIsXCJEb1wiLFwiRnJcIixcIlNhXCJdLHdlZWtIZWFkZXI6XCJLV1wiLGRhdGVGb3JtYXQ6XCJkZC5tbS55eVwiLGZpcnN0RGF5OjEsaXNSVEw6ITEsc2hvd01vbnRoQWZ0ZXJZZWFyOiExLHllYXJTdWZmaXg6XCJcIn0pLHIubG9jYWxlKFwiZGVcIix7YnV0dG9uVGV4dDp7eWVhcjpcIkphaHJcIixtb250aDpcIk1vbmF0XCIsd2VlazpcIldvY2hlXCIsZGF5OlwiVGFnXCIsbGlzdDpcIlRlcm1pbsO8YmVyc2ljaHRcIn0sYWxsRGF5VGV4dDpcIkdhbnp0w6RnaWdcIixldmVudExpbWl0VGV4dDpmdW5jdGlvbihlKXtyZXR1cm5cIisgd2VpdGVyZSBcIitlfSxub0V2ZW50c01lc3NhZ2U6XCJLZWluZSBFcmVpZ25pc3NlIGFuenV6ZWlnZW5cIixkYXlPZk1vbnRoRm9ybWF0OlwiZGRkIERELk1NLlwifSl9LDEwNDpmdW5jdGlvbihlLHQsbil7IWZ1bmN0aW9uKGUsdCl7dChuKDApKX0oMCxmdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUsdCxuLHIpe3ZhciBhPXttOltcImVpbmUgTWludXRlXCIsXCJlaW5lciBNaW51dGVcIl0saDpbXCJlaW5lIFN0dW5kZVwiLFwiZWluZXIgU3R1bmRlXCJdLGQ6W1wiZWluIFRhZ1wiLFwiZWluZW0gVGFnXCJdLGRkOltlK1wiIFRhZ2VcIixlK1wiIFRhZ2VuXCJdLE06W1wiZWluIE1vbmF0XCIsXCJlaW5lbSBNb25hdFwiXSxNTTpbZStcIiBNb25hdGVcIixlK1wiIE1vbmF0ZW5cIl0seTpbXCJlaW4gSmFoclwiLFwiZWluZW0gSmFoclwiXSx5eTpbZStcIiBKYWhyZVwiLGUrXCIgSmFocmVuXCJdfTtyZXR1cm4gdD9hW25dWzBdOmFbbl1bMV19cmV0dXJuIGUuZGVmaW5lTG9jYWxlKFwiZGVcIix7bW9udGhzOlwiSmFudWFyX0ZlYnJ1YXJfTcOkcnpfQXByaWxfTWFpX0p1bmlfSnVsaV9BdWd1c3RfU2VwdGVtYmVyX09rdG9iZXJfTm92ZW1iZXJfRGV6ZW1iZXJcIi5zcGxpdChcIl9cIiksbW9udGhzU2hvcnQ6XCJKYW4uX0ZlYi5fTcOkcnpfQXByLl9NYWlfSnVuaV9KdWxpX0F1Zy5fU2VwLl9Pa3QuX05vdi5fRGV6LlwiLnNwbGl0KFwiX1wiKSxtb250aHNQYXJzZUV4YWN0OiEwLHdlZWtkYXlzOlwiU29ubnRhZ19Nb250YWdfRGllbnN0YWdfTWl0dHdvY2hfRG9ubmVyc3RhZ19GcmVpdGFnX1NhbXN0YWdcIi5zcGxpdChcIl9cIiksd2Vla2RheXNTaG9ydDpcIlNvLl9Nby5fRGkuX01pLl9Eby5fRnIuX1NhLlwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcIlNvX01vX0RpX01pX0RvX0ZyX1NhXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzUGFyc2VFeGFjdDohMCxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJISDptbVwiLExUUzpcIkhIOm1tOnNzXCIsTDpcIkRELk1NLllZWVlcIixMTDpcIkQuIE1NTU0gWVlZWVwiLExMTDpcIkQuIE1NTU0gWVlZWSBISDptbVwiLExMTEw6XCJkZGRkLCBELiBNTU1NIFlZWVkgSEg6bW1cIn0sY2FsZW5kYXI6e3NhbWVEYXk6XCJbaGV1dGUgdW1dIExUIFtVaHJdXCIsc2FtZUVsc2U6XCJMXCIsbmV4dERheTpcIlttb3JnZW4gdW1dIExUIFtVaHJdXCIsbmV4dFdlZWs6XCJkZGRkIFt1bV0gTFQgW1Vocl1cIixsYXN0RGF5OlwiW2dlc3Rlcm4gdW1dIExUIFtVaHJdXCIsbGFzdFdlZWs6XCJbbGV0enRlbl0gZGRkZCBbdW1dIExUIFtVaHJdXCJ9LHJlbGF0aXZlVGltZTp7ZnV0dXJlOlwiaW4gJXNcIixwYXN0Olwidm9yICVzXCIsczpcImVpbiBwYWFyIFNla3VuZGVuXCIsc3M6XCIlZCBTZWt1bmRlblwiLG06dCxtbTpcIiVkIE1pbnV0ZW5cIixoOnQsaGg6XCIlZCBTdHVuZGVuXCIsZDp0LGRkOnQsTTp0LE1NOnQseTp0LHl5OnR9LGRheU9mTW9udGhPcmRpbmFsUGFyc2U6L1xcZHsxLDJ9XFwuLyxvcmRpbmFsOlwiJWQuXCIsd2Vlazp7ZG93OjEsZG95OjR9fSl9KX19KX0pOyIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIm1vbWVudFwiLFwiZnVsbGNhbGVuZGFyXCJdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP3QocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTp0KGUubW9tZW50LGUuRnVsbENhbGVuZGFyKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoYSl7aWYoclthXSlyZXR1cm4gclthXS5leHBvcnRzO3ZhciBuPXJbYV09e2k6YSxsOiExLGV4cG9ydHM6e319O3JldHVybiBlW2FdLmNhbGwobi5leHBvcnRzLG4sbi5leHBvcnRzLHQpLG4ubD0hMCxuLmV4cG9ydHN9dmFyIHI9e307cmV0dXJuIHQubT1lLHQuYz1yLHQuZD1mdW5jdGlvbihlLHIsYSl7dC5vKGUscil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDphfSl9LHQubj1mdW5jdGlvbihlKXt2YXIgcj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKHIsXCJhXCIscikscn0sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9XCJcIix0KHQucz0xMTEpfSh7MDpmdW5jdGlvbih0LHIpe3QuZXhwb3J0cz1lfSwxOmZ1bmN0aW9uKGUscil7ZS5leHBvcnRzPXR9LDExMTpmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkscigxMTIpO3ZhciBhPXIoMSk7YS5kYXRlcGlja2VyTG9jYWxlKFwiZW4tZ2JcIixcImVuLUdCXCIse2Nsb3NlVGV4dDpcIkRvbmVcIixwcmV2VGV4dDpcIlByZXZcIixuZXh0VGV4dDpcIk5leHRcIixjdXJyZW50VGV4dDpcIlRvZGF5XCIsbW9udGhOYW1lczpbXCJKYW51YXJ5XCIsXCJGZWJydWFyeVwiLFwiTWFyY2hcIixcIkFwcmlsXCIsXCJNYXlcIixcIkp1bmVcIixcIkp1bHlcIixcIkF1Z3VzdFwiLFwiU2VwdGVtYmVyXCIsXCJPY3RvYmVyXCIsXCJOb3ZlbWJlclwiLFwiRGVjZW1iZXJcIl0sbW9udGhOYW1lc1Nob3J0OltcIkphblwiLFwiRmViXCIsXCJNYXJcIixcIkFwclwiLFwiTWF5XCIsXCJKdW5cIixcIkp1bFwiLFwiQXVnXCIsXCJTZXBcIixcIk9jdFwiLFwiTm92XCIsXCJEZWNcIl0sZGF5TmFtZXM6W1wiU3VuZGF5XCIsXCJNb25kYXlcIixcIlR1ZXNkYXlcIixcIldlZG5lc2RheVwiLFwiVGh1cnNkYXlcIixcIkZyaWRheVwiLFwiU2F0dXJkYXlcIl0sZGF5TmFtZXNTaG9ydDpbXCJTdW5cIixcIk1vblwiLFwiVHVlXCIsXCJXZWRcIixcIlRodVwiLFwiRnJpXCIsXCJTYXRcIl0sZGF5TmFtZXNNaW46W1wiU3VcIixcIk1vXCIsXCJUdVwiLFwiV2VcIixcIlRoXCIsXCJGclwiLFwiU2FcIl0sd2Vla0hlYWRlcjpcIldrXCIsZGF0ZUZvcm1hdDpcImRkL21tL3l5XCIsZmlyc3REYXk6MSxpc1JUTDohMSxzaG93TW9udGhBZnRlclllYXI6ITEseWVhclN1ZmZpeDpcIlwifSksYS5sb2NhbGUoXCJlbi1nYlwiKX0sMTEyOmZ1bmN0aW9uKGUsdCxyKXshZnVuY3Rpb24oZSx0KXt0KHIoMCkpfSgwLGZ1bmN0aW9uKGUpe3JldHVybiBlLmRlZmluZUxvY2FsZShcImVuLWdiXCIse21vbnRoczpcIkphbnVhcnlfRmVicnVhcnlfTWFyY2hfQXByaWxfTWF5X0p1bmVfSnVseV9BdWd1c3RfU2VwdGVtYmVyX09jdG9iZXJfTm92ZW1iZXJfRGVjZW1iZXJcIi5zcGxpdChcIl9cIiksbW9udGhzU2hvcnQ6XCJKYW5fRmViX01hcl9BcHJfTWF5X0p1bl9KdWxfQXVnX1NlcF9PY3RfTm92X0RlY1wiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5czpcIlN1bmRheV9Nb25kYXlfVHVlc2RheV9XZWRuZXNkYXlfVGh1cnNkYXlfRnJpZGF5X1NhdHVyZGF5XCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzU2hvcnQ6XCJTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXRcIi5zcGxpdChcIl9cIiksd2Vla2RheXNNaW46XCJTdV9Nb19UdV9XZV9UaF9Gcl9TYVwiLnNwbGl0KFwiX1wiKSxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJISDptbVwiLExUUzpcIkhIOm1tOnNzXCIsTDpcIkREL01NL1lZWVlcIixMTDpcIkQgTU1NTSBZWVlZXCIsTExMOlwiRCBNTU1NIFlZWVkgSEg6bW1cIixMTExMOlwiZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW1cIn0sY2FsZW5kYXI6e3NhbWVEYXk6XCJbVG9kYXkgYXRdIExUXCIsbmV4dERheTpcIltUb21vcnJvdyBhdF0gTFRcIixuZXh0V2VlazpcImRkZGQgW2F0XSBMVFwiLGxhc3REYXk6XCJbWWVzdGVyZGF5IGF0XSBMVFwiLGxhc3RXZWVrOlwiW0xhc3RdIGRkZGQgW2F0XSBMVFwiLHNhbWVFbHNlOlwiTFwifSxyZWxhdGl2ZVRpbWU6e2Z1dHVyZTpcImluICVzXCIscGFzdDpcIiVzIGFnb1wiLHM6XCJhIGZldyBzZWNvbmRzXCIsc3M6XCIlZCBzZWNvbmRzXCIsbTpcImEgbWludXRlXCIsbW06XCIlZCBtaW51dGVzXCIsaDpcImFuIGhvdXJcIixoaDpcIiVkIGhvdXJzXCIsZDpcImEgZGF5XCIsZGQ6XCIlZCBkYXlzXCIsTTpcImEgbW9udGhcIixNTTpcIiVkIG1vbnRoc1wiLHk6XCJhIHllYXJcIix5eTpcIiVkIHllYXJzXCJ9LGRheU9mTW9udGhPcmRpbmFsUGFyc2U6L1xcZHsxLDJ9KHN0fG5kfHJkfHRoKS8sb3JkaW5hbDpmdW5jdGlvbihlKXt2YXIgdD1lJTEwO3JldHVybiBlKygxPT1+fihlJTEwMC8xMCk/XCJ0aFwiOjE9PT10P1wic3RcIjoyPT09dD9cIm5kXCI6Mz09PXQ/XCJyZFwiOlwidGhcIil9LHdlZWs6e2RvdzoxLGRveTo0fX0pfSl9fSl9KTsiLCIhZnVuY3Rpb24oZSxvKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1vKHJlcXVpcmUoXCJtb21lbnRcIikscmVxdWlyZShcImZ1bGxjYWxlbmRhclwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJtb21lbnRcIixcImZ1bGxjYWxlbmRhclwiXSxvKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9vKHJlcXVpcmUoXCJtb21lbnRcIikscmVxdWlyZShcImZ1bGxjYWxlbmRhclwiKSk6byhlLm1vbWVudCxlLkZ1bGxDYWxlbmRhcil9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyxmdW5jdGlvbihlLG8pe3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiBvKG4pe2lmKHJbbl0pcmV0dXJuIHJbbl0uZXhwb3J0czt2YXIgdD1yW25dPXtpOm4sbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtuXS5jYWxsKHQuZXhwb3J0cyx0LHQuZXhwb3J0cyxvKSx0Lmw9ITAsdC5leHBvcnRzfXZhciByPXt9O3JldHVybiBvLm09ZSxvLmM9cixvLmQ9ZnVuY3Rpb24oZSxyLG4pe28ubyhlLHIpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxvLm49ZnVuY3Rpb24oZSl7dmFyIHI9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIG8uZChyLFwiYVwiLHIpLHJ9LG8ubz1mdW5jdGlvbihlLG8pe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxvKX0sby5wPVwiXCIsbyhvLnM9MTIxKX0oezA6ZnVuY3Rpb24obyxyKXtvLmV4cG9ydHM9ZX0sMTpmdW5jdGlvbihlLHIpe2UuZXhwb3J0cz1vfSwxMjE6ZnVuY3Rpb24oZSxvLHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShvLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIoMTIyKTt2YXIgbj1yKDEpO24uZGF0ZXBpY2tlckxvY2FsZShcImVzXCIsXCJlc1wiLHtjbG9zZVRleHQ6XCJDZXJyYXJcIixwcmV2VGV4dDpcIiYjeDNDO0FudFwiLG5leHRUZXh0OlwiU2lnJiN4M0U7XCIsY3VycmVudFRleHQ6XCJIb3lcIixtb250aE5hbWVzOltcImVuZXJvXCIsXCJmZWJyZXJvXCIsXCJtYXJ6b1wiLFwiYWJyaWxcIixcIm1heW9cIixcImp1bmlvXCIsXCJqdWxpb1wiLFwiYWdvc3RvXCIsXCJzZXB0aWVtYnJlXCIsXCJvY3R1YnJlXCIsXCJub3ZpZW1icmVcIixcImRpY2llbWJyZVwiXSxtb250aE5hbWVzU2hvcnQ6W1wiZW5lXCIsXCJmZWJcIixcIm1hclwiLFwiYWJyXCIsXCJtYXlcIixcImp1blwiLFwianVsXCIsXCJhZ29cIixcInNlcFwiLFwib2N0XCIsXCJub3ZcIixcImRpY1wiXSxkYXlOYW1lczpbXCJkb21pbmdvXCIsXCJsdW5lc1wiLFwibWFydGVzXCIsXCJtacOpcmNvbGVzXCIsXCJqdWV2ZXNcIixcInZpZXJuZXNcIixcInPDoWJhZG9cIl0sZGF5TmFtZXNTaG9ydDpbXCJkb21cIixcImx1blwiLFwibWFyXCIsXCJtacOpXCIsXCJqdWVcIixcInZpZVwiLFwic8OhYlwiXSxkYXlOYW1lc01pbjpbXCJEXCIsXCJMXCIsXCJNXCIsXCJYXCIsXCJKXCIsXCJWXCIsXCJTXCJdLHdlZWtIZWFkZXI6XCJTbVwiLGRhdGVGb3JtYXQ6XCJkZC9tbS95eVwiLGZpcnN0RGF5OjEsaXNSVEw6ITEsc2hvd01vbnRoQWZ0ZXJZZWFyOiExLHllYXJTdWZmaXg6XCJcIn0pLG4ubG9jYWxlKFwiZXNcIix7YnV0dG9uVGV4dDp7bW9udGg6XCJNZXNcIix3ZWVrOlwiU2VtYW5hXCIsZGF5OlwiRMOtYVwiLGxpc3Q6XCJBZ2VuZGFcIn0sYWxsRGF5SHRtbDpcIlRvZG88YnIvPmVsIGTDrWFcIixldmVudExpbWl0VGV4dDpcIm3DoXNcIixub0V2ZW50c01lc3NhZ2U6XCJObyBoYXkgZXZlbnRvcyBwYXJhIG1vc3RyYXJcIn0pfSwxMjI6ZnVuY3Rpb24oZSxvLHIpeyFmdW5jdGlvbihlLG8pe28ocigwKSl9KDAsZnVuY3Rpb24oZSl7dmFyIG89XCJlbmUuX2ZlYi5fbWFyLl9hYnIuX21heS5fanVuLl9qdWwuX2Fnby5fc2VwLl9vY3QuX25vdi5fZGljLlwiLnNwbGl0KFwiX1wiKSxyPVwiZW5lX2ZlYl9tYXJfYWJyX21heV9qdW5fanVsX2Fnb19zZXBfb2N0X25vdl9kaWNcIi5zcGxpdChcIl9cIiksbj1bL15lbmUvaSwvXmZlYi9pLC9ebWFyL2ksL15hYnIvaSwvXm1heS9pLC9eanVuL2ksL15qdWwvaSwvXmFnby9pLC9ec2VwL2ksL15vY3QvaSwvXm5vdi9pLC9eZGljL2ldLHQ9L14oZW5lcm98ZmVicmVyb3xtYXJ6b3xhYnJpbHxtYXlvfGp1bmlvfGp1bGlvfGFnb3N0b3xzZXB0aWVtYnJlfG9jdHVicmV8bm92aWVtYnJlfGRpY2llbWJyZXxlbmVcXC4/fGZlYlxcLj98bWFyXFwuP3xhYnJcXC4/fG1heVxcLj98anVuXFwuP3xqdWxcXC4/fGFnb1xcLj98c2VwXFwuP3xvY3RcXC4/fG5vdlxcLj98ZGljXFwuPykvaTtyZXR1cm4gZS5kZWZpbmVMb2NhbGUoXCJlc1wiLHttb250aHM6XCJlbmVyb19mZWJyZXJvX21hcnpvX2FicmlsX21heW9fanVuaW9fanVsaW9fYWdvc3RvX3NlcHRpZW1icmVfb2N0dWJyZV9ub3ZpZW1icmVfZGljaWVtYnJlXCIuc3BsaXQoXCJfXCIpLG1vbnRoc1Nob3J0OmZ1bmN0aW9uKGUsbil7cmV0dXJuIGU/Ly1NTU0tLy50ZXN0KG4pP3JbZS5tb250aCgpXTpvW2UubW9udGgoKV06b30sbW9udGhzUmVnZXg6dCxtb250aHNTaG9ydFJlZ2V4OnQsbW9udGhzU3RyaWN0UmVnZXg6L14oZW5lcm98ZmVicmVyb3xtYXJ6b3xhYnJpbHxtYXlvfGp1bmlvfGp1bGlvfGFnb3N0b3xzZXB0aWVtYnJlfG9jdHVicmV8bm92aWVtYnJlfGRpY2llbWJyZSkvaSxtb250aHNTaG9ydFN0cmljdFJlZ2V4Oi9eKGVuZVxcLj98ZmViXFwuP3xtYXJcXC4/fGFiclxcLj98bWF5XFwuP3xqdW5cXC4/fGp1bFxcLj98YWdvXFwuP3xzZXBcXC4/fG9jdFxcLj98bm92XFwuP3xkaWNcXC4/KS9pLG1vbnRoc1BhcnNlOm4sbG9uZ01vbnRoc1BhcnNlOm4sc2hvcnRNb250aHNQYXJzZTpuLHdlZWtkYXlzOlwiZG9taW5nb19sdW5lc19tYXJ0ZXNfbWnDqXJjb2xlc19qdWV2ZXNfdmllcm5lc19zw6FiYWRvXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzU2hvcnQ6XCJkb20uX2x1bi5fbWFyLl9tacOpLl9qdWUuX3ZpZS5fc8OhYi5cIi5zcGxpdChcIl9cIiksd2Vla2RheXNNaW46XCJkb19sdV9tYV9taV9qdV92aV9zw6FcIi5zcGxpdChcIl9cIiksd2Vla2RheXNQYXJzZUV4YWN0OiEwLGxvbmdEYXRlRm9ybWF0OntMVDpcIkg6bW1cIixMVFM6XCJIOm1tOnNzXCIsTDpcIkREL01NL1lZWVlcIixMTDpcIkQgW2RlXSBNTU1NIFtkZV0gWVlZWVwiLExMTDpcIkQgW2RlXSBNTU1NIFtkZV0gWVlZWSBIOm1tXCIsTExMTDpcImRkZGQsIEQgW2RlXSBNTU1NIFtkZV0gWVlZWSBIOm1tXCJ9LGNhbGVuZGFyOntzYW1lRGF5OmZ1bmN0aW9uKCl7cmV0dXJuXCJbaG95IGEgbGFcIisoMSE9PXRoaXMuaG91cnMoKT9cInNcIjpcIlwiKStcIl0gTFRcIn0sbmV4dERheTpmdW5jdGlvbigpe3JldHVyblwiW21hw7FhbmEgYSBsYVwiKygxIT09dGhpcy5ob3VycygpP1wic1wiOlwiXCIpK1wiXSBMVFwifSxuZXh0V2VlazpmdW5jdGlvbigpe3JldHVyblwiZGRkZCBbYSBsYVwiKygxIT09dGhpcy5ob3VycygpP1wic1wiOlwiXCIpK1wiXSBMVFwifSxsYXN0RGF5OmZ1bmN0aW9uKCl7cmV0dXJuXCJbYXllciBhIGxhXCIrKDEhPT10aGlzLmhvdXJzKCk/XCJzXCI6XCJcIikrXCJdIExUXCJ9LGxhc3RXZWVrOmZ1bmN0aW9uKCl7cmV0dXJuXCJbZWxdIGRkZGQgW3Bhc2FkbyBhIGxhXCIrKDEhPT10aGlzLmhvdXJzKCk/XCJzXCI6XCJcIikrXCJdIExUXCJ9LHNhbWVFbHNlOlwiTFwifSxyZWxhdGl2ZVRpbWU6e2Z1dHVyZTpcImVuICVzXCIscGFzdDpcImhhY2UgJXNcIixzOlwidW5vcyBzZWd1bmRvc1wiLHNzOlwiJWQgc2VndW5kb3NcIixtOlwidW4gbWludXRvXCIsbW06XCIlZCBtaW51dG9zXCIsaDpcInVuYSBob3JhXCIsaGg6XCIlZCBob3Jhc1wiLGQ6XCJ1biBkw61hXCIsZGQ6XCIlZCBkw61hc1wiLE06XCJ1biBtZXNcIixNTTpcIiVkIG1lc2VzXCIseTpcInVuIGHDsW9cIix5eTpcIiVkIGHDsW9zXCJ9LGRheU9mTW9udGhPcmRpbmFsUGFyc2U6L1xcZHsxLDJ9wrovLG9yZGluYWw6XCIlZMK6XCIsd2Vlazp7ZG93OjEsZG95OjR9LGludmFsaWREYXRlOlwiRmVjaGEgaW52YWxpZGFcIn0pfSl9fSl9KTsiLCIhZnVuY3Rpb24oYSxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKHJlcXVpcmUoXCJtb21lbnRcIikscmVxdWlyZShcImZ1bGxjYWxlbmRhclwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJtb21lbnRcIixcImZ1bGxjYWxlbmRhclwiXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9lKHJlcXVpcmUoXCJtb21lbnRcIikscmVxdWlyZShcImZ1bGxjYWxlbmRhclwiKSk6ZShhLm1vbWVudCxhLkZ1bGxDYWxlbmRhcil9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyxmdW5jdGlvbihhLGUpe3JldHVybiBmdW5jdGlvbihhKXtmdW5jdGlvbiBlKHIpe2lmKHRbcl0pcmV0dXJuIHRbcl0uZXhwb3J0czt2YXIgbj10W3JdPXtpOnIsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gYVtyXS5jYWxsKG4uZXhwb3J0cyxuLG4uZXhwb3J0cyxlKSxuLmw9ITAsbi5leHBvcnRzfXZhciB0PXt9O3JldHVybiBlLm09YSxlLmM9dCxlLmQ9ZnVuY3Rpb24oYSx0LHIpe2UubyhhLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSx0LHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6cn0pfSxlLm49ZnVuY3Rpb24oYSl7dmFyIHQ9YSYmYS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGEuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gYX07cmV0dXJuIGUuZCh0LFwiYVwiLHQpLHR9LGUubz1mdW5jdGlvbihhLGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxlKX0sZS5wPVwiXCIsZShlLnM9MTI1KX0oezA6ZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9YX0sMTpmdW5jdGlvbihhLHQpe2EuZXhwb3J0cz1lfSwxMjU6ZnVuY3Rpb24oYSxlLHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQoMTI2KTt2YXIgcj10KDEpO3IuZGF0ZXBpY2tlckxvY2FsZShcImV1XCIsXCJldVwiLHtjbG9zZVRleHQ6XCJFZ2luYVwiLHByZXZUZXh0OlwiJiN4M0M7QXVyXCIsbmV4dFRleHQ6XCJIdXImI3gzRTtcIixjdXJyZW50VGV4dDpcIkdhdXJcIixtb250aE5hbWVzOltcInVydGFycmlsYVwiLFwib3RzYWlsYVwiLFwibWFydHhvYVwiLFwiYXBpcmlsYVwiLFwibWFpYXR6YVwiLFwiZWthaW5hXCIsXCJ1enRhaWxhXCIsXCJhYnV6dHVhXCIsXCJpcmFpbGFcIixcInVycmlhXCIsXCJhemFyb2FcIixcImFiZW5kdWFcIl0sbW9udGhOYW1lc1Nob3J0OltcInVydC5cIixcIm90cy5cIixcIm1hci5cIixcImFwaS5cIixcIm1haS5cIixcImVrYS5cIixcInV6dC5cIixcImFidS5cIixcImlyYS5cIixcInVyci5cIixcImF6YS5cIixcImFiZS5cIl0sZGF5TmFtZXM6W1wiaWdhbmRlYVwiLFwiYXN0ZWxlaGVuYVwiLFwiYXN0ZWFydGVhXCIsXCJhc3RlYXprZW5hXCIsXCJvc3RlZ3VuYVwiLFwib3N0aXJhbGFcIixcImxhcnVuYmF0YVwiXSxkYXlOYW1lc1Nob3J0OltcImlnLlwiLFwiYWwuXCIsXCJhci5cIixcImF6LlwiLFwib2cuXCIsXCJvbC5cIixcImxyLlwiXSxkYXlOYW1lc01pbjpbXCJpZ1wiLFwiYWxcIixcImFyXCIsXCJhelwiLFwib2dcIixcIm9sXCIsXCJsclwiXSx3ZWVrSGVhZGVyOlwiQXNcIixkYXRlRm9ybWF0OlwieXktbW0tZGRcIixmaXJzdERheToxLGlzUlRMOiExLHNob3dNb250aEFmdGVyWWVhcjohMSx5ZWFyU3VmZml4OlwiXCJ9KSxyLmxvY2FsZShcImV1XCIse2J1dHRvblRleHQ6e21vbnRoOlwiSGlsYWJldGVhXCIsd2VlazpcIkFzdGVhXCIsZGF5OlwiRWd1bmFcIixsaXN0OlwiQWdlbmRhXCJ9LGFsbERheUh0bWw6XCJFZ3VuPGJyLz5vc29hXCIsZXZlbnRMaW1pdFRleHQ6XCJnZWhpYWdvXCIsbm9FdmVudHNNZXNzYWdlOlwiRXogZGFnbyBla2l0YWxkaXJpayBlcmFrdXN0ZWtvXCJ9KX0sMTI2OmZ1bmN0aW9uKGEsZSx0KXshZnVuY3Rpb24oYSxlKXtlKHQoMCkpfSgwLGZ1bmN0aW9uKGEpe3JldHVybiBhLmRlZmluZUxvY2FsZShcImV1XCIse21vbnRoczpcInVydGFycmlsYV9vdHNhaWxhX21hcnR4b2FfYXBpcmlsYV9tYWlhdHphX2VrYWluYV91enRhaWxhX2FidXp0dWFfaXJhaWxhX3VycmlhX2F6YXJvYV9hYmVuZHVhXCIuc3BsaXQoXCJfXCIpLG1vbnRoc1Nob3J0OlwidXJ0Ll9vdHMuX21hci5fYXBpLl9tYWkuX2VrYS5fdXp0Ll9hYnUuX2lyYS5fdXJyLl9hemEuX2FiZS5cIi5zcGxpdChcIl9cIiksbW9udGhzUGFyc2VFeGFjdDohMCx3ZWVrZGF5czpcImlnYW5kZWFfYXN0ZWxlaGVuYV9hc3RlYXJ0ZWFfYXN0ZWF6a2VuYV9vc3RlZ3VuYV9vc3RpcmFsYV9sYXJ1bmJhdGFcIi5zcGxpdChcIl9cIiksd2Vla2RheXNTaG9ydDpcImlnLl9hbC5fYXIuX2F6Ll9vZy5fb2wuX2xyLlwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcImlnX2FsX2FyX2F6X29nX29sX2xyXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzUGFyc2VFeGFjdDohMCxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJISDptbVwiLExUUzpcIkhIOm1tOnNzXCIsTDpcIllZWVktTU0tRERcIixMTDpcIllZWVlba29dIE1NTU1bcmVuXSBEW2FdXCIsTExMOlwiWVlZWVtrb10gTU1NTVtyZW5dIERbYV0gSEg6bW1cIixMTExMOlwiZGRkZCwgWVlZWVtrb10gTU1NTVtyZW5dIERbYV0gSEg6bW1cIixsOlwiWVlZWS1NLURcIixsbDpcIllZWVlba29dIE1NTSBEW2FdXCIsbGxsOlwiWVlZWVtrb10gTU1NIERbYV0gSEg6bW1cIixsbGxsOlwiZGRkLCBZWVlZW2tvXSBNTU0gRFthXSBISDptbVwifSxjYWxlbmRhcjp7c2FtZURheTpcIltnYXVyXSBMVFtldGFuXVwiLG5leHREYXk6XCJbYmloYXJdIExUW2V0YW5dXCIsbmV4dFdlZWs6XCJkZGRkIExUW2V0YW5dXCIsbGFzdERheTpcIlthdHpvXSBMVFtldGFuXVwiLGxhc3RXZWVrOlwiW2F1cnJla29dIGRkZGQgTFRbZXRhbl1cIixzYW1lRWxzZTpcIkxcIn0scmVsYXRpdmVUaW1lOntmdXR1cmU6XCIlcyBiYXJydVwiLHBhc3Q6XCJkdWVsYSAlc1wiLHM6XCJzZWd1bmRvIGJhdHp1a1wiLHNzOlwiJWQgc2VndW5kb1wiLG06XCJtaW51dHUgYmF0XCIsbW06XCIlZCBtaW51dHVcIixoOlwib3JkdSBiYXRcIixoaDpcIiVkIG9yZHVcIixkOlwiZWd1biBiYXRcIixkZDpcIiVkIGVndW5cIixNOlwiaGlsYWJldGUgYmF0XCIsTU06XCIlZCBoaWxhYmV0ZVwiLHk6XCJ1cnRlIGJhdFwiLHl5OlwiJWQgdXJ0ZVwifSxkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOi9cXGR7MSwyfVxcLi8sb3JkaW5hbDpcIiVkLlwiLHdlZWs6e2RvdzoxLGRveTo3fX0pfSl9fSl9KTsiLCIhZnVuY3Rpb24oZSx1KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz11KHJlcXVpcmUoXCJtb21lbnRcIikscmVxdWlyZShcImZ1bGxjYWxlbmRhclwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJtb21lbnRcIixcImZ1bGxjYWxlbmRhclwiXSx1KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz91KHJlcXVpcmUoXCJtb21lbnRcIikscmVxdWlyZShcImZ1bGxjYWxlbmRhclwiKSk6dShlLm1vbWVudCxlLkZ1bGxDYWxlbmRhcil9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyxmdW5jdGlvbihlLHUpe3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiB1KGEpe2lmKHRbYV0pcmV0dXJuIHRbYV0uZXhwb3J0czt2YXIgbj10W2FdPXtpOmEsbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVthXS5jYWxsKG4uZXhwb3J0cyxuLG4uZXhwb3J0cyx1KSxuLmw9ITAsbi5leHBvcnRzfXZhciB0PXt9O3JldHVybiB1Lm09ZSx1LmM9dCx1LmQ9ZnVuY3Rpb24oZSx0LGEpe3UubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6YX0pfSx1Lm49ZnVuY3Rpb24oZSl7dmFyIHQ9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIHUuZCh0LFwiYVwiLHQpLHR9LHUubz1mdW5jdGlvbihlLHUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx1KX0sdS5wPVwiXCIsdSh1LnM9MTI5KX0oezA6ZnVuY3Rpb24odSx0KXt1LmV4cG9ydHM9ZX0sMTpmdW5jdGlvbihlLHQpe2UuZXhwb3J0cz11fSwxMjk6ZnVuY3Rpb24oZSx1LHQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHQoMTMwKTt2YXIgYT10KDEpO2EuZGF0ZXBpY2tlckxvY2FsZShcImZpXCIsXCJmaVwiLHtjbG9zZVRleHQ6XCJTdWxqZVwiLHByZXZUZXh0OlwiJiN4QUI7RWRlbGxpbmVuXCIsbmV4dFRleHQ6XCJTZXVyYWF2YSYjeEJCO1wiLGN1cnJlbnRUZXh0OlwiVMOkbsOkw6RuXCIsbW9udGhOYW1lczpbXCJUYW1taWt1dVwiLFwiSGVsbWlrdXVcIixcIk1hYWxpc2t1dVwiLFwiSHVodGlrdXVcIixcIlRvdWtva3V1XCIsXCJLZXPDpGt1dVwiLFwiSGVpbsOka3V1XCIsXCJFbG9rdXVcIixcIlN5eXNrdXVcIixcIkxva2FrdXVcIixcIk1hcnJhc2t1dVwiLFwiSm91bHVrdXVcIl0sbW9udGhOYW1lc1Nob3J0OltcIlRhbW1pXCIsXCJIZWxtaVwiLFwiTWFhbGlzXCIsXCJIdWh0aVwiLFwiVG91a29cIixcIktlc8OkXCIsXCJIZWluw6RcIixcIkVsb1wiLFwiU3l5c1wiLFwiTG9rYVwiLFwiTWFycmFzXCIsXCJKb3VsdVwiXSxkYXlOYW1lc1Nob3J0OltcIlN1XCIsXCJNYVwiLFwiVGlcIixcIktlXCIsXCJUb1wiLFwiUGVcIixcIkxhXCJdLGRheU5hbWVzOltcIlN1bm51bnRhaVwiLFwiTWFhbmFudGFpXCIsXCJUaWlzdGFpXCIsXCJLZXNraXZpaWtrb1wiLFwiVG9yc3RhaVwiLFwiUGVyamFudGFpXCIsXCJMYXVhbnRhaVwiXSxkYXlOYW1lc01pbjpbXCJTdVwiLFwiTWFcIixcIlRpXCIsXCJLZVwiLFwiVG9cIixcIlBlXCIsXCJMYVwiXSx3ZWVrSGVhZGVyOlwiVmtcIixkYXRlRm9ybWF0OlwiZC5tLnl5XCIsZmlyc3REYXk6MSxpc1JUTDohMSxzaG93TW9udGhBZnRlclllYXI6ITEseWVhclN1ZmZpeDpcIlwifSksYS5sb2NhbGUoXCJmaVwiLHtidXR0b25UZXh0Onttb250aDpcIkt1dWthdXNpXCIsd2VlazpcIlZpaWtrb1wiLGRheTpcIlDDpGl2w6RcIixsaXN0OlwiVGFwYWh0dW1hdFwifSxhbGxEYXlUZXh0OlwiS29rbyBww6RpdsOkXCIsZXZlbnRMaW1pdFRleHQ6XCJsaXPDpMOkXCIsbm9FdmVudHNNZXNzYWdlOlwiRWkgbsOkeXRldHTDpHZpw6QgdGFwYWh0dW1pYVwifSl9LDEzMDpmdW5jdGlvbihlLHUsdCl7IWZ1bmN0aW9uKGUsdSl7dSh0KDApKX0oMCxmdW5jdGlvbihlKXtmdW5jdGlvbiB1KGUsdSxhLG4pe3ZhciBpPVwiXCI7c3dpdGNoKGEpe2Nhc2VcInNcIjpyZXR1cm4gbj9cIm11dXRhbWFuIHNla3VubmluXCI6XCJtdXV0YW1hIHNla3VudGlcIjtjYXNlXCJzc1wiOnJldHVybiBuP1wic2VrdW5uaW5cIjpcInNla3VudGlhXCI7Y2FzZVwibVwiOnJldHVybiBuP1wibWludXV0aW5cIjpcIm1pbnV1dHRpXCI7Y2FzZVwibW1cIjppPW4/XCJtaW51dXRpblwiOlwibWludXV0dGlhXCI7YnJlYWs7Y2FzZVwiaFwiOnJldHVybiBuP1widHVubmluXCI6XCJ0dW50aVwiO2Nhc2VcImhoXCI6aT1uP1widHVubmluXCI6XCJ0dW50aWFcIjticmVhaztjYXNlXCJkXCI6cmV0dXJuIG4/XCJww6RpdsOkblwiOlwicMOkaXbDpFwiO2Nhc2VcImRkXCI6aT1uP1wicMOkaXbDpG5cIjpcInDDpGl2w6TDpFwiO2JyZWFrO2Nhc2VcIk1cIjpyZXR1cm4gbj9cImt1dWthdWRlblwiOlwia3V1a2F1c2lcIjtjYXNlXCJNTVwiOmk9bj9cImt1dWthdWRlblwiOlwia3V1a2F1dHRhXCI7YnJlYWs7Y2FzZVwieVwiOnJldHVybiBuP1widnVvZGVuXCI6XCJ2dW9zaVwiO2Nhc2VcInl5XCI6aT1uP1widnVvZGVuXCI6XCJ2dW90dGFcIn1yZXR1cm4gaT10KGUsbikrXCIgXCIraX1mdW5jdGlvbiB0KGUsdSl7cmV0dXJuIGU8MTA/dT9uW2VdOmFbZV06ZX12YXIgYT1cIm5vbGxhIHlrc2kga2Frc2kga29sbWUgbmVsasOkIHZpaXNpIGt1dXNpIHNlaXRzZW3DpG4ga2FoZGVrc2FuIHloZGVrc8OkblwiLnNwbGl0KFwiIFwiKSxuPVtcIm5vbGxhXCIsXCJ5aGRlblwiLFwia2FoZGVuXCIsXCJrb2xtZW5cIixcIm5lbGrDpG5cIixcInZpaWRlblwiLFwia3V1ZGVuXCIsYVs3XSxhWzhdLGFbOV1dO3JldHVybiBlLmRlZmluZUxvY2FsZShcImZpXCIse21vbnRoczpcInRhbW1pa3V1X2hlbG1pa3V1X21hYWxpc2t1dV9odWh0aWt1dV90b3Vrb2t1dV9rZXPDpGt1dV9oZWluw6RrdXVfZWxva3V1X3N5eXNrdXVfbG9rYWt1dV9tYXJyYXNrdXVfam91bHVrdXVcIi5zcGxpdChcIl9cIiksbW9udGhzU2hvcnQ6XCJ0YW1taV9oZWxtaV9tYWFsaXNfaHVodGlfdG91a29fa2Vzw6RfaGVpbsOkX2Vsb19zeXlzX2xva2FfbWFycmFzX2pvdWx1XCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzOlwic3VubnVudGFpX21hYW5hbnRhaV90aWlzdGFpX2tlc2tpdmlpa2tvX3RvcnN0YWlfcGVyamFudGFpX2xhdWFudGFpXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzU2hvcnQ6XCJzdV9tYV90aV9rZV90b19wZV9sYVwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcInN1X21hX3RpX2tlX3RvX3BlX2xhXCIuc3BsaXQoXCJfXCIpLGxvbmdEYXRlRm9ybWF0OntMVDpcIkhILm1tXCIsTFRTOlwiSEgubW0uc3NcIixMOlwiREQuTU0uWVlZWVwiLExMOlwiRG8gTU1NTVt0YV0gWVlZWVwiLExMTDpcIkRvIE1NTU1bdGFdIFlZWVksIFtrbG9dIEhILm1tXCIsTExMTDpcImRkZGQsIERvIE1NTU1bdGFdIFlZWVksIFtrbG9dIEhILm1tXCIsbDpcIkQuTS5ZWVlZXCIsbGw6XCJEbyBNTU0gWVlZWVwiLGxsbDpcIkRvIE1NTSBZWVlZLCBba2xvXSBISC5tbVwiLGxsbGw6XCJkZGQsIERvIE1NTSBZWVlZLCBba2xvXSBISC5tbVwifSxjYWxlbmRhcjp7c2FtZURheTpcIlt0w6Ruw6TDpG5dIFtrbG9dIExUXCIsbmV4dERheTpcIltodW9tZW5uYV0gW2tsb10gTFRcIixuZXh0V2VlazpcImRkZGQgW2tsb10gTFRcIixsYXN0RGF5OlwiW2VpbGVuXSBba2xvXSBMVFwiLGxhc3RXZWVrOlwiW3ZpaW1lXSBkZGRkW25hXSBba2xvXSBMVFwiLHNhbWVFbHNlOlwiTFwifSxyZWxhdGl2ZVRpbWU6e2Z1dHVyZTpcIiVzIHDDpMOkc3TDpFwiLHBhc3Q6XCIlcyBzaXR0ZW5cIixzOnUsc3M6dSxtOnUsbW06dSxoOnUsaGg6dSxkOnUsZGQ6dSxNOnUsTU06dSx5OnUseXk6dX0sZGF5T2ZNb250aE9yZGluYWxQYXJzZTovXFxkezEsMn1cXC4vLG9yZGluYWw6XCIlZC5cIix3ZWVrOntkb3c6MSxkb3k6NH19KX0pfX0pfSk7IiwiIWZ1bmN0aW9uKGUscil7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9cihyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wibW9tZW50XCIsXCJmdWxsY2FsZW5kYXJcIl0scik6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/cihyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOnIoZS5tb21lbnQsZS5GdWxsQ2FsZW5kYXIpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24oZSxyKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcih0KXtpZihuW3RdKXJldHVybiBuW3RdLmV4cG9ydHM7dmFyIGE9blt0XT17aTp0LGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbdF0uY2FsbChhLmV4cG9ydHMsYSxhLmV4cG9ydHMsciksYS5sPSEwLGEuZXhwb3J0c312YXIgbj17fTtyZXR1cm4gci5tPWUsci5jPW4sci5kPWZ1bmN0aW9uKGUsbix0KXtyLm8oZSxuKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0OnR9KX0sci5uPWZ1bmN0aW9uKGUpe3ZhciBuPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiByLmQobixcImFcIixuKSxufSxyLm89ZnVuY3Rpb24oZSxyKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUscil9LHIucD1cIlwiLHIoci5zPTEzNSl9KHswOmZ1bmN0aW9uKHIsbil7ci5leHBvcnRzPWV9LDE6ZnVuY3Rpb24oZSxuKXtlLmV4cG9ydHM9cn0sMTM1OmZ1bmN0aW9uKGUscixuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuKDEzNik7dmFyIHQ9bigxKTt0LmRhdGVwaWNrZXJMb2NhbGUoXCJmclwiLFwiZnJcIix7Y2xvc2VUZXh0OlwiRmVybWVyXCIscHJldlRleHQ6XCJQcsOpY8OpZGVudFwiLG5leHRUZXh0OlwiU3VpdmFudFwiLGN1cnJlbnRUZXh0OlwiQXVqb3VyZCdodWlcIixtb250aE5hbWVzOltcImphbnZpZXJcIixcImbDqXZyaWVyXCIsXCJtYXJzXCIsXCJhdnJpbFwiLFwibWFpXCIsXCJqdWluXCIsXCJqdWlsbGV0XCIsXCJhb8O7dFwiLFwic2VwdGVtYnJlXCIsXCJvY3RvYnJlXCIsXCJub3ZlbWJyZVwiLFwiZMOpY2VtYnJlXCJdLG1vbnRoTmFtZXNTaG9ydDpbXCJqYW52LlwiLFwiZsOpdnIuXCIsXCJtYXJzXCIsXCJhdnIuXCIsXCJtYWlcIixcImp1aW5cIixcImp1aWwuXCIsXCJhb8O7dFwiLFwic2VwdC5cIixcIm9jdC5cIixcIm5vdi5cIixcImTDqWMuXCJdLGRheU5hbWVzOltcImRpbWFuY2hlXCIsXCJsdW5kaVwiLFwibWFyZGlcIixcIm1lcmNyZWRpXCIsXCJqZXVkaVwiLFwidmVuZHJlZGlcIixcInNhbWVkaVwiXSxkYXlOYW1lc1Nob3J0OltcImRpbS5cIixcImx1bi5cIixcIm1hci5cIixcIm1lci5cIixcImpldS5cIixcInZlbi5cIixcInNhbS5cIl0sZGF5TmFtZXNNaW46W1wiRFwiLFwiTFwiLFwiTVwiLFwiTVwiLFwiSlwiLFwiVlwiLFwiU1wiXSx3ZWVrSGVhZGVyOlwiU2VtLlwiLGRhdGVGb3JtYXQ6XCJkZC9tbS95eVwiLGZpcnN0RGF5OjEsaXNSVEw6ITEsc2hvd01vbnRoQWZ0ZXJZZWFyOiExLHllYXJTdWZmaXg6XCJcIn0pLHQubG9jYWxlKFwiZnJcIix7YnV0dG9uVGV4dDp7eWVhcjpcIkFubsOpZVwiLG1vbnRoOlwiTW9pc1wiLHdlZWs6XCJTZW1haW5lXCIsZGF5OlwiSm91clwiLGxpc3Q6XCJNb24gcGxhbm5pbmdcIn0sYWxsRGF5SHRtbDpcIlRvdXRlIGxhPGJyLz5qb3VybsOpZVwiLGV2ZW50TGltaXRUZXh0OlwiZW4gcGx1c1wiLG5vRXZlbnRzTWVzc2FnZTpcIkF1Y3VuIMOpdsOpbmVtZW50IMOgIGFmZmljaGVyXCJ9KX0sMTM2OmZ1bmN0aW9uKGUscixuKXshZnVuY3Rpb24oZSxyKXtyKG4oMCkpfSgwLGZ1bmN0aW9uKGUpe3JldHVybiBlLmRlZmluZUxvY2FsZShcImZyXCIse21vbnRoczpcImphbnZpZXJfZsOpdnJpZXJfbWFyc19hdnJpbF9tYWlfanVpbl9qdWlsbGV0X2Fvw7t0X3NlcHRlbWJyZV9vY3RvYnJlX25vdmVtYnJlX2TDqWNlbWJyZVwiLnNwbGl0KFwiX1wiKSxtb250aHNTaG9ydDpcImphbnYuX2bDqXZyLl9tYXJzX2F2ci5fbWFpX2p1aW5fanVpbC5fYW/Du3Rfc2VwdC5fb2N0Ll9ub3YuX2TDqWMuXCIuc3BsaXQoXCJfXCIpLG1vbnRoc1BhcnNlRXhhY3Q6ITAsd2Vla2RheXM6XCJkaW1hbmNoZV9sdW5kaV9tYXJkaV9tZXJjcmVkaV9qZXVkaV92ZW5kcmVkaV9zYW1lZGlcIi5zcGxpdChcIl9cIiksd2Vla2RheXNTaG9ydDpcImRpbS5fbHVuLl9tYXIuX21lci5famV1Ll92ZW4uX3NhbS5cIi5zcGxpdChcIl9cIiksd2Vla2RheXNNaW46XCJkaV9sdV9tYV9tZV9qZV92ZV9zYVwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c1BhcnNlRXhhY3Q6ITAsbG9uZ0RhdGVGb3JtYXQ6e0xUOlwiSEg6bW1cIixMVFM6XCJISDptbTpzc1wiLEw6XCJERC9NTS9ZWVlZXCIsTEw6XCJEIE1NTU0gWVlZWVwiLExMTDpcIkQgTU1NTSBZWVlZIEhIOm1tXCIsTExMTDpcImRkZGQgRCBNTU1NIFlZWVkgSEg6bW1cIn0sY2FsZW5kYXI6e3NhbWVEYXk6XCJbQXVqb3VyZOKAmWh1aSDDoF0gTFRcIixuZXh0RGF5OlwiW0RlbWFpbiDDoF0gTFRcIixuZXh0V2VlazpcImRkZGQgW8OgXSBMVFwiLGxhc3REYXk6XCJbSGllciDDoF0gTFRcIixsYXN0V2VlazpcImRkZGQgW2Rlcm5pZXIgw6BdIExUXCIsc2FtZUVsc2U6XCJMXCJ9LHJlbGF0aXZlVGltZTp7ZnV0dXJlOlwiZGFucyAlc1wiLHBhc3Q6XCJpbCB5IGEgJXNcIixzOlwicXVlbHF1ZXMgc2Vjb25kZXNcIixzczpcIiVkIHNlY29uZGVzXCIsbTpcInVuZSBtaW51dGVcIixtbTpcIiVkIG1pbnV0ZXNcIixoOlwidW5lIGhldXJlXCIsaGg6XCIlZCBoZXVyZXNcIixkOlwidW4gam91clwiLGRkOlwiJWQgam91cnNcIixNOlwidW4gbW9pc1wiLE1NOlwiJWQgbW9pc1wiLHk6XCJ1biBhblwiLHl5OlwiJWQgYW5zXCJ9LGRheU9mTW9udGhPcmRpbmFsUGFyc2U6L1xcZHsxLDJ9KGVyfCkvLG9yZGluYWw6ZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiRFwiOnJldHVybiBlKygxPT09ZT9cImVyXCI6XCJcIik7ZGVmYXVsdDpjYXNlXCJNXCI6Y2FzZVwiUVwiOmNhc2VcIkRERFwiOmNhc2VcImRcIjpyZXR1cm4gZSsoMT09PWU/XCJlclwiOlwiZVwiKTtjYXNlXCJ3XCI6Y2FzZVwiV1wiOnJldHVybiBlKygxPT09ZT9cInJlXCI6XCJlXCIpfX0sd2Vlazp7ZG93OjEsZG95OjR9fSl9KX19KX0pOyIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIm1vbWVudFwiLFwiZnVsbGNhbGVuZGFyXCJdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP3QocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTp0KGUubW9tZW50LGUuRnVsbENhbGVuZGFyKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQocil7aWYobltyXSlyZXR1cm4gbltyXS5leHBvcnRzO3ZhciBvPW5bcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW3JdLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLHQpLG8ubD0hMCxvLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIHQubT1lLHQuYz1uLHQuZD1mdW5jdGlvbihlLG4scil7dC5vKGUsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpyfSl9LHQubj1mdW5jdGlvbihlKXt2YXIgbj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKG4sXCJhXCIsbiksbn0sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9XCJcIix0KHQucz0xMzkpfSh7MDpmdW5jdGlvbih0LG4pe3QuZXhwb3J0cz1lfSwxOmZ1bmN0aW9uKGUsbil7ZS5leHBvcnRzPXR9LDEzOTpmdW5jdGlvbihlLHQsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbigxNDApO3ZhciByPW4oMSk7ci5kYXRlcGlja2VyTG9jYWxlKFwiaGVcIixcImhlXCIse2Nsb3NlVGV4dDpcIteh15LXldeoXCIscHJldlRleHQ6XCImI3gzQzvXlNen15XXk9edXCIsbmV4dFRleHQ6XCLXlNeR15AmI3gzRTtcIixjdXJyZW50VGV4dDpcIteU15nXldedXCIsbW9udGhOYW1lczpbXCLXmdeg15XXkNeoXCIsXCLXpNeR16jXldeQ16hcIixcItee16jXpVwiLFwi15DXpNeo15nXnFwiLFwi157XkNeZXCIsXCLXmdeV16DXmVwiLFwi15nXldec15lcIixcIteQ15XXkteV16HXmFwiLFwi16HXpNeY157XkdeoXCIsXCLXkNeV16fXmNeV15HXqFwiLFwi16DXldeR157XkdeoXCIsXCLXk9em157XkdeoXCJdLG1vbnRoTmFtZXNTaG9ydDpbXCLXmdeg15VcIixcItek15HXqFwiLFwi157XqNelXCIsXCLXkNek16hcIixcItee15DXmVwiLFwi15nXldeg15lcIixcIteZ15XXnNeZXCIsXCLXkNeV15JcIixcIteh16TXmFwiLFwi15DXldenXCIsXCLXoNeV15FcIixcIteT16bXnlwiXSxkYXlOYW1lczpbXCLXqNeQ16nXldefXCIsXCLXqdeg15lcIixcItep15zXmdep15lcIixcIteo15HXmdei15lcIixcIteX157Xmdep15lcIixcItep15nXqdeZXCIsXCLXqdeR16pcIl0sZGF5TmFtZXNTaG9ydDpbXCLXkCdcIixcIteRJ1wiLFwi15InXCIsXCLXkydcIixcIteUJ1wiLFwi15UnXCIsXCLXqdeR16pcIl0sZGF5TmFtZXNNaW46W1wi15AnXCIsXCLXkSdcIixcIteSJ1wiLFwi15MnXCIsXCLXlCdcIixcIteVJ1wiLFwi16nXkdeqXCJdLHdlZWtIZWFkZXI6XCJXa1wiLGRhdGVGb3JtYXQ6XCJkZC9tbS95eVwiLGZpcnN0RGF5OjAsaXNSVEw6ITAsc2hvd01vbnRoQWZ0ZXJZZWFyOiExLHllYXJTdWZmaXg6XCJcIn0pLHIubG9jYWxlKFwiaGVcIix7YnV0dG9uVGV4dDp7bW9udGg6XCLXl9eV15PXqVwiLHdlZWs6XCLXqdeR15XXolwiLGRheTpcIteZ15XXnVwiLGxpc3Q6XCLXodeT16gg15nXldedXCJ9LGFsbERheVRleHQ6XCLXm9ecINeU15nXldedXCIsZXZlbnRMaW1pdFRleHQ6XCLXkNeX16hcIixub0V2ZW50c01lc3NhZ2U6XCLXkNeZ158g15DXmdeo15XXoteZ150g15zXlNem15LXlFwiLHdlZWtOdW1iZXJUaXRsZTpcItep15HXldeiXCJ9KX0sMTQwOmZ1bmN0aW9uKGUsdCxuKXshZnVuY3Rpb24oZSx0KXt0KG4oMCkpfSgwLGZ1bmN0aW9uKGUpe3JldHVybiBlLmRlZmluZUxvY2FsZShcImhlXCIse21vbnRoczpcIteZ16DXldeQ16hf16TXkdeo15XXkNeoX9ee16jXpV/XkNek16jXmdecX9ee15DXmV/XmdeV16DXmV/XmdeV15zXmV/XkNeV15LXldeh15hf16HXpNeY157XkdeoX9eQ15XXp9eY15XXkdeoX9eg15XXkdee15HXqF/Xk9em157XkdeoXCIuc3BsaXQoXCJfXCIpLG1vbnRoc1Nob3J0Olwi15nXoNeV17Nf16TXkdeo17Nf157XqNelX9eQ16TXqNezX9ee15DXmV/XmdeV16DXmV/XmdeV15zXmV/XkNeV15LXs1/Xodek15jXs1/XkNeV16fXs1/XoNeV15HXs1/Xk9em157Xs1wiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5czpcIteo15DXqdeV159f16nXoNeZX9ep15zXmdep15lf16jXkdeZ16LXmV/Xl9ee15nXqdeZX9ep15nXqdeZX9ep15HXqlwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c1Nob3J0Olwi15DXs1/XkdezX9eS17Nf15PXs1/XlNezX9eV17Nf16nXs1wiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcIteQX9eRX9eSX9eTX9eUX9eVX9epXCIuc3BsaXQoXCJfXCIpLGxvbmdEYXRlRm9ybWF0OntMVDpcIkhIOm1tXCIsTFRTOlwiSEg6bW06c3NcIixMOlwiREQvTU0vWVlZWVwiLExMOlwiRCBb15FdTU1NTSBZWVlZXCIsTExMOlwiRCBb15FdTU1NTSBZWVlZIEhIOm1tXCIsTExMTDpcImRkZGQsIEQgW9eRXU1NTU0gWVlZWSBISDptbVwiLGw6XCJEL00vWVlZWVwiLGxsOlwiRCBNTU0gWVlZWVwiLGxsbDpcIkQgTU1NIFlZWVkgSEg6bW1cIixsbGxsOlwiZGRkLCBEIE1NTSBZWVlZIEhIOm1tXCJ9LGNhbGVuZGFyOntzYW1lRGF5OlwiW9eU15nXldedINeR1r5dTFRcIixuZXh0RGF5OlwiW9ee15fXqCDXkda+XUxUXCIsbmV4dFdlZWs6XCJkZGRkIFvXkdep16LXlF0gTFRcIixsYXN0RGF5OlwiW9eQ16rXnteV15wg15HWvl1MVFwiLGxhc3RXZWVrOlwiW9eR15nXldedXSBkZGRkIFvXlNeQ15fXqNeV158g15HXqdei15RdIExUXCIsc2FtZUVsc2U6XCJMXCJ9LHJlbGF0aXZlVGltZTp7ZnV0dXJlOlwi15HXoteV15MgJXNcIixwYXN0Olwi15zXpNeg15kgJXNcIixzOlwi157Xodek16gg16nXoNeZ15XXqlwiLHNzOlwiJWQg16nXoNeZ15XXqlwiLG06XCLXk9en15RcIixtbTpcIiVkINeT16fXldeqXCIsaDpcItep16LXlFwiLGhoOmZ1bmN0aW9uKGUpe3JldHVybiAyPT09ZT9cItep16LXqteZ15nXnVwiOmUrXCIg16nXoteV16pcIn0sZDpcIteZ15XXnVwiLGRkOmZ1bmN0aW9uKGUpe3JldHVybiAyPT09ZT9cIteZ15XXnteZ15nXnVwiOmUrXCIg15nXnteZ151cIn0sTTpcIteX15XXk9epXCIsTU06ZnVuY3Rpb24oZSl7cmV0dXJuIDI9PT1lP1wi15fXldeT16nXmdeZ151cIjplK1wiINeX15XXk9ep15nXnVwifSx5Olwi16nXoNeUXCIseXk6ZnVuY3Rpb24oZSl7cmV0dXJuIDI9PT1lP1wi16nXoNeq15nXmdedXCI6ZSUxMD09MCYmMTAhPT1lP2UrXCIg16nXoNeUXCI6ZStcIiDXqdeg15nXnVwifX0sbWVyaWRpZW1QYXJzZTov15DXl9eUXCLXpnzXnNek16DXlFwi16Z815DXl9eo15kg15TXpteU16jXmdeZ151815zXpNeg15kg15TXpteU16jXmdeZ151815zXpNeg15XXqiDXkdeV16fXqHzXkdeR15XXp9eofNeR16LXqNeRL2ksaXNQTTpmdW5jdGlvbihlKXtyZXR1cm4vXijXkNeX15RcItemfNeQ15fXqNeZINeU16bXlNeo15nXmdedfNeR16LXqNeRKSQvLnRlc3QoZSl9LG1lcmlkaWVtOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZTw1P1wi15zXpNeg15XXqiDXkdeV16fXqFwiOmU8MTA/XCLXkdeR15XXp9eoXCI6ZTwxMj9uPyfXnNek16DXlFwi16YnOlwi15zXpNeg15kg15TXpteU16jXmdeZ151cIjplPDE4P24/J9eQ15fXlFwi16YnOlwi15DXl9eo15kg15TXpteU16jXmdeZ151cIjpcIteR16LXqNeRXCJ9fSl9KX19KX0pOyIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIm1vbWVudFwiLFwiZnVsbGNhbGVuZGFyXCJdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP3QocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTp0KGUubW9tZW50LGUuRnVsbENhbGVuZGFyKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7aWYocltuXSlyZXR1cm4gcltuXS5leHBvcnRzO3ZhciBhPXJbbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW25dLmNhbGwoYS5leHBvcnRzLGEsYS5leHBvcnRzLHQpLGEubD0hMCxhLmV4cG9ydHN9dmFyIHI9e307cmV0dXJuIHQubT1lLHQuYz1yLHQuZD1mdW5jdGlvbihlLHIsbil7dC5vKGUscil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpufSl9LHQubj1mdW5jdGlvbihlKXt2YXIgcj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKHIsXCJhXCIscikscn0sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9XCJcIix0KHQucz0xNDUpfSh7MDpmdW5jdGlvbih0LHIpe3QuZXhwb3J0cz1lfSwxOmZ1bmN0aW9uKGUscil7ZS5leHBvcnRzPXR9LDE0NTpmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkscigxNDYpO3ZhciBuPXIoMSk7bi5kYXRlcGlja2VyTG9jYWxlKFwiaHVcIixcImh1XCIse2Nsb3NlVGV4dDpcImJlesOhclwiLHByZXZUZXh0Olwidmlzc3phXCIsbmV4dFRleHQ6XCJlbMWRcmVcIixjdXJyZW50VGV4dDpcIm1hXCIsbW9udGhOYW1lczpbXCJKYW51w6FyXCIsXCJGZWJydcOhclwiLFwiTcOhcmNpdXNcIixcIsOBcHJpbGlzXCIsXCJNw6FqdXNcIixcIkrDum5pdXNcIixcIkrDumxpdXNcIixcIkF1Z3VzenR1c1wiLFwiU3plcHRlbWJlclwiLFwiT2t0w7NiZXJcIixcIk5vdmVtYmVyXCIsXCJEZWNlbWJlclwiXSxtb250aE5hbWVzU2hvcnQ6W1wiSmFuXCIsXCJGZWJcIixcIk3DoXJcIixcIsOBcHJcIixcIk3DoWpcIixcIkrDum5cIixcIkrDumxcIixcIkF1Z1wiLFwiU3plcFwiLFwiT2t0XCIsXCJOb3ZcIixcIkRlY1wiXSxkYXlOYW1lczpbXCJWYXPDoXJuYXBcIixcIkjDqXRmxZFcIixcIktlZGRcIixcIlN6ZXJkYVwiLFwiQ3PDvHTDtnJ0w7ZrXCIsXCJQw6ludGVrXCIsXCJTem9tYmF0XCJdLGRheU5hbWVzU2hvcnQ6W1wiVmFzXCIsXCJIw6l0XCIsXCJLZWRcIixcIlN6ZVwiLFwiQ3PDvFwiLFwiUMOpblwiLFwiU3pvXCJdLGRheU5hbWVzTWluOltcIlZcIixcIkhcIixcIktcIixcIlN6ZVwiLFwiQ3NcIixcIlBcIixcIlN6b1wiXSx3ZWVrSGVhZGVyOlwiSMOpdFwiLGRhdGVGb3JtYXQ6XCJ5eS5tbS5kZC5cIixmaXJzdERheToxLGlzUlRMOiExLHNob3dNb250aEFmdGVyWWVhcjohMCx5ZWFyU3VmZml4OlwiXCJ9KSxuLmxvY2FsZShcImh1XCIse2J1dHRvblRleHQ6e21vbnRoOlwiSMOzbmFwXCIsd2VlazpcIkjDqXRcIixkYXk6XCJOYXBcIixsaXN0OlwiTmFwbMOzXCJ9LGFsbERheVRleHQ6XCJFZ8Opc3ogbmFwXCIsZXZlbnRMaW1pdFRleHQ6XCJ0b3bDoWJiaVwiLG5vRXZlbnRzTWVzc2FnZTpcIk5pbmNzIG1lZ2plbGVuw610aGV0xZEgZXNlbcOpbnlcIn0pfSwxNDY6ZnVuY3Rpb24oZSx0LHIpeyFmdW5jdGlvbihlLHQpe3QocigwKSl9KDAsZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlLHQscixuKXt2YXIgYT1lO3N3aXRjaChyKXtjYXNlXCJzXCI6cmV0dXJuIG58fHQ/XCJuw6low6FueSBtw6Fzb2RwZXJjXCI6XCJuw6low6FueSBtw6Fzb2RwZXJjZVwiO2Nhc2VcInNzXCI6cmV0dXJuIGErKG58fHQpP1wiIG3DoXNvZHBlcmNcIjpcIiBtw6Fzb2RwZXJjZVwiO2Nhc2VcIm1cIjpyZXR1cm5cImVneVwiKyhufHx0P1wiIHBlcmNcIjpcIiBwZXJjZVwiKTtjYXNlXCJtbVwiOnJldHVybiBhKyhufHx0P1wiIHBlcmNcIjpcIiBwZXJjZVwiKTtjYXNlXCJoXCI6cmV0dXJuXCJlZ3lcIisobnx8dD9cIiDDs3JhXCI6XCIgw7Nyw6FqYVwiKTtjYXNlXCJoaFwiOnJldHVybiBhKyhufHx0P1wiIMOzcmFcIjpcIiDDs3LDoWphXCIpO2Nhc2VcImRcIjpyZXR1cm5cImVneVwiKyhufHx0P1wiIG5hcFwiOlwiIG5hcGphXCIpO2Nhc2VcImRkXCI6cmV0dXJuIGErKG58fHQ/XCIgbmFwXCI6XCIgbmFwamFcIik7Y2FzZVwiTVwiOnJldHVyblwiZWd5XCIrKG58fHQ/XCIgaMOzbmFwXCI6XCIgaMOzbmFwamFcIik7Y2FzZVwiTU1cIjpyZXR1cm4gYSsobnx8dD9cIiBow7NuYXBcIjpcIiBow7NuYXBqYVwiKTtjYXNlXCJ5XCI6cmV0dXJuXCJlZ3lcIisobnx8dD9cIiDDqXZcIjpcIiDDqXZlXCIpO2Nhc2VcInl5XCI6cmV0dXJuIGErKG58fHQ/XCIgw6l2XCI6XCIgw6l2ZVwiKX1yZXR1cm5cIlwifWZ1bmN0aW9uIHIoZSl7cmV0dXJuKGU/XCJcIjpcIlttw7psdF0gXCIpK1wiW1wiK25bdGhpcy5kYXkoKV0rXCJdIExUWy1rb3JdXCJ9dmFyIG49XCJ2YXPDoXJuYXAgaMOpdGbFkW4ga2VkZGVuIHN6ZXJkw6FuIGNzw7x0w7ZydMO2a8O2biBww6ludGVrZW4gc3pvbWJhdG9uXCIuc3BsaXQoXCIgXCIpO3JldHVybiBlLmRlZmluZUxvY2FsZShcImh1XCIse21vbnRoczpcImphbnXDoXJfZmVicnXDoXJfbcOhcmNpdXNfw6FwcmlsaXNfbcOhanVzX2rDum5pdXNfasO6bGl1c19hdWd1c3p0dXNfc3plcHRlbWJlcl9va3TDs2Jlcl9ub3ZlbWJlcl9kZWNlbWJlclwiLnNwbGl0KFwiX1wiKSxtb250aHNTaG9ydDpcImphbl9mZWJfbcOhcmNfw6Fwcl9tw6FqX2rDum5fasO6bF9hdWdfc3plcHRfb2t0X25vdl9kZWNcIi5zcGxpdChcIl9cIiksd2Vla2RheXM6XCJ2YXPDoXJuYXBfaMOpdGbFkV9rZWRkX3N6ZXJkYV9jc8O8dMO2cnTDtmtfcMOpbnRla19zem9tYmF0XCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzU2hvcnQ6XCJ2YXNfaMOpdF9rZWRkX3N6ZV9jc8O8dF9ww6luX3N6b1wiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcInZfaF9rX3N6ZV9jc19wX3N6b1wiLnNwbGl0KFwiX1wiKSxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJIOm1tXCIsTFRTOlwiSDptbTpzc1wiLEw6XCJZWVlZLk1NLkRELlwiLExMOlwiWVlZWS4gTU1NTSBELlwiLExMTDpcIllZWVkuIE1NTU0gRC4gSDptbVwiLExMTEw6XCJZWVlZLiBNTU1NIEQuLCBkZGRkIEg6bW1cIn0sbWVyaWRpZW1QYXJzZTovZGV8ZHUvaSxpc1BNOmZ1bmN0aW9uKGUpe3JldHVyblwidVwiPT09ZS5jaGFyQXQoMSkudG9Mb3dlckNhc2UoKX0sbWVyaWRpZW06ZnVuY3Rpb24oZSx0LHIpe3JldHVybiBlPDEyPyEwPT09cj9cImRlXCI6XCJERVwiOiEwPT09cj9cImR1XCI6XCJEVVwifSxjYWxlbmRhcjp7c2FtZURheTpcIlttYV0gTFRbLWtvcl1cIixuZXh0RGF5OlwiW2hvbG5hcF0gTFRbLWtvcl1cIixuZXh0V2VlazpmdW5jdGlvbigpe3JldHVybiByLmNhbGwodGhpcywhMCl9LGxhc3REYXk6XCJbdGVnbmFwXSBMVFsta29yXVwiLGxhc3RXZWVrOmZ1bmN0aW9uKCl7cmV0dXJuIHIuY2FsbCh0aGlzLCExKX0sc2FtZUVsc2U6XCJMXCJ9LHJlbGF0aXZlVGltZTp7ZnV0dXJlOlwiJXMgbcO6bHZhXCIscGFzdDpcIiVzXCIsczp0LHNzOnQsbTp0LG1tOnQsaDp0LGhoOnQsZDp0LGRkOnQsTTp0LE1NOnQseTp0LHl5OnR9LGRheU9mTW9udGhPcmRpbmFsUGFyc2U6L1xcZHsxLDJ9XFwuLyxvcmRpbmFsOlwiJWQuXCIsd2Vlazp7ZG93OjEsZG95OjR9fSl9KX19KX0pOyIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIm1vbWVudFwiLFwiZnVsbGNhbGVuZGFyXCJdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP3QocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTp0KGUubW9tZW50LGUuRnVsbENhbGVuZGFyKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7aWYob1tuXSlyZXR1cm4gb1tuXS5leHBvcnRzO3ZhciByPW9bbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW25dLmNhbGwoci5leHBvcnRzLHIsci5leHBvcnRzLHQpLHIubD0hMCxyLmV4cG9ydHN9dmFyIG89e307cmV0dXJuIHQubT1lLHQuYz1vLHQuZD1mdW5jdGlvbihlLG8sbil7dC5vKGUsbyl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG8se2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpufSl9LHQubj1mdW5jdGlvbihlKXt2YXIgbz1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKG8sXCJhXCIsbyksb30sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9XCJcIix0KHQucz0xNTEpfSh7MDpmdW5jdGlvbih0LG8pe3QuZXhwb3J0cz1lfSwxOmZ1bmN0aW9uKGUsbyl7ZS5leHBvcnRzPXR9LDE1MTpmdW5jdGlvbihlLHQsbyl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbygxNTIpO3ZhciBuPW8oMSk7bi5kYXRlcGlja2VyTG9jYWxlKFwiaXRcIixcIml0XCIse2Nsb3NlVGV4dDpcIkNoaXVkaVwiLHByZXZUZXh0OlwiJiN4M0M7UHJlY1wiLG5leHRUZXh0OlwiU3VjYyYjeDNFO1wiLGN1cnJlbnRUZXh0OlwiT2dnaVwiLG1vbnRoTmFtZXM6W1wiR2VubmFpb1wiLFwiRmViYnJhaW9cIixcIk1hcnpvXCIsXCJBcHJpbGVcIixcIk1hZ2dpb1wiLFwiR2l1Z25vXCIsXCJMdWdsaW9cIixcIkFnb3N0b1wiLFwiU2V0dGVtYnJlXCIsXCJPdHRvYnJlXCIsXCJOb3ZlbWJyZVwiLFwiRGljZW1icmVcIl0sbW9udGhOYW1lc1Nob3J0OltcIkdlblwiLFwiRmViXCIsXCJNYXJcIixcIkFwclwiLFwiTWFnXCIsXCJHaXVcIixcIkx1Z1wiLFwiQWdvXCIsXCJTZXRcIixcIk90dFwiLFwiTm92XCIsXCJEaWNcIl0sZGF5TmFtZXM6W1wiRG9tZW5pY2FcIixcIkx1bmVkw6xcIixcIk1hcnRlZMOsXCIsXCJNZXJjb2xlZMOsXCIsXCJHaW92ZWTDrFwiLFwiVmVuZXJkw6xcIixcIlNhYmF0b1wiXSxkYXlOYW1lc1Nob3J0OltcIkRvbVwiLFwiTHVuXCIsXCJNYXJcIixcIk1lclwiLFwiR2lvXCIsXCJWZW5cIixcIlNhYlwiXSxkYXlOYW1lc01pbjpbXCJEb1wiLFwiTHVcIixcIk1hXCIsXCJNZVwiLFwiR2lcIixcIlZlXCIsXCJTYVwiXSx3ZWVrSGVhZGVyOlwiU21cIixkYXRlRm9ybWF0OlwiZGQvbW0veXlcIixmaXJzdERheToxLGlzUlRMOiExLHNob3dNb250aEFmdGVyWWVhcjohMSx5ZWFyU3VmZml4OlwiXCJ9KSxuLmxvY2FsZShcIml0XCIse2J1dHRvblRleHQ6e21vbnRoOlwiTWVzZVwiLHdlZWs6XCJTZXR0aW1hbmFcIixkYXk6XCJHaW9ybm9cIixsaXN0OlwiQWdlbmRhXCJ9LGFsbERheUh0bWw6XCJUdXR0byBpbDxici8+Z2lvcm5vXCIsZXZlbnRMaW1pdFRleHQ6ZnVuY3Rpb24oZSl7cmV0dXJuXCIrYWx0cmkgXCIrZX0sbm9FdmVudHNNZXNzYWdlOlwiTm9uIGNpIHNvbm8gZXZlbnRpIGRhIHZpc3VhbGl6emFyZVwifSl9LDE1MjpmdW5jdGlvbihlLHQsbyl7IWZ1bmN0aW9uKGUsdCl7dChvKDApKX0oMCxmdW5jdGlvbihlKXtyZXR1cm4gZS5kZWZpbmVMb2NhbGUoXCJpdFwiLHttb250aHM6XCJnZW5uYWlvX2ZlYmJyYWlvX21hcnpvX2FwcmlsZV9tYWdnaW9fZ2l1Z25vX2x1Z2xpb19hZ29zdG9fc2V0dGVtYnJlX290dG9icmVfbm92ZW1icmVfZGljZW1icmVcIi5zcGxpdChcIl9cIiksbW9udGhzU2hvcnQ6XCJnZW5fZmViX21hcl9hcHJfbWFnX2dpdV9sdWdfYWdvX3NldF9vdHRfbm92X2RpY1wiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5czpcImRvbWVuaWNhX2x1bmVkw6xfbWFydGVkw6xfbWVyY29sZWTDrF9naW92ZWTDrF92ZW5lcmTDrF9zYWJhdG9cIi5zcGxpdChcIl9cIiksd2Vla2RheXNTaG9ydDpcImRvbV9sdW5fbWFyX21lcl9naW9fdmVuX3NhYlwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcImRvX2x1X21hX21lX2dpX3ZlX3NhXCIuc3BsaXQoXCJfXCIpLGxvbmdEYXRlRm9ybWF0OntMVDpcIkhIOm1tXCIsTFRTOlwiSEg6bW06c3NcIixMOlwiREQvTU0vWVlZWVwiLExMOlwiRCBNTU1NIFlZWVlcIixMTEw6XCJEIE1NTU0gWVlZWSBISDptbVwiLExMTEw6XCJkZGRkIEQgTU1NTSBZWVlZIEhIOm1tXCJ9LGNhbGVuZGFyOntzYW1lRGF5OmZ1bmN0aW9uKCl7cmV0dXJuXCJbT2dnaSBhXCIrKHRoaXMuaG91cnMoKT4xP1wibGxlIFwiOjA9PT10aGlzLmhvdXJzKCk/XCIgXCI6XCJsbCdcIikrXCJdTFRcIn0sbmV4dERheTpmdW5jdGlvbigpe3JldHVyblwiW0RvbWFuaSBhXCIrKHRoaXMuaG91cnMoKT4xP1wibGxlIFwiOjA9PT10aGlzLmhvdXJzKCk/XCIgXCI6XCJsbCdcIikrXCJdTFRcIn0sbmV4dFdlZWs6ZnVuY3Rpb24oKXtyZXR1cm5cImRkZGQgW2FcIisodGhpcy5ob3VycygpPjE/XCJsbGUgXCI6MD09PXRoaXMuaG91cnMoKT9cIiBcIjpcImxsJ1wiKStcIl1MVFwifSxsYXN0RGF5OmZ1bmN0aW9uKCl7cmV0dXJuXCJbSWVyaSBhXCIrKHRoaXMuaG91cnMoKT4xP1wibGxlIFwiOjA9PT10aGlzLmhvdXJzKCk/XCIgXCI6XCJsbCdcIikrXCJdTFRcIn0sbGFzdFdlZWs6ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5kYXkoKSl7Y2FzZSAwOnJldHVyblwiW0xhIHNjb3JzYV0gZGRkZCBbYVwiKyh0aGlzLmhvdXJzKCk+MT9cImxsZSBcIjowPT09dGhpcy5ob3VycygpP1wiIFwiOlwibGwnXCIpK1wiXUxUXCI7ZGVmYXVsdDpyZXR1cm5cIltMbyBzY29yc29dIGRkZGQgW2FcIisodGhpcy5ob3VycygpPjE/XCJsbGUgXCI6MD09PXRoaXMuaG91cnMoKT9cIiBcIjpcImxsJ1wiKStcIl1MVFwifX0sc2FtZUVsc2U6XCJMXCJ9LHJlbGF0aXZlVGltZTp7ZnV0dXJlOmZ1bmN0aW9uKGUpe3JldHVybigvXlswLTldLiskLy50ZXN0KGUpP1widHJhXCI6XCJpblwiKStcIiBcIitlfSxwYXN0OlwiJXMgZmFcIixzOlwiYWxjdW5pIHNlY29uZGlcIixzczpcIiVkIHNlY29uZGlcIixtOlwidW4gbWludXRvXCIsbW06XCIlZCBtaW51dGlcIixoOlwidW4nb3JhXCIsaGg6XCIlZCBvcmVcIixkOlwidW4gZ2lvcm5vXCIsZGQ6XCIlZCBnaW9ybmlcIixNOlwidW4gbWVzZVwiLE1NOlwiJWQgbWVzaVwiLHk6XCJ1biBhbm5vXCIseXk6XCIlZCBhbm5pXCJ9LGRheU9mTW9udGhPcmRpbmFsUGFyc2U6L1xcZHsxLDJ9wrovLG9yZGluYWw6XCIlZMK6XCIsd2Vlazp7ZG93OjEsZG95OjR9fSl9KX19KX0pOyIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIm1vbWVudFwiLFwiZnVsbGNhbGVuZGFyXCJdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP3QocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTp0KGUubW9tZW50LGUuRnVsbENhbGVuZGFyKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQocil7aWYobltyXSlyZXR1cm4gbltyXS5leHBvcnRzO3ZhciBhPW5bcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW3JdLmNhbGwoYS5leHBvcnRzLGEsYS5leHBvcnRzLHQpLGEubD0hMCxhLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIHQubT1lLHQuYz1uLHQuZD1mdW5jdGlvbihlLG4scil7dC5vKGUsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpyfSl9LHQubj1mdW5jdGlvbihlKXt2YXIgbj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKG4sXCJhXCIsbiksbn0sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9XCJcIix0KHQucz0xNTMpfSh7MDpmdW5jdGlvbih0LG4pe3QuZXhwb3J0cz1lfSwxOmZ1bmN0aW9uKGUsbil7ZS5leHBvcnRzPXR9LDE1MzpmdW5jdGlvbihlLHQsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbigxNTQpO3ZhciByPW4oMSk7ci5kYXRlcGlja2VyTG9jYWxlKFwiamFcIixcImphXCIse2Nsb3NlVGV4dDpcIumWieOBmOOCi1wiLHByZXZUZXh0OlwiJiN4M0M75YmNXCIsbmV4dFRleHQ6XCLmrKEmI3gzRTtcIixjdXJyZW50VGV4dDpcIuS7iuaXpVwiLG1vbnRoTmFtZXM6W1wiMeaciFwiLFwiMuaciFwiLFwiM+aciFwiLFwiNOaciFwiLFwiNeaciFwiLFwiNuaciFwiLFwiN+aciFwiLFwiOOaciFwiLFwiOeaciFwiLFwiMTDmnIhcIixcIjEx5pyIXCIsXCIxMuaciFwiXSxtb250aE5hbWVzU2hvcnQ6W1wiMeaciFwiLFwiMuaciFwiLFwiM+aciFwiLFwiNOaciFwiLFwiNeaciFwiLFwiNuaciFwiLFwiN+aciFwiLFwiOOaciFwiLFwiOeaciFwiLFwiMTDmnIhcIixcIjEx5pyIXCIsXCIxMuaciFwiXSxkYXlOYW1lczpbXCLml6Xmm5zml6VcIixcIuaciOabnOaXpVwiLFwi54Gr5puc5pelXCIsXCLmsLTmm5zml6VcIixcIuacqOabnOaXpVwiLFwi6YeR5puc5pelXCIsXCLlnJ/mm5zml6VcIl0sZGF5TmFtZXNTaG9ydDpbXCLml6VcIixcIuaciFwiLFwi54GrXCIsXCLmsLRcIixcIuacqFwiLFwi6YeRXCIsXCLlnJ9cIl0sZGF5TmFtZXNNaW46W1wi5pelXCIsXCLmnIhcIixcIueBq1wiLFwi5rC0XCIsXCLmnKhcIixcIumHkVwiLFwi5ZyfXCJdLHdlZWtIZWFkZXI6XCLpgLFcIixkYXRlRm9ybWF0OlwieXkvbW0vZGRcIixmaXJzdERheTowLGlzUlRMOiExLHNob3dNb250aEFmdGVyWWVhcjohMCx5ZWFyU3VmZml4Olwi5bm0XCJ9KSxyLmxvY2FsZShcImphXCIse2J1dHRvblRleHQ6e21vbnRoOlwi5pyIXCIsd2VlazpcIumAsVwiLGRheTpcIuaXpVwiLGxpc3Q6XCLkuojlrprjg6rjgrnjg4hcIn0sYWxsRGF5VGV4dDpcIue1guaXpVwiLGV2ZW50TGltaXRUZXh0OmZ1bmN0aW9uKGUpe3JldHVyblwi5LuWIFwiK2UrXCIg5Lu2XCJ9LG5vRXZlbnRzTWVzc2FnZTpcIuihqOekuuOBmeOCi+S6iOWumuOBr+OBguOCiuOBvuOBm+OCk1wifSl9LDE1NDpmdW5jdGlvbihlLHQsbil7IWZ1bmN0aW9uKGUsdCl7dChuKDApKX0oMCxmdW5jdGlvbihlKXtyZXR1cm4gZS5kZWZpbmVMb2NhbGUoXCJqYVwiLHtlcmFzOlt7c2luY2U6XCIyMDE5LTA1LTAxXCIsb2Zmc2V0OjEsbmFtZTpcIuS7pOWSjFwiLG5hcnJvdzpcIuOLv1wiLGFiYnI6XCJSXCJ9LHtzaW5jZTpcIjE5ODktMDEtMDhcIix1bnRpbDpcIjIwMTktMDQtMzBcIixvZmZzZXQ6MSxuYW1lOlwi5bmz5oiQXCIsbmFycm93Olwi4427XCIsYWJicjpcIkhcIn0se3NpbmNlOlwiMTkyNi0xMi0yNVwiLHVudGlsOlwiMTk4OS0wMS0wN1wiLG9mZnNldDoxLG5hbWU6XCLmmK3lkoxcIixuYXJyb3c6XCLjjbxcIixhYmJyOlwiU1wifSx7c2luY2U6XCIxOTEyLTA3LTMwXCIsdW50aWw6XCIxOTI2LTEyLTI0XCIsb2Zmc2V0OjEsbmFtZTpcIuWkp+ato1wiLG5hcnJvdzpcIuONvVwiLGFiYnI6XCJUXCJ9LHtzaW5jZTpcIjE4NzMtMDEtMDFcIix1bnRpbDpcIjE5MTItMDctMjlcIixvZmZzZXQ6NixuYW1lOlwi5piO5rK7XCIsbmFycm93Olwi442+XCIsYWJicjpcIk1cIn0se3NpbmNlOlwiMDAwMS0wMS0wMVwiLHVudGlsOlwiMTg3My0xMi0zMVwiLG9mZnNldDoxLG5hbWU6XCLopb/mmqZcIixuYXJyb3c6XCJBRFwiLGFiYnI6XCJBRFwifSx7c2luY2U6XCIwMDAwLTEyLTMxXCIsdW50aWw6LTEvMCxvZmZzZXQ6MSxuYW1lOlwi57SA5YWD5YmNXCIsbmFycm93OlwiQkNcIixhYmJyOlwiQkNcIn1dLGVyYVllYXJPcmRpbmFsUmVnZXg6LyjlhYN8XFxkKynlubQvLGVyYVllYXJPcmRpbmFsUGFyc2U6ZnVuY3Rpb24oZSx0KXtyZXR1cm5cIuWFg1wiPT09dFsxXT8xOnBhcnNlSW50KHRbMV18fGUsMTApfSxtb250aHM6XCIx5pyIXzLmnIhfM+aciF805pyIXzXmnIhfNuaciF835pyIXzjmnIhfOeaciF8xMOaciF8xMeaciF8xMuaciFwiLnNwbGl0KFwiX1wiKSxtb250aHNTaG9ydDpcIjHmnIhfMuaciF8z5pyIXzTmnIhfNeaciF825pyIXzfmnIhfOOaciF855pyIXzEw5pyIXzEx5pyIXzEy5pyIXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzOlwi5pel5puc5pelX+aciOabnOaXpV/ngavmm5zml6Vf5rC05puc5pelX+acqOabnOaXpV/ph5Hmm5zml6Vf5Zyf5puc5pelXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzU2hvcnQ6XCLml6Vf5pyIX+eBq1/msLRf5pyoX+mHkV/lnJ9cIi5zcGxpdChcIl9cIiksd2Vla2RheXNNaW46XCLml6Vf5pyIX+eBq1/msLRf5pyoX+mHkV/lnJ9cIi5zcGxpdChcIl9cIiksbG9uZ0RhdGVGb3JtYXQ6e0xUOlwiSEg6bW1cIixMVFM6XCJISDptbTpzc1wiLEw6XCJZWVlZL01NL0REXCIsTEw6XCJZWVlZ5bm0TeaciETml6VcIixMTEw6XCJZWVlZ5bm0TeaciETml6UgSEg6bW1cIixMTExMOlwiWVlZWeW5tE3mnIhE5pelIGRkZGQgSEg6bW1cIixsOlwiWVlZWS9NTS9ERFwiLGxsOlwiWVlZWeW5tE3mnIhE5pelXCIsbGxsOlwiWVlZWeW5tE3mnIhE5pelIEhIOm1tXCIsbGxsbDpcIllZWVnlubRN5pyIROaXpShkZGQpIEhIOm1tXCJ9LG1lcmlkaWVtUGFyc2U6L+WNiOWJjXzljYjlvowvaSxpc1BNOmZ1bmN0aW9uKGUpe3JldHVyblwi5Y2I5b6MXCI9PT1lfSxtZXJpZGllbTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIGU8MTI/XCLljYjliY1cIjpcIuWNiOW+jFwifSxjYWxlbmRhcjp7c2FtZURheTpcIlvku4rml6VdIExUXCIsbmV4dERheTpcIlvmmI7ml6VdIExUXCIsbmV4dFdlZWs6ZnVuY3Rpb24oZSl7cmV0dXJuIGUud2VlaygpIT09dGhpcy53ZWVrKCk/XCJb5p2l6YCxXWRkZGQgTFRcIjpcImRkZGQgTFRcIn0sbGFzdERheTpcIlvmmKjml6VdIExUXCIsbGFzdFdlZWs6ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMud2VlaygpIT09ZS53ZWVrKCk/XCJb5YWI6YCxXWRkZGQgTFRcIjpcImRkZGQgTFRcIn0sc2FtZUVsc2U6XCJMXCJ9LGRheU9mTW9udGhPcmRpbmFsUGFyc2U6L1xcZHsxLDJ95pelLyxvcmRpbmFsOmZ1bmN0aW9uKGUsdCl7c3dpdGNoKHQpe2Nhc2VcInlcIjpyZXR1cm4gMT09PWU/XCLlhYPlubRcIjplK1wi5bm0XCI7Y2FzZVwiZFwiOmNhc2VcIkRcIjpjYXNlXCJERERcIjpyZXR1cm4gZStcIuaXpVwiO2RlZmF1bHQ6cmV0dXJuIGV9fSxyZWxhdGl2ZVRpbWU6e2Z1dHVyZTpcIiVz5b6MXCIscGFzdDpcIiVz5YmNXCIsczpcIuaVsOenklwiLHNzOlwiJWTnp5JcIixtOlwiMeWIhlwiLG1tOlwiJWTliIZcIixoOlwiMeaZgumWk1wiLGhoOlwiJWTmmYLplpNcIixkOlwiMeaXpVwiLGRkOlwiJWTml6VcIixNOlwiMeODtuaciFwiLE1NOlwiJWTjg7bmnIhcIix5OlwiMeW5tFwiLHl5OlwiJWTlubRcIn19KX0pfX0pfSk7IiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dChyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wibW9tZW50XCIsXCJmdWxsY2FsZW5kYXJcIl0sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/dChyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOnQoZS5tb21lbnQsZS5GdWxsQ2FsZW5kYXIpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChyKXtpZihuW3JdKXJldHVybiBuW3JdLmV4cG9ydHM7dmFyIG89bltyXT17aTpyLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbcl0uY2FsbChvLmV4cG9ydHMsbyxvLmV4cG9ydHMsdCksby5sPSEwLG8uZXhwb3J0c312YXIgbj17fTtyZXR1cm4gdC5tPWUsdC5jPW4sdC5kPWZ1bmN0aW9uKGUsbixyKXt0Lm8oZSxuKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0OnJ9KX0sdC5uPWZ1bmN0aW9uKGUpe3ZhciBuPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiB0LmQobixcImFcIixuKSxufSx0Lm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHQucD1cIlwiLHQodC5zPTE1OSl9KHswOmZ1bmN0aW9uKHQsbil7dC5leHBvcnRzPWV9LDE6ZnVuY3Rpb24oZSxuKXtlLmV4cG9ydHM9dH0sMTU5OmZ1bmN0aW9uKGUsdCxuKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxuKDE2MCk7dmFyIHI9bigxKTtyLmRhdGVwaWNrZXJMb2NhbGUoXCJrb1wiLFwia29cIix7Y2xvc2VUZXh0Olwi64ur6riwXCIscHJldlRleHQ6XCLsnbTsoITri6xcIixuZXh0VGV4dDpcIuuLpOydjOuLrFwiLGN1cnJlbnRUZXh0Olwi7Jik64qYXCIsbW9udGhOYW1lczpbXCIx7JuUXCIsXCIy7JuUXCIsXCIz7JuUXCIsXCI07JuUXCIsXCI17JuUXCIsXCI27JuUXCIsXCI37JuUXCIsXCI47JuUXCIsXCI57JuUXCIsXCIxMOyblFwiLFwiMTHsm5RcIixcIjEy7JuUXCJdLG1vbnRoTmFtZXNTaG9ydDpbXCIx7JuUXCIsXCIy7JuUXCIsXCIz7JuUXCIsXCI07JuUXCIsXCI17JuUXCIsXCI27JuUXCIsXCI37JuUXCIsXCI47JuUXCIsXCI57JuUXCIsXCIxMOyblFwiLFwiMTHsm5RcIixcIjEy7JuUXCJdLGRheU5hbWVzOltcIuydvOyalOydvFwiLFwi7JuU7JqU7J28XCIsXCLtmZTsmpTsnbxcIixcIuyImOyalOydvFwiLFwi66qp7JqU7J28XCIsXCLquIjsmpTsnbxcIixcIu2GoOyalOydvFwiXSxkYXlOYW1lc1Nob3J0OltcIuydvFwiLFwi7JuUXCIsXCLtmZRcIixcIuyImFwiLFwi66qpXCIsXCLquIhcIixcIu2GoFwiXSxkYXlOYW1lc01pbjpbXCLsnbxcIixcIuyblFwiLFwi7ZmUXCIsXCLsiJhcIixcIuuqqVwiLFwi6riIXCIsXCLthqBcIl0sd2Vla0hlYWRlcjpcIuyjvFwiLGRhdGVGb3JtYXQ6XCJ5eS4gbS4gZC5cIixmaXJzdERheTowLGlzUlRMOiExLHNob3dNb250aEFmdGVyWWVhcjohMCx5ZWFyU3VmZml4Olwi64WEXCJ9KSxyLmxvY2FsZShcImtvXCIse2J1dHRvblRleHQ6e21vbnRoOlwi7JuUXCIsd2VlazpcIuyjvFwiLGRheTpcIuydvFwiLGxpc3Q6XCLsnbzsoJXrqqnroZ1cIn0sYWxsRGF5VGV4dDpcIuyiheydvFwiLGV2ZW50TGltaXRUZXh0Olwi6rCcXCIsbm9FdmVudHNNZXNzYWdlOlwi7J287KCV7J20IOyXhuyKteuLiOuLpFwifSl9LDE2MDpmdW5jdGlvbihlLHQsbil7IWZ1bmN0aW9uKGUsdCl7dChuKDApKX0oMCxmdW5jdGlvbihlKXtyZXR1cm4gZS5kZWZpbmVMb2NhbGUoXCJrb1wiLHttb250aHM6XCIx7JuUXzLsm5RfM+yblF807JuUXzXsm5RfNuyblF837JuUXzjsm5RfOeyblF8xMOyblF8xMeyblF8xMuyblFwiLnNwbGl0KFwiX1wiKSxtb250aHNTaG9ydDpcIjHsm5RfMuyblF8z7JuUXzTsm5RfNeyblF827JuUXzfsm5RfOOyblF857JuUXzEw7JuUXzEx7JuUXzEy7JuUXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzOlwi7J287JqU7J28X+yblOyalOydvF/tmZTsmpTsnbxf7IiY7JqU7J28X+uqqeyalOydvF/quIjsmpTsnbxf7Yag7JqU7J28XCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzU2hvcnQ6XCLsnbxf7JuUX+2ZlF/siJhf66qpX+q4iF/thqBcIi5zcGxpdChcIl9cIiksd2Vla2RheXNNaW46XCLsnbxf7JuUX+2ZlF/siJhf66qpX+q4iF/thqBcIi5zcGxpdChcIl9cIiksbG9uZ0RhdGVGb3JtYXQ6e0xUOlwiQSBoOm1tXCIsTFRTOlwiQSBoOm1tOnNzXCIsTDpcIllZWVkuTU0uREQuXCIsTEw6XCJZWVlZ64WEIE1NTU0gROydvFwiLExMTDpcIllZWVnrhYQgTU1NTSBE7J28IEEgaDptbVwiLExMTEw6XCJZWVlZ64WEIE1NTU0gROydvCBkZGRkIEEgaDptbVwiLGw6XCJZWVlZLk1NLkRELlwiLGxsOlwiWVlZWeuFhCBNTU1NIETsnbxcIixsbGw6XCJZWVlZ64WEIE1NTU0gROydvCBBIGg6bW1cIixsbGxsOlwiWVlZWeuFhCBNTU1NIETsnbwgZGRkZCBBIGg6bW1cIn0sY2FsZW5kYXI6e3NhbWVEYXk6XCLsmKTripggTFRcIixuZXh0RGF5Olwi64K07J28IExUXCIsbmV4dFdlZWs6XCJkZGRkIExUXCIsbGFzdERheTpcIuyWtOygnCBMVFwiLGxhc3RXZWVrOlwi7KeA64Kc7KO8IGRkZGQgTFRcIixzYW1lRWxzZTpcIkxcIn0scmVsYXRpdmVUaW1lOntmdXR1cmU6XCIlcyDtm4RcIixwYXN0OlwiJXMg7KCEXCIsczpcIuuqhyDstIhcIixzczpcIiVk7LSIXCIsbTpcIjHrtoRcIixtbTpcIiVk67aEXCIsaDpcIu2VnCDsi5zqsIRcIixoaDpcIiVk7Iuc6rCEXCIsZDpcIu2VmOujqFwiLGRkOlwiJWTsnbxcIixNOlwi7ZWcIOuLrFwiLE1NOlwiJWTri6xcIix5Olwi7J28IOuFhFwiLHl5OlwiJWTrhYRcIn0sZGF5T2ZNb250aE9yZGluYWxQYXJzZTovXFxkezEsMn0o7J28fOyblHzso7wpLyxvcmRpbmFsOmZ1bmN0aW9uKGUsdCl7c3dpdGNoKHQpe2Nhc2VcImRcIjpjYXNlXCJEXCI6Y2FzZVwiREREXCI6cmV0dXJuIGUrXCLsnbxcIjtjYXNlXCJNXCI6cmV0dXJuIGUrXCLsm5RcIjtjYXNlXCJ3XCI6Y2FzZVwiV1wiOnJldHVybiBlK1wi7KO8XCI7ZGVmYXVsdDpyZXR1cm4gZX19LG1lcmlkaWVtUGFyc2U6L+yYpOyghHzsmKTtm4QvLGlzUE06ZnVuY3Rpb24oZSl7cmV0dXJuXCLsmKTtm4RcIj09PWV9LG1lcmlkaWVtOmZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZTwxMj9cIuyYpOyghFwiOlwi7Jik7ZuEXCJ9fSl9KX19KX0pOyIsIiFmdW5jdGlvbihlLG4pe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPW4ocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIm1vbWVudFwiLFwiZnVsbGNhbGVuZGFyXCJdLG4pOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP24ocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpuKGUubW9tZW50LGUuRnVsbENhbGVuZGFyKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUsbil7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIG4odCl7aWYoYVt0XSlyZXR1cm4gYVt0XS5leHBvcnRzO3ZhciByPWFbdF09e2k6dCxsOiExLGV4cG9ydHM6e319O3JldHVybiBlW3RdLmNhbGwoci5leHBvcnRzLHIsci5leHBvcnRzLG4pLHIubD0hMCxyLmV4cG9ydHN9dmFyIGE9e307cmV0dXJuIG4ubT1lLG4uYz1hLG4uZD1mdW5jdGlvbihlLGEsdCl7bi5vKGUsYSl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLGEse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDp0fSl9LG4ubj1mdW5jdGlvbihlKXt2YXIgYT1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gbi5kKGEsXCJhXCIsYSksYX0sbi5vPWZ1bmN0aW9uKGUsbil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLG4pfSxuLnA9XCJcIixuKG4ucz0xNzcpfSh7MDpmdW5jdGlvbihuLGEpe24uZXhwb3J0cz1lfSwxOmZ1bmN0aW9uKGUsYSl7ZS5leHBvcnRzPW59LDE3NzpmdW5jdGlvbihlLG4sYSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksYSgxNzgpO3ZhciB0PWEoMSk7dC5kYXRlcGlja2VyTG9jYWxlKFwibmxcIixcIm5sXCIse2Nsb3NlVGV4dDpcIlNsdWl0ZW5cIixwcmV2VGV4dDpcIuKGkFwiLG5leHRUZXh0Olwi4oaSXCIsY3VycmVudFRleHQ6XCJWYW5kYWFnXCIsbW9udGhOYW1lczpbXCJqYW51YXJpXCIsXCJmZWJydWFyaVwiLFwibWFhcnRcIixcImFwcmlsXCIsXCJtZWlcIixcImp1bmlcIixcImp1bGlcIixcImF1Z3VzdHVzXCIsXCJzZXB0ZW1iZXJcIixcIm9rdG9iZXJcIixcIm5vdmVtYmVyXCIsXCJkZWNlbWJlclwiXSxtb250aE5hbWVzU2hvcnQ6W1wiamFuXCIsXCJmZWJcIixcIm1ydFwiLFwiYXByXCIsXCJtZWlcIixcImp1blwiLFwianVsXCIsXCJhdWdcIixcInNlcFwiLFwib2t0XCIsXCJub3ZcIixcImRlY1wiXSxkYXlOYW1lczpbXCJ6b25kYWdcIixcIm1hYW5kYWdcIixcImRpbnNkYWdcIixcIndvZW5zZGFnXCIsXCJkb25kZXJkYWdcIixcInZyaWpkYWdcIixcInphdGVyZGFnXCJdLGRheU5hbWVzU2hvcnQ6W1wiem9uXCIsXCJtYWFcIixcImRpblwiLFwid29lXCIsXCJkb25cIixcInZyaVwiLFwiemF0XCJdLGRheU5hbWVzTWluOltcInpvXCIsXCJtYVwiLFwiZGlcIixcIndvXCIsXCJkb1wiLFwidnJcIixcInphXCJdLHdlZWtIZWFkZXI6XCJXa1wiLGRhdGVGb3JtYXQ6XCJkZC1tbS15eVwiLGZpcnN0RGF5OjEsaXNSVEw6ITEsc2hvd01vbnRoQWZ0ZXJZZWFyOiExLHllYXJTdWZmaXg6XCJcIn0pLHQubG9jYWxlKFwibmxcIix7YnV0dG9uVGV4dDp7eWVhcjpcIkphYXJcIixtb250aDpcIk1hYW5kXCIsd2VlazpcIldlZWtcIixkYXk6XCJEYWdcIixsaXN0OlwiQWdlbmRhXCJ9LGFsbERheVRleHQ6XCJIZWxlIGRhZ1wiLGV2ZW50TGltaXRUZXh0OlwiZXh0cmFcIixub0V2ZW50c01lc3NhZ2U6XCJHZWVuIGV2ZW5lbWVudGVuIG9tIHRlIGxhdGVuIHppZW5cIn0pfSwxNzg6ZnVuY3Rpb24oZSxuLGEpeyFmdW5jdGlvbihlLG4pe24oYSgwKSl9KDAsZnVuY3Rpb24oZSl7dmFyIG49XCJqYW4uX2ZlYi5fbXJ0Ll9hcHIuX21laV9qdW4uX2p1bC5fYXVnLl9zZXAuX29rdC5fbm92Ll9kZWMuXCIuc3BsaXQoXCJfXCIpLGE9XCJqYW5fZmViX21ydF9hcHJfbWVpX2p1bl9qdWxfYXVnX3NlcF9va3Rfbm92X2RlY1wiLnNwbGl0KFwiX1wiKSx0PVsvXmphbi9pLC9eZmViL2ksL15tYWFydHxtcnQuPyQvaSwvXmFwci9pLC9ebWVpJC9pLC9eanVuW2kuXT8kL2ksL15qdWxbaS5dPyQvaSwvXmF1Zy9pLC9ec2VwL2ksL15va3QvaSwvXm5vdi9pLC9eZGVjL2ldLHI9L14oamFudWFyaXxmZWJydWFyaXxtYWFydHxhcHJpbHxtZWl8anVbbmxdaXxhdWd1c3R1c3xzZXB0ZW1iZXJ8b2t0b2Jlcnxub3ZlbWJlcnxkZWNlbWJlcnxqYW5cXC4/fGZlYlxcLj98bXJ0XFwuP3xhcHJcXC4/fGp1W25sXVxcLj98YXVnXFwuP3xzZXBcXC4/fG9rdFxcLj98bm92XFwuP3xkZWNcXC4/KS9pO3JldHVybiBlLmRlZmluZUxvY2FsZShcIm5sXCIse21vbnRoczpcImphbnVhcmlfZmVicnVhcmlfbWFhcnRfYXByaWxfbWVpX2p1bmlfanVsaV9hdWd1c3R1c19zZXB0ZW1iZXJfb2t0b2Jlcl9ub3ZlbWJlcl9kZWNlbWJlclwiLnNwbGl0KFwiX1wiKSxtb250aHNTaG9ydDpmdW5jdGlvbihlLHQpe3JldHVybiBlPy8tTU1NLS8udGVzdCh0KT9hW2UubW9udGgoKV06bltlLm1vbnRoKCldOm59LG1vbnRoc1JlZ2V4OnIsbW9udGhzU2hvcnRSZWdleDpyLG1vbnRoc1N0cmljdFJlZ2V4Oi9eKGphbnVhcml8ZmVicnVhcml8bWFhcnR8YXByaWx8bWVpfGp1W25sXWl8YXVndXN0dXN8c2VwdGVtYmVyfG9rdG9iZXJ8bm92ZW1iZXJ8ZGVjZW1iZXIpL2ksbW9udGhzU2hvcnRTdHJpY3RSZWdleDovXihqYW5cXC4/fGZlYlxcLj98bXJ0XFwuP3xhcHJcXC4/fG1laXxqdVtubF1cXC4/fGF1Z1xcLj98c2VwXFwuP3xva3RcXC4/fG5vdlxcLj98ZGVjXFwuPykvaSxtb250aHNQYXJzZTp0LGxvbmdNb250aHNQYXJzZTp0LHNob3J0TW9udGhzUGFyc2U6dCx3ZWVrZGF5czpcInpvbmRhZ19tYWFuZGFnX2RpbnNkYWdfd29lbnNkYWdfZG9uZGVyZGFnX3ZyaWpkYWdfemF0ZXJkYWdcIi5zcGxpdChcIl9cIiksd2Vla2RheXNTaG9ydDpcInpvLl9tYS5fZGkuX3dvLl9kby5fdnIuX3phLlwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcInpvX21hX2RpX3dvX2RvX3ZyX3phXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzUGFyc2VFeGFjdDohMCxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJISDptbVwiLExUUzpcIkhIOm1tOnNzXCIsTDpcIkRELU1NLVlZWVlcIixMTDpcIkQgTU1NTSBZWVlZXCIsTExMOlwiRCBNTU1NIFlZWVkgSEg6bW1cIixMTExMOlwiZGRkZCBEIE1NTU0gWVlZWSBISDptbVwifSxjYWxlbmRhcjp7c2FtZURheTpcIlt2YW5kYWFnIG9tXSBMVFwiLG5leHREYXk6XCJbbW9yZ2VuIG9tXSBMVFwiLG5leHRXZWVrOlwiZGRkZCBbb21dIExUXCIsbGFzdERheTpcIltnaXN0ZXJlbiBvbV0gTFRcIixsYXN0V2VlazpcIlthZmdlbG9wZW5dIGRkZGQgW29tXSBMVFwiLHNhbWVFbHNlOlwiTFwifSxyZWxhdGl2ZVRpbWU6e2Z1dHVyZTpcIm92ZXIgJXNcIixwYXN0OlwiJXMgZ2VsZWRlblwiLHM6XCJlZW4gcGFhciBzZWNvbmRlblwiLHNzOlwiJWQgc2Vjb25kZW5cIixtOlwiw6nDqW4gbWludXV0XCIsbW06XCIlZCBtaW51dGVuXCIsaDpcIsOpw6luIHV1clwiLGhoOlwiJWQgdXVyXCIsZDpcIsOpw6luIGRhZ1wiLGRkOlwiJWQgZGFnZW5cIixNOlwiw6nDqW4gbWFhbmRcIixNTTpcIiVkIG1hYW5kZW5cIix5Olwiw6nDqW4gamFhclwiLHl5OlwiJWQgamFhclwifSxkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOi9cXGR7MSwyfShzdGV8ZGUpLyxvcmRpbmFsOmZ1bmN0aW9uKGUpe3JldHVybiBlKygxPT09ZXx8OD09PWV8fGU+PTIwP1wic3RlXCI6XCJkZVwiKX0sd2Vlazp7ZG93OjEsZG95OjR9fSl9KX19KX0pOyIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIm1vbWVudFwiLFwiZnVsbGNhbGVuZGFyXCJdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP3QocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTp0KGUubW9tZW50LGUuRnVsbENhbGVuZGFyKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQobil7aWYocltuXSlyZXR1cm4gcltuXS5leHBvcnRzO3ZhciBpPXJbbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW25dLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLHQpLGkubD0hMCxpLmV4cG9ydHN9dmFyIHI9e307cmV0dXJuIHQubT1lLHQuYz1yLHQuZD1mdW5jdGlvbihlLHIsbil7dC5vKGUscil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHIse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpufSl9LHQubj1mdW5jdGlvbihlKXt2YXIgcj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKHIsXCJhXCIscikscn0sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9XCJcIix0KHQucz0xODEpfSh7MDpmdW5jdGlvbih0LHIpe3QuZXhwb3J0cz1lfSwxOmZ1bmN0aW9uKGUscil7ZS5leHBvcnRzPXR9LDE4MTpmdW5jdGlvbihlLHQscil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSkscigxODIpO3ZhciBuPXIoMSk7bi5kYXRlcGlja2VyTG9jYWxlKFwicGxcIixcInBsXCIse2Nsb3NlVGV4dDpcIlphbWtuaWpcIixwcmV2VGV4dDpcIiYjeDNDO1BvcHJ6ZWRuaVwiLG5leHRUZXh0OlwiTmFzdMSZcG55JiN4M0U7XCIsY3VycmVudFRleHQ6XCJEemnFm1wiLG1vbnRoTmFtZXM6W1wiU3R5Y3plxYRcIixcIkx1dHlcIixcIk1hcnplY1wiLFwiS3dpZWNpZcWEXCIsXCJNYWpcIixcIkN6ZXJ3aWVjXCIsXCJMaXBpZWNcIixcIlNpZXJwaWXFhFwiLFwiV3J6ZXNpZcWEXCIsXCJQYcW6ZHppZXJuaWtcIixcIkxpc3RvcGFkXCIsXCJHcnVkemllxYRcIl0sbW9udGhOYW1lc1Nob3J0OltcIlN0eVwiLFwiTHVcIixcIk1hclwiLFwiS3dcIixcIk1halwiLFwiQ3plXCIsXCJMaXBcIixcIlNpZVwiLFwiV3J6XCIsXCJQYVwiLFwiTGlzXCIsXCJHcnVcIl0sZGF5TmFtZXM6W1wiTmllZHppZWxhXCIsXCJQb25pZWR6aWHFgmVrXCIsXCJXdG9yZWtcIixcIsWacm9kYVwiLFwiQ3p3YXJ0ZWtcIixcIlBpxIV0ZWtcIixcIlNvYm90YVwiXSxkYXlOYW1lc1Nob3J0OltcIk5pZVwiLFwiUG5cIixcIld0XCIsXCLFmnJcIixcIkN6d1wiLFwiUHRcIixcIlNvXCJdLGRheU5hbWVzTWluOltcIk5cIixcIlBuXCIsXCJXdFwiLFwixZpyXCIsXCJDelwiLFwiUHRcIixcIlNvXCJdLHdlZWtIZWFkZXI6XCJUeWR6XCIsZGF0ZUZvcm1hdDpcImRkLm1tLnl5XCIsZmlyc3REYXk6MSxpc1JUTDohMSxzaG93TW9udGhBZnRlclllYXI6ITEseWVhclN1ZmZpeDpcIlwifSksbi5sb2NhbGUoXCJwbFwiLHtidXR0b25UZXh0Onttb250aDpcIk1pZXNpxIVjXCIsd2VlazpcIlR5ZHppZcWEXCIsZGF5OlwiRHppZcWEXCIsbGlzdDpcIlBsYW4gZG5pYVwifSxhbGxEYXlUZXh0OlwiQ2HFgnkgZHppZcWEXCIsZXZlbnRMaW1pdFRleHQ6XCJ3acSZY2VqXCIsbm9FdmVudHNNZXNzYWdlOlwiQnJhayB3eWRhcnplxYQgZG8gd3nFm3dpZXRsZW5pYVwifSl9LDE4MjpmdW5jdGlvbihlLHQscil7IWZ1bmN0aW9uKGUsdCl7dChyKDApKX0oMCxmdW5jdGlvbihlKXtmdW5jdGlvbiB0KGUpe3JldHVybiBlJTEwPDUmJmUlMTA+MSYmfn4oZS8xMCklMTAhPTF9ZnVuY3Rpb24gcihlLHIsbil7dmFyIGk9ZStcIiBcIjtzd2l0Y2gobil7Y2FzZVwic3NcIjpyZXR1cm4gaSsodChlKT9cInNla3VuZHlcIjpcInNla3VuZFwiKTtjYXNlXCJtXCI6cmV0dXJuIHI/XCJtaW51dGFcIjpcIm1pbnV0xJlcIjtjYXNlXCJtbVwiOnJldHVybiBpKyh0KGUpP1wibWludXR5XCI6XCJtaW51dFwiKTtjYXNlXCJoXCI6cmV0dXJuIHI/XCJnb2R6aW5hXCI6XCJnb2R6aW7EmVwiO2Nhc2VcImhoXCI6cmV0dXJuIGkrKHQoZSk/XCJnb2R6aW55XCI6XCJnb2R6aW5cIik7Y2FzZVwiTU1cIjpyZXR1cm4gaSsodChlKT9cIm1pZXNpxIVjZVwiOlwibWllc2nEmWN5XCIpO2Nhc2VcInl5XCI6cmV0dXJuIGkrKHQoZSk/XCJsYXRhXCI6XCJsYXRcIil9fXZhciBuPVwic3R5Y3plxYRfbHV0eV9tYXJ6ZWNfa3dpZWNpZcWEX21hal9jemVyd2llY19saXBpZWNfc2llcnBpZcWEX3dyemVzaWXFhF9wYcW6ZHppZXJuaWtfbGlzdG9wYWRfZ3J1ZHppZcWEXCIuc3BsaXQoXCJfXCIpLGk9XCJzdHljem5pYV9sdXRlZ29fbWFyY2Ffa3dpZXRuaWFfbWFqYV9jemVyd2NhX2xpcGNhX3NpZXJwbmlhX3dyemXFm25pYV9wYcW6ZHppZXJuaWthX2xpc3RvcGFkYV9ncnVkbmlhXCIuc3BsaXQoXCJfXCIpO3JldHVybiBlLmRlZmluZUxvY2FsZShcInBsXCIse21vbnRoczpmdW5jdGlvbihlLHQpe3JldHVybiBlP1wiXCI9PT10P1wiKFwiK2lbZS5tb250aCgpXStcInxcIituW2UubW9udGgoKV0rXCIpXCI6L0QgTU1NTS8udGVzdCh0KT9pW2UubW9udGgoKV06bltlLm1vbnRoKCldOm59LG1vbnRoc1Nob3J0Olwic3R5X2x1dF9tYXJfa3dpX21hal9jemVfbGlwX3NpZV93cnpfcGHFul9saXNfZ3J1XCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzOlwibmllZHppZWxhX3BvbmllZHppYcWCZWtfd3RvcmVrX8Wbcm9kYV9jendhcnRla19wacSFdGVrX3NvYm90YVwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c1Nob3J0OlwibmR6X3Bvbl93dF/Fm3JfY3p3X3B0X3NvYlwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcIk5kX1BuX1d0X8Wacl9Del9QdF9Tb1wiLnNwbGl0KFwiX1wiKSxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJISDptbVwiLExUUzpcIkhIOm1tOnNzXCIsTDpcIkRELk1NLllZWVlcIixMTDpcIkQgTU1NTSBZWVlZXCIsTExMOlwiRCBNTU1NIFlZWVkgSEg6bW1cIixMTExMOlwiZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW1cIn0sY2FsZW5kYXI6e3NhbWVEYXk6XCJbRHppxZsgb10gTFRcIixuZXh0RGF5OlwiW0p1dHJvIG9dIExUXCIsbmV4dFdlZWs6ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5kYXkoKSl7Y2FzZSAwOnJldHVyblwiW1cgbmllZHppZWzEmSBvXSBMVFwiO2Nhc2UgMjpyZXR1cm5cIltXZSB3dG9yZWsgb10gTFRcIjtjYXNlIDM6cmV0dXJuXCJbVyDFm3JvZMSZIG9dIExUXCI7Y2FzZSA2OnJldHVyblwiW1cgc29ib3TEmSBvXSBMVFwiO2RlZmF1bHQ6cmV0dXJuXCJbV10gZGRkZCBbb10gTFRcIn19LGxhc3REYXk6XCJbV2N6b3JhaiBvXSBMVFwiLGxhc3RXZWVrOmZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuZGF5KCkpe2Nhc2UgMDpyZXR1cm5cIltXIHplc3rFgsSFIG5pZWR6aWVsxJkgb10gTFRcIjtjYXNlIDM6cmV0dXJuXCJbVyB6ZXN6xYLEhSDFm3JvZMSZIG9dIExUXCI7Y2FzZSA2OnJldHVyblwiW1cgemVzesWCxIUgc29ib3TEmSBvXSBMVFwiO2RlZmF1bHQ6cmV0dXJuXCJbVyB6ZXN6xYJ5XSBkZGRkIFtvXSBMVFwifX0sc2FtZUVsc2U6XCJMXCJ9LHJlbGF0aXZlVGltZTp7ZnV0dXJlOlwiemEgJXNcIixwYXN0OlwiJXMgdGVtdVwiLHM6XCJraWxrYSBzZWt1bmRcIixzczpyLG06cixtbTpyLGg6cixoaDpyLGQ6XCIxIGR6aWXFhFwiLGRkOlwiJWQgZG5pXCIsTTpcIm1pZXNpxIVjXCIsTU06cix5Olwicm9rXCIseXk6cn0sZGF5T2ZNb250aE9yZGluYWxQYXJzZTovXFxkezEsMn1cXC4vLG9yZGluYWw6XCIlZC5cIix3ZWVrOntkb3c6MSxkb3k6NH19KX0pfX0pfSk7IiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dChyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wibW9tZW50XCIsXCJmdWxsY2FsZW5kYXJcIl0sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/dChyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOnQoZS5tb21lbnQsZS5GdWxsQ2FsZW5kYXIpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChyKXtpZihvW3JdKXJldHVybiBvW3JdLmV4cG9ydHM7dmFyIGE9b1tyXT17aTpyLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbcl0uY2FsbChhLmV4cG9ydHMsYSxhLmV4cG9ydHMsdCksYS5sPSEwLGEuZXhwb3J0c312YXIgbz17fTtyZXR1cm4gdC5tPWUsdC5jPW8sdC5kPWZ1bmN0aW9uKGUsbyxyKXt0Lm8oZSxvKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbyx7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0OnJ9KX0sdC5uPWZ1bmN0aW9uKGUpe3ZhciBvPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiB0LmQobyxcImFcIixvKSxvfSx0Lm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHQucD1cIlwiLHQodC5zPTE4Myl9KHswOmZ1bmN0aW9uKHQsbyl7dC5leHBvcnRzPWV9LDE6ZnVuY3Rpb24oZSxvKXtlLmV4cG9ydHM9dH0sMTgzOmZ1bmN0aW9uKGUsdCxvKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxvKDE4NCk7dmFyIHI9bygxKTtyLmRhdGVwaWNrZXJMb2NhbGUoXCJwdC1iclwiLFwicHQtQlJcIix7Y2xvc2VUZXh0OlwiRmVjaGFyXCIscHJldlRleHQ6XCImI3gzQztBbnRlcmlvclwiLG5leHRUZXh0OlwiUHLDs3hpbW8mI3gzRTtcIixjdXJyZW50VGV4dDpcIkhvamVcIixtb250aE5hbWVzOltcIkphbmVpcm9cIixcIkZldmVyZWlyb1wiLFwiTWFyw6dvXCIsXCJBYnJpbFwiLFwiTWFpb1wiLFwiSnVuaG9cIixcIkp1bGhvXCIsXCJBZ29zdG9cIixcIlNldGVtYnJvXCIsXCJPdXR1YnJvXCIsXCJOb3ZlbWJyb1wiLFwiRGV6ZW1icm9cIl0sbW9udGhOYW1lc1Nob3J0OltcIkphblwiLFwiRmV2XCIsXCJNYXJcIixcIkFiclwiLFwiTWFpXCIsXCJKdW5cIixcIkp1bFwiLFwiQWdvXCIsXCJTZXRcIixcIk91dFwiLFwiTm92XCIsXCJEZXpcIl0sZGF5TmFtZXM6W1wiRG9taW5nb1wiLFwiU2VndW5kYS1mZWlyYVwiLFwiVGVyw6dhLWZlaXJhXCIsXCJRdWFydGEtZmVpcmFcIixcIlF1aW50YS1mZWlyYVwiLFwiU2V4dGEtZmVpcmFcIixcIlPDoWJhZG9cIl0sZGF5TmFtZXNTaG9ydDpbXCJEb21cIixcIlNlZ1wiLFwiVGVyXCIsXCJRdWFcIixcIlF1aVwiLFwiU2V4XCIsXCJTw6FiXCJdLGRheU5hbWVzTWluOltcIkRvbVwiLFwiU2VnXCIsXCJUZXJcIixcIlF1YVwiLFwiUXVpXCIsXCJTZXhcIixcIlPDoWJcIl0sd2Vla0hlYWRlcjpcIlNtXCIsZGF0ZUZvcm1hdDpcImRkL21tL3l5XCIsZmlyc3REYXk6MCxpc1JUTDohMSxzaG93TW9udGhBZnRlclllYXI6ITEseWVhclN1ZmZpeDpcIlwifSksci5sb2NhbGUoXCJwdC1iclwiLHtidXR0b25UZXh0Onttb250aDpcIk3DqnNcIix3ZWVrOlwiU2VtYW5hXCIsZGF5OlwiRGlhXCIsbGlzdDpcIkNvbXByb21pc3Nvc1wifSxhbGxEYXlUZXh0OlwiZGlhIGludGVpcm9cIixldmVudExpbWl0VGV4dDpmdW5jdGlvbihlKXtyZXR1cm5cIm1haXMgK1wiK2V9LG5vRXZlbnRzTWVzc2FnZTpcIk7Do28gaMOhIGV2ZW50b3MgcGFyYSBtb3N0cmFyXCJ9KX0sMTg0OmZ1bmN0aW9uKGUsdCxvKXshZnVuY3Rpb24oZSx0KXt0KG8oMCkpfSgwLGZ1bmN0aW9uKGUpe3JldHVybiBlLmRlZmluZUxvY2FsZShcInB0LWJyXCIse21vbnRoczpcImphbmVpcm9fZmV2ZXJlaXJvX21hcsOnb19hYnJpbF9tYWlvX2p1bmhvX2p1bGhvX2Fnb3N0b19zZXRlbWJyb19vdXR1YnJvX25vdmVtYnJvX2RlemVtYnJvXCIuc3BsaXQoXCJfXCIpLG1vbnRoc1Nob3J0OlwiamFuX2Zldl9tYXJfYWJyX21haV9qdW5fanVsX2Fnb19zZXRfb3V0X25vdl9kZXpcIi5zcGxpdChcIl9cIiksd2Vla2RheXM6XCJkb21pbmdvX3NlZ3VuZGEtZmVpcmFfdGVyw6dhLWZlaXJhX3F1YXJ0YS1mZWlyYV9xdWludGEtZmVpcmFfc2V4dGEtZmVpcmFfc8OhYmFkb1wiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c1Nob3J0OlwiZG9tX3NlZ190ZXJfcXVhX3F1aV9zZXhfc8OhYlwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcImRvXzLCql8zwqpfNMKqXzXCql82wqpfc8OhXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzUGFyc2VFeGFjdDohMCxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJISDptbVwiLExUUzpcIkhIOm1tOnNzXCIsTDpcIkREL01NL1lZWVlcIixMTDpcIkQgW2RlXSBNTU1NIFtkZV0gWVlZWVwiLExMTDpcIkQgW2RlXSBNTU1NIFtkZV0gWVlZWSBbw6BzXSBISDptbVwiLExMTEw6XCJkZGRkLCBEIFtkZV0gTU1NTSBbZGVdIFlZWVkgW8Ogc10gSEg6bW1cIn0sY2FsZW5kYXI6e3NhbWVEYXk6XCJbSG9qZSDDoHNdIExUXCIsbmV4dERheTpcIltBbWFuaMOjIMOgc10gTFRcIixuZXh0V2VlazpcImRkZGQgW8Ogc10gTFRcIixsYXN0RGF5OlwiW09udGVtIMOgc10gTFRcIixsYXN0V2VlazpmdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5kYXkoKXx8Nj09PXRoaXMuZGF5KCk/XCJbw5psdGltb10gZGRkZCBbw6BzXSBMVFwiOlwiW8OabHRpbWFdIGRkZGQgW8Ogc10gTFRcIn0sc2FtZUVsc2U6XCJMXCJ9LHJlbGF0aXZlVGltZTp7ZnV0dXJlOlwiZW0gJXNcIixwYXN0OlwiaMOhICVzXCIsczpcInBvdWNvcyBzZWd1bmRvc1wiLHNzOlwiJWQgc2VndW5kb3NcIixtOlwidW0gbWludXRvXCIsbW06XCIlZCBtaW51dG9zXCIsaDpcInVtYSBob3JhXCIsaGg6XCIlZCBob3Jhc1wiLGQ6XCJ1bSBkaWFcIixkZDpcIiVkIGRpYXNcIixNOlwidW0gbcOqc1wiLE1NOlwiJWQgbWVzZXNcIix5OlwidW0gYW5vXCIseXk6XCIlZCBhbm9zXCJ9LGRheU9mTW9udGhPcmRpbmFsUGFyc2U6L1xcZHsxLDJ9wrovLG9yZGluYWw6XCIlZMK6XCJ9KX0pfX0pfSk7IiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dChyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wibW9tZW50XCIsXCJmdWxsY2FsZW5kYXJcIl0sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/dChyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOnQoZS5tb21lbnQsZS5GdWxsQ2FsZW5kYXIpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChhKXtpZihvW2FdKXJldHVybiBvW2FdLmV4cG9ydHM7dmFyIHI9b1thXT17aTphLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbYV0uY2FsbChyLmV4cG9ydHMscixyLmV4cG9ydHMsdCksci5sPSEwLHIuZXhwb3J0c312YXIgbz17fTtyZXR1cm4gdC5tPWUsdC5jPW8sdC5kPWZ1bmN0aW9uKGUsbyxhKXt0Lm8oZSxvKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbyx7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0OmF9KX0sdC5uPWZ1bmN0aW9uKGUpe3ZhciBvPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiB0LmQobyxcImFcIixvKSxvfSx0Lm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHQucD1cIlwiLHQodC5zPTE4NSl9KHswOmZ1bmN0aW9uKHQsbyl7dC5leHBvcnRzPWV9LDE6ZnVuY3Rpb24oZSxvKXtlLmV4cG9ydHM9dH0sMTg1OmZ1bmN0aW9uKGUsdCxvKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxvKDE4Nik7dmFyIGE9bygxKTthLmRhdGVwaWNrZXJMb2NhbGUoXCJwdFwiLFwicHRcIix7Y2xvc2VUZXh0OlwiRmVjaGFyXCIscHJldlRleHQ6XCJBbnRlcmlvclwiLG5leHRUZXh0OlwiU2VndWludGVcIixjdXJyZW50VGV4dDpcIkhvamVcIixtb250aE5hbWVzOltcIkphbmVpcm9cIixcIkZldmVyZWlyb1wiLFwiTWFyw6dvXCIsXCJBYnJpbFwiLFwiTWFpb1wiLFwiSnVuaG9cIixcIkp1bGhvXCIsXCJBZ29zdG9cIixcIlNldGVtYnJvXCIsXCJPdXR1YnJvXCIsXCJOb3ZlbWJyb1wiLFwiRGV6ZW1icm9cIl0sbW9udGhOYW1lc1Nob3J0OltcIkphblwiLFwiRmV2XCIsXCJNYXJcIixcIkFiclwiLFwiTWFpXCIsXCJKdW5cIixcIkp1bFwiLFwiQWdvXCIsXCJTZXRcIixcIk91dFwiLFwiTm92XCIsXCJEZXpcIl0sZGF5TmFtZXM6W1wiRG9taW5nb1wiLFwiU2VndW5kYS1mZWlyYVwiLFwiVGVyw6dhLWZlaXJhXCIsXCJRdWFydGEtZmVpcmFcIixcIlF1aW50YS1mZWlyYVwiLFwiU2V4dGEtZmVpcmFcIixcIlPDoWJhZG9cIl0sZGF5TmFtZXNTaG9ydDpbXCJEb21cIixcIlNlZ1wiLFwiVGVyXCIsXCJRdWFcIixcIlF1aVwiLFwiU2V4XCIsXCJTw6FiXCJdLGRheU5hbWVzTWluOltcIkRvbVwiLFwiU2VnXCIsXCJUZXJcIixcIlF1YVwiLFwiUXVpXCIsXCJTZXhcIixcIlPDoWJcIl0sd2Vla0hlYWRlcjpcIlNlbVwiLGRhdGVGb3JtYXQ6XCJkZC9tbS95eVwiLGZpcnN0RGF5OjAsaXNSVEw6ITEsc2hvd01vbnRoQWZ0ZXJZZWFyOiExLHllYXJTdWZmaXg6XCJcIn0pLGEubG9jYWxlKFwicHRcIix7YnV0dG9uVGV4dDp7bW9udGg6XCJNw6pzXCIsd2VlazpcIlNlbWFuYVwiLGRheTpcIkRpYVwiLGxpc3Q6XCJBZ2VuZGFcIn0sYWxsRGF5VGV4dDpcIlRvZG8gbyBkaWFcIixldmVudExpbWl0VGV4dDpcIm1haXNcIixub0V2ZW50c01lc3NhZ2U6XCJOw6NvIGjDoSBldmVudG9zIHBhcmEgbW9zdHJhclwifSl9LDE4NjpmdW5jdGlvbihlLHQsbyl7IWZ1bmN0aW9uKGUsdCl7dChvKDApKX0oMCxmdW5jdGlvbihlKXtyZXR1cm4gZS5kZWZpbmVMb2NhbGUoXCJwdFwiLHttb250aHM6XCJqYW5laXJvX2ZldmVyZWlyb19tYXLDp29fYWJyaWxfbWFpb19qdW5ob19qdWxob19hZ29zdG9fc2V0ZW1icm9fb3V0dWJyb19ub3ZlbWJyb19kZXplbWJyb1wiLnNwbGl0KFwiX1wiKSxtb250aHNTaG9ydDpcImphbl9mZXZfbWFyX2Ficl9tYWlfanVuX2p1bF9hZ29fc2V0X291dF9ub3ZfZGV6XCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzOlwiRG9taW5nb19TZWd1bmRhLWZlaXJhX1RlcsOnYS1mZWlyYV9RdWFydGEtZmVpcmFfUXVpbnRhLWZlaXJhX1NleHRhLWZlaXJhX1PDoWJhZG9cIi5zcGxpdChcIl9cIiksd2Vla2RheXNTaG9ydDpcIkRvbV9TZWdfVGVyX1F1YV9RdWlfU2V4X1PDoWJcIi5zcGxpdChcIl9cIiksd2Vla2RheXNNaW46XCJEb18ywqpfM8KqXzTCql81wqpfNsKqX1PDoVwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c1BhcnNlRXhhY3Q6ITAsbG9uZ0RhdGVGb3JtYXQ6e0xUOlwiSEg6bW1cIixMVFM6XCJISDptbTpzc1wiLEw6XCJERC9NTS9ZWVlZXCIsTEw6XCJEIFtkZV0gTU1NTSBbZGVdIFlZWVlcIixMTEw6XCJEIFtkZV0gTU1NTSBbZGVdIFlZWVkgSEg6bW1cIixMTExMOlwiZGRkZCwgRCBbZGVdIE1NTU0gW2RlXSBZWVlZIEhIOm1tXCJ9LGNhbGVuZGFyOntzYW1lRGF5OlwiW0hvamUgw6BzXSBMVFwiLG5leHREYXk6XCJbQW1hbmjDoyDDoHNdIExUXCIsbmV4dFdlZWs6XCJkZGRkIFvDoHNdIExUXCIsbGFzdERheTpcIltPbnRlbSDDoHNdIExUXCIsbGFzdFdlZWs6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuZGF5KCl8fDY9PT10aGlzLmRheSgpP1wiW8OabHRpbW9dIGRkZGQgW8Ogc10gTFRcIjpcIlvDmmx0aW1hXSBkZGRkIFvDoHNdIExUXCJ9LHNhbWVFbHNlOlwiTFwifSxyZWxhdGl2ZVRpbWU6e2Z1dHVyZTpcImVtICVzXCIscGFzdDpcImjDoSAlc1wiLHM6XCJzZWd1bmRvc1wiLHNzOlwiJWQgc2VndW5kb3NcIixtOlwidW0gbWludXRvXCIsbW06XCIlZCBtaW51dG9zXCIsaDpcInVtYSBob3JhXCIsaGg6XCIlZCBob3Jhc1wiLGQ6XCJ1bSBkaWFcIixkZDpcIiVkIGRpYXNcIixNOlwidW0gbcOqc1wiLE1NOlwiJWQgbWVzZXNcIix5OlwidW0gYW5vXCIseXk6XCIlZCBhbm9zXCJ9LGRheU9mTW9udGhPcmRpbmFsUGFyc2U6L1xcZHsxLDJ9wrovLG9yZGluYWw6XCIlZMK6XCIsd2Vlazp7ZG93OjEsZG95OjR9fSl9KX19KX0pOyIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIm1vbWVudFwiLFwiZnVsbGNhbGVuZGFyXCJdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP3QocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTp0KGUubW9tZW50LGUuRnVsbENhbGVuZGFyKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoaSl7aWYobltpXSlyZXR1cm4gbltpXS5leHBvcnRzO3ZhciByPW5baV09e2k6aSxsOiExLGV4cG9ydHM6e319O3JldHVybiBlW2ldLmNhbGwoci5leHBvcnRzLHIsci5leHBvcnRzLHQpLHIubD0hMCxyLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIHQubT1lLHQuYz1uLHQuZD1mdW5jdGlvbihlLG4saSl7dC5vKGUsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDppfSl9LHQubj1mdW5jdGlvbihlKXt2YXIgbj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKG4sXCJhXCIsbiksbn0sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9XCJcIix0KHQucz0xODcpfSh7MDpmdW5jdGlvbih0LG4pe3QuZXhwb3J0cz1lfSwxOmZ1bmN0aW9uKGUsbil7ZS5leHBvcnRzPXR9LDE4NzpmdW5jdGlvbihlLHQsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbigxODgpO3ZhciBpPW4oMSk7aS5kYXRlcGlja2VyTG9jYWxlKFwicm9cIixcInJvXCIse2Nsb3NlVGV4dDpcIsOObmNoaWRlXCIscHJldlRleHQ6XCImI3hBQjsgTHVuYSBwcmVjZWRlbnTEg1wiLG5leHRUZXh0OlwiTHVuYSB1cm3Eg3RvYXJlICYjeEJCO1wiLGN1cnJlbnRUZXh0OlwiQXppXCIsbW9udGhOYW1lczpbXCJJYW51YXJpZVwiLFwiRmVicnVhcmllXCIsXCJNYXJ0aWVcIixcIkFwcmlsaWVcIixcIk1haVwiLFwiSXVuaWVcIixcIkl1bGllXCIsXCJBdWd1c3RcIixcIlNlcHRlbWJyaWVcIixcIk9jdG9tYnJpZVwiLFwiTm9pZW1icmllXCIsXCJEZWNlbWJyaWVcIl0sbW9udGhOYW1lc1Nob3J0OltcIklhblwiLFwiRmViXCIsXCJNYXJcIixcIkFwclwiLFwiTWFpXCIsXCJJdW5cIixcIkl1bFwiLFwiQXVnXCIsXCJTZXBcIixcIk9jdFwiLFwiTm92XCIsXCJEZWNcIl0sZGF5TmFtZXM6W1wiRHVtaW5pY8SDXCIsXCJMdW5pXCIsXCJNYXLFo2lcIixcIk1pZXJjdXJpXCIsXCJKb2lcIixcIlZpbmVyaVwiLFwiU8OibWLEg3TEg1wiXSxkYXlOYW1lc1Nob3J0OltcIkR1bVwiLFwiTHVuXCIsXCJNYXJcIixcIk1pZVwiLFwiSm9pXCIsXCJWaW5cIixcIlPDom1cIl0sZGF5TmFtZXNNaW46W1wiRHVcIixcIkx1XCIsXCJNYVwiLFwiTWlcIixcIkpvXCIsXCJWaVwiLFwiU8OiXCJdLHdlZWtIZWFkZXI6XCJTxINwdFwiLGRhdGVGb3JtYXQ6XCJkZC5tbS55eVwiLGZpcnN0RGF5OjEsaXNSVEw6ITEsc2hvd01vbnRoQWZ0ZXJZZWFyOiExLHllYXJTdWZmaXg6XCJcIn0pLGkubG9jYWxlKFwicm9cIix7YnV0dG9uVGV4dDp7cHJldjpcInByZWNlZGVudMSDXCIsbmV4dDpcInVybcSDdG9hcmVcIixtb250aDpcIkx1bsSDXCIsd2VlazpcIlPEg3B0xINtw6JuxINcIixkYXk6XCJaaVwiLGxpc3Q6XCJBZ2VuZMSDXCJ9LGFsbERheVRleHQ6XCJUb2F0xIMgeml1YVwiLGV2ZW50TGltaXRUZXh0OmZ1bmN0aW9uKGUpe3JldHVyblwiK2FsdGUgXCIrZX0sbm9FdmVudHNNZXNzYWdlOlwiTnUgZXhpc3TEgyBldmVuaW1lbnRlIGRlIGFmaciZYXRcIn0pfSwxODg6ZnVuY3Rpb24oZSx0LG4peyFmdW5jdGlvbihlLHQpe3QobigwKSl9KDAsZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlLHQsbil7dmFyIGk9e3NzOlwic2VjdW5kZVwiLG1tOlwibWludXRlXCIsaGg6XCJvcmVcIixkZDpcInppbGVcIixNTTpcImx1bmlcIix5eTpcImFuaVwifSxyPVwiIFwiO3JldHVybihlJTEwMD49MjB8fGU+PTEwMCYmZSUxMDA9PTApJiYocj1cIiBkZSBcIiksZStyK2lbbl19cmV0dXJuIGUuZGVmaW5lTG9jYWxlKFwicm9cIix7bW9udGhzOlwiaWFudWFyaWVfZmVicnVhcmllX21hcnRpZV9hcHJpbGllX21haV9pdW5pZV9pdWxpZV9hdWd1c3Rfc2VwdGVtYnJpZV9vY3RvbWJyaWVfbm9pZW1icmllX2RlY2VtYnJpZVwiLnNwbGl0KFwiX1wiKSxtb250aHNTaG9ydDpcImlhbi5fZmViLl9tYXJ0Ll9hcHIuX21haV9pdW4uX2l1bC5fYXVnLl9zZXB0Ll9vY3QuX25vdi5fZGVjLlwiLnNwbGl0KFwiX1wiKSxtb250aHNQYXJzZUV4YWN0OiEwLHdlZWtkYXlzOlwiZHVtaW5pY8SDX2x1bmlfbWFyyJtpX21pZXJjdXJpX2pvaV92aW5lcmlfc8OibWLEg3TEg1wiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c1Nob3J0OlwiRHVtX0x1bl9NYXJfTWllX0pvaV9WaW5fU8OibVwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcIkR1X0x1X01hX01pX0pvX1ZpX1PDolwiLnNwbGl0KFwiX1wiKSxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJIOm1tXCIsTFRTOlwiSDptbTpzc1wiLEw6XCJERC5NTS5ZWVlZXCIsTEw6XCJEIE1NTU0gWVlZWVwiLExMTDpcIkQgTU1NTSBZWVlZIEg6bW1cIixMTExMOlwiZGRkZCwgRCBNTU1NIFlZWVkgSDptbVwifSxjYWxlbmRhcjp7c2FtZURheTpcIlthemkgbGFdIExUXCIsbmV4dERheTpcIlttw6JpbmUgbGFdIExUXCIsbmV4dFdlZWs6XCJkZGRkIFtsYV0gTFRcIixsYXN0RGF5OlwiW2llcmkgbGFdIExUXCIsbGFzdFdlZWs6XCJbZm9zdGFdIGRkZGQgW2xhXSBMVFwiLHNhbWVFbHNlOlwiTFwifSxyZWxhdGl2ZVRpbWU6e2Z1dHVyZTpcInBlc3RlICVzXCIscGFzdDpcIiVzIMOubiB1cm3Eg1wiLHM6XCJjw6J0ZXZhIHNlY3VuZGVcIixzczp0LG06XCJ1biBtaW51dFwiLG1tOnQsaDpcIm8gb3LEg1wiLGhoOnQsZDpcIm8gemlcIixkZDp0LE06XCJvIGx1bsSDXCIsTU06dCx5OlwidW4gYW5cIix5eTp0fSx3ZWVrOntkb3c6MSxkb3k6N319KX0pfX0pfSk7IiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dChyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wibW9tZW50XCIsXCJmdWxsY2FsZW5kYXJcIl0sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/dChyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOnQoZS5tb21lbnQsZS5GdWxsQ2FsZW5kYXIpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24oZSx0KXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChuKXtpZihyW25dKXJldHVybiByW25dLmV4cG9ydHM7dmFyIHM9cltuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChzLmV4cG9ydHMscyxzLmV4cG9ydHMsdCkscy5sPSEwLHMuZXhwb3J0c312YXIgcj17fTtyZXR1cm4gdC5tPWUsdC5jPXIsdC5kPWZ1bmN0aW9uKGUscixuKXt0Lm8oZSxyKXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUscix7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0Om59KX0sdC5uPWZ1bmN0aW9uKGUpe3ZhciByPWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiB0LmQocixcImFcIixyKSxyfSx0Lm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHQucD1cIlwiLHQodC5zPTE4OSl9KHswOmZ1bmN0aW9uKHQscil7dC5leHBvcnRzPWV9LDE6ZnVuY3Rpb24oZSxyKXtlLmV4cG9ydHM9dH0sMTg5OmZ1bmN0aW9uKGUsdCxyKXtPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxyKDE5MCk7dmFyIG49cigxKTtuLmRhdGVwaWNrZXJMb2NhbGUoXCJydVwiLFwicnVcIix7Y2xvc2VUZXh0Olwi0JfQsNC60YDRi9GC0YxcIixwcmV2VGV4dDpcIiYjeDNDO9Cf0YDQtdC0XCIsbmV4dFRleHQ6XCLQodC70LXQtCYjeDNFO1wiLGN1cnJlbnRUZXh0Olwi0KHQtdCz0L7QtNC90Y9cIixtb250aE5hbWVzOltcItCv0L3QstCw0YDRjFwiLFwi0KTQtdCy0YDQsNC70YxcIixcItCc0LDRgNGCXCIsXCLQkNC/0YDQtdC70YxcIixcItCc0LDQuVwiLFwi0JjRjtC90YxcIixcItCY0Y7Qu9GMXCIsXCLQkNCy0LPRg9GB0YJcIixcItCh0LXQvdGC0Y/QsdGA0YxcIixcItCe0LrRgtGP0LHRgNGMXCIsXCLQndC+0Y/QsdGA0YxcIixcItCU0LXQutCw0LHRgNGMXCJdLG1vbnRoTmFtZXNTaG9ydDpbXCLQr9C90LJcIixcItCk0LXQslwiLFwi0JzQsNGAXCIsXCLQkNC/0YBcIixcItCc0LDQuVwiLFwi0JjRjtC9XCIsXCLQmNGO0LtcIixcItCQ0LLQs1wiLFwi0KHQtdC9XCIsXCLQntC60YJcIixcItCd0L7Rj1wiLFwi0JTQtdC6XCJdLGRheU5hbWVzOltcItCy0L7RgdC60YDQtdGB0LXQvdGM0LVcIixcItC/0L7QvdC10LTQtdC70YzQvdC40LpcIixcItCy0YLQvtGA0L3QuNC6XCIsXCLRgdGA0LXQtNCwXCIsXCLRh9C10YLQstC10YDQs1wiLFwi0L/Rj9GC0L3QuNGG0LBcIixcItGB0YPQsdCx0L7RgtCwXCJdLGRheU5hbWVzU2hvcnQ6W1wi0LLRgdC6XCIsXCLQv9C90LRcIixcItCy0YLRgFwiLFwi0YHRgNC0XCIsXCLRh9GC0LJcIixcItC/0YLQvVwiLFwi0YHQsdGCXCJdLGRheU5hbWVzTWluOltcItCS0YFcIixcItCf0L1cIixcItCS0YJcIixcItCh0YBcIixcItCn0YJcIixcItCf0YJcIixcItCh0LFcIl0sd2Vla0hlYWRlcjpcItCd0LXQtFwiLGRhdGVGb3JtYXQ6XCJkZC5tbS55eVwiLGZpcnN0RGF5OjEsaXNSVEw6ITEsc2hvd01vbnRoQWZ0ZXJZZWFyOiExLHllYXJTdWZmaXg6XCJcIn0pLG4ubG9jYWxlKFwicnVcIix7YnV0dG9uVGV4dDp7bW9udGg6XCLQnNC10YHRj9GGXCIsd2VlazpcItCd0LXQtNC10LvRj1wiLGRheTpcItCU0LXQvdGMXCIsbGlzdDpcItCf0L7QstC10YHRgtC60LAg0LTQvdGPXCJ9LGFsbERheVRleHQ6XCLQktC10YHRjCDQtNC10L3RjFwiLGV2ZW50TGltaXRUZXh0OmZ1bmN0aW9uKGUpe3JldHVyblwiKyDQtdGJ0ZEgXCIrZX0sbm9FdmVudHNNZXNzYWdlOlwi0J3QtdGCINGB0L7QsdGL0YLQuNC5INC00LvRjyDQvtGC0L7QsdGA0LDQttC10L3QuNGPXCJ9KX0sMTkwOmZ1bmN0aW9uKGUsdCxyKXshZnVuY3Rpb24oZSx0KXt0KHIoMCkpfSgwLGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQoZSx0KXt2YXIgcj1lLnNwbGl0KFwiX1wiKTtyZXR1cm4gdCUxMD09MSYmdCUxMDAhPTExP3JbMF06dCUxMD49MiYmdCUxMDw9NCYmKHQlMTAwPDEwfHx0JTEwMD49MjApP3JbMV06clsyXX1mdW5jdGlvbiByKGUscixuKXt2YXIgcz17c3M6cj9cItGB0LXQutGD0L3QtNCwX9GB0LXQutGD0L3QtNGLX9GB0LXQutGD0L3QtFwiOlwi0YHQtdC60YPQvdC00YNf0YHQtdC60YPQvdC00Ytf0YHQtdC60YPQvdC0XCIsbW06cj9cItC80LjQvdGD0YLQsF/QvNC40L3Rg9GC0Ytf0LzQuNC90YPRglwiOlwi0LzQuNC90YPRgtGDX9C80LjQvdGD0YLRi1/QvNC40L3Rg9GCXCIsaGg6XCLRh9Cw0YFf0YfQsNGB0LBf0YfQsNGB0L7QslwiLGRkOlwi0LTQtdC90Yxf0LTQvdGPX9C00L3QtdC5XCIsTU06XCLQvNC10YHRj9GGX9C80LXRgdGP0YbQsF/QvNC10YHRj9GG0LXQslwiLHl5Olwi0LPQvtC0X9Cz0L7QtNCwX9C70LXRglwifTtyZXR1cm5cIm1cIj09PW4/cj9cItC80LjQvdGD0YLQsFwiOlwi0LzQuNC90YPRgtGDXCI6ZStcIiBcIit0KHNbbl0sK2UpfXZhciBuPVsvXtGP0L3Qsi9pLC9e0YTQtdCyL2ksL17QvNCw0YAvaSwvXtCw0L/RgC9pLC9e0LzQsFvQudGPXS9pLC9e0LjRjtC9L2ksL17QuNGO0LsvaSwvXtCw0LLQsy9pLC9e0YHQtdC9L2ksL17QvtC60YIvaSwvXtC90L7Rjy9pLC9e0LTQtdC6L2ldO3JldHVybiBlLmRlZmluZUxvY2FsZShcInJ1XCIse21vbnRoczp7Zm9ybWF0Olwi0Y/QvdCy0LDRgNGPX9GE0LXQstGA0LDQu9GPX9C80LDRgNGC0LBf0LDQv9GA0LXQu9GPX9C80LDRj1/QuNGO0L3Rj1/QuNGO0LvRj1/QsNCy0LPRg9GB0YLQsF/RgdC10L3RgtGP0LHRgNGPX9C+0LrRgtGP0LHRgNGPX9C90L7Rj9Cx0YDRj1/QtNC10LrQsNCx0YDRj1wiLnNwbGl0KFwiX1wiKSxzdGFuZGFsb25lOlwi0Y/QvdCy0LDRgNGMX9GE0LXQstGA0LDQu9GMX9C80LDRgNGCX9Cw0L/RgNC10LvRjF/QvNCw0Llf0LjRjtC90Yxf0LjRjtC70Yxf0LDQstCz0YPRgdGCX9GB0LXQvdGC0Y/QsdGA0Yxf0L7QutGC0Y/QsdGA0Yxf0L3QvtGP0LHRgNGMX9C00LXQutCw0LHRgNGMXCIuc3BsaXQoXCJfXCIpfSxtb250aHNTaG9ydDp7Zm9ybWF0Olwi0Y/QvdCyLl/RhNC10LLRgC5f0LzQsNGALl/QsNC/0YAuX9C80LDRj1/QuNGO0L3Rj1/QuNGO0LvRj1/QsNCy0LMuX9GB0LXQvdGCLl/QvtC60YIuX9C90L7Rj9CxLl/QtNC10LouXCIuc3BsaXQoXCJfXCIpLHN0YW5kYWxvbmU6XCLRj9C90LIuX9GE0LXQstGALl/QvNCw0YDRgl/QsNC/0YAuX9C80LDQuV/QuNGO0L3RjF/QuNGO0LvRjF/QsNCy0LMuX9GB0LXQvdGCLl/QvtC60YIuX9C90L7Rj9CxLl/QtNC10LouXCIuc3BsaXQoXCJfXCIpfSx3ZWVrZGF5czp7c3RhbmRhbG9uZTpcItCy0L7RgdC60YDQtdGB0LXQvdGM0LVf0L/QvtC90LXQtNC10LvRjNC90LjQul/QstGC0L7RgNC90LjQul/RgdGA0LXQtNCwX9GH0LXRgtCy0LXRgNCzX9C/0Y/RgtC90LjRhtCwX9GB0YPQsdCx0L7RgtCwXCIuc3BsaXQoXCJfXCIpLGZvcm1hdDpcItCy0L7RgdC60YDQtdGB0LXQvdGM0LVf0L/QvtC90LXQtNC10LvRjNC90LjQul/QstGC0L7RgNC90LjQul/RgdGA0LXQtNGDX9GH0LXRgtCy0LXRgNCzX9C/0Y/RgtC90LjRhtGDX9GB0YPQsdCx0L7RgtGDXCIuc3BsaXQoXCJfXCIpLGlzRm9ybWF0Oi9cXFsgP1vQktCyXSA/KD860L/RgNC+0YjQu9GD0Y580YHQu9C10LTRg9GO0YnRg9GOfNGN0YLRgyk/ID9cXF0gP2RkZGQvfSx3ZWVrZGF5c1Nob3J0Olwi0LLRgV/Qv9C9X9Cy0YJf0YHRgF/Rh9GCX9C/0YJf0YHQsVwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcItCy0YFf0L/QvV/QstGCX9GB0YBf0YfRgl/Qv9GCX9GB0LFcIi5zcGxpdChcIl9cIiksbW9udGhzUGFyc2U6bixsb25nTW9udGhzUGFyc2U6bixzaG9ydE1vbnRoc1BhcnNlOm4sbW9udGhzUmVnZXg6L14o0Y/QvdCy0LDRgFvRjNGPXXzRj9C90LJcXC4/fNGE0LXQstGA0LDQu1vRjNGPXXzRhNC10LLRgD9cXC4/fNC80LDRgNGC0LA/fNC80LDRgFxcLj980LDQv9GA0LXQu1vRjNGPXXzQsNC/0YBcXC4/fNC80LBb0LnRj1180LjRjtC9W9GM0Y9dfNC40Y7QvVxcLj980LjRjtC7W9GM0Y9dfNC40Y7Qu1xcLj980LDQstCz0YPRgdGC0LA/fNCw0LLQs1xcLj980YHQtdC90YLRj9Cx0YBb0YzRj1180YHQtdC90YI/XFwuP3zQvtC60YLRj9Cx0YBb0YzRj1180L7QutGCXFwuP3zQvdC+0Y/QsdGAW9GM0Y9dfNC90L7Rj9CxP1xcLj980LTQtdC60LDQsdGAW9GM0Y9dfNC00LXQulxcLj8pL2ksbW9udGhzU2hvcnRSZWdleDovXijRj9C90LLQsNGAW9GM0Y9dfNGP0L3QslxcLj980YTQtdCy0YDQsNC7W9GM0Y9dfNGE0LXQstGAP1xcLj980LzQsNGA0YLQsD980LzQsNGAXFwuP3zQsNC/0YDQtdC7W9GM0Y9dfNCw0L/RgFxcLj980LzQsFvQudGPXXzQuNGO0L1b0YzRj1180LjRjtC9XFwuP3zQuNGO0Ltb0YzRj1180LjRjtC7XFwuP3zQsNCy0LPRg9GB0YLQsD980LDQstCzXFwuP3zRgdC10L3RgtGP0LHRgFvRjNGPXXzRgdC10L3Rgj9cXC4/fNC+0LrRgtGP0LHRgFvRjNGPXXzQvtC60YJcXC4/fNC90L7Rj9Cx0YBb0YzRj1180L3QvtGP0LE/XFwuP3zQtNC10LrQsNCx0YBb0YzRj1180LTQtdC6XFwuPykvaSxtb250aHNTdHJpY3RSZWdleDovXijRj9C90LLQsNGAW9GP0YxdfNGE0LXQstGA0LDQu1vRj9GMXXzQvNCw0YDRgtCwP3zQsNC/0YDQtdC7W9GP0YxdfNC80LBb0Y/QuV180LjRjtC9W9GP0YxdfNC40Y7Qu1vRj9GMXXzQsNCy0LPRg9GB0YLQsD980YHQtdC90YLRj9Cx0YBb0Y/RjF180L7QutGC0Y/QsdGAW9GP0YxdfNC90L7Rj9Cx0YBb0Y/RjF180LTQtdC60LDQsdGAW9GP0YxdKS9pLG1vbnRoc1Nob3J0U3RyaWN0UmVnZXg6L14o0Y/QvdCyXFwufNGE0LXQstGAP1xcLnzQvNCw0YBb0YIuXXzQsNC/0YBcXC580LzQsFvRj9C5XXzQuNGO0L1b0YzRjy5dfNC40Y7Qu1vRjNGPLl180LDQstCzXFwufNGB0LXQvdGCP1xcLnzQvtC60YJcXC580L3QvtGP0LE/XFwufNC00LXQulxcLikvaSxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJIOm1tXCIsTFRTOlwiSDptbTpzc1wiLEw6XCJERC5NTS5ZWVlZXCIsTEw6XCJEIE1NTU0gWVlZWSDQsy5cIixMTEw6XCJEIE1NTU0gWVlZWSDQsy4sIEg6bW1cIixMTExMOlwiZGRkZCwgRCBNTU1NIFlZWVkg0LMuLCBIOm1tXCJ9LGNhbGVuZGFyOntzYW1lRGF5OlwiW9Ch0LXQs9C+0LTQvdGPLCDQsl0gTFRcIixuZXh0RGF5OlwiW9CX0LDQstGC0YDQsCwg0LJdIExUXCIsbGFzdERheTpcIlvQktGH0LXRgNCwLCDQsl0gTFRcIixuZXh0V2VlazpmdW5jdGlvbihlKXtpZihlLndlZWsoKT09PXRoaXMud2VlaygpKXJldHVybiAyPT09dGhpcy5kYXkoKT9cIlvQktC+XSBkZGRkLCBb0LJdIExUXCI6XCJb0JJdIGRkZGQsIFvQsl0gTFRcIjtzd2l0Y2godGhpcy5kYXkoKSl7Y2FzZSAwOnJldHVyblwiW9CSINGB0LvQtdC00YPRjtGJ0LXQtV0gZGRkZCwgW9CyXSBMVFwiO2Nhc2UgMTpjYXNlIDI6Y2FzZSA0OnJldHVyblwiW9CSINGB0LvQtdC00YPRjtGJ0LjQuV0gZGRkZCwgW9CyXSBMVFwiO2Nhc2UgMzpjYXNlIDU6Y2FzZSA2OnJldHVyblwiW9CSINGB0LvQtdC00YPRjtGJ0YPRjl0gZGRkZCwgW9CyXSBMVFwifX0sbGFzdFdlZWs6ZnVuY3Rpb24oZSl7aWYoZS53ZWVrKCk9PT10aGlzLndlZWsoKSlyZXR1cm4gMj09PXRoaXMuZGF5KCk/XCJb0JLQvl0gZGRkZCwgW9CyXSBMVFwiOlwiW9CSXSBkZGRkLCBb0LJdIExUXCI7c3dpdGNoKHRoaXMuZGF5KCkpe2Nhc2UgMDpyZXR1cm5cIlvQkiDQv9GA0L7RiNC70L7QtV0gZGRkZCwgW9CyXSBMVFwiO2Nhc2UgMTpjYXNlIDI6Y2FzZSA0OnJldHVyblwiW9CSINC/0YDQvtGI0LvRi9C5XSBkZGRkLCBb0LJdIExUXCI7Y2FzZSAzOmNhc2UgNTpjYXNlIDY6cmV0dXJuXCJb0JIg0L/RgNC+0YjQu9GD0Y5dIGRkZGQsIFvQsl0gTFRcIn19LHNhbWVFbHNlOlwiTFwifSxyZWxhdGl2ZVRpbWU6e2Z1dHVyZTpcItGH0LXRgNC10LcgJXNcIixwYXN0OlwiJXMg0L3QsNC30LDQtFwiLHM6XCLQvdC10YHQutC+0LvRjNC60L4g0YHQtdC60YPQvdC0XCIsc3M6cixtOnIsbW06cixoOlwi0YfQsNGBXCIsaGg6cixkOlwi0LTQtdC90YxcIixkZDpyLE06XCLQvNC10YHRj9GGXCIsTU06cix5Olwi0LPQvtC0XCIseXk6cn0sbWVyaWRpZW1QYXJzZTov0L3QvtGH0Lh80YPRgtGA0LB80LTQvdGPfNCy0LXRh9C10YDQsC9pLGlzUE06ZnVuY3Rpb24oZSl7cmV0dXJuL14o0LTQvdGPfNCy0LXRh9C10YDQsCkkLy50ZXN0KGUpfSxtZXJpZGllbTpmdW5jdGlvbihlLHQscil7cmV0dXJuIGU8ND9cItC90L7Rh9C4XCI6ZTwxMj9cItGD0YLRgNCwXCI6ZTwxNz9cItC00L3Rj1wiOlwi0LLQtdGH0LXRgNCwXCJ9LGRheU9mTW9udGhPcmRpbmFsUGFyc2U6L1xcZHsxLDJ9LSjQuXzQs9C+fNGPKS8sb3JkaW5hbDpmdW5jdGlvbihlLHQpe3N3aXRjaCh0KXtjYXNlXCJNXCI6Y2FzZVwiZFwiOmNhc2VcIkRERFwiOnJldHVybiBlK1wiLdC5XCI7Y2FzZVwiRFwiOnJldHVybiBlK1wiLdCz0L5cIjtjYXNlXCJ3XCI6Y2FzZVwiV1wiOnJldHVybiBlK1wiLdGPXCI7ZGVmYXVsdDpyZXR1cm4gZX19LHdlZWs6e2RvdzoxLGRveTo0fX0pfSl9fSl9KTsiLCIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KHJlcXVpcmUoXCJtb21lbnRcIikscmVxdWlyZShcImZ1bGxjYWxlbmRhclwiKSk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJtb21lbnRcIixcImZ1bGxjYWxlbmRhclwiXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz90KHJlcXVpcmUoXCJtb21lbnRcIikscmVxdWlyZShcImZ1bGxjYWxlbmRhclwiKSk6dChlLm1vbWVudCxlLkZ1bGxDYWxlbmRhcil9KFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6dGhpcyxmdW5jdGlvbihlLHQpe3JldHVybiBmdW5jdGlvbihlKXtmdW5jdGlvbiB0KG4pe2lmKHJbbl0pcmV0dXJuIHJbbl0uZXhwb3J0czt2YXIgbz1yW25dPXtpOm4sbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtuXS5jYWxsKG8uZXhwb3J0cyxvLG8uZXhwb3J0cyx0KSxvLmw9ITAsby5leHBvcnRzfXZhciByPXt9O3JldHVybiB0Lm09ZSx0LmM9cix0LmQ9ZnVuY3Rpb24oZSxyLG4pe3QubyhlLHIpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxyLHtjb25maWd1cmFibGU6ITEsZW51bWVyYWJsZTohMCxnZXQ6bn0pfSx0Lm49ZnVuY3Rpb24oZSl7dmFyIHI9ZSYmZS5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIGUuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gZX07cmV0dXJuIHQuZChyLFwiYVwiLHIpLHJ9LHQubz1mdW5jdGlvbihlLHQpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSx0KX0sdC5wPVwiXCIsdCh0LnM9MTkxKX0oezA6ZnVuY3Rpb24odCxyKXt0LmV4cG9ydHM9ZX0sMTpmdW5jdGlvbihlLHIpe2UuZXhwb3J0cz10fSwxOTE6ZnVuY3Rpb24oZSx0LHIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHIoMTkyKTt2YXIgbj1yKDEpO24uZGF0ZXBpY2tlckxvY2FsZShcInNrXCIsXCJza1wiLHtjbG9zZVRleHQ6XCJaYXZyaWXFpVwiLHByZXZUZXh0OlwiJiN4M0M7UHJlZGNow6FkemFqw7pjaVwiLG5leHRUZXh0OlwiTmFzbGVkdWrDumNpJiN4M0U7XCIsY3VycmVudFRleHQ6XCJEbmVzXCIsbW9udGhOYW1lczpbXCJqYW51w6FyXCIsXCJmZWJydcOhclwiLFwibWFyZWNcIixcImFwcsOtbFwiLFwibcOhalwiLFwiasO6blwiLFwiasO6bFwiLFwiYXVndXN0XCIsXCJzZXB0ZW1iZXJcIixcIm9rdMOzYmVyXCIsXCJub3ZlbWJlclwiLFwiZGVjZW1iZXJcIl0sbW9udGhOYW1lc1Nob3J0OltcIkphblwiLFwiRmViXCIsXCJNYXJcIixcIkFwclwiLFwiTcOhalwiLFwiSsO6blwiLFwiSsO6bFwiLFwiQXVnXCIsXCJTZXBcIixcIk9rdFwiLFwiTm92XCIsXCJEZWNcIl0sZGF5TmFtZXM6W1wibmVkZcS+YVwiLFwicG9uZGVsb2tcIixcInV0b3Jva1wiLFwic3RyZWRhXCIsXCLFoXR2cnRva1wiLFwicGlhdG9rXCIsXCJzb2JvdGFcIl0sZGF5TmFtZXNTaG9ydDpbXCJOZWRcIixcIlBvblwiLFwiVXRvXCIsXCJTdHJcIixcIsWgdHZcIixcIlBpYVwiLFwiU29iXCJdLGRheU5hbWVzTWluOltcIk5lXCIsXCJQb1wiLFwiVXRcIixcIlN0XCIsXCLFoHRcIixcIlBpYVwiLFwiU29cIl0sd2Vla0hlYWRlcjpcIlR5XCIsZGF0ZUZvcm1hdDpcImRkLm1tLnl5XCIsZmlyc3REYXk6MSxpc1JUTDohMSxzaG93TW9udGhBZnRlclllYXI6ITEseWVhclN1ZmZpeDpcIlwifSksbi5sb2NhbGUoXCJza1wiLHtidXR0b25UZXh0Onttb250aDpcIk1lc2lhY1wiLHdlZWs6XCJUw73FvmRlxYhcIixkYXk6XCJEZcWIXCIsbGlzdDpcIlJvenZyaFwifSxhbGxEYXlUZXh0OlwiQ2Vsw70gZGXFiFwiLGV2ZW50TGltaXRUZXh0OmZ1bmN0aW9uKGUpe3JldHVyblwiK8SPYWzFoWllOiBcIitlfSxub0V2ZW50c01lc3NhZ2U6XCLFvWlhZG5lIGFrY2llIG5hIHpvYnJhemVuaWVcIn0pfSwxOTI6ZnVuY3Rpb24oZSx0LHIpeyFmdW5jdGlvbihlLHQpe3QocigwKSl9KDAsZnVuY3Rpb24oZSl7ZnVuY3Rpb24gdChlKXtyZXR1cm4gZT4xJiZlPDV9ZnVuY3Rpb24gcihlLHIsbixvKXt2YXIgYT1lK1wiIFwiO3N3aXRjaChuKXtjYXNlXCJzXCI6cmV0dXJuIHJ8fG8/XCJww6FyIHNla8O6bmRcIjpcInDDoXIgc2VrdW5kYW1pXCI7Y2FzZVwic3NcIjpyZXR1cm4gcnx8bz9hKyh0KGUpP1wic2VrdW5keVwiOlwic2Vrw7puZFwiKTphK1wic2VrdW5kYW1pXCI7Y2FzZVwibVwiOnJldHVybiByP1wibWluw7p0YVwiOm8/XCJtaW7DunR1XCI6XCJtaW7DunRvdVwiO2Nhc2VcIm1tXCI6cmV0dXJuIHJ8fG8/YSsodChlKT9cIm1pbsO6dHlcIjpcIm1pbsO6dFwiKTphK1wibWluw7p0YW1pXCI7Y2FzZVwiaFwiOnJldHVybiByP1wiaG9kaW5hXCI6bz9cImhvZGludVwiOlwiaG9kaW5vdVwiO2Nhc2VcImhoXCI6cmV0dXJuIHJ8fG8/YSsodChlKT9cImhvZGlueVwiOlwiaG9kw61uXCIpOmErXCJob2RpbmFtaVwiO2Nhc2VcImRcIjpyZXR1cm4gcnx8bz9cImRlxYhcIjpcImTFiG9tXCI7Y2FzZVwiZGRcIjpyZXR1cm4gcnx8bz9hKyh0KGUpP1wiZG5pXCI6XCJkbsOtXCIpOmErXCJkxYhhbWlcIjtjYXNlXCJNXCI6cmV0dXJuIHJ8fG8/XCJtZXNpYWNcIjpcIm1lc2lhY29tXCI7Y2FzZVwiTU1cIjpyZXR1cm4gcnx8bz9hKyh0KGUpP1wibWVzaWFjZVwiOlwibWVzaWFjb3ZcIik6YStcIm1lc2lhY21pXCI7Y2FzZVwieVwiOnJldHVybiByfHxvP1wicm9rXCI6XCJyb2tvbVwiO2Nhc2VcInl5XCI6cmV0dXJuIHJ8fG8/YSsodChlKT9cInJva3lcIjpcInJva292XCIpOmErXCJyb2ttaVwifX12YXIgbj1cImphbnXDoXJfZmVicnXDoXJfbWFyZWNfYXByw61sX23DoWpfasO6bl9qw7psX2F1Z3VzdF9zZXB0ZW1iZXJfb2t0w7NiZXJfbm92ZW1iZXJfZGVjZW1iZXJcIi5zcGxpdChcIl9cIiksbz1cImphbl9mZWJfbWFyX2Fwcl9tw6FqX2rDum5fasO6bF9hdWdfc2VwX29rdF9ub3ZfZGVjXCIuc3BsaXQoXCJfXCIpO3JldHVybiBlLmRlZmluZUxvY2FsZShcInNrXCIse21vbnRoczpuLG1vbnRoc1Nob3J0Om8sd2Vla2RheXM6XCJuZWRlxL5hX3BvbmRlbG9rX3V0b3Jva19zdHJlZGFfxaF0dnJ0b2tfcGlhdG9rX3NvYm90YVwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c1Nob3J0OlwibmVfcG9fdXRfc3RfxaF0X3BpX3NvXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzTWluOlwibmVfcG9fdXRfc3RfxaF0X3BpX3NvXCIuc3BsaXQoXCJfXCIpLGxvbmdEYXRlRm9ybWF0OntMVDpcIkg6bW1cIixMVFM6XCJIOm1tOnNzXCIsTDpcIkRELk1NLllZWVlcIixMTDpcIkQuIE1NTU0gWVlZWVwiLExMTDpcIkQuIE1NTU0gWVlZWSBIOm1tXCIsTExMTDpcImRkZGQgRC4gTU1NTSBZWVlZIEg6bW1cIn0sY2FsZW5kYXI6e3NhbWVEYXk6XCJbZG5lcyBvXSBMVFwiLG5leHREYXk6XCJbemFqdHJhIG9dIExUXCIsbmV4dFdlZWs6ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5kYXkoKSl7Y2FzZSAwOnJldHVyblwiW3YgbmVkZcS+dSBvXSBMVFwiO2Nhc2UgMTpjYXNlIDI6cmV0dXJuXCJbdl0gZGRkZCBbb10gTFRcIjtjYXNlIDM6cmV0dXJuXCJbdiBzdHJlZHUgb10gTFRcIjtjYXNlIDQ6cmV0dXJuXCJbdm8gxaF0dnJ0b2sgb10gTFRcIjtjYXNlIDU6cmV0dXJuXCJbdiBwaWF0b2sgb10gTFRcIjtjYXNlIDY6cmV0dXJuXCJbdiBzb2JvdHUgb10gTFRcIn19LGxhc3REYXk6XCJbdsSNZXJhIG9dIExUXCIsbGFzdFdlZWs6ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5kYXkoKSl7Y2FzZSAwOnJldHVyblwiW21pbnVsw7ogbmVkZcS+dSBvXSBMVFwiO2Nhc2UgMTpjYXNlIDI6cmV0dXJuXCJbbWludWzDvV0gZGRkZCBbb10gTFRcIjtjYXNlIDM6cmV0dXJuXCJbbWludWzDuiBzdHJlZHUgb10gTFRcIjtjYXNlIDQ6Y2FzZSA1OnJldHVyblwiW21pbnVsw71dIGRkZGQgW29dIExUXCI7Y2FzZSA2OnJldHVyblwiW21pbnVsw7ogc29ib3R1IG9dIExUXCJ9fSxzYW1lRWxzZTpcIkxcIn0scmVsYXRpdmVUaW1lOntmdXR1cmU6XCJ6YSAlc1wiLHBhc3Q6XCJwcmVkICVzXCIsczpyLHNzOnIsbTpyLG1tOnIsaDpyLGhoOnIsZDpyLGRkOnIsTTpyLE1NOnIseTpyLHl5OnJ9LGRheU9mTW9udGhPcmRpbmFsUGFyc2U6L1xcZHsxLDJ9XFwuLyxvcmRpbmFsOlwiJWQuXCIsd2Vlazp7ZG93OjEsZG95OjR9fSl9KX19KX0pOyIsIiFmdW5jdGlvbihlLHIpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXIocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIm1vbWVudFwiLFwiZnVsbGNhbGVuZGFyXCJdLHIpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP3IocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpyKGUubW9tZW50LGUuRnVsbENhbGVuZGFyKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUscil7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHIobil7aWYodFtuXSlyZXR1cm4gdFtuXS5leHBvcnRzO3ZhciBhPXRbbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW25dLmNhbGwoYS5leHBvcnRzLGEsYS5leHBvcnRzLHIpLGEubD0hMCxhLmV4cG9ydHN9dmFyIHQ9e307cmV0dXJuIHIubT1lLHIuYz10LHIuZD1mdW5jdGlvbihlLHQsbil7ci5vKGUsdCl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLHQse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpufSl9LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsXCJhXCIsdCksdH0sci5vPWZ1bmN0aW9uKGUscil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHIpfSxyLnA9XCJcIixyKHIucz0yMDEpfSh7MDpmdW5jdGlvbihyLHQpe3IuZXhwb3J0cz1lfSwxOmZ1bmN0aW9uKGUsdCl7ZS5leHBvcnRzPXJ9LDIwMTpmdW5jdGlvbihlLHIsdCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksdCgyMDIpO3ZhciBuPXQoMSk7bi5kYXRlcGlja2VyTG9jYWxlKFwic3ZcIixcInN2XCIse2Nsb3NlVGV4dDpcIlN0w6RuZ1wiLHByZXZUZXh0OlwiJiN4QUI7RsO2cnJhXCIsbmV4dFRleHQ6XCJOw6RzdGEmI3hCQjtcIixjdXJyZW50VGV4dDpcIklkYWdcIixtb250aE5hbWVzOltcIkphbnVhcmlcIixcIkZlYnJ1YXJpXCIsXCJNYXJzXCIsXCJBcHJpbFwiLFwiTWFqXCIsXCJKdW5pXCIsXCJKdWxpXCIsXCJBdWd1c3RpXCIsXCJTZXB0ZW1iZXJcIixcIk9rdG9iZXJcIixcIk5vdmVtYmVyXCIsXCJEZWNlbWJlclwiXSxtb250aE5hbWVzU2hvcnQ6W1wiSmFuXCIsXCJGZWJcIixcIk1hclwiLFwiQXByXCIsXCJNYWpcIixcIkp1blwiLFwiSnVsXCIsXCJBdWdcIixcIlNlcFwiLFwiT2t0XCIsXCJOb3ZcIixcIkRlY1wiXSxkYXlOYW1lc1Nob3J0OltcIlPDtm5cIixcIk3DpW5cIixcIlRpc1wiLFwiT25zXCIsXCJUb3JcIixcIkZyZVwiLFwiTMO2clwiXSxkYXlOYW1lczpbXCJTw7ZuZGFnXCIsXCJNw6VuZGFnXCIsXCJUaXNkYWdcIixcIk9uc2RhZ1wiLFwiVG9yc2RhZ1wiLFwiRnJlZGFnXCIsXCJMw7ZyZGFnXCJdLGRheU5hbWVzTWluOltcIlPDtlwiLFwiTcOlXCIsXCJUaVwiLFwiT25cIixcIlRvXCIsXCJGclwiLFwiTMO2XCJdLHdlZWtIZWFkZXI6XCJ2LiBcIixkYXRlRm9ybWF0OlwieXktbW0tZGRcIixmaXJzdERheToxLGlzUlRMOiExLHNob3dNb250aEFmdGVyWWVhcjohMSx5ZWFyU3VmZml4OlwiXCJ9KSxuLmxvY2FsZShcInN2XCIse2J1dHRvblRleHQ6e21vbnRoOlwiTcOlbmFkXCIsd2VlazpcIlZlY2thXCIsZGF5OlwiRGFnXCIsbGlzdDpcIlByb2dyYW1cIn0sYWxsRGF5VGV4dDpcIkhlbGRhZ1wiLGV2ZW50TGltaXRUZXh0OlwidGlsbFwiLG5vRXZlbnRzTWVzc2FnZTpcIkluZ2EgaMOkbmRlbHNlciBhdHQgdmlzYVwifSl9LDIwMjpmdW5jdGlvbihlLHIsdCl7IWZ1bmN0aW9uKGUscil7cih0KDApKX0oMCxmdW5jdGlvbihlKXtyZXR1cm4gZS5kZWZpbmVMb2NhbGUoXCJzdlwiLHttb250aHM6XCJqYW51YXJpX2ZlYnJ1YXJpX21hcnNfYXByaWxfbWFqX2p1bmlfanVsaV9hdWd1c3RpX3NlcHRlbWJlcl9va3RvYmVyX25vdmVtYmVyX2RlY2VtYmVyXCIuc3BsaXQoXCJfXCIpLG1vbnRoc1Nob3J0OlwiamFuX2ZlYl9tYXJfYXByX21hal9qdW5fanVsX2F1Z19zZXBfb2t0X25vdl9kZWNcIi5zcGxpdChcIl9cIiksd2Vla2RheXM6XCJzw7ZuZGFnX23DpW5kYWdfdGlzZGFnX29uc2RhZ190b3JzZGFnX2ZyZWRhZ19sw7ZyZGFnXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzU2hvcnQ6XCJzw7ZuX23DpW5fdGlzX29uc190b3JfZnJlX2zDtnJcIi5zcGxpdChcIl9cIiksd2Vla2RheXNNaW46XCJzw7ZfbcOlX3RpX29uX3RvX2ZyX2zDtlwiLnNwbGl0KFwiX1wiKSxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJISDptbVwiLExUUzpcIkhIOm1tOnNzXCIsTDpcIllZWVktTU0tRERcIixMTDpcIkQgTU1NTSBZWVlZXCIsTExMOlwiRCBNTU1NIFlZWVkgW2tsLl0gSEg6bW1cIixMTExMOlwiZGRkZCBEIE1NTU0gWVlZWSBba2wuXSBISDptbVwiLGxsbDpcIkQgTU1NIFlZWVkgSEg6bW1cIixsbGxsOlwiZGRkIEQgTU1NIFlZWVkgSEg6bW1cIn0sY2FsZW5kYXI6e3NhbWVEYXk6XCJbSWRhZ10gTFRcIixuZXh0RGF5OlwiW0ltb3Jnb25dIExUXCIsbGFzdERheTpcIltJZ8Olcl0gTFRcIixuZXh0V2VlazpcIltQw6VdIGRkZGQgTFRcIixsYXN0V2VlazpcIltJXSBkZGRkW3NdIExUXCIsc2FtZUVsc2U6XCJMXCJ9LHJlbGF0aXZlVGltZTp7ZnV0dXJlOlwib20gJXNcIixwYXN0OlwiZsO2ciAlcyBzZWRhblwiLHM6XCJuw6VncmEgc2VrdW5kZXJcIixzczpcIiVkIHNla3VuZGVyXCIsbTpcImVuIG1pbnV0XCIsbW06XCIlZCBtaW51dGVyXCIsaDpcImVuIHRpbW1lXCIsaGg6XCIlZCB0aW1tYXJcIixkOlwiZW4gZGFnXCIsZGQ6XCIlZCBkYWdhclwiLE06XCJlbiBtw6VuYWRcIixNTTpcIiVkIG3DpW5hZGVyXCIseTpcImV0dCDDpXJcIix5eTpcIiVkIMOlclwifSxkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOi9cXGR7MSwyfShcXDplfFxcOmEpLyxvcmRpbmFsOmZ1bmN0aW9uKGUpe3ZhciByPWUlMTA7cmV0dXJuIGUrKDE9PX5+KGUlMTAwLzEwKT9cIjplXCI6MT09PXI/XCI6YVwiOjI9PT1yP1wiOmFcIjpcIjplXCIpfSx3ZWVrOntkb3c6MSxkb3k6NH19KX0pfX0pfSk7IiwiIWZ1bmN0aW9uKGUsYSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9YShyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wibW9tZW50XCIsXCJmdWxsY2FsZW5kYXJcIl0sYSk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/YShyZXF1aXJlKFwibW9tZW50XCIpLHJlcXVpcmUoXCJmdWxsY2FsZW5kYXJcIikpOmEoZS5tb21lbnQsZS5GdWxsQ2FsZW5kYXIpfShcInVuZGVmaW5lZFwiIT10eXBlb2Ygc2VsZj9zZWxmOnRoaXMsZnVuY3Rpb24oZSxhKXtyZXR1cm4gZnVuY3Rpb24oZSl7ZnVuY3Rpb24gYShuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIHI9dFtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChyLmV4cG9ydHMscixyLmV4cG9ydHMsYSksci5sPSEwLHIuZXhwb3J0c312YXIgdD17fTtyZXR1cm4gYS5tPWUsYS5jPXQsYS5kPWZ1bmN0aW9uKGUsdCxuKXthLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7Y29uZmlndXJhYmxlOiExLGVudW1lcmFibGU6ITAsZ2V0Om59KX0sYS5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiBhLmQodCxcImFcIix0KSx0fSxhLm89ZnVuY3Rpb24oZSxhKXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsYSl9LGEucD1cIlwiLGEoYS5zPTIwNSl9KHswOmZ1bmN0aW9uKGEsdCl7YS5leHBvcnRzPWV9LDE6ZnVuY3Rpb24oZSx0KXtlLmV4cG9ydHM9YX0sMjA1OmZ1bmN0aW9uKGUsYSx0KXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSx0KDIwNik7dmFyIG49dCgxKTtuLmRhdGVwaWNrZXJMb2NhbGUoXCJ0clwiLFwidHJcIix7Y2xvc2VUZXh0Olwia2FwYXRcIixwcmV2VGV4dDpcIiYjeDNDO2dlcmlcIixuZXh0VGV4dDpcImlsZXJpJiN4M2VcIixjdXJyZW50VGV4dDpcImJ1Z8O8blwiLG1vbnRoTmFtZXM6W1wiT2Nha1wiLFwixZ51YmF0XCIsXCJNYXJ0XCIsXCJOaXNhblwiLFwiTWF5xLFzXCIsXCJIYXppcmFuXCIsXCJUZW1tdXpcIixcIkHEn3VzdG9zXCIsXCJFeWzDvGxcIixcIkVraW1cIixcIkthc8SxbVwiLFwiQXJhbMSxa1wiXSxtb250aE5hbWVzU2hvcnQ6W1wiT2NhXCIsXCLFnnViXCIsXCJNYXJcIixcIk5pc1wiLFwiTWF5XCIsXCJIYXpcIixcIlRlbVwiLFwiQcSfdVwiLFwiRXlsXCIsXCJFa2lcIixcIkthc1wiLFwiQXJhXCJdLGRheU5hbWVzOltcIlBhemFyXCIsXCJQYXphcnRlc2lcIixcIlNhbMSxXCIsXCLDh2FyxZ9hbWJhXCIsXCJQZXLFn2VtYmVcIixcIkN1bWFcIixcIkN1bWFydGVzaVwiXSxkYXlOYW1lc1Nob3J0OltcIlB6XCIsXCJQdFwiLFwiU2FcIixcIsOHYVwiLFwiUGVcIixcIkN1XCIsXCJDdFwiXSxkYXlOYW1lc01pbjpbXCJQelwiLFwiUHRcIixcIlNhXCIsXCLDh2FcIixcIlBlXCIsXCJDdVwiLFwiQ3RcIl0sd2Vla0hlYWRlcjpcIkhmXCIsZGF0ZUZvcm1hdDpcImRkLm1tLnl5XCIsZmlyc3REYXk6MSxpc1JUTDohMSxzaG93TW9udGhBZnRlclllYXI6ITEseWVhclN1ZmZpeDpcIlwifSksbi5sb2NhbGUoXCJ0clwiLHtidXR0b25UZXh0OntuZXh0OlwiaWxlcmlcIixtb250aDpcIkF5XCIsd2VlazpcIkhhZnRhXCIsZGF5OlwiR8O8blwiLGxpc3Q6XCJBamFuZGFcIn0sYWxsRGF5VGV4dDpcIlTDvG0gZ8O8blwiLGV2ZW50TGltaXRUZXh0OlwiZGFoYSBmYXpsYVwiLG5vRXZlbnRzTWVzc2FnZTpcIkfDtnN0ZXJpbGVjZWsgZXRraW5saWsgeW9rXCJ9KX0sMjA2OmZ1bmN0aW9uKGUsYSx0KXshZnVuY3Rpb24oZSxhKXthKHQoMCkpfSgwLGZ1bmN0aW9uKGUpe3ZhciBhPXsxOlwiJ2luY2lcIiw1OlwiJ2luY2lcIiw4OlwiJ2luY2lcIiw3MDpcIidpbmNpXCIsODA6XCInaW5jaVwiLDI6XCInbmNpXCIsNzpcIiduY2lcIiwyMDpcIiduY2lcIiw1MDpcIiduY2lcIiwzOlwiJ8O8bmPDvFwiLDQ6XCInw7xuY8O8XCIsMTAwOlwiJ8O8bmPDvFwiLDY6XCInbmPEsVwiLDk6XCIndW5jdVwiLDEwOlwiJ3VuY3VcIiwzMDpcIid1bmN1XCIsNjA6XCInxLFuY8SxXCIsOTA6XCInxLFuY8SxXCJ9O3JldHVybiBlLmRlZmluZUxvY2FsZShcInRyXCIse21vbnRoczpcIk9jYWtfxZ51YmF0X01hcnRfTmlzYW5fTWF5xLFzX0hhemlyYW5fVGVtbXV6X0HEn3VzdG9zX0V5bMO8bF9Fa2ltX0thc8SxbV9BcmFsxLFrXCIuc3BsaXQoXCJfXCIpLG1vbnRoc1Nob3J0OlwiT2NhX8WedWJfTWFyX05pc19NYXlfSGF6X1RlbV9BxJ91X0V5bF9Fa2lfS2FzX0FyYVwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5czpcIlBhemFyX1BhemFydGVzaV9TYWzEsV/Dh2FyxZ9hbWJhX1BlcsWfZW1iZV9DdW1hX0N1bWFydGVzaVwiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c1Nob3J0OlwiUGF6X1B0c19TYWxfw4dhcl9QZXJfQ3VtX0N0c1wiLnNwbGl0KFwiX1wiKSx3ZWVrZGF5c01pbjpcIlB6X1B0X1NhX8OHYV9QZV9DdV9DdFwiLnNwbGl0KFwiX1wiKSxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJISDptbVwiLExUUzpcIkhIOm1tOnNzXCIsTDpcIkRELk1NLllZWVlcIixMTDpcIkQgTU1NTSBZWVlZXCIsTExMOlwiRCBNTU1NIFlZWVkgSEg6bW1cIixMTExMOlwiZGRkZCwgRCBNTU1NIFlZWVkgSEg6bW1cIn0sY2FsZW5kYXI6e3NhbWVEYXk6XCJbYnVnw7xuIHNhYXRdIExUXCIsbmV4dERheTpcIlt5YXLEsW4gc2FhdF0gTFRcIixuZXh0V2VlazpcIltnZWxlY2VrXSBkZGRkIFtzYWF0XSBMVFwiLGxhc3REYXk6XCJbZMO8bl0gTFRcIixsYXN0V2VlazpcIltnZcOnZW5dIGRkZGQgW3NhYXRdIExUXCIsc2FtZUVsc2U6XCJMXCJ9LHJlbGF0aXZlVGltZTp7ZnV0dXJlOlwiJXMgc29ucmFcIixwYXN0OlwiJXMgw7ZuY2VcIixzOlwiYmlya2HDpyBzYW5peWVcIixzczpcIiVkIHNhbml5ZVwiLG06XCJiaXIgZGFraWthXCIsbW06XCIlZCBkYWtpa2FcIixoOlwiYmlyIHNhYXRcIixoaDpcIiVkIHNhYXRcIixkOlwiYmlyIGfDvG5cIixkZDpcIiVkIGfDvG5cIixNOlwiYmlyIGF5XCIsTU06XCIlZCBheVwiLHk6XCJiaXIgecSxbFwiLHl5OlwiJWQgecSxbFwifSxvcmRpbmFsOmZ1bmN0aW9uKGUsdCl7c3dpdGNoKHQpe2Nhc2VcImRcIjpjYXNlXCJEXCI6Y2FzZVwiRG9cIjpjYXNlXCJERFwiOnJldHVybiBlO2RlZmF1bHQ6aWYoMD09PWUpcmV0dXJuIGUrXCInxLFuY8SxXCI7dmFyIG49ZSUxMCxyPWUlMTAwLW4saT1lPj0xMDA/MTAwOm51bGw7cmV0dXJuIGUrKGFbbl18fGFbcl18fGFbaV0pfX0sd2Vlazp7ZG93OjEsZG95Ojd9fSl9KX19KX0pOyIsIiFmdW5jdGlvbih0LG4pe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPW4ocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIm1vbWVudFwiLFwiZnVsbGNhbGVuZGFyXCJdLG4pOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP24ocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpuKHQubW9tZW50LHQuRnVsbENhbGVuZGFyKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKHQsbil7cmV0dXJuIGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIG4oaCl7aWYoZVtoXSlyZXR1cm4gZVtoXS5leHBvcnRzO3ZhciByPWVbaF09e2k6aCxsOiExLGV4cG9ydHM6e319O3JldHVybiB0W2hdLmNhbGwoci5leHBvcnRzLHIsci5leHBvcnRzLG4pLHIubD0hMCxyLmV4cG9ydHN9dmFyIGU9e307cmV0dXJuIG4ubT10LG4uYz1lLG4uZD1mdW5jdGlvbih0LGUsaCl7bi5vKHQsZSl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpofSl9LG4ubj1mdW5jdGlvbih0KXt2YXIgZT10JiZ0Ll9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gdC5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiB0fTtyZXR1cm4gbi5kKGUsXCJhXCIsZSksZX0sbi5vPWZ1bmN0aW9uKHQsbil7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LG4pfSxuLnA9XCJcIixuKG4ucz0yMDkpfSh7MDpmdW5jdGlvbihuLGUpe24uZXhwb3J0cz10fSwxOmZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPW59LDIwOTpmdW5jdGlvbih0LG4sZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZSgyMTApO3ZhciBoPWUoMSk7aC5kYXRlcGlja2VyTG9jYWxlKFwidmlcIixcInZpXCIse2Nsb3NlVGV4dDpcIsSQw7NuZ1wiLHByZXZUZXh0OlwiJiN4M0M7VHLGsOG7m2NcIixuZXh0VGV4dDpcIlRp4bq/cCYjeDNFO1wiLGN1cnJlbnRUZXh0OlwiSMO0bSBuYXlcIixtb250aE5hbWVzOltcIlRow6FuZyBN4buZdFwiLFwiVGjDoW5nIEhhaVwiLFwiVGjDoW5nIEJhXCIsXCJUaMOhbmcgVMawXCIsXCJUaMOhbmcgTsSDbVwiLFwiVGjDoW5nIFPDoXVcIixcIlRow6FuZyBC4bqjeVwiLFwiVGjDoW5nIFTDoW1cIixcIlRow6FuZyBDaMOtblwiLFwiVGjDoW5nIE3GsOG7nWlcIixcIlRow6FuZyBNxrDhu51pIE3hu5l0XCIsXCJUaMOhbmcgTcaw4budaSBIYWlcIl0sbW9udGhOYW1lc1Nob3J0OltcIlRow6FuZyAxXCIsXCJUaMOhbmcgMlwiLFwiVGjDoW5nIDNcIixcIlRow6FuZyA0XCIsXCJUaMOhbmcgNVwiLFwiVGjDoW5nIDZcIixcIlRow6FuZyA3XCIsXCJUaMOhbmcgOFwiLFwiVGjDoW5nIDlcIixcIlRow6FuZyAxMFwiLFwiVGjDoW5nIDExXCIsXCJUaMOhbmcgMTJcIl0sZGF5TmFtZXM6W1wiQ2jhu6cgTmjhuq10XCIsXCJUaOG7qSBIYWlcIixcIlRo4bupIEJhXCIsXCJUaOG7qSBUxrBcIixcIlRo4bupIE7Eg21cIixcIlRo4bupIFPDoXVcIixcIlRo4bupIELhuqN5XCJdLGRheU5hbWVzU2hvcnQ6W1wiQ05cIixcIlQyXCIsXCJUM1wiLFwiVDRcIixcIlQ1XCIsXCJUNlwiLFwiVDdcIl0sZGF5TmFtZXNNaW46W1wiQ05cIixcIlQyXCIsXCJUM1wiLFwiVDRcIixcIlQ1XCIsXCJUNlwiLFwiVDdcIl0sd2Vla0hlYWRlcjpcIlR1XCIsZGF0ZUZvcm1hdDpcImRkL21tL3l5XCIsZmlyc3REYXk6MCxpc1JUTDohMSxzaG93TW9udGhBZnRlclllYXI6ITEseWVhclN1ZmZpeDpcIlwifSksaC5sb2NhbGUoXCJ2aVwiLHtidXR0b25UZXh0Onttb250aDpcIlRow6FuZ1wiLHdlZWs6XCJUdcOizIBuXCIsZGF5OlwiTmfDoHlcIixsaXN0OlwiTOG7i2NoIGJp4buDdVwifSxhbGxEYXlUZXh0OlwiQ+G6oyBuZ8OgeVwiLGV2ZW50TGltaXRUZXh0OmZ1bmN0aW9uKHQpe3JldHVyblwiKyB0aMOqbSBcIit0fSxub0V2ZW50c01lc3NhZ2U6XCJLaMO0bmcgY8OzIHPhu7Ega2nhu4duIMSR4buDIGhp4buDbiB0aOG7i1wifSl9LDIxMDpmdW5jdGlvbih0LG4sZSl7IWZ1bmN0aW9uKHQsbil7bihlKDApKX0oMCxmdW5jdGlvbih0KXtyZXR1cm4gdC5kZWZpbmVMb2NhbGUoXCJ2aVwiLHttb250aHM6XCJ0aMOhbmcgMV90aMOhbmcgMl90aMOhbmcgM190aMOhbmcgNF90aMOhbmcgNV90aMOhbmcgNl90aMOhbmcgN190aMOhbmcgOF90aMOhbmcgOV90aMOhbmcgMTBfdGjDoW5nIDExX3Row6FuZyAxMlwiLnNwbGl0KFwiX1wiKSxtb250aHNTaG9ydDpcIlRoMDFfVGgwMl9UaDAzX1RoMDRfVGgwNV9UaDA2X1RoMDdfVGgwOF9UaDA5X1RoMTBfVGgxMV9UaDEyXCIuc3BsaXQoXCJfXCIpLG1vbnRoc1BhcnNlRXhhY3Q6ITAsd2Vla2RheXM6XCJjaOG7pyBuaOG6rXRfdGjhu6kgaGFpX3Ro4bupIGJhX3Ro4bupIHTGsF90aOG7qSBuxINtX3Ro4bupIHPDoXVfdGjhu6kgYuG6o3lcIi5zcGxpdChcIl9cIiksd2Vla2RheXNTaG9ydDpcIkNOX1QyX1QzX1Q0X1Q1X1Q2X1Q3XCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzTWluOlwiQ05fVDJfVDNfVDRfVDVfVDZfVDdcIi5zcGxpdChcIl9cIiksd2Vla2RheXNQYXJzZUV4YWN0OiEwLG1lcmlkaWVtUGFyc2U6L3NhfGNoL2ksaXNQTTpmdW5jdGlvbih0KXtyZXR1cm4vXmNoJC9pLnRlc3QodCl9LG1lcmlkaWVtOmZ1bmN0aW9uKHQsbixlKXtyZXR1cm4gdDwxMj9lP1wic2FcIjpcIlNBXCI6ZT9cImNoXCI6XCJDSFwifSxsb25nRGF0ZUZvcm1hdDp7TFQ6XCJISDptbVwiLExUUzpcIkhIOm1tOnNzXCIsTDpcIkREL01NL1lZWVlcIixMTDpcIkQgTU1NTSBbbsSDbV0gWVlZWVwiLExMTDpcIkQgTU1NTSBbbsSDbV0gWVlZWSBISDptbVwiLExMTEw6XCJkZGRkLCBEIE1NTU0gW27Eg21dIFlZWVkgSEg6bW1cIixsOlwiREQvTS9ZWVlZXCIsbGw6XCJEIE1NTSBZWVlZXCIsbGxsOlwiRCBNTU0gWVlZWSBISDptbVwiLGxsbGw6XCJkZGQsIEQgTU1NIFlZWVkgSEg6bW1cIn0sY2FsZW5kYXI6e3NhbWVEYXk6XCJbSMO0bSBuYXkgbMO6Y10gTFRcIixuZXh0RGF5OlwiW05nw6B5IG1haSBsw7pjXSBMVFwiLG5leHRXZWVrOlwiZGRkZCBbdHXhuqduIHThu5tpIGzDumNdIExUXCIsbGFzdERheTpcIltIw7RtIHF1YSBsw7pjXSBMVFwiLGxhc3RXZWVrOlwiZGRkZCBbdHXhuqduIHRyxrDhu5tjIGzDumNdIExUXCIsc2FtZUVsc2U6XCJMXCJ9LHJlbGF0aXZlVGltZTp7ZnV0dXJlOlwiJXMgdOG7m2lcIixwYXN0OlwiJXMgdHLGsOG7m2NcIixzOlwidsOgaSBnacOieVwiLHNzOlwiJWQgZ2nDonlcIixtOlwibeG7mXQgcGjDunRcIixtbTpcIiVkIHBow7p0XCIsaDpcIm3hu5l0IGdp4budXCIsaGg6XCIlZCBnaeG7nVwiLGQ6XCJt4buZdCBuZ8OgeVwiLGRkOlwiJWQgbmfDoHlcIixNOlwibeG7mXQgdGjDoW5nXCIsTU06XCIlZCB0aMOhbmdcIix5OlwibeG7mXQgbsSDbVwiLHl5OlwiJWQgbsSDbVwifSxkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOi9cXGR7MSwyfS8sb3JkaW5hbDpmdW5jdGlvbih0KXtyZXR1cm4gdH0sd2Vlazp7ZG93OjEsZG95OjR9fSl9KX19KX0pOyIsIiFmdW5jdGlvbihlLHQpe1wib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP21vZHVsZS5leHBvcnRzPXQocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcIm1vbWVudFwiLFwiZnVsbGNhbGVuZGFyXCJdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzP3QocmVxdWlyZShcIm1vbWVudFwiKSxyZXF1aXJlKFwiZnVsbGNhbGVuZGFyXCIpKTp0KGUubW9tZW50LGUuRnVsbENhbGVuZGFyKX0oXCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjp0aGlzLGZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKGUpe2Z1bmN0aW9uIHQocil7aWYobltyXSlyZXR1cm4gbltyXS5leHBvcnRzO3ZhciBvPW5bcl09e2k6cixsOiExLGV4cG9ydHM6e319O3JldHVybiBlW3JdLmNhbGwoby5leHBvcnRzLG8sby5leHBvcnRzLHQpLG8ubD0hMCxvLmV4cG9ydHN9dmFyIG49e307cmV0dXJuIHQubT1lLHQuYz1uLHQuZD1mdW5jdGlvbihlLG4scil7dC5vKGUsbil8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se2NvbmZpZ3VyYWJsZTohMSxlbnVtZXJhYmxlOiEwLGdldDpyfSl9LHQubj1mdW5jdGlvbihlKXt2YXIgbj1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gdC5kKG4sXCJhXCIsbiksbn0sdC5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSx0LnA9XCJcIix0KHQucz0yMTEpfSh7MDpmdW5jdGlvbih0LG4pe3QuZXhwb3J0cz1lfSwxOmZ1bmN0aW9uKGUsbil7ZS5leHBvcnRzPXR9LDIxMTpmdW5jdGlvbihlLHQsbil7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksbigyMTIpO3ZhciByPW4oMSk7ci5kYXRlcGlja2VyTG9jYWxlKFwiemgtY25cIixcInpoLUNOXCIse2Nsb3NlVGV4dDpcIuWFs+mXrVwiLHByZXZUZXh0OlwiJiN4M0M75LiK5pyIXCIsbmV4dFRleHQ6XCLkuIvmnIgmI3gzRTtcIixjdXJyZW50VGV4dDpcIuS7iuWkqVwiLG1vbnRoTmFtZXM6W1wi5LiA5pyIXCIsXCLkuozmnIhcIixcIuS4ieaciFwiLFwi5Zub5pyIXCIsXCLkupTmnIhcIixcIuWFreaciFwiLFwi5LiD5pyIXCIsXCLlhavmnIhcIixcIuS5neaciFwiLFwi5Y2B5pyIXCIsXCLljYHkuIDmnIhcIixcIuWNgeS6jOaciFwiXSxtb250aE5hbWVzU2hvcnQ6W1wi5LiA5pyIXCIsXCLkuozmnIhcIixcIuS4ieaciFwiLFwi5Zub5pyIXCIsXCLkupTmnIhcIixcIuWFreaciFwiLFwi5LiD5pyIXCIsXCLlhavmnIhcIixcIuS5neaciFwiLFwi5Y2B5pyIXCIsXCLljYHkuIDmnIhcIixcIuWNgeS6jOaciFwiXSxkYXlOYW1lczpbXCLmmJ/mnJ/ml6VcIixcIuaYn+acn+S4gFwiLFwi5pif5pyf5LqMXCIsXCLmmJ/mnJ/kuIlcIixcIuaYn+acn+Wbm1wiLFwi5pif5pyf5LqUXCIsXCLmmJ/mnJ/lha1cIl0sZGF5TmFtZXNTaG9ydDpbXCLlkajml6VcIixcIuWRqOS4gFwiLFwi5ZGo5LqMXCIsXCLlkajkuIlcIixcIuWRqOWbm1wiLFwi5ZGo5LqUXCIsXCLlkajlha1cIl0sZGF5TmFtZXNNaW46W1wi5pelXCIsXCLkuIBcIixcIuS6jFwiLFwi5LiJXCIsXCLlm5tcIixcIuS6lFwiLFwi5YWtXCJdLHdlZWtIZWFkZXI6XCLlkahcIixkYXRlRm9ybWF0OlwieXktbW0tZGRcIixmaXJzdERheToxLGlzUlRMOiExLHNob3dNb250aEFmdGVyWWVhcjohMCx5ZWFyU3VmZml4Olwi5bm0XCJ9KSxyLmxvY2FsZShcInpoLWNuXCIse2J1dHRvblRleHQ6e21vbnRoOlwi5pyIXCIsd2VlazpcIuWRqFwiLGRheTpcIuaXpVwiLGxpc3Q6XCLml6XnqItcIn0sYWxsRGF5VGV4dDpcIuWFqOWkqVwiLGV2ZW50TGltaXRUZXh0OmZ1bmN0aW9uKGUpe3JldHVyblwi5Y+m5aSWIFwiK2UrXCIg5LiqXCJ9LG5vRXZlbnRzTWVzc2FnZTpcIuayoeacieS6i+S7tuaYvuekulwifSl9LDIxMjpmdW5jdGlvbihlLHQsbil7IWZ1bmN0aW9uKGUsdCl7dChuKDApKX0oMCxmdW5jdGlvbihlKXtyZXR1cm4gZS5kZWZpbmVMb2NhbGUoXCJ6aC1jblwiLHttb250aHM6XCLkuIDmnIhf5LqM5pyIX+S4ieaciF/lm5vmnIhf5LqU5pyIX+WFreaciF/kuIPmnIhf5YWr5pyIX+S5neaciF/ljYHmnIhf5Y2B5LiA5pyIX+WNgeS6jOaciFwiLnNwbGl0KFwiX1wiKSxtb250aHNTaG9ydDpcIjHmnIhfMuaciF8z5pyIXzTmnIhfNeaciF825pyIXzfmnIhfOOaciF855pyIXzEw5pyIXzEx5pyIXzEy5pyIXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzOlwi5pif5pyf5pelX+aYn+acn+S4gF/mmJ/mnJ/kuoxf5pif5pyf5LiJX+aYn+acn+Wbm1/mmJ/mnJ/kupRf5pif5pyf5YWtXCIuc3BsaXQoXCJfXCIpLHdlZWtkYXlzU2hvcnQ6XCLlkajml6Vf5ZGo5LiAX+WRqOS6jF/lkajkuIlf5ZGo5ZubX+WRqOS6lF/lkajlha1cIi5zcGxpdChcIl9cIiksd2Vla2RheXNNaW46XCLml6Vf5LiAX+S6jF/kuIlf5ZubX+S6lF/lha1cIi5zcGxpdChcIl9cIiksbG9uZ0RhdGVGb3JtYXQ6e0xUOlwiSEg6bW1cIixMVFM6XCJISDptbTpzc1wiLEw6XCJZWVlZL01NL0REXCIsTEw6XCJZWVlZ5bm0TeaciETml6VcIixMTEw6XCJZWVlZ5bm0TeaciETml6VBaOeCuW1t5YiGXCIsTExMTDpcIllZWVnlubRN5pyIROaXpWRkZGRBaOeCuW1t5YiGXCIsbDpcIllZWVkvTS9EXCIsbGw6XCJZWVlZ5bm0TeaciETml6VcIixsbGw6XCJZWVlZ5bm0TeaciETml6UgSEg6bW1cIixsbGxsOlwiWVlZWeW5tE3mnIhE5pelZGRkZCBISDptbVwifSxtZXJpZGllbVBhcnNlOi/lh4zmmah85pep5LiKfOS4iuWNiHzkuK3ljYh85LiL5Y2IfOaZmuS4ii8sbWVyaWRpZW1Ib3VyOmZ1bmN0aW9uKGUsdCl7cmV0dXJuIDEyPT09ZSYmKGU9MCksXCLlh4zmmahcIj09PXR8fFwi5pep5LiKXCI9PT10fHxcIuS4iuWNiFwiPT09dD9lOlwi5LiL5Y2IXCI9PT10fHxcIuaZmuS4ilwiPT09dD9lKzEyOmU+PTExP2U6ZSsxMn0sbWVyaWRpZW06ZnVuY3Rpb24oZSx0LG4pe3ZhciByPTEwMCplK3Q7cmV0dXJuIHI8NjAwP1wi5YeM5pmoXCI6cjw5MDA/XCLml6nkuIpcIjpyPDExMzA/XCLkuIrljYhcIjpyPDEyMzA/XCLkuK3ljYhcIjpyPDE4MDA/XCLkuIvljYhcIjpcIuaZmuS4ilwifSxjYWxlbmRhcjp7c2FtZURheTpcIlvku4rlpKldTFRcIixuZXh0RGF5OlwiW+aYjuWkqV1MVFwiLG5leHRXZWVrOlwiW+S4i11kZGRkTFRcIixsYXN0RGF5OlwiW+aYqOWkqV1MVFwiLGxhc3RXZWVrOlwiW+S4il1kZGRkTFRcIixzYW1lRWxzZTpcIkxcIn0sZGF5T2ZNb250aE9yZGluYWxQYXJzZTovXFxkezEsMn0o5pelfOaciHzlkagpLyxvcmRpbmFsOmZ1bmN0aW9uKGUsdCl7c3dpdGNoKHQpe2Nhc2VcImRcIjpjYXNlXCJEXCI6Y2FzZVwiREREXCI6cmV0dXJuIGUrXCLml6VcIjtjYXNlXCJNXCI6cmV0dXJuIGUrXCLmnIhcIjtjYXNlXCJ3XCI6Y2FzZVwiV1wiOnJldHVybiBlK1wi5ZGoXCI7ZGVmYXVsdDpyZXR1cm4gZX19LHJlbGF0aXZlVGltZTp7ZnV0dXJlOlwiJXPlkI5cIixwYXN0OlwiJXPliY1cIixzOlwi5Yeg56eSXCIsc3M6XCIlZCDnp5JcIixtOlwiMSDliIbpkp9cIixtbTpcIiVkIOWIhumSn1wiLGg6XCIxIOWwj+aXtlwiLGhoOlwiJWQg5bCP5pe2XCIsZDpcIjEg5aSpXCIsZGQ6XCIlZCDlpKlcIixNOlwiMSDkuKrmnIhcIixNTTpcIiVkIOS4quaciFwiLHk6XCIxIOW5tFwiLHl5OlwiJWQg5bm0XCJ9LHdlZWs6e2RvdzoxLGRveTo0fX0pfSl9fSl9KTsiLCIvKiFcbiAqIGpRdWVyeSBVSSA6ZGF0YSAxLjEyLjFcbiAqIGh0dHA6Ly9qcXVlcnl1aS5jb21cbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICovXG5cbi8vPj5sYWJlbDogOmRhdGEgU2VsZWN0b3Jcbi8vPj5ncm91cDogQ29yZVxuLy8+PmRlc2NyaXB0aW9uOiBTZWxlY3RzIGVsZW1lbnRzIHdoaWNoIGhhdmUgZGF0YSBzdG9yZWQgdW5kZXIgdGhlIHNwZWNpZmllZCBrZXkuXG4vLz4+ZG9jczogaHR0cDovL2FwaS5qcXVlcnl1aS5jb20vZGF0YS1zZWxlY3Rvci9cblxuKCBmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIFsgXCJqcXVlcnlcIiwgXCIuL3ZlcnNpb25cIiBdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufSAoIGZ1bmN0aW9uKCAkICkge1xucmV0dXJuICQuZXh0ZW5kKCAkLmV4cHJbIFwiOlwiIF0sIHtcblx0ZGF0YTogJC5leHByLmNyZWF0ZVBzZXVkbyA/XG5cdFx0JC5leHByLmNyZWF0ZVBzZXVkbyggZnVuY3Rpb24oIGRhdGFOYW1lICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gISEkLmRhdGEoIGVsZW0sIGRhdGFOYW1lICk7XG5cdFx0XHR9O1xuXHRcdH0gKSA6XG5cblx0XHQvLyBTdXBwb3J0OiBqUXVlcnkgPDEuOFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBpLCBtYXRjaCApIHtcblx0XHRcdHJldHVybiAhISQuZGF0YSggZWxlbSwgbWF0Y2hbIDMgXSApO1xuXHRcdH1cbn0gKTtcbn0gKSApO1xuIiwiKCBmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIFsgXCJqcXVlcnlcIiwgXCIuL3ZlcnNpb25cIiBdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufSAoIGZ1bmN0aW9uKCAkICkge1xuXG4vLyBUaGlzIGZpbGUgaXMgZGVwcmVjYXRlZFxucmV0dXJuICQudWkuaWUgPSAhIS9tc2llIFtcXHcuXSsvLmV4ZWMoIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSApO1xufSApICk7XG4iLCIoIGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1ELiBSZWdpc3RlciBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlLlxuXHRcdGRlZmluZSggWyBcImpxdWVyeVwiLCBcIi4vdmVyc2lvblwiIF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEJyb3dzZXIgZ2xvYmFsc1xuXHRcdGZhY3RvcnkoIGpRdWVyeSApO1xuXHR9XG59ICggZnVuY3Rpb24oICQgKSB7XG5cbi8vICQudWkucGx1Z2luIGlzIGRlcHJlY2F0ZWQuIFVzZSAkLndpZGdldCgpIGV4dGVuc2lvbnMgaW5zdGVhZC5cbnJldHVybiAkLnVpLnBsdWdpbiA9IHtcblx0YWRkOiBmdW5jdGlvbiggbW9kdWxlLCBvcHRpb24sIHNldCApIHtcblx0XHR2YXIgaSxcblx0XHRcdHByb3RvID0gJC51aVsgbW9kdWxlIF0ucHJvdG90eXBlO1xuXHRcdGZvciAoIGkgaW4gc2V0ICkge1xuXHRcdFx0cHJvdG8ucGx1Z2luc1sgaSBdID0gcHJvdG8ucGx1Z2luc1sgaSBdIHx8IFtdO1xuXHRcdFx0cHJvdG8ucGx1Z2luc1sgaSBdLnB1c2goIFsgb3B0aW9uLCBzZXRbIGkgXSBdICk7XG5cdFx0fVxuXHR9LFxuXHRjYWxsOiBmdW5jdGlvbiggaW5zdGFuY2UsIG5hbWUsIGFyZ3MsIGFsbG93RGlzY29ubmVjdGVkICkge1xuXHRcdHZhciBpLFxuXHRcdFx0c2V0ID0gaW5zdGFuY2UucGx1Z2luc1sgbmFtZSBdO1xuXG5cdFx0aWYgKCAhc2V0ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggIWFsbG93RGlzY29ubmVjdGVkICYmICggIWluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlIHx8XG5cdFx0XHRcdGluc3RhbmNlLmVsZW1lbnRbIDAgXS5wYXJlbnROb2RlLm5vZGVUeXBlID09PSAxMSApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrICkge1xuXHRcdFx0aWYgKCBpbnN0YW5jZS5vcHRpb25zWyBzZXRbIGkgXVsgMCBdIF0gKSB7XG5cdFx0XHRcdHNldFsgaSBdWyAxIF0uYXBwbHkoIGluc3RhbmNlLmVsZW1lbnQsIGFyZ3MgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbn0gKSApO1xuIiwiKCBmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIFsgXCJqcXVlcnlcIiwgXCIuL3ZlcnNpb25cIiBdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufSAoIGZ1bmN0aW9uKCAkICkge1xucmV0dXJuICQudWkuc2FmZUJsdXIgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblxuXHQvLyBTdXBwb3J0OiBJRTkgLSAxMCBvbmx5XG5cdC8vIElmIHRoZSA8Ym9keT4gaXMgYmx1cnJlZCwgSUUgd2lsbCBzd2l0Y2ggd2luZG93cywgc2VlICM5NDIwXG5cdGlmICggZWxlbWVudCAmJiBlbGVtZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiYm9keVwiICkge1xuXHRcdCQoIGVsZW1lbnQgKS50cmlnZ2VyKCBcImJsdXJcIiApO1xuXHR9XG59O1xuXG59ICkgKTtcbiIsIi8qIVxuICogalF1ZXJ5IFVJIFNjcm9sbCBQYXJlbnQgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IHNjcm9sbFBhcmVudFxuLy8+Pmdyb3VwOiBDb3JlXG4vLz4+ZGVzY3JpcHRpb246IEdldCB0aGUgY2xvc2VzdCBhbmNlc3RvciBlbGVtZW50IHRoYXQgaXMgc2Nyb2xsYWJsZS5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9zY3JvbGxQYXJlbnQvXG5cbiggZnVuY3Rpb24oIGZhY3RvcnkgKSB7XG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG5cdFx0ZGVmaW5lKCBbIFwianF1ZXJ5XCIsIFwiLi92ZXJzaW9uXCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0gKCBmdW5jdGlvbiggJCApIHtcblxucmV0dXJuICQuZm4uc2Nyb2xsUGFyZW50ID0gZnVuY3Rpb24oIGluY2x1ZGVIaWRkZW4gKSB7XG5cdHZhciBwb3NpdGlvbiA9IHRoaXMuY3NzKCBcInBvc2l0aW9uXCIgKSxcblx0XHRleGNsdWRlU3RhdGljUGFyZW50ID0gcG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblx0XHRvdmVyZmxvd1JlZ2V4ID0gaW5jbHVkZUhpZGRlbiA/IC8oYXV0b3xzY3JvbGx8aGlkZGVuKS8gOiAvKGF1dG98c2Nyb2xsKS8sXG5cdFx0c2Nyb2xsUGFyZW50ID0gdGhpcy5wYXJlbnRzKCkuZmlsdGVyKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwYXJlbnQgPSAkKCB0aGlzICk7XG5cdFx0XHRpZiAoIGV4Y2x1ZGVTdGF0aWNQYXJlbnQgJiYgcGFyZW50LmNzcyggXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvdmVyZmxvd1JlZ2V4LnRlc3QoIHBhcmVudC5jc3MoIFwib3ZlcmZsb3dcIiApICsgcGFyZW50LmNzcyggXCJvdmVyZmxvdy15XCIgKSArXG5cdFx0XHRcdHBhcmVudC5jc3MoIFwib3ZlcmZsb3cteFwiICkgKTtcblx0XHR9ICkuZXEoIDAgKTtcblxuXHRyZXR1cm4gcG9zaXRpb24gPT09IFwiZml4ZWRcIiB8fCAhc2Nyb2xsUGFyZW50Lmxlbmd0aCA/XG5cdFx0JCggdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQgKSA6XG5cdFx0c2Nyb2xsUGFyZW50O1xufTtcblxufSApICk7XG4iLCIvKiFcbiAqIGpRdWVyeSBVSSBEcmFnZ2FibGUgMS4xMi4xXG4gKiBodHRwOi8vanF1ZXJ5dWkuY29tXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqL1xuXG4vLz4+bGFiZWw6IERyYWdnYWJsZVxuLy8+Pmdyb3VwOiBJbnRlcmFjdGlvbnNcbi8vPj5kZXNjcmlwdGlvbjogRW5hYmxlcyBkcmFnZ2luZyBmdW5jdGlvbmFsaXR5IGZvciBhbnkgZWxlbWVudC5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9kcmFnZ2FibGUvXG4vLz4+ZGVtb3M6IGh0dHA6Ly9qcXVlcnl1aS5jb20vZHJhZ2dhYmxlL1xuLy8+PmNzcy5zdHJ1Y3R1cmU6IC4uLy4uL3RoZW1lcy9iYXNlL2RyYWdnYWJsZS5jc3NcblxuKCBmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIFtcblx0XHRcdFwianF1ZXJ5XCIsXG5cdFx0XHRcIi4vbW91c2VcIixcblx0XHRcdFwiLi4vZGF0YVwiLFxuXHRcdFx0XCIuLi9wbHVnaW5cIixcblx0XHRcdFwiLi4vc2FmZS1hY3RpdmUtZWxlbWVudFwiLFxuXHRcdFx0XCIuLi9zYWZlLWJsdXJcIixcblx0XHRcdFwiLi4vc2Nyb2xsLXBhcmVudFwiLFxuXHRcdFx0XCIuLi92ZXJzaW9uXCIsXG5cdFx0XHRcIi4uL3dpZGdldFwiXG5cdFx0XSwgZmFjdG9yeSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gQnJvd3NlciBnbG9iYWxzXG5cdFx0ZmFjdG9yeSggalF1ZXJ5ICk7XG5cdH1cbn0oIGZ1bmN0aW9uKCAkICkge1xuXG4kLndpZGdldCggXCJ1aS5kcmFnZ2FibGVcIiwgJC51aS5tb3VzZSwge1xuXHR2ZXJzaW9uOiBcIjEuMTIuMVwiLFxuXHR3aWRnZXRFdmVudFByZWZpeDogXCJkcmFnXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRhZGRDbGFzc2VzOiB0cnVlLFxuXHRcdGFwcGVuZFRvOiBcInBhcmVudFwiLFxuXHRcdGF4aXM6IGZhbHNlLFxuXHRcdGNvbm5lY3RUb1NvcnRhYmxlOiBmYWxzZSxcblx0XHRjb250YWlubWVudDogZmFsc2UsXG5cdFx0Y3Vyc29yOiBcImF1dG9cIixcblx0XHRjdXJzb3JBdDogZmFsc2UsXG5cdFx0Z3JpZDogZmFsc2UsXG5cdFx0aGFuZGxlOiBmYWxzZSxcblx0XHRoZWxwZXI6IFwib3JpZ2luYWxcIixcblx0XHRpZnJhbWVGaXg6IGZhbHNlLFxuXHRcdG9wYWNpdHk6IGZhbHNlLFxuXHRcdHJlZnJlc2hQb3NpdGlvbnM6IGZhbHNlLFxuXHRcdHJldmVydDogZmFsc2UsXG5cdFx0cmV2ZXJ0RHVyYXRpb246IDUwMCxcblx0XHRzY29wZTogXCJkZWZhdWx0XCIsXG5cdFx0c2Nyb2xsOiB0cnVlLFxuXHRcdHNjcm9sbFNlbnNpdGl2aXR5OiAyMCxcblx0XHRzY3JvbGxTcGVlZDogMjAsXG5cdFx0c25hcDogZmFsc2UsXG5cdFx0c25hcE1vZGU6IFwiYm90aFwiLFxuXHRcdHNuYXBUb2xlcmFuY2U6IDIwLFxuXHRcdHN0YWNrOiBmYWxzZSxcblx0XHR6SW5kZXg6IGZhbHNlLFxuXG5cdFx0Ly8gQ2FsbGJhY2tzXG5cdFx0ZHJhZzogbnVsbCxcblx0XHRzdGFydDogbnVsbCxcblx0XHRzdG9wOiBudWxsXG5cdH0sXG5cdF9jcmVhdGU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuaGVscGVyID09PSBcIm9yaWdpbmFsXCIgKSB7XG5cdFx0XHR0aGlzLl9zZXRQb3NpdGlvblJlbGF0aXZlKCk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5vcHRpb25zLmFkZENsYXNzZXMgKSB7XG5cdFx0XHR0aGlzLl9hZGRDbGFzcyggXCJ1aS1kcmFnZ2FibGVcIiApO1xuXHRcdH1cblx0XHR0aGlzLl9zZXRIYW5kbGVDbGFzc05hbWUoKTtcblxuXHRcdHRoaXMuX21vdXNlSW5pdCgpO1xuXHR9LFxuXG5cdF9zZXRPcHRpb246IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHRoaXMuX3N1cGVyKCBrZXksIHZhbHVlICk7XG5cdFx0aWYgKCBrZXkgPT09IFwiaGFuZGxlXCIgKSB7XG5cdFx0XHR0aGlzLl9yZW1vdmVIYW5kbGVDbGFzc05hbWUoKTtcblx0XHRcdHRoaXMuX3NldEhhbmRsZUNsYXNzTmFtZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAoIHRoaXMuaGVscGVyIHx8IHRoaXMuZWxlbWVudCApLmlzKCBcIi51aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIiApICkge1xuXHRcdFx0dGhpcy5kZXN0cm95T25DbGVhciA9IHRydWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX3JlbW92ZUhhbmRsZUNsYXNzTmFtZSgpO1xuXHRcdHRoaXMuX21vdXNlRGVzdHJveSgpO1xuXHR9LFxuXG5cdF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucztcblxuXHRcdC8vIEFtb25nIG90aGVycywgcHJldmVudCBhIGRyYWcgb24gYSByZXNpemFibGUtaGFuZGxlXG5cdFx0aWYgKCB0aGlzLmhlbHBlciB8fCBvLmRpc2FibGVkIHx8XG5cdFx0XHRcdCQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIFwiLnVpLXJlc2l6YWJsZS1oYW5kbGVcIiApLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly9RdWl0IGlmIHdlJ3JlIG5vdCBvbiBhIHZhbGlkIGhhbmRsZVxuXHRcdHRoaXMuaGFuZGxlID0gdGhpcy5fZ2V0SGFuZGxlKCBldmVudCApO1xuXHRcdGlmICggIXRoaXMuaGFuZGxlICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuX2JsdXJBY3RpdmVFbGVtZW50KCBldmVudCApO1xuXG5cdFx0dGhpcy5fYmxvY2tGcmFtZXMoIG8uaWZyYW1lRml4ID09PSB0cnVlID8gXCJpZnJhbWVcIiA6IG8uaWZyYW1lRml4ICk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblxuXHR9LFxuXG5cdF9ibG9ja0ZyYW1lczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMuaWZyYW1lQmxvY2tzID0gdGhpcy5kb2N1bWVudC5maW5kKCBzZWxlY3RvciApLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaWZyYW1lID0gJCggdGhpcyApO1xuXG5cdFx0XHRyZXR1cm4gJCggXCI8ZGl2PlwiIClcblx0XHRcdFx0LmNzcyggXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIgKVxuXHRcdFx0XHQuYXBwZW5kVG8oIGlmcmFtZS5wYXJlbnQoKSApXG5cdFx0XHRcdC5vdXRlcldpZHRoKCBpZnJhbWUub3V0ZXJXaWR0aCgpIClcblx0XHRcdFx0Lm91dGVySGVpZ2h0KCBpZnJhbWUub3V0ZXJIZWlnaHQoKSApXG5cdFx0XHRcdC5vZmZzZXQoIGlmcmFtZS5vZmZzZXQoKSApWyAwIF07XG5cdFx0fSApO1xuXHR9LFxuXG5cdF91bmJsb2NrRnJhbWVzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIHRoaXMuaWZyYW1lQmxvY2tzICkge1xuXHRcdFx0dGhpcy5pZnJhbWVCbG9ja3MucmVtb3ZlKCk7XG5cdFx0XHRkZWxldGUgdGhpcy5pZnJhbWVCbG9ja3M7XG5cdFx0fVxuXHR9LFxuXG5cdF9ibHVyQWN0aXZlRWxlbWVudDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdHZhciBhY3RpdmVFbGVtZW50ID0gJC51aS5zYWZlQWN0aXZlRWxlbWVudCggdGhpcy5kb2N1bWVudFsgMCBdICksXG5cdFx0XHR0YXJnZXQgPSAkKCBldmVudC50YXJnZXQgKTtcblxuXHRcdC8vIERvbid0IGJsdXIgaWYgdGhlIGV2ZW50IG9jY3VycmVkIG9uIGFuIGVsZW1lbnQgdGhhdCBpcyB3aXRoaW5cblx0XHQvLyB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudFxuXHRcdC8vIFNlZSAjMTA1MjcsICMxMjQ3MlxuXHRcdGlmICggdGFyZ2V0LmNsb3Nlc3QoIGFjdGl2ZUVsZW1lbnQgKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gQmx1ciBhbnkgZWxlbWVudCB0aGF0IGN1cnJlbnRseSBoYXMgZm9jdXMsIHNlZSAjNDI2MVxuXHRcdCQudWkuc2FmZUJsdXIoIGFjdGl2ZUVsZW1lbnQgKTtcblx0fSxcblxuXHRfbW91c2VTdGFydDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0dmFyIG8gPSB0aGlzLm9wdGlvbnM7XG5cblx0XHQvL0NyZWF0ZSBhbmQgYXBwZW5kIHRoZSB2aXNpYmxlIGhlbHBlclxuXHRcdHRoaXMuaGVscGVyID0gdGhpcy5fY3JlYXRlSGVscGVyKCBldmVudCApO1xuXG5cdFx0dGhpcy5fYWRkQ2xhc3MoIHRoaXMuaGVscGVyLCBcInVpLWRyYWdnYWJsZS1kcmFnZ2luZ1wiICk7XG5cblx0XHQvL0NhY2hlIHRoZSBoZWxwZXIgc2l6ZVxuXHRcdHRoaXMuX2NhY2hlSGVscGVyUHJvcG9ydGlvbnMoKTtcblxuXHRcdC8vSWYgZGRtYW5hZ2VyIGlzIHVzZWQgZm9yIGRyb3BwYWJsZXMsIHNldCB0aGUgZ2xvYmFsIGRyYWdnYWJsZVxuXHRcdGlmICggJC51aS5kZG1hbmFnZXIgKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5jdXJyZW50ID0gdGhpcztcblx0XHR9XG5cblx0XHQvKlxuXHRcdCAqIC0gUG9zaXRpb24gZ2VuZXJhdGlvbiAtXG5cdFx0ICogVGhpcyBibG9jayBnZW5lcmF0ZXMgZXZlcnl0aGluZyBwb3NpdGlvbiByZWxhdGVkIC0gaXQncyB0aGUgY29yZSBvZiBkcmFnZ2FibGVzLlxuXHRcdCAqL1xuXG5cdFx0Ly9DYWNoZSB0aGUgbWFyZ2lucyBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudFxuXHRcdHRoaXMuX2NhY2hlTWFyZ2lucygpO1xuXG5cdFx0Ly9TdG9yZSB0aGUgaGVscGVyJ3MgY3NzIHBvc2l0aW9uXG5cdFx0dGhpcy5jc3NQb3NpdGlvbiA9IHRoaXMuaGVscGVyLmNzcyggXCJwb3NpdGlvblwiICk7XG5cdFx0dGhpcy5zY3JvbGxQYXJlbnQgPSB0aGlzLmhlbHBlci5zY3JvbGxQYXJlbnQoIHRydWUgKTtcblx0XHR0aGlzLm9mZnNldFBhcmVudCA9IHRoaXMuaGVscGVyLm9mZnNldFBhcmVudCgpO1xuXHRcdHRoaXMuaGFzRml4ZWRBbmNlc3RvciA9IHRoaXMuaGVscGVyLnBhcmVudHMoKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJCggdGhpcyApLmNzcyggXCJwb3NpdGlvblwiICkgPT09IFwiZml4ZWRcIjtcblx0XHRcdH0gKS5sZW5ndGggPiAwO1xuXG5cdFx0Ly9UaGUgZWxlbWVudCdzIGFic29sdXRlIHBvc2l0aW9uIG9uIHRoZSBwYWdlIG1pbnVzIG1hcmdpbnNcblx0XHR0aGlzLnBvc2l0aW9uQWJzID0gdGhpcy5lbGVtZW50Lm9mZnNldCgpO1xuXHRcdHRoaXMuX3JlZnJlc2hPZmZzZXRzKCBldmVudCApO1xuXG5cdFx0Ly9HZW5lcmF0ZSB0aGUgb3JpZ2luYWwgcG9zaXRpb25cblx0XHR0aGlzLm9yaWdpbmFsUG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uID0gdGhpcy5fZ2VuZXJhdGVQb3NpdGlvbiggZXZlbnQsIGZhbHNlICk7XG5cdFx0dGhpcy5vcmlnaW5hbFBhZ2VYID0gZXZlbnQucGFnZVg7XG5cdFx0dGhpcy5vcmlnaW5hbFBhZ2VZID0gZXZlbnQucGFnZVk7XG5cblx0XHQvL0FkanVzdCB0aGUgbW91c2Ugb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBoZWxwZXIgaWYgXCJjdXJzb3JBdFwiIGlzIHN1cHBsaWVkXG5cdFx0KCBvLmN1cnNvckF0ICYmIHRoaXMuX2FkanVzdE9mZnNldEZyb21IZWxwZXIoIG8uY3Vyc29yQXQgKSApO1xuXG5cdFx0Ly9TZXQgYSBjb250YWlubWVudCBpZiBnaXZlbiBpbiB0aGUgb3B0aW9uc1xuXHRcdHRoaXMuX3NldENvbnRhaW5tZW50KCk7XG5cblx0XHQvL1RyaWdnZXIgZXZlbnQgKyBjYWxsYmFja3Ncblx0XHRpZiAoIHRoaXMuX3RyaWdnZXIoIFwic3RhcnRcIiwgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLl9jbGVhcigpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vUmVjYWNoZSB0aGUgaGVscGVyIHNpemVcblx0XHR0aGlzLl9jYWNoZUhlbHBlclByb3BvcnRpb25zKCk7XG5cblx0XHQvL1ByZXBhcmUgdGhlIGRyb3BwYWJsZSBvZmZzZXRzXG5cdFx0aWYgKCAkLnVpLmRkbWFuYWdlciAmJiAhby5kcm9wQmVoYXZpb3VyICkge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIucHJlcGFyZU9mZnNldHMoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0Ly8gRXhlY3V0ZSB0aGUgZHJhZyBvbmNlIC0gdGhpcyBjYXVzZXMgdGhlIGhlbHBlciBub3QgdG8gYmUgdmlzaWJsZSBiZWZvcmUgZ2V0dGluZyBpdHNcblx0XHQvLyBjb3JyZWN0IHBvc2l0aW9uXG5cdFx0dGhpcy5fbW91c2VEcmFnKCBldmVudCwgdHJ1ZSApO1xuXG5cdFx0Ly8gSWYgdGhlIGRkbWFuYWdlciBpcyB1c2VkIGZvciBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgdGhhdCBkcmFnZ2luZyBoYXMgc3RhcnRlZFxuXHRcdC8vIChzZWUgIzUwMDMpXG5cdFx0aWYgKCAkLnVpLmRkbWFuYWdlciApIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLmRyYWdTdGFydCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfcmVmcmVzaE9mZnNldHM6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLm9mZnNldCA9IHtcblx0XHRcdHRvcDogdGhpcy5wb3NpdGlvbkFicy50b3AgLSB0aGlzLm1hcmdpbnMudG9wLFxuXHRcdFx0bGVmdDogdGhpcy5wb3NpdGlvbkFicy5sZWZ0IC0gdGhpcy5tYXJnaW5zLmxlZnQsXG5cdFx0XHRzY3JvbGw6IGZhbHNlLFxuXHRcdFx0cGFyZW50OiB0aGlzLl9nZXRQYXJlbnRPZmZzZXQoKSxcblx0XHRcdHJlbGF0aXZlOiB0aGlzLl9nZXRSZWxhdGl2ZU9mZnNldCgpXG5cdFx0fTtcblxuXHRcdHRoaXMub2Zmc2V0LmNsaWNrID0ge1xuXHRcdFx0bGVmdDogZXZlbnQucGFnZVggLSB0aGlzLm9mZnNldC5sZWZ0LFxuXHRcdFx0dG9wOiBldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LnRvcFxuXHRcdH07XG5cdH0sXG5cblx0X21vdXNlRHJhZzogZnVuY3Rpb24oIGV2ZW50LCBub1Byb3BhZ2F0aW9uICkge1xuXG5cdFx0Ly8gcmVzZXQgYW55IG5lY2Vzc2FyeSBjYWNoZWQgcHJvcGVydGllcyAoc2VlICM1MDA5KVxuXHRcdGlmICggdGhpcy5oYXNGaXhlZEFuY2VzdG9yICkge1xuXHRcdFx0dGhpcy5vZmZzZXQucGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50T2Zmc2V0KCk7XG5cdFx0fVxuXG5cdFx0Ly9Db21wdXRlIHRoZSBoZWxwZXJzIHBvc2l0aW9uXG5cdFx0dGhpcy5wb3NpdGlvbiA9IHRoaXMuX2dlbmVyYXRlUG9zaXRpb24oIGV2ZW50LCB0cnVlICk7XG5cdFx0dGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuX2NvbnZlcnRQb3NpdGlvblRvKCBcImFic29sdXRlXCIgKTtcblxuXHRcdC8vQ2FsbCBwbHVnaW5zIGFuZCBjYWxsYmFja3MgYW5kIHVzZSB0aGUgcmVzdWx0aW5nIHBvc2l0aW9uIGlmIHNvbWV0aGluZyBpcyByZXR1cm5lZFxuXHRcdGlmICggIW5vUHJvcGFnYXRpb24gKSB7XG5cdFx0XHR2YXIgdWkgPSB0aGlzLl91aUhhc2goKTtcblx0XHRcdGlmICggdGhpcy5fdHJpZ2dlciggXCJkcmFnXCIsIGV2ZW50LCB1aSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0dGhpcy5fbW91c2VVcCggbmV3ICQuRXZlbnQoIFwibW91c2V1cFwiLCBldmVudCApICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMucG9zaXRpb24gPSB1aS5wb3NpdGlvbjtcblx0XHR9XG5cblx0XHR0aGlzLmhlbHBlclsgMCBdLnN0eWxlLmxlZnQgPSB0aGlzLnBvc2l0aW9uLmxlZnQgKyBcInB4XCI7XG5cdFx0dGhpcy5oZWxwZXJbIDAgXS5zdHlsZS50b3AgPSB0aGlzLnBvc2l0aW9uLnRvcCArIFwicHhcIjtcblxuXHRcdGlmICggJC51aS5kZG1hbmFnZXIgKSB7XG5cdFx0XHQkLnVpLmRkbWFuYWdlci5kcmFnKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfbW91c2VTdG9wOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHQvL0lmIHdlIGFyZSB1c2luZyBkcm9wcGFibGVzLCBpbmZvcm0gdGhlIG1hbmFnZXIgYWJvdXQgdGhlIGRyb3Bcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRkcm9wcGVkID0gZmFsc2U7XG5cdFx0aWYgKCAkLnVpLmRkbWFuYWdlciAmJiAhdGhpcy5vcHRpb25zLmRyb3BCZWhhdmlvdXIgKSB7XG5cdFx0XHRkcm9wcGVkID0gJC51aS5kZG1hbmFnZXIuZHJvcCggdGhpcywgZXZlbnQgKTtcblx0XHR9XG5cblx0XHQvL2lmIGEgZHJvcCBjb21lcyBmcm9tIG91dHNpZGUgKGEgc29ydGFibGUpXG5cdFx0aWYgKCB0aGlzLmRyb3BwZWQgKSB7XG5cdFx0XHRkcm9wcGVkID0gdGhpcy5kcm9wcGVkO1xuXHRcdFx0dGhpcy5kcm9wcGVkID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCAoIHRoaXMub3B0aW9ucy5yZXZlcnQgPT09IFwiaW52YWxpZFwiICYmICFkcm9wcGVkICkgfHxcblx0XHRcdFx0KCB0aGlzLm9wdGlvbnMucmV2ZXJ0ID09PSBcInZhbGlkXCIgJiYgZHJvcHBlZCApIHx8XG5cdFx0XHRcdHRoaXMub3B0aW9ucy5yZXZlcnQgPT09IHRydWUgfHwgKCAkLmlzRnVuY3Rpb24oIHRoaXMub3B0aW9ucy5yZXZlcnQgKSAmJlxuXHRcdFx0XHR0aGlzLm9wdGlvbnMucmV2ZXJ0LmNhbGwoIHRoaXMuZWxlbWVudCwgZHJvcHBlZCApIClcblx0XHQpIHtcblx0XHRcdCQoIHRoaXMuaGVscGVyICkuYW5pbWF0ZShcblx0XHRcdFx0dGhpcy5vcmlnaW5hbFBvc2l0aW9uLFxuXHRcdFx0XHRwYXJzZUludCggdGhpcy5vcHRpb25zLnJldmVydER1cmF0aW9uLCAxMCApLFxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoYXQuX3RyaWdnZXIoIFwic3RvcFwiLCBldmVudCApICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdHRoYXQuX2NsZWFyKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIHRoaXMuX3RyaWdnZXIoIFwic3RvcFwiLCBldmVudCApICE9PSBmYWxzZSApIHtcblx0XHRcdFx0dGhpcy5fY2xlYXIoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0X21vdXNlVXA6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR0aGlzLl91bmJsb2NrRnJhbWVzKCk7XG5cblx0XHQvLyBJZiB0aGUgZGRtYW5hZ2VyIGlzIHVzZWQgZm9yIGRyb3BwYWJsZXMsIGluZm9ybSB0aGUgbWFuYWdlciB0aGF0IGRyYWdnaW5nIGhhcyBzdG9wcGVkXG5cdFx0Ly8gKHNlZSAjNTAwMylcblx0XHRpZiAoICQudWkuZGRtYW5hZ2VyICkge1xuXHRcdFx0JC51aS5kZG1hbmFnZXIuZHJhZ1N0b3AoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0Ly8gT25seSBuZWVkIHRvIGZvY3VzIGlmIHRoZSBldmVudCBvY2N1cnJlZCBvbiB0aGUgZHJhZ2dhYmxlIGl0c2VsZiwgc2VlICMxMDUyN1xuXHRcdGlmICggdGhpcy5oYW5kbGVFbGVtZW50LmlzKCBldmVudC50YXJnZXQgKSApIHtcblxuXHRcdFx0Ly8gVGhlIGludGVyYWN0aW9uIGlzIG92ZXI7IHdoZXRoZXIgb3Igbm90IHRoZSBjbGljayByZXN1bHRlZCBpbiBhIGRyYWcsXG5cdFx0XHQvLyBmb2N1cyB0aGUgZWxlbWVudFxuXHRcdFx0dGhpcy5lbGVtZW50LnRyaWdnZXIoIFwiZm9jdXNcIiApO1xuXHRcdH1cblxuXHRcdHJldHVybiAkLnVpLm1vdXNlLnByb3RvdHlwZS5fbW91c2VVcC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHR9LFxuXG5cdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cblx0XHRpZiAoIHRoaXMuaGVscGVyLmlzKCBcIi51aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIiApICkge1xuXHRcdFx0dGhpcy5fbW91c2VVcCggbmV3ICQuRXZlbnQoIFwibW91c2V1cFwiLCB7IHRhcmdldDogdGhpcy5lbGVtZW50WyAwIF0gfSApICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2NsZWFyKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cblx0fSxcblxuXHRfZ2V0SGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5oYW5kbGUgP1xuXHRcdFx0ISEkKCBldmVudC50YXJnZXQgKS5jbG9zZXN0KCB0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5vcHRpb25zLmhhbmRsZSApICkubGVuZ3RoIDpcblx0XHRcdHRydWU7XG5cdH0sXG5cblx0X3NldEhhbmRsZUNsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oYW5kbGVFbGVtZW50ID0gdGhpcy5vcHRpb25zLmhhbmRsZSA/XG5cdFx0XHR0aGlzLmVsZW1lbnQuZmluZCggdGhpcy5vcHRpb25zLmhhbmRsZSApIDogdGhpcy5lbGVtZW50O1xuXHRcdHRoaXMuX2FkZENsYXNzKCB0aGlzLmhhbmRsZUVsZW1lbnQsIFwidWktZHJhZ2dhYmxlLWhhbmRsZVwiICk7XG5cdH0sXG5cblx0X3JlbW92ZUhhbmRsZUNsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcmVtb3ZlQ2xhc3MoIHRoaXMuaGFuZGxlRWxlbWVudCwgXCJ1aS1kcmFnZ2FibGUtaGFuZGxlXCIgKTtcblx0fSxcblxuXHRfY3JlYXRlSGVscGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHR2YXIgbyA9IHRoaXMub3B0aW9ucyxcblx0XHRcdGhlbHBlcklzRnVuY3Rpb24gPSAkLmlzRnVuY3Rpb24oIG8uaGVscGVyICksXG5cdFx0XHRoZWxwZXIgPSBoZWxwZXJJc0Z1bmN0aW9uID9cblx0XHRcdFx0JCggby5oZWxwZXIuYXBwbHkoIHRoaXMuZWxlbWVudFsgMCBdLCBbIGV2ZW50IF0gKSApIDpcblx0XHRcdFx0KCBvLmhlbHBlciA9PT0gXCJjbG9uZVwiID9cblx0XHRcdFx0XHR0aGlzLmVsZW1lbnQuY2xvbmUoKS5yZW1vdmVBdHRyKCBcImlkXCIgKSA6XG5cdFx0XHRcdFx0dGhpcy5lbGVtZW50ICk7XG5cblx0XHRpZiAoICFoZWxwZXIucGFyZW50cyggXCJib2R5XCIgKS5sZW5ndGggKSB7XG5cdFx0XHRoZWxwZXIuYXBwZW5kVG8oICggby5hcHBlbmRUbyA9PT0gXCJwYXJlbnRcIiA/XG5cdFx0XHRcdHRoaXMuZWxlbWVudFsgMCBdLnBhcmVudE5vZGUgOlxuXHRcdFx0XHRvLmFwcGVuZFRvICkgKTtcblx0XHR9XG5cblx0XHQvLyBIdHRwOi8vYnVncy5qcXVlcnl1aS5jb20vdGlja2V0Lzk0NDZcblx0XHQvLyBhIGhlbHBlciBmdW5jdGlvbiBjYW4gcmV0dXJuIHRoZSBvcmlnaW5hbCBlbGVtZW50XG5cdFx0Ly8gd2hpY2ggd291bGRuJ3QgaGF2ZSBiZWVuIHNldCB0byByZWxhdGl2ZSBpbiBfY3JlYXRlXG5cdFx0aWYgKCBoZWxwZXJJc0Z1bmN0aW9uICYmIGhlbHBlclsgMCBdID09PSB0aGlzLmVsZW1lbnRbIDAgXSApIHtcblx0XHRcdHRoaXMuX3NldFBvc2l0aW9uUmVsYXRpdmUoKTtcblx0XHR9XG5cblx0XHRpZiAoIGhlbHBlclsgMCBdICE9PSB0aGlzLmVsZW1lbnRbIDAgXSAmJlxuXHRcdFx0XHQhKCAvKGZpeGVkfGFic29sdXRlKS8gKS50ZXN0KCBoZWxwZXIuY3NzKCBcInBvc2l0aW9uXCIgKSApICkge1xuXHRcdFx0aGVscGVyLmNzcyggXCJwb3NpdGlvblwiLCBcImFic29sdXRlXCIgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGVscGVyO1xuXG5cdH0sXG5cblx0X3NldFBvc2l0aW9uUmVsYXRpdmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggISggL14oPzpyfGF8ZikvICkudGVzdCggdGhpcy5lbGVtZW50LmNzcyggXCJwb3NpdGlvblwiICkgKSApIHtcblx0XHRcdHRoaXMuZWxlbWVudFsgMCBdLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblx0fSxcblxuXHRfYWRqdXN0T2Zmc2V0RnJvbUhlbHBlcjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRpZiAoIHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRvYmogPSBvYmouc3BsaXQoIFwiIFwiICk7XG5cdFx0fVxuXHRcdGlmICggJC5pc0FycmF5KCBvYmogKSApIHtcblx0XHRcdG9iaiA9IHsgbGVmdDogK29ialsgMCBdLCB0b3A6ICtvYmpbIDEgXSB8fCAwIH07XG5cdFx0fVxuXHRcdGlmICggXCJsZWZ0XCIgaW4gb2JqICkge1xuXHRcdFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCA9IG9iai5sZWZ0ICsgdGhpcy5tYXJnaW5zLmxlZnQ7XG5cdFx0fVxuXHRcdGlmICggXCJyaWdodFwiIGluIG9iaiApIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPSB0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC0gb2JqLnJpZ2h0ICsgdGhpcy5tYXJnaW5zLmxlZnQ7XG5cdFx0fVxuXHRcdGlmICggXCJ0b3BcIiBpbiBvYmogKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5jbGljay50b3AgPSBvYmoudG9wICsgdGhpcy5tYXJnaW5zLnRvcDtcblx0XHR9XG5cdFx0aWYgKCBcImJvdHRvbVwiIGluIG9iaiApIHtcblx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA9IHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gb2JqLmJvdHRvbSArIHRoaXMubWFyZ2lucy50b3A7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1Jvb3ROb2RlOiBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRyZXR1cm4gKCAvKGh0bWx8Ym9keSkvaSApLnRlc3QoIGVsZW1lbnQudGFnTmFtZSApIHx8IGVsZW1lbnQgPT09IHRoaXMuZG9jdW1lbnRbIDAgXTtcblx0fSxcblxuXHRfZ2V0UGFyZW50T2Zmc2V0OiBmdW5jdGlvbigpIHtcblxuXHRcdC8vR2V0IHRoZSBvZmZzZXRQYXJlbnQgYW5kIGNhY2hlIGl0cyBwb3NpdGlvblxuXHRcdHZhciBwbyA9IHRoaXMub2Zmc2V0UGFyZW50Lm9mZnNldCgpLFxuXHRcdFx0ZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50WyAwIF07XG5cblx0XHQvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHdoZXJlIHdlIG5lZWQgdG8gbW9kaWZ5IGEgb2Zmc2V0IGNhbGN1bGF0ZWQgb24gc3RhcnQsIHNpbmNlIHRoZVxuXHRcdC8vIGZvbGxvd2luZyBoYXBwZW5lZDpcblx0XHQvLyAxLiBUaGUgcG9zaXRpb24gb2YgdGhlIGhlbHBlciBpcyBhYnNvbHV0ZSwgc28gaXQncyBwb3NpdGlvbiBpcyBjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZVxuXHRcdC8vIG5leHQgcG9zaXRpb25lZCBwYXJlbnRcblx0XHQvLyAyLiBUaGUgYWN0dWFsIG9mZnNldCBwYXJlbnQgaXMgYSBjaGlsZCBvZiB0aGUgc2Nyb2xsIHBhcmVudCwgYW5kIHRoZSBzY3JvbGwgcGFyZW50IGlzbid0XG5cdFx0Ly8gdGhlIGRvY3VtZW50LCB3aGljaCBtZWFucyB0aGF0IHRoZSBzY3JvbGwgaXMgaW5jbHVkZWQgaW4gdGhlIGluaXRpYWwgY2FsY3VsYXRpb24gb2YgdGhlXG5cdFx0Ly8gb2Zmc2V0IG9mIHRoZSBwYXJlbnQsIGFuZCBuZXZlciByZWNhbGN1bGF0ZWQgdXBvbiBkcmFnXG5cdFx0aWYgKCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImFic29sdXRlXCIgJiYgdGhpcy5zY3JvbGxQYXJlbnRbIDAgXSAhPT0gZG9jdW1lbnQgJiZcblx0XHRcdFx0JC5jb250YWlucyggdGhpcy5zY3JvbGxQYXJlbnRbIDAgXSwgdGhpcy5vZmZzZXRQYXJlbnRbIDAgXSApICkge1xuXHRcdFx0cG8ubGVmdCArPSB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCk7XG5cdFx0XHRwby50b3AgKz0gdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9pc1Jvb3ROb2RlKCB0aGlzLm9mZnNldFBhcmVudFsgMCBdICkgKSB7XG5cdFx0XHRwbyA9IHsgdG9wOiAwLCBsZWZ0OiAwIH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHRvcDogcG8udG9wICsgKCBwYXJzZUludCggdGhpcy5vZmZzZXRQYXJlbnQuY3NzKCBcImJvcmRlclRvcFdpZHRoXCIgKSwgMTAgKSB8fCAwICksXG5cdFx0XHRsZWZ0OiBwby5sZWZ0ICsgKCBwYXJzZUludCggdGhpcy5vZmZzZXRQYXJlbnQuY3NzKCBcImJvcmRlckxlZnRXaWR0aFwiICksIDEwICkgfHwgMCApXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9nZXRSZWxhdGl2ZU9mZnNldDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCB0aGlzLmNzc1Bvc2l0aW9uICE9PSBcInJlbGF0aXZlXCIgKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHR2YXIgcCA9IHRoaXMuZWxlbWVudC5wb3NpdGlvbigpLFxuXHRcdFx0c2Nyb2xsSXNSb290Tm9kZSA9IHRoaXMuX2lzUm9vdE5vZGUoIHRoaXMuc2Nyb2xsUGFyZW50WyAwIF0gKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHAudG9wIC0gKCBwYXJzZUludCggdGhpcy5oZWxwZXIuY3NzKCBcInRvcFwiICksIDEwICkgfHwgMCApICtcblx0XHRcdFx0KCAhc2Nyb2xsSXNSb290Tm9kZSA/IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCgpIDogMCApLFxuXHRcdFx0bGVmdDogcC5sZWZ0IC0gKCBwYXJzZUludCggdGhpcy5oZWxwZXIuY3NzKCBcImxlZnRcIiApLCAxMCApIHx8IDAgKSArXG5cdFx0XHRcdCggIXNjcm9sbElzUm9vdE5vZGUgPyB0aGlzLnNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0KCkgOiAwIClcblx0XHR9O1xuXG5cdH0sXG5cblx0X2NhY2hlTWFyZ2luczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5tYXJnaW5zID0ge1xuXHRcdFx0bGVmdDogKCBwYXJzZUludCggdGhpcy5lbGVtZW50LmNzcyggXCJtYXJnaW5MZWZ0XCIgKSwgMTAgKSB8fCAwICksXG5cdFx0XHR0b3A6ICggcGFyc2VJbnQoIHRoaXMuZWxlbWVudC5jc3MoIFwibWFyZ2luVG9wXCIgKSwgMTAgKSB8fCAwICksXG5cdFx0XHRyaWdodDogKCBwYXJzZUludCggdGhpcy5lbGVtZW50LmNzcyggXCJtYXJnaW5SaWdodFwiICksIDEwICkgfHwgMCApLFxuXHRcdFx0Ym90dG9tOiAoIHBhcnNlSW50KCB0aGlzLmVsZW1lbnQuY3NzKCBcIm1hcmdpbkJvdHRvbVwiICksIDEwICkgfHwgMCApXG5cdFx0fTtcblx0fSxcblxuXHRfY2FjaGVIZWxwZXJQcm9wb3J0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5oZWxwZXJQcm9wb3J0aW9ucyA9IHtcblx0XHRcdHdpZHRoOiB0aGlzLmhlbHBlci5vdXRlcldpZHRoKCksXG5cdFx0XHRoZWlnaHQ6IHRoaXMuaGVscGVyLm91dGVySGVpZ2h0KClcblx0XHR9O1xuXHR9LFxuXG5cdF9zZXRDb250YWlubWVudDogZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgaXNVc2VyU2Nyb2xsYWJsZSwgYywgY2UsXG5cdFx0XHRvID0gdGhpcy5vcHRpb25zLFxuXHRcdFx0ZG9jdW1lbnQgPSB0aGlzLmRvY3VtZW50WyAwIF07XG5cblx0XHR0aGlzLnJlbGF0aXZlQ29udGFpbmVyID0gbnVsbDtcblxuXHRcdGlmICggIW8uY29udGFpbm1lbnQgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gbnVsbDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGFpbm1lbnQgPT09IFwid2luZG93XCIgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gW1xuXHRcdFx0XHQkKCB3aW5kb3cgKS5zY3JvbGxMZWZ0KCkgLSB0aGlzLm9mZnNldC5yZWxhdGl2ZS5sZWZ0IC0gdGhpcy5vZmZzZXQucGFyZW50LmxlZnQsXG5cdFx0XHRcdCQoIHdpbmRvdyApLnNjcm9sbFRvcCgpIC0gdGhpcy5vZmZzZXQucmVsYXRpdmUudG9wIC0gdGhpcy5vZmZzZXQucGFyZW50LnRvcCxcblx0XHRcdFx0JCggd2luZG93ICkuc2Nyb2xsTGVmdCgpICsgJCggd2luZG93ICkud2lkdGgoKSAtXG5cdFx0XHRcdFx0dGhpcy5oZWxwZXJQcm9wb3J0aW9ucy53aWR0aCAtIHRoaXMubWFyZ2lucy5sZWZ0LFxuXHRcdFx0XHQkKCB3aW5kb3cgKS5zY3JvbGxUb3AoKSArXG5cdFx0XHRcdFx0KCAkKCB3aW5kb3cgKS5oZWlnaHQoKSB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsSGVpZ2h0ICkgLVxuXHRcdFx0XHRcdHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC0gdGhpcy5tYXJnaW5zLnRvcFxuXHRcdFx0XTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGFpbm1lbnQgPT09IFwiZG9jdW1lbnRcIiApIHtcblx0XHRcdHRoaXMuY29udGFpbm1lbnQgPSBbXG5cdFx0XHRcdDAsXG5cdFx0XHRcdDAsXG5cdFx0XHRcdCQoIGRvY3VtZW50ICkud2lkdGgoKSAtIHRoaXMuaGVscGVyUHJvcG9ydGlvbnMud2lkdGggLSB0aGlzLm1hcmdpbnMubGVmdCxcblx0XHRcdFx0KCAkKCBkb2N1bWVudCApLmhlaWdodCgpIHx8IGRvY3VtZW50LmJvZHkucGFyZW50Tm9kZS5zY3JvbGxIZWlnaHQgKSAtXG5cdFx0XHRcdFx0dGhpcy5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQgLSB0aGlzLm1hcmdpbnMudG9wXG5cdFx0XHRdO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggby5jb250YWlubWVudC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgKSB7XG5cdFx0XHR0aGlzLmNvbnRhaW5tZW50ID0gby5jb250YWlubWVudDtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIG8uY29udGFpbm1lbnQgPT09IFwicGFyZW50XCIgKSB7XG5cdFx0XHRvLmNvbnRhaW5tZW50ID0gdGhpcy5oZWxwZXJbIDAgXS5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdGMgPSAkKCBvLmNvbnRhaW5tZW50ICk7XG5cdFx0Y2UgPSBjWyAwIF07XG5cblx0XHRpZiAoICFjZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpc1VzZXJTY3JvbGxhYmxlID0gLyhzY3JvbGx8YXV0bykvLnRlc3QoIGMuY3NzKCBcIm92ZXJmbG93XCIgKSApO1xuXG5cdFx0dGhpcy5jb250YWlubWVudCA9IFtcblx0XHRcdCggcGFyc2VJbnQoIGMuY3NzKCBcImJvcmRlckxlZnRXaWR0aFwiICksIDEwICkgfHwgMCApICtcblx0XHRcdFx0KCBwYXJzZUludCggYy5jc3MoIFwicGFkZGluZ0xlZnRcIiApLCAxMCApIHx8IDAgKSxcblx0XHRcdCggcGFyc2VJbnQoIGMuY3NzKCBcImJvcmRlclRvcFdpZHRoXCIgKSwgMTAgKSB8fCAwICkgK1xuXHRcdFx0XHQoIHBhcnNlSW50KCBjLmNzcyggXCJwYWRkaW5nVG9wXCIgKSwgMTAgKSB8fCAwICksXG5cdFx0XHQoIGlzVXNlclNjcm9sbGFibGUgPyBNYXRoLm1heCggY2Uuc2Nyb2xsV2lkdGgsIGNlLm9mZnNldFdpZHRoICkgOiBjZS5vZmZzZXRXaWR0aCApIC1cblx0XHRcdFx0KCBwYXJzZUludCggYy5jc3MoIFwiYm9yZGVyUmlnaHRXaWR0aFwiICksIDEwICkgfHwgMCApIC1cblx0XHRcdFx0KCBwYXJzZUludCggYy5jc3MoIFwicGFkZGluZ1JpZ2h0XCIgKSwgMTAgKSB8fCAwICkgLVxuXHRcdFx0XHR0aGlzLmhlbHBlclByb3BvcnRpb25zLndpZHRoIC1cblx0XHRcdFx0dGhpcy5tYXJnaW5zLmxlZnQgLVxuXHRcdFx0XHR0aGlzLm1hcmdpbnMucmlnaHQsXG5cdFx0XHQoIGlzVXNlclNjcm9sbGFibGUgPyBNYXRoLm1heCggY2Uuc2Nyb2xsSGVpZ2h0LCBjZS5vZmZzZXRIZWlnaHQgKSA6IGNlLm9mZnNldEhlaWdodCApIC1cblx0XHRcdFx0KCBwYXJzZUludCggYy5jc3MoIFwiYm9yZGVyQm90dG9tV2lkdGhcIiApLCAxMCApIHx8IDAgKSAtXG5cdFx0XHRcdCggcGFyc2VJbnQoIGMuY3NzKCBcInBhZGRpbmdCb3R0b21cIiApLCAxMCApIHx8IDAgKSAtXG5cdFx0XHRcdHRoaXMuaGVscGVyUHJvcG9ydGlvbnMuaGVpZ2h0IC1cblx0XHRcdFx0dGhpcy5tYXJnaW5zLnRvcCAtXG5cdFx0XHRcdHRoaXMubWFyZ2lucy5ib3R0b21cblx0XHRdO1xuXHRcdHRoaXMucmVsYXRpdmVDb250YWluZXIgPSBjO1xuXHR9LFxuXG5cdF9jb252ZXJ0UG9zaXRpb25UbzogZnVuY3Rpb24oIGQsIHBvcyApIHtcblxuXHRcdGlmICggIXBvcyApIHtcblx0XHRcdHBvcyA9IHRoaXMucG9zaXRpb247XG5cdFx0fVxuXG5cdFx0dmFyIG1vZCA9IGQgPT09IFwiYWJzb2x1dGVcIiA/IDEgOiAtMSxcblx0XHRcdHNjcm9sbElzUm9vdE5vZGUgPSB0aGlzLl9pc1Jvb3ROb2RlKCB0aGlzLnNjcm9sbFBhcmVudFsgMCBdICk7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiAoXG5cblx0XHRcdFx0Ly8gVGhlIGFic29sdXRlIG1vdXNlIHBvc2l0aW9uXG5cdFx0XHRcdHBvcy50b3BcdCtcblxuXHRcdFx0XHQvLyBPbmx5IGZvciByZWxhdGl2ZSBwb3NpdGlvbmVkIG5vZGVzOiBSZWxhdGl2ZSBvZmZzZXQgZnJvbSBlbGVtZW50IHRvIG9mZnNldCBwYXJlbnRcblx0XHRcdFx0dGhpcy5vZmZzZXQucmVsYXRpdmUudG9wICogbW9kICtcblxuXHRcdFx0XHQvLyBUaGUgb2Zmc2V0UGFyZW50J3Mgb2Zmc2V0IHdpdGhvdXQgYm9yZGVycyAob2Zmc2V0ICsgYm9yZGVyKVxuXHRcdFx0XHR0aGlzLm9mZnNldC5wYXJlbnQudG9wICogbW9kIC1cblx0XHRcdFx0KCAoIHRoaXMuY3NzUG9zaXRpb24gPT09IFwiZml4ZWRcIiA/XG5cdFx0XHRcdFx0LXRoaXMub2Zmc2V0LnNjcm9sbC50b3AgOlxuXHRcdFx0XHRcdCggc2Nyb2xsSXNSb290Tm9kZSA/IDAgOiB0aGlzLm9mZnNldC5zY3JvbGwudG9wICkgKSAqIG1vZCApXG5cdFx0XHQpLFxuXHRcdFx0bGVmdDogKFxuXG5cdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHRwb3MubGVmdCArXG5cblx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgKiBtb2QgK1xuXG5cdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0ICogbW9kXHQtXG5cdFx0XHRcdCggKCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgP1xuXHRcdFx0XHRcdC10aGlzLm9mZnNldC5zY3JvbGwubGVmdCA6XG5cdFx0XHRcdFx0KCBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHRoaXMub2Zmc2V0LnNjcm9sbC5sZWZ0ICkgKSAqIG1vZCApXG5cdFx0XHQpXG5cdFx0fTtcblxuXHR9LFxuXG5cdF9nZW5lcmF0ZVBvc2l0aW9uOiBmdW5jdGlvbiggZXZlbnQsIGNvbnN0cmFpblBvc2l0aW9uICkge1xuXG5cdFx0dmFyIGNvbnRhaW5tZW50LCBjbywgdG9wLCBsZWZ0LFxuXHRcdFx0byA9IHRoaXMub3B0aW9ucyxcblx0XHRcdHNjcm9sbElzUm9vdE5vZGUgPSB0aGlzLl9pc1Jvb3ROb2RlKCB0aGlzLnNjcm9sbFBhcmVudFsgMCBdICksXG5cdFx0XHRwYWdlWCA9IGV2ZW50LnBhZ2VYLFxuXHRcdFx0cGFnZVkgPSBldmVudC5wYWdlWTtcblxuXHRcdC8vIENhY2hlIHRoZSBzY3JvbGxcblx0XHRpZiAoICFzY3JvbGxJc1Jvb3ROb2RlIHx8ICF0aGlzLm9mZnNldC5zY3JvbGwgKSB7XG5cdFx0XHR0aGlzLm9mZnNldC5zY3JvbGwgPSB7XG5cdFx0XHRcdHRvcDogdGhpcy5zY3JvbGxQYXJlbnQuc2Nyb2xsVG9wKCksXG5cdFx0XHRcdGxlZnQ6IHRoaXMuc2Nyb2xsUGFyZW50LnNjcm9sbExlZnQoKVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvKlxuXHRcdCAqIC0gUG9zaXRpb24gY29uc3RyYWluaW5nIC1cblx0XHQgKiBDb25zdHJhaW4gdGhlIHBvc2l0aW9uIHRvIGEgbWl4IG9mIGdyaWQsIGNvbnRhaW5tZW50LlxuXHRcdCAqL1xuXG5cdFx0Ly8gSWYgd2UgYXJlIG5vdCBkcmFnZ2luZyB5ZXQsIHdlIHdvbid0IGNoZWNrIGZvciBvcHRpb25zXG5cdFx0aWYgKCBjb25zdHJhaW5Qb3NpdGlvbiApIHtcblx0XHRcdGlmICggdGhpcy5jb250YWlubWVudCApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnJlbGF0aXZlQ29udGFpbmVyICkge1xuXHRcdFx0XHRcdGNvID0gdGhpcy5yZWxhdGl2ZUNvbnRhaW5lci5vZmZzZXQoKTtcblx0XHRcdFx0XHRjb250YWlubWVudCA9IFtcblx0XHRcdFx0XHRcdHRoaXMuY29udGFpbm1lbnRbIDAgXSArIGNvLmxlZnQsXG5cdFx0XHRcdFx0XHR0aGlzLmNvbnRhaW5tZW50WyAxIF0gKyBjby50b3AsXG5cdFx0XHRcdFx0XHR0aGlzLmNvbnRhaW5tZW50WyAyIF0gKyBjby5sZWZ0LFxuXHRcdFx0XHRcdFx0dGhpcy5jb250YWlubWVudFsgMyBdICsgY28udG9wXG5cdFx0XHRcdFx0XTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250YWlubWVudCA9IHRoaXMuY29udGFpbm1lbnQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGV2ZW50LnBhZ2VYIC0gdGhpcy5vZmZzZXQuY2xpY2subGVmdCA8IGNvbnRhaW5tZW50WyAwIF0gKSB7XG5cdFx0XHRcdFx0cGFnZVggPSBjb250YWlubWVudFsgMCBdICsgdGhpcy5vZmZzZXQuY2xpY2subGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGV2ZW50LnBhZ2VZIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wIDwgY29udGFpbm1lbnRbIDEgXSApIHtcblx0XHRcdFx0XHRwYWdlWSA9IGNvbnRhaW5tZW50WyAxIF0gKyB0aGlzLm9mZnNldC5jbGljay50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBldmVudC5wYWdlWCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPiBjb250YWlubWVudFsgMiBdICkge1xuXHRcdFx0XHRcdHBhZ2VYID0gY29udGFpbm1lbnRbIDIgXSArIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBldmVudC5wYWdlWSAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+IGNvbnRhaW5tZW50WyAzIF0gKSB7XG5cdFx0XHRcdFx0cGFnZVkgPSBjb250YWlubWVudFsgMyBdICsgdGhpcy5vZmZzZXQuY2xpY2sudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggby5ncmlkICkge1xuXG5cdFx0XHRcdC8vQ2hlY2sgZm9yIGdyaWQgZWxlbWVudHMgc2V0IHRvIDAgdG8gcHJldmVudCBkaXZpZGUgYnkgMCBlcnJvciBjYXVzaW5nIGludmFsaWRcblx0XHRcdFx0Ly8gYXJndW1lbnQgZXJyb3JzIGluIElFIChzZWUgdGlja2V0ICM2OTUwKVxuXHRcdFx0XHR0b3AgPSBvLmdyaWRbIDEgXSA/IHRoaXMub3JpZ2luYWxQYWdlWSArIE1hdGgucm91bmQoICggcGFnZVkgLVxuXHRcdFx0XHRcdHRoaXMub3JpZ2luYWxQYWdlWSApIC8gby5ncmlkWyAxIF0gKSAqIG8uZ3JpZFsgMSBdIDogdGhpcy5vcmlnaW5hbFBhZ2VZO1xuXHRcdFx0XHRwYWdlWSA9IGNvbnRhaW5tZW50ID8gKCAoIHRvcCAtIHRoaXMub2Zmc2V0LmNsaWNrLnRvcCA+PSBjb250YWlubWVudFsgMSBdIHx8XG5cdFx0XHRcdFx0dG9wIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID4gY29udGFpbm1lbnRbIDMgXSApID9cblx0XHRcdFx0XHRcdHRvcCA6XG5cdFx0XHRcdFx0XHQoICggdG9wIC0gdGhpcy5vZmZzZXQuY2xpY2sudG9wID49IGNvbnRhaW5tZW50WyAxIF0gKSA/XG5cdFx0XHRcdFx0XHRcdHRvcCAtIG8uZ3JpZFsgMSBdIDogdG9wICsgby5ncmlkWyAxIF0gKSApIDogdG9wO1xuXG5cdFx0XHRcdGxlZnQgPSBvLmdyaWRbIDAgXSA/IHRoaXMub3JpZ2luYWxQYWdlWCArXG5cdFx0XHRcdFx0TWF0aC5yb3VuZCggKCBwYWdlWCAtIHRoaXMub3JpZ2luYWxQYWdlWCApIC8gby5ncmlkWyAwIF0gKSAqIG8uZ3JpZFsgMCBdIDpcblx0XHRcdFx0XHR0aGlzLm9yaWdpbmFsUGFnZVg7XG5cdFx0XHRcdHBhZ2VYID0gY29udGFpbm1lbnQgPyAoICggbGVmdCAtIHRoaXMub2Zmc2V0LmNsaWNrLmxlZnQgPj0gY29udGFpbm1lbnRbIDAgXSB8fFxuXHRcdFx0XHRcdGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID4gY29udGFpbm1lbnRbIDIgXSApID9cblx0XHRcdFx0XHRcdGxlZnQgOlxuXHRcdFx0XHRcdFx0KCAoIGxlZnQgLSB0aGlzLm9mZnNldC5jbGljay5sZWZ0ID49IGNvbnRhaW5tZW50WyAwIF0gKSA/XG5cdFx0XHRcdFx0XHRcdGxlZnQgLSBvLmdyaWRbIDAgXSA6IGxlZnQgKyBvLmdyaWRbIDAgXSApICkgOiBsZWZ0O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG8uYXhpcyA9PT0gXCJ5XCIgKSB7XG5cdFx0XHRcdHBhZ2VYID0gdGhpcy5vcmlnaW5hbFBhZ2VYO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG8uYXhpcyA9PT0gXCJ4XCIgKSB7XG5cdFx0XHRcdHBhZ2VZID0gdGhpcy5vcmlnaW5hbFBhZ2VZO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IChcblxuXHRcdFx0XHQvLyBUaGUgYWJzb2x1dGUgbW91c2UgcG9zaXRpb25cblx0XHRcdFx0cGFnZVkgLVxuXG5cdFx0XHRcdC8vIENsaWNrIG9mZnNldCAocmVsYXRpdmUgdG8gdGhlIGVsZW1lbnQpXG5cdFx0XHRcdHRoaXMub2Zmc2V0LmNsaWNrLnRvcCAtXG5cblx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLnRvcCAtXG5cblx0XHRcdFx0Ly8gVGhlIG9mZnNldFBhcmVudCdzIG9mZnNldCB3aXRob3V0IGJvcmRlcnMgKG9mZnNldCArIGJvcmRlcilcblx0XHRcdFx0dGhpcy5vZmZzZXQucGFyZW50LnRvcCArXG5cdFx0XHRcdCggdGhpcy5jc3NQb3NpdGlvbiA9PT0gXCJmaXhlZFwiID9cblx0XHRcdFx0XHQtdGhpcy5vZmZzZXQuc2Nyb2xsLnRvcCA6XG5cdFx0XHRcdFx0KCBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHRoaXMub2Zmc2V0LnNjcm9sbC50b3AgKSApXG5cdFx0XHQpLFxuXHRcdFx0bGVmdDogKFxuXG5cdFx0XHRcdC8vIFRoZSBhYnNvbHV0ZSBtb3VzZSBwb3NpdGlvblxuXHRcdFx0XHRwYWdlWCAtXG5cblx0XHRcdFx0Ly8gQ2xpY2sgb2Zmc2V0IChyZWxhdGl2ZSB0byB0aGUgZWxlbWVudClcblx0XHRcdFx0dGhpcy5vZmZzZXQuY2xpY2subGVmdCAtXG5cblx0XHRcdFx0Ly8gT25seSBmb3IgcmVsYXRpdmUgcG9zaXRpb25lZCBub2RlczogUmVsYXRpdmUgb2Zmc2V0IGZyb20gZWxlbWVudCB0byBvZmZzZXQgcGFyZW50XG5cdFx0XHRcdHRoaXMub2Zmc2V0LnJlbGF0aXZlLmxlZnQgLVxuXG5cdFx0XHRcdC8vIFRoZSBvZmZzZXRQYXJlbnQncyBvZmZzZXQgd2l0aG91dCBib3JkZXJzIChvZmZzZXQgKyBib3JkZXIpXG5cdFx0XHRcdHRoaXMub2Zmc2V0LnBhcmVudC5sZWZ0ICtcblx0XHRcdFx0KCB0aGlzLmNzc1Bvc2l0aW9uID09PSBcImZpeGVkXCIgP1xuXHRcdFx0XHRcdC10aGlzLm9mZnNldC5zY3JvbGwubGVmdCA6XG5cdFx0XHRcdFx0KCBzY3JvbGxJc1Jvb3ROb2RlID8gMCA6IHRoaXMub2Zmc2V0LnNjcm9sbC5sZWZ0ICkgKVxuXHRcdFx0KVxuXHRcdH07XG5cblx0fSxcblxuXHRfY2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3JlbW92ZUNsYXNzKCB0aGlzLmhlbHBlciwgXCJ1aS1kcmFnZ2FibGUtZHJhZ2dpbmdcIiApO1xuXHRcdGlmICggdGhpcy5oZWxwZXJbIDAgXSAhPT0gdGhpcy5lbGVtZW50WyAwIF0gJiYgIXRoaXMuY2FuY2VsSGVscGVyUmVtb3ZhbCApIHtcblx0XHRcdHRoaXMuaGVscGVyLnJlbW92ZSgpO1xuXHRcdH1cblx0XHR0aGlzLmhlbHBlciA9IG51bGw7XG5cdFx0dGhpcy5jYW5jZWxIZWxwZXJSZW1vdmFsID0gZmFsc2U7XG5cdFx0aWYgKCB0aGlzLmRlc3Ryb3lPbkNsZWFyICkge1xuXHRcdFx0dGhpcy5kZXN0cm95KCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIEZyb20gbm93IG9uIGJ1bGsgc3R1ZmYgLSBtYWlubHkgaGVscGVyc1xuXG5cdF90cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZXZlbnQsIHVpICkge1xuXHRcdHVpID0gdWkgfHwgdGhpcy5fdWlIYXNoKCk7XG5cdFx0JC51aS5wbHVnaW4uY2FsbCggdGhpcywgdHlwZSwgWyBldmVudCwgdWksIHRoaXMgXSwgdHJ1ZSApO1xuXG5cdFx0Ly8gQWJzb2x1dGUgcG9zaXRpb24gYW5kIG9mZnNldCAoc2VlICM2ODg0ICkgaGF2ZSB0byBiZSByZWNhbGN1bGF0ZWQgYWZ0ZXIgcGx1Z2luc1xuXHRcdGlmICggL14oZHJhZ3xzdGFydHxzdG9wKS8udGVzdCggdHlwZSApICkge1xuXHRcdFx0dGhpcy5wb3NpdGlvbkFicyA9IHRoaXMuX2NvbnZlcnRQb3NpdGlvblRvKCBcImFic29sdXRlXCIgKTtcblx0XHRcdHVpLm9mZnNldCA9IHRoaXMucG9zaXRpb25BYnM7XG5cdFx0fVxuXHRcdHJldHVybiAkLldpZGdldC5wcm90b3R5cGUuX3RyaWdnZXIuY2FsbCggdGhpcywgdHlwZSwgZXZlbnQsIHVpICk7XG5cdH0sXG5cblx0cGx1Z2luczoge30sXG5cblx0X3VpSGFzaDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGhlbHBlcjogdGhpcy5oZWxwZXIsXG5cdFx0XHRwb3NpdGlvbjogdGhpcy5wb3NpdGlvbixcblx0XHRcdG9yaWdpbmFsUG9zaXRpb246IHRoaXMub3JpZ2luYWxQb3NpdGlvbixcblx0XHRcdG9mZnNldDogdGhpcy5wb3NpdGlvbkFic1xuXHRcdH07XG5cdH1cblxufSApO1xuXG4kLnVpLnBsdWdpbi5hZGQoIFwiZHJhZ2dhYmxlXCIsIFwiY29ubmVjdFRvU29ydGFibGVcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oIGV2ZW50LCB1aSwgZHJhZ2dhYmxlICkge1xuXHRcdHZhciB1aVNvcnRhYmxlID0gJC5leHRlbmQoIHt9LCB1aSwge1xuXHRcdFx0aXRlbTogZHJhZ2dhYmxlLmVsZW1lbnRcblx0XHR9ICk7XG5cblx0XHRkcmFnZ2FibGUuc29ydGFibGVzID0gW107XG5cdFx0JCggZHJhZ2dhYmxlLm9wdGlvbnMuY29ubmVjdFRvU29ydGFibGUgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzb3J0YWJsZSA9ICQoIHRoaXMgKS5zb3J0YWJsZSggXCJpbnN0YW5jZVwiICk7XG5cblx0XHRcdGlmICggc29ydGFibGUgJiYgIXNvcnRhYmxlLm9wdGlvbnMuZGlzYWJsZWQgKSB7XG5cdFx0XHRcdGRyYWdnYWJsZS5zb3J0YWJsZXMucHVzaCggc29ydGFibGUgKTtcblxuXHRcdFx0XHQvLyBSZWZyZXNoUG9zaXRpb25zIGlzIGNhbGxlZCBhdCBkcmFnIHN0YXJ0IHRvIHJlZnJlc2ggdGhlIGNvbnRhaW5lckNhY2hlXG5cdFx0XHRcdC8vIHdoaWNoIGlzIHVzZWQgaW4gZHJhZy4gVGhpcyBlbnN1cmVzIGl0J3MgaW5pdGlhbGl6ZWQgYW5kIHN5bmNocm9uaXplZFxuXHRcdFx0XHQvLyB3aXRoIGFueSBjaGFuZ2VzIHRoYXQgbWlnaHQgaGF2ZSBoYXBwZW5lZCBvbiB0aGUgcGFnZSBzaW5jZSBpbml0aWFsaXphdGlvbi5cblx0XHRcdFx0c29ydGFibGUucmVmcmVzaFBvc2l0aW9ucygpO1xuXHRcdFx0XHRzb3J0YWJsZS5fdHJpZ2dlciggXCJhY3RpdmF0ZVwiLCBldmVudCwgdWlTb3J0YWJsZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0c3RvcDogZnVuY3Rpb24oIGV2ZW50LCB1aSwgZHJhZ2dhYmxlICkge1xuXHRcdHZhciB1aVNvcnRhYmxlID0gJC5leHRlbmQoIHt9LCB1aSwge1xuXHRcdFx0aXRlbTogZHJhZ2dhYmxlLmVsZW1lbnRcblx0XHR9ICk7XG5cblx0XHRkcmFnZ2FibGUuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IGZhbHNlO1xuXG5cdFx0JC5lYWNoKCBkcmFnZ2FibGUuc29ydGFibGVzLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzb3J0YWJsZSA9IHRoaXM7XG5cblx0XHRcdGlmICggc29ydGFibGUuaXNPdmVyICkge1xuXHRcdFx0XHRzb3J0YWJsZS5pc092ZXIgPSAwO1xuXG5cdFx0XHRcdC8vIEFsbG93IHRoaXMgc29ydGFibGUgdG8gaGFuZGxlIHJlbW92aW5nIHRoZSBoZWxwZXJcblx0XHRcdFx0ZHJhZ2dhYmxlLmNhbmNlbEhlbHBlclJlbW92YWwgPSB0cnVlO1xuXHRcdFx0XHRzb3J0YWJsZS5jYW5jZWxIZWxwZXJSZW1vdmFsID0gZmFsc2U7XG5cblx0XHRcdFx0Ly8gVXNlIF9zdG9yZWRDU1MgVG8gcmVzdG9yZSBwcm9wZXJ0aWVzIGluIHRoZSBzb3J0YWJsZSxcblx0XHRcdFx0Ly8gYXMgdGhpcyBhbHNvIGhhbmRsZXMgcmV2ZXJ0ICgjOTY3NSkgc2luY2UgdGhlIGRyYWdnYWJsZVxuXHRcdFx0XHQvLyBtYXkgaGF2ZSBtb2RpZmllZCB0aGVtIGluIHVuZXhwZWN0ZWQgd2F5cyAoIzg4MDkpXG5cdFx0XHRcdHNvcnRhYmxlLl9zdG9yZWRDU1MgPSB7XG5cdFx0XHRcdFx0cG9zaXRpb246IHNvcnRhYmxlLnBsYWNlaG9sZGVyLmNzcyggXCJwb3NpdGlvblwiICksXG5cdFx0XHRcdFx0dG9wOiBzb3J0YWJsZS5wbGFjZWhvbGRlci5jc3MoIFwidG9wXCIgKSxcblx0XHRcdFx0XHRsZWZ0OiBzb3J0YWJsZS5wbGFjZWhvbGRlci5jc3MoIFwibGVmdFwiIClcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRzb3J0YWJsZS5fbW91c2VTdG9wKCBldmVudCApO1xuXG5cdFx0XHRcdC8vIE9uY2UgZHJhZyBoYXMgZW5kZWQsIHRoZSBzb3J0YWJsZSBzaG91bGQgcmV0dXJuIHRvIHVzaW5nXG5cdFx0XHRcdC8vIGl0cyBvcmlnaW5hbCBoZWxwZXIsIG5vdCB0aGUgc2hhcmVkIGhlbHBlciBmcm9tIGRyYWdnYWJsZVxuXHRcdFx0XHRzb3J0YWJsZS5vcHRpb25zLmhlbHBlciA9IHNvcnRhYmxlLm9wdGlvbnMuX2hlbHBlcjtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCB0aGlzIFNvcnRhYmxlIGZyb20gcmVtb3ZpbmcgdGhlIGhlbHBlci5cblx0XHRcdFx0Ly8gSG93ZXZlciwgZG9uJ3Qgc2V0IHRoZSBkcmFnZ2FibGUgdG8gcmVtb3ZlIHRoZSBoZWxwZXJcblx0XHRcdFx0Ly8gZWl0aGVyIGFzIGFub3RoZXIgY29ubmVjdGVkIFNvcnRhYmxlIG1heSB5ZXQgaGFuZGxlIHRoZSByZW1vdmFsLlxuXHRcdFx0XHRzb3J0YWJsZS5jYW5jZWxIZWxwZXJSZW1vdmFsID0gdHJ1ZTtcblxuXHRcdFx0XHRzb3J0YWJsZS5fdHJpZ2dlciggXCJkZWFjdGl2YXRlXCIsIGV2ZW50LCB1aVNvcnRhYmxlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbiggZXZlbnQsIHVpLCBkcmFnZ2FibGUgKSB7XG5cdFx0JC5lYWNoKCBkcmFnZ2FibGUuc29ydGFibGVzLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbm5lcm1vc3RJbnRlcnNlY3RpbmcgPSBmYWxzZSxcblx0XHRcdFx0c29ydGFibGUgPSB0aGlzO1xuXG5cdFx0XHQvLyBDb3B5IG92ZXIgdmFyaWFibGVzIHRoYXQgc29ydGFibGUncyBfaW50ZXJzZWN0c1dpdGggdXNlc1xuXHRcdFx0c29ydGFibGUucG9zaXRpb25BYnMgPSBkcmFnZ2FibGUucG9zaXRpb25BYnM7XG5cdFx0XHRzb3J0YWJsZS5oZWxwZXJQcm9wb3J0aW9ucyA9IGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucztcblx0XHRcdHNvcnRhYmxlLm9mZnNldC5jbGljayA9IGRyYWdnYWJsZS5vZmZzZXQuY2xpY2s7XG5cblx0XHRcdGlmICggc29ydGFibGUuX2ludGVyc2VjdHNXaXRoKCBzb3J0YWJsZS5jb250YWluZXJDYWNoZSApICkge1xuXHRcdFx0XHRpbm5lcm1vc3RJbnRlcnNlY3RpbmcgPSB0cnVlO1xuXG5cdFx0XHRcdCQuZWFjaCggZHJhZ2dhYmxlLnNvcnRhYmxlcywgZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHQvLyBDb3B5IG92ZXIgdmFyaWFibGVzIHRoYXQgc29ydGFibGUncyBfaW50ZXJzZWN0c1dpdGggdXNlc1xuXHRcdFx0XHRcdHRoaXMucG9zaXRpb25BYnMgPSBkcmFnZ2FibGUucG9zaXRpb25BYnM7XG5cdFx0XHRcdFx0dGhpcy5oZWxwZXJQcm9wb3J0aW9ucyA9IGRyYWdnYWJsZS5oZWxwZXJQcm9wb3J0aW9ucztcblx0XHRcdFx0XHR0aGlzLm9mZnNldC5jbGljayA9IGRyYWdnYWJsZS5vZmZzZXQuY2xpY2s7XG5cblx0XHRcdFx0XHRpZiAoIHRoaXMgIT09IHNvcnRhYmxlICYmXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2ludGVyc2VjdHNXaXRoKCB0aGlzLmNvbnRhaW5lckNhY2hlICkgJiZcblx0XHRcdFx0XHRcdFx0JC5jb250YWlucyggc29ydGFibGUuZWxlbWVudFsgMCBdLCB0aGlzLmVsZW1lbnRbIDAgXSApICkge1xuXHRcdFx0XHRcdFx0aW5uZXJtb3N0SW50ZXJzZWN0aW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGlubmVybW9zdEludGVyc2VjdGluZztcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGlubmVybW9zdEludGVyc2VjdGluZyApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpbnRlcnNlY3RzLCB3ZSB1c2UgYSBsaXR0bGUgaXNPdmVyIHZhcmlhYmxlIGFuZCBzZXQgaXQgb25jZSxcblx0XHRcdFx0Ly8gc28gdGhhdCB0aGUgbW92ZS1pbiBzdHVmZiBnZXRzIGZpcmVkIG9ubHkgb25jZS5cblx0XHRcdFx0aWYgKCAhc29ydGFibGUuaXNPdmVyICkge1xuXHRcdFx0XHRcdHNvcnRhYmxlLmlzT3ZlciA9IDE7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBkcmFnZ2FibGUncyBwYXJlbnQgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlYXBwZW5kIHRvIGl0IGxhdGVyLlxuXHRcdFx0XHRcdGRyYWdnYWJsZS5fcGFyZW50ID0gdWkuaGVscGVyLnBhcmVudCgpO1xuXG5cdFx0XHRcdFx0c29ydGFibGUuY3VycmVudEl0ZW0gPSB1aS5oZWxwZXJcblx0XHRcdFx0XHRcdC5hcHBlbmRUbyggc29ydGFibGUuZWxlbWVudCApXG5cdFx0XHRcdFx0XHQuZGF0YSggXCJ1aS1zb3J0YWJsZS1pdGVtXCIsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGhlbHBlciBvcHRpb24gdG8gbGF0ZXIgcmVzdG9yZSBpdFxuXHRcdFx0XHRcdHNvcnRhYmxlLm9wdGlvbnMuX2hlbHBlciA9IHNvcnRhYmxlLm9wdGlvbnMuaGVscGVyO1xuXG5cdFx0XHRcdFx0c29ydGFibGUub3B0aW9ucy5oZWxwZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB1aS5oZWxwZXJbIDAgXTtcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0Ly8gRmlyZSB0aGUgc3RhcnQgZXZlbnRzIG9mIHRoZSBzb3J0YWJsZSB3aXRoIG91ciBwYXNzZWQgYnJvd3NlciBldmVudCxcblx0XHRcdFx0XHQvLyBhbmQgb3VyIG93biBoZWxwZXIgKHNvIGl0IGRvZXNuJ3QgY3JlYXRlIGEgbmV3IG9uZSlcblx0XHRcdFx0XHRldmVudC50YXJnZXQgPSBzb3J0YWJsZS5jdXJyZW50SXRlbVsgMCBdO1xuXHRcdFx0XHRcdHNvcnRhYmxlLl9tb3VzZUNhcHR1cmUoIGV2ZW50LCB0cnVlICk7XG5cdFx0XHRcdFx0c29ydGFibGUuX21vdXNlU3RhcnQoIGV2ZW50LCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBCZWNhdXNlIHRoZSBicm93c2VyIGV2ZW50IGlzIHdheSBvZmYgdGhlIG5ldyBhcHBlbmRlZCBwb3J0bGV0LFxuXHRcdFx0XHRcdC8vIG1vZGlmeSBuZWNlc3NhcnkgdmFyaWFibGVzIHRvIHJlZmxlY3QgdGhlIGNoYW5nZXNcblx0XHRcdFx0XHRzb3J0YWJsZS5vZmZzZXQuY2xpY2sudG9wID0gZHJhZ2dhYmxlLm9mZnNldC5jbGljay50b3A7XG5cdFx0XHRcdFx0c29ydGFibGUub2Zmc2V0LmNsaWNrLmxlZnQgPSBkcmFnZ2FibGUub2Zmc2V0LmNsaWNrLmxlZnQ7XG5cdFx0XHRcdFx0c29ydGFibGUub2Zmc2V0LnBhcmVudC5sZWZ0IC09IGRyYWdnYWJsZS5vZmZzZXQucGFyZW50LmxlZnQgLVxuXHRcdFx0XHRcdFx0c29ydGFibGUub2Zmc2V0LnBhcmVudC5sZWZ0O1xuXHRcdFx0XHRcdHNvcnRhYmxlLm9mZnNldC5wYXJlbnQudG9wIC09IGRyYWdnYWJsZS5vZmZzZXQucGFyZW50LnRvcCAtXG5cdFx0XHRcdFx0XHRzb3J0YWJsZS5vZmZzZXQucGFyZW50LnRvcDtcblxuXHRcdFx0XHRcdGRyYWdnYWJsZS5fdHJpZ2dlciggXCJ0b1NvcnRhYmxlXCIsIGV2ZW50ICk7XG5cblx0XHRcdFx0XHQvLyBJbmZvcm0gZHJhZ2dhYmxlIHRoYXQgdGhlIGhlbHBlciBpcyBpbiBhIHZhbGlkIGRyb3Agem9uZSxcblx0XHRcdFx0XHQvLyB1c2VkIHNvbGVseSBpbiB0aGUgcmV2ZXJ0IG9wdGlvbiB0byBoYW5kbGUgXCJ2YWxpZC9pbnZhbGlkXCIuXG5cdFx0XHRcdFx0ZHJhZ2dhYmxlLmRyb3BwZWQgPSBzb3J0YWJsZS5lbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gTmVlZCB0byByZWZyZXNoUG9zaXRpb25zIG9mIGFsbCBzb3J0YWJsZXMgaW4gdGhlIGNhc2UgdGhhdFxuXHRcdFx0XHRcdC8vIGFkZGluZyB0byBvbmUgc29ydGFibGUgY2hhbmdlcyB0aGUgbG9jYXRpb24gb2YgdGhlIG90aGVyIHNvcnRhYmxlcyAoIzk2NzUpXG5cdFx0XHRcdFx0JC5lYWNoKCBkcmFnZ2FibGUuc29ydGFibGVzLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVmcmVzaFBvc2l0aW9ucygpO1xuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHRcdC8vIEhhY2sgc28gcmVjZWl2ZS91cGRhdGUgY2FsbGJhY2tzIHdvcmsgKG1vc3RseSlcblx0XHRcdFx0XHRkcmFnZ2FibGUuY3VycmVudEl0ZW0gPSBkcmFnZ2FibGUuZWxlbWVudDtcblx0XHRcdFx0XHRzb3J0YWJsZS5mcm9tT3V0c2lkZSA9IGRyYWdnYWJsZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc29ydGFibGUuY3VycmVudEl0ZW0gKSB7XG5cdFx0XHRcdFx0c29ydGFibGUuX21vdXNlRHJhZyggZXZlbnQgKTtcblxuXHRcdFx0XHRcdC8vIENvcHkgdGhlIHNvcnRhYmxlJ3MgcG9zaXRpb24gYmVjYXVzZSB0aGUgZHJhZ2dhYmxlJ3MgY2FuIHBvdGVudGlhbGx5IHJlZmxlY3Rcblx0XHRcdFx0XHQvLyBhIHJlbGF0aXZlIHBvc2l0aW9uLCB3aGlsZSBzb3J0YWJsZSBpcyBhbHdheXMgYWJzb2x1dGUsIHdoaWNoIHRoZSBkcmFnZ2VkXG5cdFx0XHRcdFx0Ly8gZWxlbWVudCBoYXMgbm93IGJlY29tZS4gKCM4ODA5KVxuXHRcdFx0XHRcdHVpLnBvc2l0aW9uID0gc29ydGFibGUucG9zaXRpb247XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gSWYgaXQgZG9lc24ndCBpbnRlcnNlY3Qgd2l0aCB0aGUgc29ydGFibGUsIGFuZCBpdCBpbnRlcnNlY3RlZCBiZWZvcmUsXG5cdFx0XHRcdC8vIHdlIGZha2UgdGhlIGRyYWcgc3RvcCBvZiB0aGUgc29ydGFibGUsIGJ1dCBtYWtlIHN1cmUgaXQgZG9lc24ndCByZW1vdmVcblx0XHRcdFx0Ly8gdGhlIGhlbHBlciBieSB1c2luZyBjYW5jZWxIZWxwZXJSZW1vdmFsLlxuXHRcdFx0XHRpZiAoIHNvcnRhYmxlLmlzT3ZlciApIHtcblxuXHRcdFx0XHRcdHNvcnRhYmxlLmlzT3ZlciA9IDA7XG5cdFx0XHRcdFx0c29ydGFibGUuY2FuY2VsSGVscGVyUmVtb3ZhbCA9IHRydWU7XG5cblx0XHRcdFx0XHQvLyBDYWxsaW5nIHNvcnRhYmxlJ3MgbW91c2VTdG9wIHdvdWxkIHRyaWdnZXIgYSByZXZlcnQsXG5cdFx0XHRcdFx0Ly8gc28gcmV2ZXJ0IG11c3QgYmUgdGVtcG9yYXJpbHkgZmFsc2UgdW50aWwgYWZ0ZXIgbW91c2VTdG9wIGlzIGNhbGxlZC5cblx0XHRcdFx0XHRzb3J0YWJsZS5vcHRpb25zLl9yZXZlcnQgPSBzb3J0YWJsZS5vcHRpb25zLnJldmVydDtcblx0XHRcdFx0XHRzb3J0YWJsZS5vcHRpb25zLnJldmVydCA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0c29ydGFibGUuX3RyaWdnZXIoIFwib3V0XCIsIGV2ZW50LCBzb3J0YWJsZS5fdWlIYXNoKCBzb3J0YWJsZSApICk7XG5cdFx0XHRcdFx0c29ydGFibGUuX21vdXNlU3RvcCggZXZlbnQsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIFJlc3RvcmUgc29ydGFibGUgYmVoYXZpb3JzIHRoYXQgd2VyZSBtb2RmaWVkXG5cdFx0XHRcdFx0Ly8gd2hlbiB0aGUgZHJhZ2dhYmxlIGVudGVyZWQgdGhlIHNvcnRhYmxlIGFyZWEgKCM5NDgxKVxuXHRcdFx0XHRcdHNvcnRhYmxlLm9wdGlvbnMucmV2ZXJ0ID0gc29ydGFibGUub3B0aW9ucy5fcmV2ZXJ0O1xuXHRcdFx0XHRcdHNvcnRhYmxlLm9wdGlvbnMuaGVscGVyID0gc29ydGFibGUub3B0aW9ucy5faGVscGVyO1xuXG5cdFx0XHRcdFx0aWYgKCBzb3J0YWJsZS5wbGFjZWhvbGRlciApIHtcblx0XHRcdFx0XHRcdHNvcnRhYmxlLnBsYWNlaG9sZGVyLnJlbW92ZSgpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFJlc3RvcmUgYW5kIHJlY2FsY3VsYXRlIHRoZSBkcmFnZ2FibGUncyBvZmZzZXQgY29uc2lkZXJpbmcgdGhlIHNvcnRhYmxlXG5cdFx0XHRcdFx0Ly8gbWF5IGhhdmUgbW9kaWZpZWQgdGhlbSBpbiB1bmV4cGVjdGVkIHdheXMuICgjODgwOSwgIzEwNjY5KVxuXHRcdFx0XHRcdHVpLmhlbHBlci5hcHBlbmRUbyggZHJhZ2dhYmxlLl9wYXJlbnQgKTtcblx0XHRcdFx0XHRkcmFnZ2FibGUuX3JlZnJlc2hPZmZzZXRzKCBldmVudCApO1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uID0gZHJhZ2dhYmxlLl9nZW5lcmF0ZVBvc2l0aW9uKCBldmVudCwgdHJ1ZSApO1xuXG5cdFx0XHRcdFx0ZHJhZ2dhYmxlLl90cmlnZ2VyKCBcImZyb21Tb3J0YWJsZVwiLCBldmVudCApO1xuXG5cdFx0XHRcdFx0Ly8gSW5mb3JtIGRyYWdnYWJsZSB0aGF0IHRoZSBoZWxwZXIgaXMgbm8gbG9uZ2VyIGluIGEgdmFsaWQgZHJvcCB6b25lXG5cdFx0XHRcdFx0ZHJhZ2dhYmxlLmRyb3BwZWQgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIE5lZWQgdG8gcmVmcmVzaFBvc2l0aW9ucyBvZiBhbGwgc29ydGFibGVzIGp1c3QgaW4gY2FzZSByZW1vdmluZ1xuXHRcdFx0XHRcdC8vIGZyb20gb25lIHNvcnRhYmxlIGNoYW5nZXMgdGhlIGxvY2F0aW9uIG9mIG90aGVyIHNvcnRhYmxlcyAoIzk2NzUpXG5cdFx0XHRcdFx0JC5lYWNoKCBkcmFnZ2FibGUuc29ydGFibGVzLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVmcmVzaFBvc2l0aW9ucygpO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fVxufSApO1xuXG4kLnVpLnBsdWdpbi5hZGQoIFwiZHJhZ2dhYmxlXCIsIFwiY3Vyc29yXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWksIGluc3RhbmNlICkge1xuXHRcdHZhciB0ID0gJCggXCJib2R5XCIgKSxcblx0XHRcdG8gPSBpbnN0YW5jZS5vcHRpb25zO1xuXG5cdFx0aWYgKCB0LmNzcyggXCJjdXJzb3JcIiApICkge1xuXHRcdFx0by5fY3Vyc29yID0gdC5jc3MoIFwiY3Vyc29yXCIgKTtcblx0XHR9XG5cdFx0dC5jc3MoIFwiY3Vyc29yXCIsIG8uY3Vyc29yICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCBldmVudCwgdWksIGluc3RhbmNlICkge1xuXHRcdHZhciBvID0gaW5zdGFuY2Uub3B0aW9ucztcblx0XHRpZiAoIG8uX2N1cnNvciApIHtcblx0XHRcdCQoIFwiYm9keVwiICkuY3NzKCBcImN1cnNvclwiLCBvLl9jdXJzb3IgKTtcblx0XHR9XG5cdH1cbn0gKTtcblxuJC51aS5wbHVnaW4uYWRkKCBcImRyYWdnYWJsZVwiLCBcIm9wYWNpdHlcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oIGV2ZW50LCB1aSwgaW5zdGFuY2UgKSB7XG5cdFx0dmFyIHQgPSAkKCB1aS5oZWxwZXIgKSxcblx0XHRcdG8gPSBpbnN0YW5jZS5vcHRpb25zO1xuXHRcdGlmICggdC5jc3MoIFwib3BhY2l0eVwiICkgKSB7XG5cdFx0XHRvLl9vcGFjaXR5ID0gdC5jc3MoIFwib3BhY2l0eVwiICk7XG5cdFx0fVxuXHRcdHQuY3NzKCBcIm9wYWNpdHlcIiwgby5vcGFjaXR5ICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCBldmVudCwgdWksIGluc3RhbmNlICkge1xuXHRcdHZhciBvID0gaW5zdGFuY2Uub3B0aW9ucztcblx0XHRpZiAoIG8uX29wYWNpdHkgKSB7XG5cdFx0XHQkKCB1aS5oZWxwZXIgKS5jc3MoIFwib3BhY2l0eVwiLCBvLl9vcGFjaXR5ICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbiQudWkucGx1Z2luLmFkZCggXCJkcmFnZ2FibGVcIiwgXCJzY3JvbGxcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oIGV2ZW50LCB1aSwgaSApIHtcblx0XHRpZiAoICFpLnNjcm9sbFBhcmVudE5vdEhpZGRlbiApIHtcblx0XHRcdGkuc2Nyb2xsUGFyZW50Tm90SGlkZGVuID0gaS5oZWxwZXIuc2Nyb2xsUGFyZW50KCBmYWxzZSApO1xuXHRcdH1cblxuXHRcdGlmICggaS5zY3JvbGxQYXJlbnROb3RIaWRkZW5bIDAgXSAhPT0gaS5kb2N1bWVudFsgMCBdICYmXG5cdFx0XHRcdGkuc2Nyb2xsUGFyZW50Tm90SGlkZGVuWyAwIF0udGFnTmFtZSAhPT0gXCJIVE1MXCIgKSB7XG5cdFx0XHRpLm92ZXJmbG93T2Zmc2V0ID0gaS5zY3JvbGxQYXJlbnROb3RIaWRkZW4ub2Zmc2V0KCk7XG5cdFx0fVxuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbiggZXZlbnQsIHVpLCBpICApIHtcblxuXHRcdHZhciBvID0gaS5vcHRpb25zLFxuXHRcdFx0c2Nyb2xsZWQgPSBmYWxzZSxcblx0XHRcdHNjcm9sbFBhcmVudCA9IGkuc2Nyb2xsUGFyZW50Tm90SGlkZGVuWyAwIF0sXG5cdFx0XHRkb2N1bWVudCA9IGkuZG9jdW1lbnRbIDAgXTtcblxuXHRcdGlmICggc2Nyb2xsUGFyZW50ICE9PSBkb2N1bWVudCAmJiBzY3JvbGxQYXJlbnQudGFnTmFtZSAhPT0gXCJIVE1MXCIgKSB7XG5cdFx0XHRpZiAoICFvLmF4aXMgfHwgby5heGlzICE9PSBcInhcIiApIHtcblx0XHRcdFx0aWYgKCAoIGkub3ZlcmZsb3dPZmZzZXQudG9wICsgc2Nyb2xsUGFyZW50Lm9mZnNldEhlaWdodCApIC0gZXZlbnQucGFnZVkgPFxuXHRcdFx0XHRcdFx0by5zY3JvbGxTZW5zaXRpdml0eSApIHtcblx0XHRcdFx0XHRzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wID0gc2Nyb2xsZWQgPSBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wICsgby5zY3JvbGxTcGVlZDtcblx0XHRcdFx0fSBlbHNlIGlmICggZXZlbnQucGFnZVkgLSBpLm92ZXJmbG93T2Zmc2V0LnRvcCA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkgKSB7XG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50LnNjcm9sbFRvcCA9IHNjcm9sbGVkID0gc2Nyb2xsUGFyZW50LnNjcm9sbFRvcCAtIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCAhby5heGlzIHx8IG8uYXhpcyAhPT0gXCJ5XCIgKSB7XG5cdFx0XHRcdGlmICggKCBpLm92ZXJmbG93T2Zmc2V0LmxlZnQgKyBzY3JvbGxQYXJlbnQub2Zmc2V0V2lkdGggKSAtIGV2ZW50LnBhZ2VYIDxcblx0XHRcdFx0XHRcdG8uc2Nyb2xsU2Vuc2l0aXZpdHkgKSB7XG5cdFx0XHRcdFx0c2Nyb2xsUGFyZW50LnNjcm9sbExlZnQgPSBzY3JvbGxlZCA9IHNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ICsgby5zY3JvbGxTcGVlZDtcblx0XHRcdFx0fSBlbHNlIGlmICggZXZlbnQucGFnZVggLSBpLm92ZXJmbG93T2Zmc2V0LmxlZnQgPCBvLnNjcm9sbFNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHRcdHNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0ID0gc2Nyb2xsZWQgPSBzY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdCAtIG8uc2Nyb2xsU3BlZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGlmICggIW8uYXhpcyB8fCBvLmF4aXMgIT09IFwieFwiICkge1xuXHRcdFx0XHRpZiAoIGV2ZW50LnBhZ2VZIC0gJCggZG9jdW1lbnQgKS5zY3JvbGxUb3AoKSA8IG8uc2Nyb2xsU2Vuc2l0aXZpdHkgKSB7XG5cdFx0XHRcdFx0c2Nyb2xsZWQgPSAkKCBkb2N1bWVudCApLnNjcm9sbFRvcCggJCggZG9jdW1lbnQgKS5zY3JvbGxUb3AoKSAtIG8uc2Nyb2xsU3BlZWQgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggJCggd2luZG93ICkuaGVpZ2h0KCkgLSAoIGV2ZW50LnBhZ2VZIC0gJCggZG9jdW1lbnQgKS5zY3JvbGxUb3AoKSApIDxcblx0XHRcdFx0XHRcdG8uc2Nyb2xsU2Vuc2l0aXZpdHkgKSB7XG5cdFx0XHRcdFx0c2Nyb2xsZWQgPSAkKCBkb2N1bWVudCApLnNjcm9sbFRvcCggJCggZG9jdW1lbnQgKS5zY3JvbGxUb3AoKSArIG8uc2Nyb2xsU3BlZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICFvLmF4aXMgfHwgby5heGlzICE9PSBcInlcIiApIHtcblx0XHRcdFx0aWYgKCBldmVudC5wYWdlWCAtICQoIGRvY3VtZW50ICkuc2Nyb2xsTGVmdCgpIDwgby5zY3JvbGxTZW5zaXRpdml0eSApIHtcblx0XHRcdFx0XHRzY3JvbGxlZCA9ICQoIGRvY3VtZW50ICkuc2Nyb2xsTGVmdChcblx0XHRcdFx0XHRcdCQoIGRvY3VtZW50ICkuc2Nyb2xsTGVmdCgpIC0gby5zY3JvbGxTcGVlZFxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoICQoIHdpbmRvdyApLndpZHRoKCkgLSAoIGV2ZW50LnBhZ2VYIC0gJCggZG9jdW1lbnQgKS5zY3JvbGxMZWZ0KCkgKSA8XG5cdFx0XHRcdFx0XHRvLnNjcm9sbFNlbnNpdGl2aXR5ICkge1xuXHRcdFx0XHRcdHNjcm9sbGVkID0gJCggZG9jdW1lbnQgKS5zY3JvbGxMZWZ0KFxuXHRcdFx0XHRcdFx0JCggZG9jdW1lbnQgKS5zY3JvbGxMZWZ0KCkgKyBvLnNjcm9sbFNwZWVkXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0aWYgKCBzY3JvbGxlZCAhPT0gZmFsc2UgJiYgJC51aS5kZG1hbmFnZXIgJiYgIW8uZHJvcEJlaGF2aW91ciApIHtcblx0XHRcdCQudWkuZGRtYW5hZ2VyLnByZXBhcmVPZmZzZXRzKCBpLCBldmVudCApO1xuXHRcdH1cblxuXHR9XG59ICk7XG5cbiQudWkucGx1Z2luLmFkZCggXCJkcmFnZ2FibGVcIiwgXCJzbmFwXCIsIHtcblx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCwgdWksIGkgKSB7XG5cblx0XHR2YXIgbyA9IGkub3B0aW9ucztcblxuXHRcdGkuc25hcEVsZW1lbnRzID0gW107XG5cblx0XHQkKCBvLnNuYXAuY29uc3RydWN0b3IgIT09IFN0cmluZyA/ICggby5zbmFwLml0ZW1zIHx8IFwiOmRhdGEodWktZHJhZ2dhYmxlKVwiICkgOiBvLnNuYXAgKVxuXHRcdFx0LmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgJHQgPSAkKCB0aGlzICksXG5cdFx0XHRcdFx0JG8gPSAkdC5vZmZzZXQoKTtcblx0XHRcdFx0aWYgKCB0aGlzICE9PSBpLmVsZW1lbnRbIDAgXSApIHtcblx0XHRcdFx0XHRpLnNuYXBFbGVtZW50cy5wdXNoKCB7XG5cdFx0XHRcdFx0XHRpdGVtOiB0aGlzLFxuXHRcdFx0XHRcdFx0d2lkdGg6ICR0Lm91dGVyV2lkdGgoKSwgaGVpZ2h0OiAkdC5vdXRlckhlaWdodCgpLFxuXHRcdFx0XHRcdFx0dG9wOiAkby50b3AsIGxlZnQ6ICRvLmxlZnRcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHR9LFxuXHRkcmFnOiBmdW5jdGlvbiggZXZlbnQsIHVpLCBpbnN0ICkge1xuXG5cdFx0dmFyIHRzLCBicywgbHMsIHJzLCBsLCByLCB0LCBiLCBpLCBmaXJzdCxcblx0XHRcdG8gPSBpbnN0Lm9wdGlvbnMsXG5cdFx0XHRkID0gby5zbmFwVG9sZXJhbmNlLFxuXHRcdFx0eDEgPSB1aS5vZmZzZXQubGVmdCwgeDIgPSB4MSArIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGgsXG5cdFx0XHR5MSA9IHVpLm9mZnNldC50b3AsIHkyID0geTEgKyBpbnN0LmhlbHBlclByb3BvcnRpb25zLmhlaWdodDtcblxuXHRcdGZvciAoIGkgPSBpbnN0LnNuYXBFbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSApIHtcblxuXHRcdFx0bCA9IGluc3Quc25hcEVsZW1lbnRzWyBpIF0ubGVmdCAtIGluc3QubWFyZ2lucy5sZWZ0O1xuXHRcdFx0ciA9IGwgKyBpbnN0LnNuYXBFbGVtZW50c1sgaSBdLndpZHRoO1xuXHRcdFx0dCA9IGluc3Quc25hcEVsZW1lbnRzWyBpIF0udG9wIC0gaW5zdC5tYXJnaW5zLnRvcDtcblx0XHRcdGIgPSB0ICsgaW5zdC5zbmFwRWxlbWVudHNbIGkgXS5oZWlnaHQ7XG5cblx0XHRcdGlmICggeDIgPCBsIC0gZCB8fCB4MSA+IHIgKyBkIHx8IHkyIDwgdCAtIGQgfHwgeTEgPiBiICsgZCB8fFxuXHRcdFx0XHRcdCEkLmNvbnRhaW5zKCBpbnN0LnNuYXBFbGVtZW50c1sgaSBdLml0ZW0ub3duZXJEb2N1bWVudCxcblx0XHRcdFx0XHRpbnN0LnNuYXBFbGVtZW50c1sgaSBdLml0ZW0gKSApIHtcblx0XHRcdFx0aWYgKCBpbnN0LnNuYXBFbGVtZW50c1sgaSBdLnNuYXBwaW5nICkge1xuXHRcdFx0XHRcdCggaW5zdC5vcHRpb25zLnNuYXAucmVsZWFzZSAmJlxuXHRcdFx0XHRcdFx0aW5zdC5vcHRpb25zLnNuYXAucmVsZWFzZS5jYWxsKFxuXHRcdFx0XHRcdFx0XHRpbnN0LmVsZW1lbnQsXG5cdFx0XHRcdFx0XHRcdGV2ZW50LFxuXHRcdFx0XHRcdFx0XHQkLmV4dGVuZCggaW5zdC5fdWlIYXNoKCksIHsgc25hcEl0ZW06IGluc3Quc25hcEVsZW1lbnRzWyBpIF0uaXRlbSB9IClcblx0XHRcdFx0XHRcdCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbnN0LnNuYXBFbGVtZW50c1sgaSBdLnNuYXBwaW5nID0gZmFsc2U7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIG8uc25hcE1vZGUgIT09IFwiaW5uZXJcIiApIHtcblx0XHRcdFx0dHMgPSBNYXRoLmFicyggdCAtIHkyICkgPD0gZDtcblx0XHRcdFx0YnMgPSBNYXRoLmFicyggYiAtIHkxICkgPD0gZDtcblx0XHRcdFx0bHMgPSBNYXRoLmFicyggbCAtIHgyICkgPD0gZDtcblx0XHRcdFx0cnMgPSBNYXRoLmFicyggciAtIHgxICkgPD0gZDtcblx0XHRcdFx0aWYgKCB0cyApIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi50b3AgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyggXCJyZWxhdGl2ZVwiLCB7XG5cdFx0XHRcdFx0XHR0b3A6IHQgLSBpbnN0LmhlbHBlclByb3BvcnRpb25zLmhlaWdodCxcblx0XHRcdFx0XHRcdGxlZnQ6IDBcblx0XHRcdFx0XHR9ICkudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggYnMgKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oIFwicmVsYXRpdmVcIiwge1xuXHRcdFx0XHRcdFx0dG9wOiBiLFxuXHRcdFx0XHRcdFx0bGVmdDogMFxuXHRcdFx0XHRcdH0gKS50b3A7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBscyApIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oIFwicmVsYXRpdmVcIiwge1xuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0bGVmdDogbCAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGhcblx0XHRcdFx0XHR9ICkubGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHJzICkge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLmxlZnQgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyggXCJyZWxhdGl2ZVwiLCB7XG5cdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHRsZWZ0OiByXG5cdFx0XHRcdFx0fSApLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zmlyc3QgPSAoIHRzIHx8IGJzIHx8IGxzIHx8IHJzICk7XG5cblx0XHRcdGlmICggby5zbmFwTW9kZSAhPT0gXCJvdXRlclwiICkge1xuXHRcdFx0XHR0cyA9IE1hdGguYWJzKCB0IC0geTEgKSA8PSBkO1xuXHRcdFx0XHRicyA9IE1hdGguYWJzKCBiIC0geTIgKSA8PSBkO1xuXHRcdFx0XHRscyA9IE1hdGguYWJzKCBsIC0geDEgKSA8PSBkO1xuXHRcdFx0XHRycyA9IE1hdGguYWJzKCByIC0geDIgKSA8PSBkO1xuXHRcdFx0XHRpZiAoIHRzICkge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLnRvcCA9IGluc3QuX2NvbnZlcnRQb3NpdGlvblRvKCBcInJlbGF0aXZlXCIsIHtcblx0XHRcdFx0XHRcdHRvcDogdCxcblx0XHRcdFx0XHRcdGxlZnQ6IDBcblx0XHRcdFx0XHR9ICkudG9wO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggYnMgKSB7XG5cdFx0XHRcdFx0dWkucG9zaXRpb24udG9wID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oIFwicmVsYXRpdmVcIiwge1xuXHRcdFx0XHRcdFx0dG9wOiBiIC0gaW5zdC5oZWxwZXJQcm9wb3J0aW9ucy5oZWlnaHQsXG5cdFx0XHRcdFx0XHRsZWZ0OiAwXG5cdFx0XHRcdFx0fSApLnRvcDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGxzICkge1xuXHRcdFx0XHRcdHVpLnBvc2l0aW9uLmxlZnQgPSBpbnN0Ll9jb252ZXJ0UG9zaXRpb25UbyggXCJyZWxhdGl2ZVwiLCB7XG5cdFx0XHRcdFx0XHR0b3A6IDAsXG5cdFx0XHRcdFx0XHRsZWZ0OiBsXG5cdFx0XHRcdFx0fSApLmxlZnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBycyApIHtcblx0XHRcdFx0XHR1aS5wb3NpdGlvbi5sZWZ0ID0gaW5zdC5fY29udmVydFBvc2l0aW9uVG8oIFwicmVsYXRpdmVcIiwge1xuXHRcdFx0XHRcdFx0dG9wOiAwLFxuXHRcdFx0XHRcdFx0bGVmdDogciAtIGluc3QuaGVscGVyUHJvcG9ydGlvbnMud2lkdGhcblx0XHRcdFx0XHR9ICkubGVmdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoICFpbnN0LnNuYXBFbGVtZW50c1sgaSBdLnNuYXBwaW5nICYmICggdHMgfHwgYnMgfHwgbHMgfHwgcnMgfHwgZmlyc3QgKSApIHtcblx0XHRcdFx0KCBpbnN0Lm9wdGlvbnMuc25hcC5zbmFwICYmXG5cdFx0XHRcdFx0aW5zdC5vcHRpb25zLnNuYXAuc25hcC5jYWxsKFxuXHRcdFx0XHRcdFx0aW5zdC5lbGVtZW50LFxuXHRcdFx0XHRcdFx0ZXZlbnQsXG5cdFx0XHRcdFx0XHQkLmV4dGVuZCggaW5zdC5fdWlIYXNoKCksIHtcblx0XHRcdFx0XHRcdFx0c25hcEl0ZW06IGluc3Quc25hcEVsZW1lbnRzWyBpIF0uaXRlbVxuXHRcdFx0XHRcdFx0fSApICkgKTtcblx0XHRcdH1cblx0XHRcdGluc3Quc25hcEVsZW1lbnRzWyBpIF0uc25hcHBpbmcgPSAoIHRzIHx8IGJzIHx8IGxzIHx8IHJzIHx8IGZpcnN0ICk7XG5cblx0XHR9XG5cblx0fVxufSApO1xuXG4kLnVpLnBsdWdpbi5hZGQoIFwiZHJhZ2dhYmxlXCIsIFwic3RhY2tcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oIGV2ZW50LCB1aSwgaW5zdGFuY2UgKSB7XG5cdFx0dmFyIG1pbixcblx0XHRcdG8gPSBpbnN0YW5jZS5vcHRpb25zLFxuXHRcdFx0Z3JvdXAgPSAkLm1ha2VBcnJheSggJCggby5zdGFjayApICkuc29ydCggZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRcdHJldHVybiAoIHBhcnNlSW50KCAkKCBhICkuY3NzKCBcInpJbmRleFwiICksIDEwICkgfHwgMCApIC1cblx0XHRcdFx0XHQoIHBhcnNlSW50KCAkKCBiICkuY3NzKCBcInpJbmRleFwiICksIDEwICkgfHwgMCApO1xuXHRcdFx0fSApO1xuXG5cdFx0aWYgKCAhZ3JvdXAubGVuZ3RoICkgeyByZXR1cm47IH1cblxuXHRcdG1pbiA9IHBhcnNlSW50KCAkKCBncm91cFsgMCBdICkuY3NzKCBcInpJbmRleFwiICksIDEwICkgfHwgMDtcblx0XHQkKCBncm91cCApLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0JCggdGhpcyApLmNzcyggXCJ6SW5kZXhcIiwgbWluICsgaSApO1xuXHRcdH0gKTtcblx0XHR0aGlzLmNzcyggXCJ6SW5kZXhcIiwgKCBtaW4gKyBncm91cC5sZW5ndGggKSApO1xuXHR9XG59ICk7XG5cbiQudWkucGx1Z2luLmFkZCggXCJkcmFnZ2FibGVcIiwgXCJ6SW5kZXhcIiwge1xuXHRzdGFydDogZnVuY3Rpb24oIGV2ZW50LCB1aSwgaW5zdGFuY2UgKSB7XG5cdFx0dmFyIHQgPSAkKCB1aS5oZWxwZXIgKSxcblx0XHRcdG8gPSBpbnN0YW5jZS5vcHRpb25zO1xuXG5cdFx0aWYgKCB0LmNzcyggXCJ6SW5kZXhcIiApICkge1xuXHRcdFx0by5fekluZGV4ID0gdC5jc3MoIFwiekluZGV4XCIgKTtcblx0XHR9XG5cdFx0dC5jc3MoIFwiekluZGV4XCIsIG8uekluZGV4ICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCBldmVudCwgdWksIGluc3RhbmNlICkge1xuXHRcdHZhciBvID0gaW5zdGFuY2Uub3B0aW9ucztcblxuXHRcdGlmICggby5fekluZGV4ICkge1xuXHRcdFx0JCggdWkuaGVscGVyICkuY3NzKCBcInpJbmRleFwiLCBvLl96SW5kZXggKTtcblx0XHR9XG5cdH1cbn0gKTtcblxucmV0dXJuICQudWkuZHJhZ2dhYmxlO1xuXG59ICkgKTtcbiIsIi8qIVxuICogalF1ZXJ5IFVJIE1vdXNlIDEuMTIuMVxuICogaHR0cDovL2pxdWVyeXVpLmNvbVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKi9cblxuLy8+PmxhYmVsOiBNb3VzZVxuLy8+Pmdyb3VwOiBXaWRnZXRzXG4vLz4+ZGVzY3JpcHRpb246IEFic3RyYWN0cyBtb3VzZS1iYXNlZCBpbnRlcmFjdGlvbnMgdG8gYXNzaXN0IGluIGNyZWF0aW5nIGNlcnRhaW4gd2lkZ2V0cy5cbi8vPj5kb2NzOiBodHRwOi8vYXBpLmpxdWVyeXVpLmNvbS9tb3VzZS9cblxuKCBmdW5jdGlvbiggZmFjdG9yeSApIHtcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cblx0XHRkZWZpbmUoIFtcblx0XHRcdFwianF1ZXJ5XCIsXG5cdFx0XHRcIi4uL2llXCIsXG5cdFx0XHRcIi4uL3ZlcnNpb25cIixcblx0XHRcdFwiLi4vd2lkZ2V0XCJcblx0XHRdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBCcm93c2VyIGdsb2JhbHNcblx0XHRmYWN0b3J5KCBqUXVlcnkgKTtcblx0fVxufSggZnVuY3Rpb24oICQgKSB7XG5cbnZhciBtb3VzZUhhbmRsZWQgPSBmYWxzZTtcbiQoIGRvY3VtZW50ICkub24oIFwibW91c2V1cFwiLCBmdW5jdGlvbigpIHtcblx0bW91c2VIYW5kbGVkID0gZmFsc2U7XG59ICk7XG5cbnJldHVybiAkLndpZGdldCggXCJ1aS5tb3VzZVwiLCB7XG5cdHZlcnNpb246IFwiMS4xMi4xXCIsXG5cdG9wdGlvbnM6IHtcblx0XHRjYW5jZWw6IFwiaW5wdXQsIHRleHRhcmVhLCBidXR0b24sIHNlbGVjdCwgb3B0aW9uXCIsXG5cdFx0ZGlzdGFuY2U6IDEsXG5cdFx0ZGVsYXk6IDBcblx0fSxcblx0X21vdXNlSW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXG5cdFx0dGhpcy5lbGVtZW50XG5cdFx0XHQub24oIFwibW91c2Vkb3duLlwiICsgdGhpcy53aWRnZXROYW1lLCBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZURvd24oIGV2ZW50ICk7XG5cdFx0XHR9IClcblx0XHRcdC5vbiggXCJjbGljay5cIiArIHRoaXMud2lkZ2V0TmFtZSwgZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0XHRpZiAoIHRydWUgPT09ICQuZGF0YSggZXZlbnQudGFyZ2V0LCB0aGF0LndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiICkgKSB7XG5cdFx0XHRcdFx0JC5yZW1vdmVEYXRhKCBldmVudC50YXJnZXQsIHRoYXQud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIgKTtcblx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblxuXHRcdHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuXHR9LFxuXG5cdC8vIFRPRE86IG1ha2Ugc3VyZSBkZXN0cm95aW5nIG9uZSBpbnN0YW5jZSBvZiBtb3VzZSBkb2Vzbid0IG1lc3Mgd2l0aFxuXHQvLyBvdGhlciBpbnN0YW5jZXMgb2YgbW91c2Vcblx0X21vdXNlRGVzdHJveTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5lbGVtZW50Lm9mZiggXCIuXCIgKyB0aGlzLndpZGdldE5hbWUgKTtcblx0XHRpZiAoIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlICkge1xuXHRcdFx0dGhpcy5kb2N1bWVudFxuXHRcdFx0XHQub2ZmKCBcIm1vdXNlbW92ZS5cIiArIHRoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgKVxuXHRcdFx0XHQub2ZmKCBcIm1vdXNldXAuXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSApO1xuXHRcdH1cblx0fSxcblxuXHRfbW91c2VEb3duOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHQvLyBkb24ndCBsZXQgbW9yZSB0aGFuIG9uZSB3aWRnZXQgaGFuZGxlIG1vdXNlU3RhcnRcblx0XHRpZiAoIG1vdXNlSGFuZGxlZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9tb3VzZU1vdmVkID0gZmFsc2U7XG5cblx0XHQvLyBXZSBtYXkgaGF2ZSBtaXNzZWQgbW91c2V1cCAob3V0IG9mIHdpbmRvdylcblx0XHQoIHRoaXMuX21vdXNlU3RhcnRlZCAmJiB0aGlzLl9tb3VzZVVwKCBldmVudCApICk7XG5cblx0XHR0aGlzLl9tb3VzZURvd25FdmVudCA9IGV2ZW50O1xuXG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0YnRuSXNMZWZ0ID0gKCBldmVudC53aGljaCA9PT0gMSApLFxuXG5cdFx0XHQvLyBldmVudC50YXJnZXQubm9kZU5hbWUgd29ya3MgYXJvdW5kIGEgYnVnIGluIElFIDggd2l0aFxuXHRcdFx0Ly8gZGlzYWJsZWQgaW5wdXRzICgjNzYyMClcblx0XHRcdGVsSXNDYW5jZWwgPSAoIHR5cGVvZiB0aGlzLm9wdGlvbnMuY2FuY2VsID09PSBcInN0cmluZ1wiICYmIGV2ZW50LnRhcmdldC5ub2RlTmFtZSA/XG5cdFx0XHRcdCQoIGV2ZW50LnRhcmdldCApLmNsb3Nlc3QoIHRoaXMub3B0aW9ucy5jYW5jZWwgKS5sZW5ndGggOiBmYWxzZSApO1xuXHRcdGlmICggIWJ0bklzTGVmdCB8fCBlbElzQ2FuY2VsIHx8ICF0aGlzLl9tb3VzZUNhcHR1cmUoIGV2ZW50ICkgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR0aGlzLm1vdXNlRGVsYXlNZXQgPSAhdGhpcy5vcHRpb25zLmRlbGF5O1xuXHRcdGlmICggIXRoaXMubW91c2VEZWxheU1ldCApIHtcblx0XHRcdHRoaXMuX21vdXNlRGVsYXlUaW1lciA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGF0Lm1vdXNlRGVsYXlNZXQgPSB0cnVlO1xuXHRcdFx0fSwgdGhpcy5vcHRpb25zLmRlbGF5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9tb3VzZURpc3RhbmNlTWV0KCBldmVudCApICYmIHRoaXMuX21vdXNlRGVsYXlNZXQoIGV2ZW50ICkgKSB7XG5cdFx0XHR0aGlzLl9tb3VzZVN0YXJ0ZWQgPSAoIHRoaXMuX21vdXNlU3RhcnQoIGV2ZW50ICkgIT09IGZhbHNlICk7XG5cdFx0XHRpZiAoICF0aGlzLl9tb3VzZVN0YXJ0ZWQgKSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENsaWNrIGV2ZW50IG1heSBuZXZlciBoYXZlIGZpcmVkIChHZWNrbyAmIE9wZXJhKVxuXHRcdGlmICggdHJ1ZSA9PT0gJC5kYXRhKCBldmVudC50YXJnZXQsIHRoaXMud2lkZ2V0TmFtZSArIFwiLnByZXZlbnRDbGlja0V2ZW50XCIgKSApIHtcblx0XHRcdCQucmVtb3ZlRGF0YSggZXZlbnQudGFyZ2V0LCB0aGlzLndpZGdldE5hbWUgKyBcIi5wcmV2ZW50Q2xpY2tFdmVudFwiICk7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlc2UgZGVsZWdhdGVzIGFyZSByZXF1aXJlZCB0byBrZWVwIGNvbnRleHRcblx0XHR0aGlzLl9tb3VzZU1vdmVEZWxlZ2F0ZSA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHJldHVybiB0aGF0Ll9tb3VzZU1vdmUoIGV2ZW50ICk7XG5cdFx0fTtcblx0XHR0aGlzLl9tb3VzZVVwRGVsZWdhdGUgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhhdC5fbW91c2VVcCggZXZlbnQgKTtcblx0XHR9O1xuXG5cdFx0dGhpcy5kb2N1bWVudFxuXHRcdFx0Lm9uKCBcIm1vdXNlbW92ZS5cIiArIHRoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VNb3ZlRGVsZWdhdGUgKVxuXHRcdFx0Lm9uKCBcIm1vdXNldXAuXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlVXBEZWxlZ2F0ZSApO1xuXG5cdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuXHRcdG1vdXNlSGFuZGxlZCA9IHRydWU7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X21vdXNlTW92ZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0Ly8gT25seSBjaGVjayBmb3IgbW91c2V1cHMgb3V0c2lkZSB0aGUgZG9jdW1lbnQgaWYgeW91J3ZlIG1vdmVkIGluc2lkZSB0aGUgZG9jdW1lbnRcblx0XHQvLyBhdCBsZWFzdCBvbmNlLiBUaGlzIHByZXZlbnRzIHRoZSBmaXJpbmcgb2YgbW91c2V1cCBpbiB0aGUgY2FzZSBvZiBJRTw5LCB3aGljaCB3aWxsXG5cdFx0Ly8gZmlyZSBhIG1vdXNlbW92ZSBldmVudCBpZiBjb250ZW50IGlzIHBsYWNlZCB1bmRlciB0aGUgY3Vyc29yLiBTZWUgIzc3Nzhcblx0XHQvLyBTdXBwb3J0OiBJRSA8OVxuXHRcdGlmICggdGhpcy5fbW91c2VNb3ZlZCApIHtcblxuXHRcdFx0Ly8gSUUgbW91c2V1cCBjaGVjayAtIG1vdXNldXAgaGFwcGVuZWQgd2hlbiBtb3VzZSB3YXMgb3V0IG9mIHdpbmRvd1xuXHRcdFx0aWYgKCAkLnVpLmllICYmICggIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPCA5ICkgJiZcblx0XHRcdFx0XHQhZXZlbnQuYnV0dG9uICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fbW91c2VVcCggZXZlbnQgKTtcblxuXHRcdFx0Ly8gSWZyYW1lIG1vdXNldXAgY2hlY2sgLSBtb3VzZXVwIG9jY3VycmVkIGluIGFub3RoZXIgZG9jdW1lbnRcblx0XHRcdH0gZWxzZSBpZiAoICFldmVudC53aGljaCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD04IC0gOVxuXHRcdFx0XHQvLyBTYWZhcmkgc2V0cyB3aGljaCB0byAwIGlmIHlvdSBwcmVzcyBhbnkgb2YgdGhlIGZvbGxvd2luZyBrZXlzXG5cdFx0XHRcdC8vIGR1cmluZyBhIGRyYWcgKCMxNDQ2MSlcblx0XHRcdFx0aWYgKCBldmVudC5vcmlnaW5hbEV2ZW50LmFsdEtleSB8fCBldmVudC5vcmlnaW5hbEV2ZW50LmN0cmxLZXkgfHxcblx0XHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQubWV0YUtleSB8fCBldmVudC5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ICkge1xuXHRcdFx0XHRcdHRoaXMuaWdub3JlTWlzc2luZ1doaWNoID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggIXRoaXMuaWdub3JlTWlzc2luZ1doaWNoICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLl9tb3VzZVVwKCBldmVudCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBldmVudC53aGljaCB8fCBldmVudC5idXR0b24gKSB7XG5cdFx0XHR0aGlzLl9tb3VzZU1vdmVkID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMuX21vdXNlU3RhcnRlZCApIHtcblx0XHRcdHRoaXMuX21vdXNlRHJhZyggZXZlbnQgKTtcblx0XHRcdHJldHVybiBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblxuXHRcdGlmICggdGhpcy5fbW91c2VEaXN0YW5jZU1ldCggZXZlbnQgKSAmJiB0aGlzLl9tb3VzZURlbGF5TWV0KCBldmVudCApICkge1xuXHRcdFx0dGhpcy5fbW91c2VTdGFydGVkID1cblx0XHRcdFx0KCB0aGlzLl9tb3VzZVN0YXJ0KCB0aGlzLl9tb3VzZURvd25FdmVudCwgZXZlbnQgKSAhPT0gZmFsc2UgKTtcblx0XHRcdCggdGhpcy5fbW91c2VTdGFydGVkID8gdGhpcy5fbW91c2VEcmFnKCBldmVudCApIDogdGhpcy5fbW91c2VVcCggZXZlbnQgKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiAhdGhpcy5fbW91c2VTdGFydGVkO1xuXHR9LFxuXG5cdF9tb3VzZVVwOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dGhpcy5kb2N1bWVudFxuXHRcdFx0Lm9mZiggXCJtb3VzZW1vdmUuXCIgKyB0aGlzLndpZGdldE5hbWUsIHRoaXMuX21vdXNlTW92ZURlbGVnYXRlIClcblx0XHRcdC5vZmYoIFwibW91c2V1cC5cIiArIHRoaXMud2lkZ2V0TmFtZSwgdGhpcy5fbW91c2VVcERlbGVnYXRlICk7XG5cblx0XHRpZiAoIHRoaXMuX21vdXNlU3RhcnRlZCApIHtcblx0XHRcdHRoaXMuX21vdXNlU3RhcnRlZCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIGV2ZW50LnRhcmdldCA9PT0gdGhpcy5fbW91c2VEb3duRXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0XHQkLmRhdGEoIGV2ZW50LnRhcmdldCwgdGhpcy53aWRnZXROYW1lICsgXCIucHJldmVudENsaWNrRXZlbnRcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9tb3VzZVN0b3AoIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLl9tb3VzZURlbGF5VGltZXIgKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQoIHRoaXMuX21vdXNlRGVsYXlUaW1lciApO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX21vdXNlRGVsYXlUaW1lcjtcblx0XHR9XG5cblx0XHR0aGlzLmlnbm9yZU1pc3NpbmdXaGljaCA9IGZhbHNlO1xuXHRcdG1vdXNlSGFuZGxlZCA9IGZhbHNlO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH0sXG5cblx0X21vdXNlRGlzdGFuY2VNZXQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRyZXR1cm4gKCBNYXRoLm1heChcblx0XHRcdFx0TWF0aC5hYnMoIHRoaXMuX21vdXNlRG93bkV2ZW50LnBhZ2VYIC0gZXZlbnQucGFnZVggKSxcblx0XHRcdFx0TWF0aC5hYnMoIHRoaXMuX21vdXNlRG93bkV2ZW50LnBhZ2VZIC0gZXZlbnQucGFnZVkgKVxuXHRcdFx0KSA+PSB0aGlzLm9wdGlvbnMuZGlzdGFuY2Vcblx0XHQpO1xuXHR9LFxuXG5cdF9tb3VzZURlbGF5TWV0OiBmdW5jdGlvbiggLyogZXZlbnQgKi8gKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VEZWxheU1ldDtcblx0fSxcblxuXHQvLyBUaGVzZSBhcmUgcGxhY2Vob2xkZXIgbWV0aG9kcywgdG8gYmUgb3ZlcnJpZGVuIGJ5IGV4dGVuZGluZyBwbHVnaW5cblx0X21vdXNlU3RhcnQ6IGZ1bmN0aW9uKCAvKiBldmVudCAqLyApIHt9LFxuXHRfbW91c2VEcmFnOiBmdW5jdGlvbiggLyogZXZlbnQgKi8gKSB7fSxcblx0X21vdXNlU3RvcDogZnVuY3Rpb24oIC8qIGV2ZW50ICovICkge30sXG5cdF9tb3VzZUNhcHR1cmU6IGZ1bmN0aW9uKCAvKiBldmVudCAqLyApIHsgcmV0dXJuIHRydWU7IH1cbn0gKTtcblxufSApICk7XG4iXSwic291cmNlUm9vdCI6IiJ9